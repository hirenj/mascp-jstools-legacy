/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./js/bean.js":
/*!********************!*\
  !*** ./js/bean.js ***!
  \********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(module) {/*!\n  * bean.js - copyright Jacob Thornton 2011\n  * https://github.com/fat/bean\n  * MIT License\n  * special thanks to:\n  * dean edwards: http://dean.edwards.name/\n  * dperini: https://github.com/dperini/nwevents\n  * the entire mootools team: github.com/mootools/mootools-core\n  */\nconst bean = function (context) {\n  var __uid = 1,\n      registry = {},\n      collected = {},\n      overOut = /over|out/,\n      namespace = /[^\\.]*(?=\\..*)\\.|.*/,\n      stripName = /\\..*/,\n      addEvent = 'addEventListener',\n      attachEvent = 'attachEvent',\n      removeEvent = 'removeEventListener',\n      detachEvent = 'detachEvent',\n      doc = context.document || {},\n      root = doc.documentElement || {},\n      W3C_MODEL = root[addEvent],\n      eventSupport = W3C_MODEL ? addEvent : attachEvent,\n      isDescendant = function isDescendant(parent, child) {\n    var node = child.parentNode;\n    while (node !== null) {\n      if (node == parent) {\n        return true;\n      }\n      node = node.parentNode;\n    }\n  },\n      retrieveUid = function retrieveUid(obj, uid) {\n    return obj.__uid = uid && uid + '::' + __uid++ || obj.__uid || __uid++;\n  },\n      retrieveEvents = function retrieveEvents(element) {\n    var uid = retrieveUid(element);\n    return registry[uid] = registry[uid] || {};\n  },\n      listener = W3C_MODEL ? function (element, type, fn, add) {\n    element[add ? addEvent : removeEvent](type, fn, false);\n  } : function (element, type, fn, add, custom) {\n    custom && add && (element['_on' + custom] = element['_on' + custom] || 0);\n    element[add ? attachEvent : detachEvent]('on' + type, fn);\n  },\n      nativeHandler = function nativeHandler(element, fn, args) {\n    return function (event, arg) {\n      event = fixEvent(event || ((this.ownerDocument || this.document || this).parentWindow || context).event);\n      return fn.apply(element, [event].concat(args).concat(arg));\n    };\n  },\n      customHandler = function customHandler(element, fn, type, condition, args) {\n    return function (e) {\n      if (condition ? condition.apply(this, arguments) : W3C_MODEL ? true : e && e.propertyName == '_on' + type || !e) {\n        fn.apply(element, Array.prototype.slice.call(arguments, e ? 0 : 1).concat(args));\n      }\n    };\n  },\n      addListener = function addListener(element, orgType, _fn, args) {\n    var type = orgType.replace(stripName, ''),\n        events = retrieveEvents(element),\n        handlers = events[type] || (events[type] = {}),\n        originalFn = _fn,\n        uid = retrieveUid(_fn, orgType.replace(namespace, ''));\n    if (handlers[uid]) {\n      return element;\n    }\n    var custom = customEvents[type];\n    if (custom) {\n      _fn = custom.condition ? customHandler(element, _fn, type, custom.condition) : _fn;\n      type = custom.base || type;\n    }\n    var isNative = nativeEvents[type];\n    _fn = isNative ? nativeHandler(element, _fn, args) : customHandler(element, _fn, type, false, args);\n    isNative = W3C_MODEL || isNative;\n    if (type == 'unload') {\n      var org = _fn;\n      _fn = function fn() {\n        removeListener(element, type, _fn) && org();\n      };\n    }\n    element[eventSupport] && listener(element, isNative ? type : 'propertychange', _fn, true, !isNative && type);\n    handlers[uid] = _fn;\n    _fn.__uid = uid;\n    _fn.__originalFn = originalFn;\n    return type == 'unload' ? element : collected[retrieveUid(element)] = element;\n  },\n      removeListener = function removeListener(element, orgType, handler) {\n    var uid,\n        names,\n        uids,\n        i,\n        events = retrieveEvents(element),\n        type = orgType.replace(stripName, '');\n    if (!events || !events[type]) {\n      return element;\n    }\n    names = orgType.replace(namespace, '');\n    uids = names ? names.split('.') : [handler.__uid];\n\n    function destroyHandler(uid) {\n      handler = events[type][uid];\n      if (!handler) {\n        return;\n      }\n      delete events[type][uid];\n      if (element[eventSupport]) {\n        type = customEvents[type] ? customEvents[type].base : type;\n        var isNative = W3C_MODEL || nativeEvents[type];\n        listener(element, isNative ? type : 'propertychange', handler, false, !isNative && type);\n      }\n    }\n\n    destroyHandler(names); //get combos\n    for (i = uids.length; i--; destroyHandler(uids[i])) {} //get singles\n\n    return element;\n  },\n      del = function del(selector, fn, $) {\n    return function (e) {\n      var array = typeof selector == 'string' ? $(selector, this) : selector;\n      for (var target = e.target; target && target != this; target = target.parentNode) {\n        for (var i = array.length; i--;) {\n          if (array[i] == target) {\n            return fn.apply(target, arguments);\n          }\n        }\n      }\n    };\n  },\n      add = function add(element, events, fn, delfn, $) {\n    if (typeof events == 'object' && !fn) {\n      for (var type in events) {\n        events.hasOwnProperty(type) && add(element, type, events[type]);\n      }\n    } else {\n      var isDel = typeof fn == 'string',\n          types = (isDel ? fn : events).split(' ');\n      fn = isDel ? del(events, delfn, $) : fn;\n      for (var i = types.length; i--;) {\n        addListener(element, types[i], fn, Array.prototype.slice.call(arguments, isDel ? 4 : 3));\n      }\n    }\n    return element;\n  },\n      remove = function remove(element, orgEvents, fn) {\n    var k,\n        m,\n        type,\n        events,\n        i,\n        isString = typeof orgEvents == 'string',\n        names = isString && orgEvents.replace(namespace, ''),\n        names = names && names.split('.'),\n        rm = removeListener,\n        attached = retrieveEvents(element);\n    if (isString && /\\s/.test(orgEvents)) {\n      orgEvents = orgEvents.split(' ');\n      i = orgEvents.length - 1;\n      while (remove(element, orgEvents[i]) && i--) {}\n      return element;\n    }\n    events = isString ? orgEvents.replace(stripName, '') : orgEvents;\n    if (!attached || names || isString && !attached[events]) {\n      for (k in attached) {\n        if (attached.hasOwnProperty(k)) {\n          for (i in attached[k]) {\n            for (m = names.length; m--;) {\n              attached[k].hasOwnProperty(i) && new RegExp('^' + names[m] + '::\\\\d*(\\\\..*)?$').test(i) && rm(element, [k, i].join('.'));\n            }\n          }\n        }\n      }\n      return element;\n    }\n    if (typeof fn == 'function') {\n      rm(element, events, fn);\n    } else if (names) {\n      rm(element, orgEvents);\n    } else {\n      rm = events ? rm : remove;\n      type = isString && events;\n      events = events ? fn || attached[events] || events : attached;\n      for (k in events) {\n        if (events.hasOwnProperty(k)) {\n          rm(element, type || k, events[k]);\n          delete events[k]; // remove unused leaf keys\n        }\n      }\n    }\n    return element;\n  },\n      fire = function fire(element, type, args) {\n    var evt,\n        k,\n        i,\n        m,\n        types = type.split(' ');\n    for (i = types.length; i--;) {\n      type = types[i].replace(stripName, '');\n      var isNative = nativeEvents[type],\n          isNamespace = types[i].replace(namespace, ''),\n          handlers = retrieveEvents(element)[type];\n      if (isNamespace) {\n        isNamespace = isNamespace.split('.');\n        for (k = isNamespace.length; k--;) {\n          for (m in handlers) {\n            handlers.hasOwnProperty(m) && new RegExp('^' + isNamespace[k] + '::\\\\d*(\\\\..*)?$').test(m) && handlers[m].apply(element, [false].concat(args));\n          }\n        }\n      } else if (!args && element[eventSupport]) {\n        fireListener(isNative, type, element);\n      } else {\n        for (k in handlers) {\n          handlers.hasOwnProperty(k) && handlers[k].apply(element, [false].concat(args));\n        }\n      }\n    }\n    return element;\n  },\n      fireListener = W3C_MODEL ? function (isNative, type, element) {\n    evt = document.createEvent(isNative ? \"HTMLEvents\" : \"UIEvents\");\n    evt[isNative ? 'initEvent' : 'initUIEvent'](type, true, true, context, 1);\n    element.dispatchEvent(evt);\n  } : function (isNative, type, element) {\n    isNative ? element.fireEvent('on' + type, document.createEventObject()) : element['_on' + type]++;\n  },\n      clone = function clone(element, from, type) {\n    var events = retrieveEvents(from),\n        obj,\n        k;\n    var uid = retrieveUid(element);\n    obj = type ? events[type] : events;\n    for (k in obj) {\n      obj.hasOwnProperty(k) && (type ? add : clone)(element, type || from, type ? obj[k].__originalFn : k);\n    }\n    return element;\n  },\n      fixEvent = function fixEvent(e) {\n    var result = {};\n    if (!e) {\n      return result;\n    }\n    var type = e.type,\n        target = e.target || e.srcElement;\n    result.preventDefault = fixEvent.preventDefault(e);\n    result.stopPropagation = fixEvent.stopPropagation(e);\n    result.target = target && target.nodeType == 3 ? target.parentNode : target;\n    if (type && type.indexOf('key')) {\n      result.keyCode = e.which || e.keyCode;\n    } else if (/click|mouse|menu/i.test(type)) {\n      result.rightClick = e.which == 3 || e.button == 2;\n      result.pos = { x: 0, y: 0 };\n      if (e.pageX || e.pageY) {\n        result.clientX = e.pageX;\n        result.clientY = e.pageY;\n      } else if (e.clientX || e.clientY) {\n        result.clientX = e.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;\n        result.clientY = e.clientY + document.body.scrollTop + document.documentElement.scrollTop;\n      }\n      overOut.test(type) && (result.relatedTarget = e.relatedTarget || e[(type == 'mouseover' ? 'from' : 'to') + 'Element']);\n    }\n    for (var k in e) {\n      if (!(k in result)) {\n        result[k] = e[k];\n      }\n    }\n    return result;\n  };\n\n  fixEvent.preventDefault = function (e) {\n    return function () {\n      if (e.preventDefault) {\n        e.preventDefault();\n      } else {\n        e.returnValue = false;\n      }\n    };\n  };\n\n  fixEvent.stopPropagation = function (e) {\n    return function () {\n      if (e.stopPropagation) {\n        e.stopPropagation();\n      } else {\n        e.cancelBubble = true;\n      }\n    };\n  };\n\n  var nativeEvents = { click: 1, dblclick: 1, mouseup: 1, mousedown: 1, contextmenu: 1, //mouse buttons\n    mousewheel: 1, DOMMouseScroll: 1, //mouse wheel\n    mouseover: 1, mouseout: 1, mousemove: 1, selectstart: 1, selectend: 1, //mouse movement\n    keydown: 1, keypress: 1, keyup: 1, //keyboard\n    orientationchange: 1, // mobile\n    touchstart: 1, touchmove: 1, touchend: 1, touchcancel: 1, // touch\n    gesturestart: 1, gesturechange: 1, gestureend: 1, // gesture\n    focus: 1, blur: 1, change: 1, reset: 1, select: 1, submit: 1, //form elements\n    load: 1, unload: 1, beforeunload: 1, resize: 1, move: 1, DOMContentLoaded: 1, readystatechange: 1, //window\n    error: 0, abort: 1, scroll: 1 }; //misc\n\n  function check(event) {\n    var related = event.relatedTarget;\n    if (!related) {\n      return related === null;\n    }\n    return related != this && related.prefix != 'xul' && !/document/.test(this.toString()) && !isDescendant(this, related);\n  }\n\n  var customEvents = {\n    mouseenter: { base: 'mouseover', condition: check },\n    mouseleave: { base: 'mouseout', condition: check\n      //    mousewheel: { base: /Firefox/.test(navigator.userAgent) ? 'DOMMouseScroll' : 'mousewheel' }\n    } };\n\n  var bean = { add: add, remove: remove, clone: clone, fire: fire };\n\n  var clean = function clean(el) {\n    var uid = remove(el).__uid;\n    if (uid) {\n      delete collected[uid];\n      delete registry[uid];\n    }\n  };\n\n  if (context[attachEvent]) {\n    add(context, 'unload', function () {\n      for (var k in collected) {\n        collected.hasOwnProperty(k) && clean(collected[k]);\n      }\n      context.CollectGarbage && CollectGarbage();\n    });\n  }\n\n  var oldBean = context.bean;\n  bean.noConflict = function () {\n    context.bean = oldBean;\n    return this;\n  };\n\n  typeof module !== 'undefined' && module.exports ? module.exports = bean : context['bean'] = bean;\n\n  return bean;\n}({});\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (bean);\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/webpack/buildin/harmony-module.js */ \"./node_modules/webpack/buildin/harmony-module.js\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9qcy9iZWFuLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL2pzL2JlYW4uanM/YjRkMSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAgKiBiZWFuLmpzIC0gY29weXJpZ2h0IEphY29iIFRob3JudG9uIDIwMTFcbiAgKiBodHRwczovL2dpdGh1Yi5jb20vZmF0L2JlYW5cbiAgKiBNSVQgTGljZW5zZVxuICAqIHNwZWNpYWwgdGhhbmtzIHRvOlxuICAqIGRlYW4gZWR3YXJkczogaHR0cDovL2RlYW4uZWR3YXJkcy5uYW1lL1xuICAqIGRwZXJpbmk6IGh0dHBzOi8vZ2l0aHViLmNvbS9kcGVyaW5pL253ZXZlbnRzXG4gICogdGhlIGVudGlyZSBtb290b29scyB0ZWFtOiBnaXRodWIuY29tL21vb3Rvb2xzL21vb3Rvb2xzLWNvcmVcbiAgKi9cbmNvbnN0IGJlYW4gPSAoZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgdmFyIF9fdWlkID0gMSxcbiAgICAgIHJlZ2lzdHJ5ID0ge30sXG4gICAgICBjb2xsZWN0ZWQgPSB7fSxcbiAgICAgIG92ZXJPdXQgPSAvb3ZlcnxvdXQvLFxuICAgICAgbmFtZXNwYWNlID0gL1teXFwuXSooPz1cXC4uKilcXC58LiovLFxuICAgICAgc3RyaXBOYW1lID0gL1xcLi4qLyxcbiAgICAgIGFkZEV2ZW50ID0gJ2FkZEV2ZW50TGlzdGVuZXInLFxuICAgICAgYXR0YWNoRXZlbnQgPSAnYXR0YWNoRXZlbnQnLFxuICAgICAgcmVtb3ZlRXZlbnQgPSAncmVtb3ZlRXZlbnRMaXN0ZW5lcicsXG4gICAgICBkZXRhY2hFdmVudCA9ICdkZXRhY2hFdmVudCcsXG4gICAgICBkb2MgPSBjb250ZXh0LmRvY3VtZW50IHx8IHt9LFxuICAgICAgcm9vdCA9IGRvYy5kb2N1bWVudEVsZW1lbnQgfHwge30sXG4gICAgICBXM0NfTU9ERUwgPSByb290W2FkZEV2ZW50XSxcbiAgICAgIGV2ZW50U3VwcG9ydCA9IFczQ19NT0RFTCA/IGFkZEV2ZW50IDogYXR0YWNoRXZlbnQsXG5cbiAgaXNEZXNjZW5kYW50ID0gZnVuY3Rpb24gKHBhcmVudCwgY2hpbGQpIHtcbiAgICB2YXIgbm9kZSA9IGNoaWxkLnBhcmVudE5vZGU7XG4gICAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgIGlmIChub2RlID09IHBhcmVudCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgfVxuICB9LFxuXG4gIHJldHJpZXZlVWlkID0gZnVuY3Rpb24gKG9iaiwgdWlkKSB7XG4gICAgcmV0dXJuIChvYmouX191aWQgPSB1aWQgJiYgKHVpZCArICc6OicgKyBfX3VpZCsrKSB8fCBvYmouX191aWQgfHwgX191aWQrKyk7XG4gIH0sXG5cbiAgcmV0cmlldmVFdmVudHMgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIHZhciB1aWQgPSByZXRyaWV2ZVVpZChlbGVtZW50KTtcbiAgICByZXR1cm4gKHJlZ2lzdHJ5W3VpZF0gPSByZWdpc3RyeVt1aWRdIHx8IHt9KTtcbiAgfSxcblxuICBsaXN0ZW5lciA9IFczQ19NT0RFTCA/IGZ1bmN0aW9uIChlbGVtZW50LCB0eXBlLCBmbiwgYWRkKSB7XG4gICAgZWxlbWVudFthZGQgPyBhZGRFdmVudCA6IHJlbW92ZUV2ZW50XSh0eXBlLCBmbiwgZmFsc2UpO1xuICB9IDogZnVuY3Rpb24gKGVsZW1lbnQsIHR5cGUsIGZuLCBhZGQsIGN1c3RvbSkge1xuICAgIGN1c3RvbSAmJiBhZGQgJiYgKGVsZW1lbnRbJ19vbicgKyBjdXN0b21dID0gZWxlbWVudFsnX29uJyArIGN1c3RvbV0gfHwgMCk7XG4gICAgZWxlbWVudFthZGQgPyBhdHRhY2hFdmVudCA6IGRldGFjaEV2ZW50XSgnb24nICsgdHlwZSwgZm4pO1xuICB9LFxuXG4gIG5hdGl2ZUhhbmRsZXIgPSBmdW5jdGlvbiAoZWxlbWVudCwgZm4sYXJncykge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZXZlbnQsYXJnKSB7XG4gICAgICBldmVudCA9IGZpeEV2ZW50KGV2ZW50IHx8ICgodGhpcy5vd25lckRvY3VtZW50IHx8IHRoaXMuZG9jdW1lbnQgfHwgdGhpcykucGFyZW50V2luZG93IHx8IGNvbnRleHQpLmV2ZW50KTtcbiAgICAgIHJldHVybiBmbi5hcHBseShlbGVtZW50LCBbZXZlbnRdLmNvbmNhdChhcmdzKS5jb25jYXQoYXJnKSk7XG4gICAgfTtcbiAgfSxcblxuICBjdXN0b21IYW5kbGVyID0gZnVuY3Rpb24gKGVsZW1lbnQsIGZuLCB0eXBlLCBjb25kaXRpb24sIGFyZ3MpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGUpIHtcbiAgICAgIGlmIChjb25kaXRpb24gPyBjb25kaXRpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IFczQ19NT0RFTCA/IHRydWUgOiBlICYmIGUucHJvcGVydHlOYW1lID09ICdfb24nICsgdHlwZSB8fCAhZSkge1xuICAgICAgICBmbi5hcHBseShlbGVtZW50LCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIGUgPyAwIDogMSkuY29uY2F0KGFyZ3MpKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuXG4gIGFkZExpc3RlbmVyID0gZnVuY3Rpb24gKGVsZW1lbnQsIG9yZ1R5cGUsIGZuLCBhcmdzKSB7XG4gICAgdmFyIHR5cGUgPSBvcmdUeXBlLnJlcGxhY2Uoc3RyaXBOYW1lLCAnJyksXG4gICAgICAgIGV2ZW50cyA9IHJldHJpZXZlRXZlbnRzKGVsZW1lbnQpLFxuICAgICAgICBoYW5kbGVycyA9IGV2ZW50c1t0eXBlXSB8fCAoZXZlbnRzW3R5cGVdID0ge30pLFxuICAgICAgICBvcmlnaW5hbEZuID0gZm4sXG4gICAgICAgIHVpZCA9IHJldHJpZXZlVWlkKGZuLCBvcmdUeXBlLnJlcGxhY2UobmFtZXNwYWNlLCAnJykpO1xuICAgIGlmIChoYW5kbGVyc1t1aWRdKSB7XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9XG4gICAgdmFyIGN1c3RvbSA9IGN1c3RvbUV2ZW50c1t0eXBlXTtcbiAgICBpZiAoY3VzdG9tKSB7XG4gICAgICBmbiA9IGN1c3RvbS5jb25kaXRpb24gPyBjdXN0b21IYW5kbGVyKGVsZW1lbnQsIGZuLCB0eXBlLCBjdXN0b20uY29uZGl0aW9uKSA6IGZuO1xuICAgICAgdHlwZSA9IGN1c3RvbS5iYXNlIHx8IHR5cGU7XG4gICAgfVxuICAgIHZhciBpc05hdGl2ZSA9IG5hdGl2ZUV2ZW50c1t0eXBlXTtcbiAgICBmbiA9IGlzTmF0aXZlID8gbmF0aXZlSGFuZGxlcihlbGVtZW50LCBmbiwgYXJncykgOiBjdXN0b21IYW5kbGVyKGVsZW1lbnQsIGZuLCB0eXBlLCBmYWxzZSwgYXJncyk7XG4gICAgaXNOYXRpdmUgPSBXM0NfTU9ERUwgfHwgaXNOYXRpdmU7XG4gICAgaWYgKHR5cGUgPT0gJ3VubG9hZCcpIHtcbiAgICAgIHZhciBvcmcgPSBmbjtcbiAgICAgIGZuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZW1vdmVMaXN0ZW5lcihlbGVtZW50LCB0eXBlLCBmbikgJiYgb3JnKCk7XG4gICAgICB9O1xuICAgIH1cbiAgICBlbGVtZW50W2V2ZW50U3VwcG9ydF0gJiYgbGlzdGVuZXIoZWxlbWVudCwgaXNOYXRpdmUgPyB0eXBlIDogJ3Byb3BlcnR5Y2hhbmdlJywgZm4sIHRydWUsICFpc05hdGl2ZSAmJiB0eXBlKTtcbiAgICBoYW5kbGVyc1t1aWRdID0gZm47XG4gICAgZm4uX191aWQgPSB1aWQ7XG4gICAgZm4uX19vcmlnaW5hbEZuID0gb3JpZ2luYWxGbjtcbiAgICByZXR1cm4gdHlwZSA9PSAndW5sb2FkJyA/IGVsZW1lbnQgOiAoY29sbGVjdGVkW3JldHJpZXZlVWlkKGVsZW1lbnQpXSA9IGVsZW1lbnQpO1xuICB9LFxuXG4gIHJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gKGVsZW1lbnQsIG9yZ1R5cGUsIGhhbmRsZXIpIHtcbiAgICB2YXIgdWlkLCBuYW1lcywgdWlkcywgaSwgZXZlbnRzID0gcmV0cmlldmVFdmVudHMoZWxlbWVudCksIHR5cGUgPSBvcmdUeXBlLnJlcGxhY2Uoc3RyaXBOYW1lLCAnJyk7XG4gICAgaWYgKCFldmVudHMgfHwgIWV2ZW50c1t0eXBlXSkge1xuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfVxuICAgIG5hbWVzID0gb3JnVHlwZS5yZXBsYWNlKG5hbWVzcGFjZSwgJycpO1xuICAgIHVpZHMgPSBuYW1lcyA/IG5hbWVzLnNwbGl0KCcuJykgOiBbaGFuZGxlci5fX3VpZF07XG5cbiAgICBmdW5jdGlvbiBkZXN0cm95SGFuZGxlcih1aWQpIHtcbiAgICAgIGhhbmRsZXIgPSBldmVudHNbdHlwZV1bdWlkXTtcbiAgICAgIGlmICghaGFuZGxlcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBkZWxldGUgZXZlbnRzW3R5cGVdW3VpZF07XG4gICAgICBpZiAoZWxlbWVudFtldmVudFN1cHBvcnRdKSB7XG4gICAgICAgIHR5cGUgPSBjdXN0b21FdmVudHNbdHlwZV0gPyBjdXN0b21FdmVudHNbdHlwZV0uYmFzZSA6IHR5cGU7XG4gICAgICAgIHZhciBpc05hdGl2ZSA9IFczQ19NT0RFTCB8fCBuYXRpdmVFdmVudHNbdHlwZV07XG4gICAgICAgIGxpc3RlbmVyKGVsZW1lbnQsIGlzTmF0aXZlID8gdHlwZSA6ICdwcm9wZXJ0eWNoYW5nZScsIGhhbmRsZXIsIGZhbHNlLCAhaXNOYXRpdmUgJiYgdHlwZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZGVzdHJveUhhbmRsZXIobmFtZXMpOyAvL2dldCBjb21ib3NcbiAgICBmb3IgKGkgPSB1aWRzLmxlbmd0aDsgaS0tOyBkZXN0cm95SGFuZGxlcih1aWRzW2ldKSkge30gLy9nZXQgc2luZ2xlc1xuXG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH0sXG5cbiAgZGVsID0gZnVuY3Rpb24gKHNlbGVjdG9yLCBmbiwgJCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZSkge1xuICAgICAgdmFyIGFycmF5ID0gdHlwZW9mIHNlbGVjdG9yID09ICdzdHJpbmcnID8gJChzZWxlY3RvciwgdGhpcykgOiBzZWxlY3RvcjtcbiAgICAgIGZvciAodmFyIHRhcmdldCA9IGUudGFyZ2V0OyB0YXJnZXQgJiYgdGFyZ2V0ICE9IHRoaXM7IHRhcmdldCA9IHRhcmdldC5wYXJlbnROb2RlKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSBhcnJheS5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgICBpZiAoYXJyYXlbaV0gPT0gdGFyZ2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gZm4uYXBwbHkodGFyZ2V0LCBhcmd1bWVudHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH0sXG5cbiAgYWRkID0gZnVuY3Rpb24gKGVsZW1lbnQsIGV2ZW50cywgZm4sIGRlbGZuLCAkKSB7XG4gICAgaWYgKHR5cGVvZiBldmVudHMgPT0gJ29iamVjdCcgJiYgIWZuKSB7XG4gICAgICBmb3IgKHZhciB0eXBlIGluIGV2ZW50cykge1xuICAgICAgICBldmVudHMuaGFzT3duUHJvcGVydHkodHlwZSkgJiYgYWRkKGVsZW1lbnQsIHR5cGUsIGV2ZW50c1t0eXBlXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBpc0RlbCA9IHR5cGVvZiBmbiA9PSAnc3RyaW5nJywgdHlwZXMgPSAoaXNEZWwgPyBmbiA6IGV2ZW50cykuc3BsaXQoJyAnKTtcbiAgICAgIGZuID0gaXNEZWwgPyBkZWwoZXZlbnRzLCBkZWxmbiwgJCkgOiBmbjtcbiAgICAgIGZvciAodmFyIGkgPSB0eXBlcy5sZW5ndGg7IGktLTspIHtcbiAgICAgICAgYWRkTGlzdGVuZXIoZWxlbWVudCwgdHlwZXNbaV0sIGZuLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIGlzRGVsID8gNCA6IDMpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH0sXG5cbiAgcmVtb3ZlID0gZnVuY3Rpb24gKGVsZW1lbnQsIG9yZ0V2ZW50cywgZm4pIHtcbiAgICB2YXIgaywgbSwgdHlwZSwgZXZlbnRzLCBpLFxuICAgICAgICBpc1N0cmluZyA9IHR5cGVvZihvcmdFdmVudHMpID09ICdzdHJpbmcnLFxuICAgICAgICBuYW1lcyA9IGlzU3RyaW5nICYmIG9yZ0V2ZW50cy5yZXBsYWNlKG5hbWVzcGFjZSwgJycpLFxuICAgICAgICBuYW1lcyA9IG5hbWVzICYmIG5hbWVzLnNwbGl0KCcuJyksXG4gICAgICAgIHJtID0gcmVtb3ZlTGlzdGVuZXIsXG4gICAgICAgIGF0dGFjaGVkID0gcmV0cmlldmVFdmVudHMoZWxlbWVudCk7XG4gICAgaWYgKGlzU3RyaW5nICYmIC9cXHMvLnRlc3Qob3JnRXZlbnRzKSkge1xuICAgICAgb3JnRXZlbnRzID0gb3JnRXZlbnRzLnNwbGl0KCcgJyk7XG4gICAgICBpID0gb3JnRXZlbnRzLmxlbmd0aCAtIDE7XG4gICAgICB3aGlsZSAocmVtb3ZlKGVsZW1lbnQsIG9yZ0V2ZW50c1tpXSkgJiYgaS0tKSB7fVxuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfVxuICAgIGV2ZW50cyA9IGlzU3RyaW5nID8gb3JnRXZlbnRzLnJlcGxhY2Uoc3RyaXBOYW1lLCAnJykgOiBvcmdFdmVudHM7XG4gICAgaWYgKCFhdHRhY2hlZCB8fCBuYW1lcyB8fCAoaXNTdHJpbmcgJiYgIWF0dGFjaGVkW2V2ZW50c10pKSB7XG4gICAgICBmb3IgKGsgaW4gYXR0YWNoZWQpIHtcbiAgICAgICAgaWYgKGF0dGFjaGVkLmhhc093blByb3BlcnR5KGspKSB7XG4gICAgICAgICAgZm9yIChpIGluIGF0dGFjaGVkW2tdKSB7XG4gICAgICAgICAgICBmb3IgKG0gPSBuYW1lcy5sZW5ndGg7IG0tLTspIHtcbiAgICAgICAgICAgICAgYXR0YWNoZWRba10uaGFzT3duUHJvcGVydHkoaSkgJiYgbmV3IFJlZ0V4cCgnXicgKyBuYW1lc1ttXSArICc6OlxcXFxkKihcXFxcLi4qKT8kJykudGVzdChpKSAmJiBybShlbGVtZW50LCBbaywgaV0uam9pbignLicpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGZuID09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJtKGVsZW1lbnQsIGV2ZW50cywgZm4pO1xuICAgIH0gZWxzZSBpZiAobmFtZXMpIHtcbiAgICAgIHJtKGVsZW1lbnQsIG9yZ0V2ZW50cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJtID0gZXZlbnRzID8gcm0gOiByZW1vdmU7XG4gICAgICB0eXBlID0gaXNTdHJpbmcgJiYgZXZlbnRzO1xuICAgICAgZXZlbnRzID0gZXZlbnRzID8gKGZuIHx8IGF0dGFjaGVkW2V2ZW50c10gfHwgZXZlbnRzKSA6IGF0dGFjaGVkO1xuICAgICAgZm9yIChrIGluIGV2ZW50cykge1xuICAgICAgICBpZiAoZXZlbnRzLmhhc093blByb3BlcnR5KGspKSB7XG4gICAgICAgICAgcm0oZWxlbWVudCwgdHlwZSB8fCBrLCBldmVudHNba10pO1xuICAgICAgICAgIGRlbGV0ZSBldmVudHNba107IC8vIHJlbW92ZSB1bnVzZWQgbGVhZiBrZXlzXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH0sXG5cbiAgZmlyZSA9IGZ1bmN0aW9uIChlbGVtZW50LCB0eXBlLCBhcmdzKSB7XG4gICAgdmFyIGV2dCwgaywgaSwgbSwgdHlwZXMgPSB0eXBlLnNwbGl0KCcgJyk7XG4gICAgZm9yIChpID0gdHlwZXMubGVuZ3RoOyBpLS07KSB7XG4gICAgICB0eXBlID0gdHlwZXNbaV0ucmVwbGFjZShzdHJpcE5hbWUsICcnKTtcbiAgICAgIHZhciBpc05hdGl2ZSA9IG5hdGl2ZUV2ZW50c1t0eXBlXSxcbiAgICAgICAgICBpc05hbWVzcGFjZSA9IHR5cGVzW2ldLnJlcGxhY2UobmFtZXNwYWNlLCAnJyksXG4gICAgICAgICAgaGFuZGxlcnMgPSByZXRyaWV2ZUV2ZW50cyhlbGVtZW50KVt0eXBlXTtcbiAgICAgIGlmIChpc05hbWVzcGFjZSkge1xuICAgICAgICBpc05hbWVzcGFjZSA9IGlzTmFtZXNwYWNlLnNwbGl0KCcuJyk7XG4gICAgICAgIGZvciAoayA9IGlzTmFtZXNwYWNlLmxlbmd0aDsgay0tOykge1xuICAgICAgICAgIGZvciAobSBpbiBoYW5kbGVycykge1xuICAgICAgICAgICAgaGFuZGxlcnMuaGFzT3duUHJvcGVydHkobSkgJiYgbmV3IFJlZ0V4cCgnXicgKyBpc05hbWVzcGFjZVtrXSArICc6OlxcXFxkKihcXFxcLi4qKT8kJykudGVzdChtKSAmJiBoYW5kbGVyc1ttXS5hcHBseShlbGVtZW50LCBbZmFsc2VdLmNvbmNhdChhcmdzKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCFhcmdzICYmIGVsZW1lbnRbZXZlbnRTdXBwb3J0XSkge1xuICAgICAgICBmaXJlTGlzdGVuZXIoaXNOYXRpdmUsIHR5cGUsIGVsZW1lbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChrIGluIGhhbmRsZXJzKSB7XG4gICAgICAgICAgaGFuZGxlcnMuaGFzT3duUHJvcGVydHkoaykgJiYgaGFuZGxlcnNba10uYXBwbHkoZWxlbWVudCwgW2ZhbHNlXS5jb25jYXQoYXJncykpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbGVtZW50O1xuICB9LFxuXG4gIGZpcmVMaXN0ZW5lciA9IFczQ19NT0RFTCA/IGZ1bmN0aW9uIChpc05hdGl2ZSwgdHlwZSwgZWxlbWVudCkge1xuICAgIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KGlzTmF0aXZlID8gXCJIVE1MRXZlbnRzXCIgOiBcIlVJRXZlbnRzXCIpO1xuICAgIGV2dFtpc05hdGl2ZSA/ICdpbml0RXZlbnQnIDogJ2luaXRVSUV2ZW50J10odHlwZSwgdHJ1ZSwgdHJ1ZSwgY29udGV4dCwgMSk7XG4gICAgZWxlbWVudC5kaXNwYXRjaEV2ZW50KGV2dCk7XG4gIH0gOiBmdW5jdGlvbiAoaXNOYXRpdmUsIHR5cGUsIGVsZW1lbnQpIHtcbiAgICBpc05hdGl2ZSA/IGVsZW1lbnQuZmlyZUV2ZW50KCdvbicgKyB0eXBlLCBkb2N1bWVudC5jcmVhdGVFdmVudE9iamVjdCgpKSA6IGVsZW1lbnRbJ19vbicgKyB0eXBlXSsrO1xuICB9LFxuXG4gIGNsb25lID0gZnVuY3Rpb24gKGVsZW1lbnQsIGZyb20sIHR5cGUpIHtcbiAgICB2YXIgZXZlbnRzID0gcmV0cmlldmVFdmVudHMoZnJvbSksIG9iaiwgaztcbiAgICB2YXIgdWlkID0gcmV0cmlldmVVaWQoZWxlbWVudCk7XG4gICAgb2JqID0gdHlwZSA/IGV2ZW50c1t0eXBlXSA6IGV2ZW50cztcbiAgICBmb3IgKGsgaW4gb2JqKSB7XG4gICAgICBvYmouaGFzT3duUHJvcGVydHkoaykgJiYgKHR5cGUgPyBhZGQgOiBjbG9uZSkoZWxlbWVudCwgdHlwZSB8fCBmcm9tLCB0eXBlID8gb2JqW2tdLl9fb3JpZ2luYWxGbiA6IGspO1xuICAgIH1cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfSxcblxuICBmaXhFdmVudCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmICghZSkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgdmFyIHR5cGUgPSBlLnR5cGUsIHRhcmdldCA9IGUudGFyZ2V0IHx8IGUuc3JjRWxlbWVudDtcbiAgICByZXN1bHQucHJldmVudERlZmF1bHQgPSBmaXhFdmVudC5wcmV2ZW50RGVmYXVsdChlKTtcbiAgICByZXN1bHQuc3RvcFByb3BhZ2F0aW9uID0gZml4RXZlbnQuc3RvcFByb3BhZ2F0aW9uKGUpO1xuICAgIHJlc3VsdC50YXJnZXQgPSB0YXJnZXQgJiYgdGFyZ2V0Lm5vZGVUeXBlID09IDMgPyB0YXJnZXQucGFyZW50Tm9kZSA6IHRhcmdldDtcbiAgICBpZiAodHlwZSAmJiB0eXBlLmluZGV4T2YoJ2tleScpKSB7XG4gICAgICByZXN1bHQua2V5Q29kZSA9IGUud2hpY2ggfHwgZS5rZXlDb2RlO1xuICAgIH0gZWxzZSBpZiAoKC9jbGlja3xtb3VzZXxtZW51L2kpLnRlc3QodHlwZSkpIHtcbiAgICAgIHJlc3VsdC5yaWdodENsaWNrID0gZS53aGljaCA9PSAzIHx8IGUuYnV0dG9uID09IDI7XG4gICAgICByZXN1bHQucG9zID0geyB4OiAwLCB5OiAwIH07XG4gICAgICBpZiAoZS5wYWdlWCB8fCBlLnBhZ2VZKSB7XG4gICAgICAgIHJlc3VsdC5jbGllbnRYID0gZS5wYWdlWDtcbiAgICAgICAgcmVzdWx0LmNsaWVudFkgPSBlLnBhZ2VZO1xuICAgICAgfSBlbHNlIGlmIChlLmNsaWVudFggfHwgZS5jbGllbnRZKSB7XG4gICAgICAgIHJlc3VsdC5jbGllbnRYID0gZS5jbGllbnRYICsgZG9jdW1lbnQuYm9keS5zY3JvbGxMZWZ0ICsgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQ7XG4gICAgICAgIHJlc3VsdC5jbGllbnRZID0gZS5jbGllbnRZICsgZG9jdW1lbnQuYm9keS5zY3JvbGxUb3AgKyBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wO1xuICAgICAgfVxuICAgICAgb3Zlck91dC50ZXN0KHR5cGUpICYmIChyZXN1bHQucmVsYXRlZFRhcmdldCA9IGUucmVsYXRlZFRhcmdldCB8fCBlWyh0eXBlID09ICdtb3VzZW92ZXInID8gJ2Zyb20nIDogJ3RvJykgKyAnRWxlbWVudCddKTtcbiAgICB9XG4gICAgZm9yICh2YXIgayBpbiBlKSB7XG4gICAgICBpZiAoIShrIGluIHJlc3VsdCkpIHtcbiAgICAgICAgcmVzdWx0W2tdID0gZVtrXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICBmaXhFdmVudC5wcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChlLnByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBlLnJldHVyblZhbHVlID0gZmFsc2U7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcblxuICBmaXhFdmVudC5zdG9wUHJvcGFnYXRpb24gPSBmdW5jdGlvbiAoZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoZS5zdG9wUHJvcGFnYXRpb24pIHtcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGUuY2FuY2VsQnViYmxlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIHZhciBuYXRpdmVFdmVudHMgPSB7IGNsaWNrOiAxLCBkYmxjbGljazogMSwgbW91c2V1cDogMSwgbW91c2Vkb3duOiAxLCBjb250ZXh0bWVudTogMSwgLy9tb3VzZSBidXR0b25zXG4gICAgbW91c2V3aGVlbDogMSwgRE9NTW91c2VTY3JvbGw6IDEsIC8vbW91c2Ugd2hlZWxcbiAgICBtb3VzZW92ZXI6IDEsIG1vdXNlb3V0OiAxLCBtb3VzZW1vdmU6IDEsIHNlbGVjdHN0YXJ0OiAxLCBzZWxlY3RlbmQ6IDEsIC8vbW91c2UgbW92ZW1lbnRcbiAgICBrZXlkb3duOiAxLCBrZXlwcmVzczogMSwga2V5dXA6IDEsIC8va2V5Ym9hcmRcbiAgICBvcmllbnRhdGlvbmNoYW5nZTogMSwgLy8gbW9iaWxlXG4gICAgdG91Y2hzdGFydDogMSwgdG91Y2htb3ZlOiAxLCB0b3VjaGVuZDogMSwgdG91Y2hjYW5jZWw6IDEsIC8vIHRvdWNoXG4gICAgZ2VzdHVyZXN0YXJ0OiAxLCBnZXN0dXJlY2hhbmdlOiAxLCBnZXN0dXJlZW5kOiAxLCAvLyBnZXN0dXJlXG4gICAgZm9jdXM6IDEsIGJsdXI6IDEsIGNoYW5nZTogMSwgcmVzZXQ6IDEsIHNlbGVjdDogMSwgc3VibWl0OiAxLCAvL2Zvcm0gZWxlbWVudHNcbiAgICBsb2FkOiAxLCB1bmxvYWQ6IDEsIGJlZm9yZXVubG9hZDogMSwgcmVzaXplOiAxLCBtb3ZlOiAxLCBET01Db250ZW50TG9hZGVkOiAxLCByZWFkeXN0YXRlY2hhbmdlOiAxLCAvL3dpbmRvd1xuICAgIGVycm9yOiAwLCBhYm9ydDogMSwgc2Nyb2xsOiAxIH07IC8vbWlzY1xuXG4gIGZ1bmN0aW9uIGNoZWNrKGV2ZW50KSB7XG4gICAgdmFyIHJlbGF0ZWQgPSBldmVudC5yZWxhdGVkVGFyZ2V0O1xuICAgIGlmICghcmVsYXRlZCkge1xuICAgICAgcmV0dXJuIHJlbGF0ZWQgPT09IG51bGw7XG4gICAgfVxuICAgIHJldHVybiAocmVsYXRlZCAhPSB0aGlzICYmIHJlbGF0ZWQucHJlZml4ICE9ICd4dWwnICYmICEvZG9jdW1lbnQvLnRlc3QodGhpcy50b1N0cmluZygpKSAmJiAhaXNEZXNjZW5kYW50KHRoaXMsIHJlbGF0ZWQpKTtcbiAgfVxuXG4gIHZhciBjdXN0b21FdmVudHMgPSB7XG4gICAgbW91c2VlbnRlcjogeyBiYXNlOiAnbW91c2VvdmVyJywgY29uZGl0aW9uOiBjaGVjayB9LFxuICAgIG1vdXNlbGVhdmU6IHsgYmFzZTogJ21vdXNlb3V0JywgY29uZGl0aW9uOiBjaGVjayB9XG4vLyAgICBtb3VzZXdoZWVsOiB7IGJhc2U6IC9GaXJlZm94Ly50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpID8gJ0RPTU1vdXNlU2Nyb2xsJyA6ICdtb3VzZXdoZWVsJyB9XG4gIH07XG5cbiAgdmFyIGJlYW4gPSB7IGFkZDogYWRkLCByZW1vdmU6IHJlbW92ZSwgY2xvbmU6IGNsb25lLCBmaXJlOiBmaXJlIH07XG5cbiAgdmFyIGNsZWFuID0gZnVuY3Rpb24gKGVsKSB7XG4gICAgdmFyIHVpZCA9IHJlbW92ZShlbCkuX191aWQ7XG4gICAgaWYgKHVpZCkge1xuICAgICAgZGVsZXRlIGNvbGxlY3RlZFt1aWRdO1xuICAgICAgZGVsZXRlIHJlZ2lzdHJ5W3VpZF07XG4gICAgfVxuICB9O1xuXG4gIGlmIChjb250ZXh0W2F0dGFjaEV2ZW50XSkge1xuICAgIGFkZChjb250ZXh0LCAndW5sb2FkJywgZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgayBpbiBjb2xsZWN0ZWQpIHtcbiAgICAgICAgY29sbGVjdGVkLmhhc093blByb3BlcnR5KGspICYmIGNsZWFuKGNvbGxlY3RlZFtrXSk7XG4gICAgICB9XG4gICAgICBjb250ZXh0LkNvbGxlY3RHYXJiYWdlICYmIENvbGxlY3RHYXJiYWdlKCk7XG4gICAgfSk7XG4gIH1cblxuICB2YXIgb2xkQmVhbiA9IGNvbnRleHQuYmVhbjtcbiAgYmVhbi5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkge1xuICAgIGNvbnRleHQuYmVhbiA9IG9sZEJlYW47XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSA/XG4gICAgKG1vZHVsZS5leHBvcnRzID0gYmVhbikgOlxuICAgIChjb250ZXh0WydiZWFuJ10gPSBiZWFuKTtcblxuICAgIHJldHVybiBiZWFuO1xuXG59KSh7fSk7XG5cbmV4cG9ydCBkZWZhdWx0IGJlYW47XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7Ozs7Ozs7OztBQVNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBZ0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF2QkE7QUEwQkE7QUFDQTtBQTNCQTtBQThCQTtBQUNBO0FBQ0E7QUFoQ0E7QUFtQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXZDQTtBQTBDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBOUNBO0FBaURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXREQTtBQXlEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXBGQTtBQXVGQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUEvR0E7QUFrSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQTVIQTtBQStIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBM0lBO0FBOElBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBdkxBO0FBMExBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWhOQTtBQW1OQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF4TkE7QUEyTkE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFsT0E7QUFxT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUVBO0FBQ0E7QUFDQTtBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./js/bean.js\n");

/***/ }),

/***/ "./js/gator.js":
/*!*********************!*\
  !*** ./js/gator.js ***!
  \*********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _lib_ClustalRunner__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/ClustalRunner */ \"./js/lib/ClustalRunner.js\");\n/* harmony import */ var _lib_UniprotReader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/UniprotReader */ \"./js/lib/UniprotReader.js\");\n/* harmony import */ var _lib_UserdataReader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/UserdataReader */ \"./js/lib/UserdataReader.js\");\n/* harmony import */ var _lib_GenomeReader__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/GenomeReader */ \"./js/lib/GenomeReader.js\");\n/* harmony import */ var _lib_GatorDataReader__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lib/GatorDataReader */ \"./js/lib/GatorDataReader.js\");\n/* harmony import */ var _lib_Service__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./lib/Service */ \"./js/lib/Service.js\");\n/* harmony import */ var _lib_MASCP__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./lib/MASCP */ \"./js/lib/MASCP.js\");\n/* harmony import */ var _lib_CondensedSequenceRenderer__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./lib/CondensedSequenceRenderer */ \"./js/lib/CondensedSequenceRenderer.js\");\n/* harmony import */ var _lib_Dragger__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./lib/Dragger */ \"./js/lib/Dragger.js\");\n/* harmony import */ var _lib_GatorComponent__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./lib/GatorComponent */ \"./js/lib/GatorComponent.js\");\n/* harmony import */ var _lib_GeneComponent__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./lib/GeneComponent */ \"./js/lib/GeneComponent.js\");\n/* harmony import */ var _lib_TrackRendererComponent__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./lib/TrackRendererComponent */ \"./js/lib/TrackRendererComponent.js\");\n\n\n\n\n\n\n\n\n\n\n\n\nwindow.MASCP = _lib_MASCP__WEBPACK_IMPORTED_MODULE_6__[\"default\"];\n_lib_MASCP__WEBPACK_IMPORTED_MODULE_6__[\"default\"].ClustalRunner = _lib_ClustalRunner__WEBPACK_IMPORTED_MODULE_0__[\"default\"];\n_lib_MASCP__WEBPACK_IMPORTED_MODULE_6__[\"default\"].UniprotReader = _lib_UniprotReader__WEBPACK_IMPORTED_MODULE_1__[\"default\"];\n_lib_MASCP__WEBPACK_IMPORTED_MODULE_6__[\"default\"].UserdataReader = _lib_UserdataReader__WEBPACK_IMPORTED_MODULE_2__[\"default\"];\n_lib_MASCP__WEBPACK_IMPORTED_MODULE_6__[\"default\"].GenomeReader = _lib_GenomeReader__WEBPACK_IMPORTED_MODULE_3__[\"default\"];\n_lib_MASCP__WEBPACK_IMPORTED_MODULE_6__[\"default\"].GatorDataReader = _lib_GatorDataReader__WEBPACK_IMPORTED_MODULE_4__[\"default\"];\n\n\n\n\n\n\n\n_lib_MASCP__WEBPACK_IMPORTED_MODULE_6__[\"default\"].GatorComponent = _lib_GatorComponent__WEBPACK_IMPORTED_MODULE_9__[\"default\"];\n_lib_MASCP__WEBPACK_IMPORTED_MODULE_6__[\"default\"].GeneComponent = _lib_GeneComponent__WEBPACK_IMPORTED_MODULE_10__[\"default\"];\n_lib_MASCP__WEBPACK_IMPORTED_MODULE_6__[\"default\"].TrackComponent = _lib_TrackRendererComponent__WEBPACK_IMPORTED_MODULE_11__[\"default\"];//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9qcy9nYXRvci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9qcy9nYXRvci5qcz9hMjM2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBDbHVzdGFsUnVubmVyIGZyb20gJy4vbGliL0NsdXN0YWxSdW5uZXInO1xuaW1wb3J0IFVuaXByb3RSZWFkZXIgZnJvbSAnLi9saWIvVW5pcHJvdFJlYWRlcic7XG5pbXBvcnQgVXNlcmRhdGFSZWFkZXIgZnJvbSAnLi9saWIvVXNlcmRhdGFSZWFkZXInO1xuaW1wb3J0IEdlbm9tZVJlYWRlciBmcm9tICcuL2xpYi9HZW5vbWVSZWFkZXInO1xuaW1wb3J0IEdhdG9yRGF0YVJlYWRlciBmcm9tICcuL2xpYi9HYXRvckRhdGFSZWFkZXInO1xuaW1wb3J0IFNlcnZpY2UgZnJvbSAnLi9saWIvU2VydmljZSc7XG5cblxuaW1wb3J0IE1BU0NQIGZyb20gJy4vbGliL01BU0NQJztcbmltcG9ydCBDb25kZW5zZWRTZXF1ZW5jZVJlbmRlcmVyIGZyb20gJy4vbGliL0NvbmRlbnNlZFNlcXVlbmNlUmVuZGVyZXInO1xuXG5cbmltcG9ydCBEcmFnZ2VyIGZyb20gJy4vbGliL0RyYWdnZXInO1xuXG53aW5kb3cuTUFTQ1AgPSBNQVNDUDtcbk1BU0NQLkNsdXN0YWxSdW5uZXIgPSBDbHVzdGFsUnVubmVyO1xuTUFTQ1AuVW5pcHJvdFJlYWRlciA9IFVuaXByb3RSZWFkZXI7XG5NQVNDUC5Vc2VyZGF0YVJlYWRlciAgPSBVc2VyZGF0YVJlYWRlciA7XG5NQVNDUC5HZW5vbWVSZWFkZXIgPSBHZW5vbWVSZWFkZXI7XG5NQVNDUC5HYXRvckRhdGFSZWFkZXIgPSBHYXRvckRhdGFSZWFkZXI7XG5cbmltcG9ydCBHYXRvckNvbXBvbmVudCBmcm9tICcuL2xpYi9HYXRvckNvbXBvbmVudCc7XG5cbmltcG9ydCBHZW5lQ29tcG9uZW50IGZyb20gJy4vbGliL0dlbmVDb21wb25lbnQnO1xuXG5pbXBvcnQgVHJhY2tDb21wb25lbnQgZnJvbSAnLi9saWIvVHJhY2tSZW5kZXJlckNvbXBvbmVudCc7XG5cbk1BU0NQLkdhdG9yQ29tcG9uZW50ID0gR2F0b3JDb21wb25lbnQ7XG5NQVNDUC5HZW5lQ29tcG9uZW50ID0gR2VuZUNvbXBvbmVudDtcbk1BU0NQLlRyYWNrQ29tcG9uZW50ID0gVHJhY2tDb21wb25lbnQ7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./js/gator.js\n");

/***/ }),

/***/ "./js/hammer.js":
/*!**********************!*\
  !*** ./js/hammer.js ***!
  \**********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(module) {/*! Hammer.JS - v1.0.7dev - 2014-01-15\n * http://eightmedia.github.com/hammer.js\n *\n * Copyright (c) 2014 Jorik Tangelder <j.tangelder@gmail.com>;\n * Licensed under the MIT license */\n\nconst Hammer = function (window, undefined) {\n  'use strict';\n\n  /**\n   * Hammer\n   * use this to create instances\n   * @param   {HTMLElement}   element\n   * @param   {Object}        options\n   * @returns {Hammer.Instance}\n   * @constructor\n   */\n\n  var Hammer = function Hammer(element, options) {\n    return new Hammer.Instance(element, options || {});\n  };\n\n  // default settings\n  Hammer.defaults = {\n    // add styles and attributes to the element to prevent the browser from doing\n    // its native behavior. this doesnt prevent the scrolling, but cancels\n    // the contextmenu, tap highlighting etc\n    // set to false to disable this\n    stop_browser_behavior: {\n      // this also triggers onselectstart=false for IE\n      userSelect: 'none',\n      // this makes the element blocking in IE10 >, you could experiment with the value\n      // see for more options this issue; https://github.com/EightMedia/hammer.js/issues/241\n      touchAction: 'none',\n      touchCallout: 'none',\n      contentZooming: 'none',\n      userDrag: 'none',\n      tapHighlightColor: 'rgba(0,0,0,0)'\n\n      //\n      // more settings are defined per gesture at gestures.js\n      //\n    } };\n\n  // detect touchevents\n  Hammer.HAS_POINTEREVENTS = window.navigator.pointerEnabled || window.navigator.msPointerEnabled;\n  Hammer.HAS_TOUCHEVENTS = 'ontouchstart' in window;\n\n  // dont use mouseevents on mobile devices\n  Hammer.MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android|silk/i;\n  Hammer.NO_MOUSEEVENTS = Hammer.HAS_TOUCHEVENTS && window.navigator.userAgent.match(Hammer.MOBILE_REGEX);\n\n  // eventtypes per touchevent (start, move, end)\n  // are filled by Hammer.event.determineEventTypes on setup\n  Hammer.EVENT_TYPES = {};\n\n  // direction defines\n  Hammer.DIRECTION_DOWN = 'down';\n  Hammer.DIRECTION_LEFT = 'left';\n  Hammer.DIRECTION_UP = 'up';\n  Hammer.DIRECTION_RIGHT = 'right';\n\n  // pointer type\n  Hammer.POINTER_MOUSE = 'mouse';\n  Hammer.POINTER_TOUCH = 'touch';\n  Hammer.POINTER_PEN = 'pen';\n\n  // touch event defines\n  Hammer.EVENT_START = 'start';\n  Hammer.EVENT_MOVE = 'move';\n  Hammer.EVENT_END = 'end';\n\n  // hammer document where the base events are added at\n  Hammer.DOCUMENT = window.document;\n\n  // plugins and gestures namespaces\n  Hammer.plugins = Hammer.plugins || {};\n  Hammer.gestures = Hammer.gestures || {};\n\n  // if the window events are set...\n  Hammer.READY = false;\n\n  /**\n   * setup events to detect gestures on the document\n   */\n  function setup() {\n    if (Hammer.READY) {\n      return;\n    }\n\n    // find what eventtypes we add listeners to\n    Hammer.event.determineEventTypes();\n\n    // Register all gestures inside Hammer.gestures\n    Hammer.utils.each(Hammer.gestures, function (gesture) {\n      Hammer.detection.register(gesture);\n    });\n\n    // Add touch events on the document\n    Hammer.event.onTouch(Hammer.DOCUMENT, Hammer.EVENT_MOVE, Hammer.detection.detect);\n    Hammer.event.onTouch(Hammer.DOCUMENT, Hammer.EVENT_END, Hammer.detection.detect);\n\n    // Hammer is ready...!\n    Hammer.READY = true;\n  }\n\n  Hammer.utils = {\n    /**\n     * extend method,\n     * also used for cloning when dest is an empty object\n     * @param   {Object}    dest\n     * @param   {Object}    src\n     * @parm  {Boolean}  merge    do a merge\n     * @returns {Object}    dest\n     */\n    extend: function extend(dest, src, merge) {\n      for (var key in src) {\n        if (dest[key] !== undefined && merge) {\n          continue;\n        }\n        dest[key] = src[key];\n      }\n      return dest;\n    },\n\n    /**\n     * for each\n     * @param obj\n     * @param iterator\n     */\n    each: function each(obj, iterator, context) {\n      var i, length;\n      // native forEach on arrays\n      if ('forEach' in obj) {\n        obj.forEach(iterator, context);\n      }\n      // arrays\n      else if (obj.length !== undefined) {\n          for (i = 0, length = obj.length; i < length; i++) {\n            if (iterator.call(context, obj[i], i, obj) === false) {\n              return;\n            }\n          }\n        }\n        // objects\n        else {\n            for (i in obj) {\n              if (obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj) === false) {\n                return;\n              }\n            }\n          }\n    },\n\n    /**\n     * find if a node is in the given parent\n     * used for event delegation tricks\n     * @param   {HTMLElement}   node\n     * @param   {HTMLElement}   parent\n     * @returns {boolean}       has_parent\n     */\n    hasParent: function hasParent(node, parent) {\n      while (node) {\n        if (node == parent) {\n          return true;\n        }\n        node = node.parentNode;\n      }\n      return false;\n    },\n\n    /**\n     * get the center of all the touches\n     * @param   {Array}     touches\n     * @returns {Object}    center\n     */\n    getCenter: function getCenter(touches) {\n      var valuesX = [],\n          valuesY = [];\n\n      Hammer.utils.each(touches, function (touch) {\n        // I prefer clientX because it ignore the scrolling position\n        valuesX.push(typeof touch.clientX !== 'undefined' ? touch.clientX : touch.pageX);\n        valuesY.push(typeof touch.clientY !== 'undefined' ? touch.clientY : touch.pageY);\n      });\n\n      return {\n        pageX: (Math.min.apply(Math, valuesX) + Math.max.apply(Math, valuesX)) / 2,\n        pageY: (Math.min.apply(Math, valuesY) + Math.max.apply(Math, valuesY)) / 2\n      };\n    },\n\n    /**\n     * calculate the velocity between two points\n     * @param   {Number}    delta_time\n     * @param   {Number}    delta_x\n     * @param   {Number}    delta_y\n     * @returns {Object}    velocity\n     */\n    getVelocity: function getVelocity(delta_time, delta_x, delta_y) {\n      return {\n        x: Math.abs(delta_x / delta_time) || 0,\n        y: Math.abs(delta_y / delta_time) || 0\n      };\n    },\n\n    /**\n     * calculate the angle between two coordinates\n     * @param   {Touch}     touch1\n     * @param   {Touch}     touch2\n     * @returns {Number}    angle\n     */\n    getAngle: function getAngle(touch1, touch2) {\n      var y = touch2.pageY - touch1.pageY,\n          x = touch2.pageX - touch1.pageX;\n      return Math.atan2(y, x) * 180 / Math.PI;\n    },\n\n    /**\n     * angle to direction define\n     * @param   {Touch}     touch1\n     * @param   {Touch}     touch2\n     * @returns {String}    direction constant, like Hammer.DIRECTION_LEFT\n     */\n    getDirection: function getDirection(touch1, touch2) {\n      var x = Math.abs(touch1.pageX - touch2.pageX),\n          y = Math.abs(touch1.pageY - touch2.pageY);\n\n      if (x >= y) {\n        return touch1.pageX - touch2.pageX > 0 ? Hammer.DIRECTION_LEFT : Hammer.DIRECTION_RIGHT;\n      } else {\n        return touch1.pageY - touch2.pageY > 0 ? Hammer.DIRECTION_UP : Hammer.DIRECTION_DOWN;\n      }\n    },\n\n    /**\n     * calculate the distance between two touches\n     * @param   {Touch}     touch1\n     * @param   {Touch}     touch2\n     * @returns {Number}    distance\n     */\n    getDistance: function getDistance(touch1, touch2) {\n      var x = touch2.pageX - touch1.pageX,\n          y = touch2.pageY - touch1.pageY;\n      return Math.sqrt(x * x + y * y);\n    },\n\n    /**\n     * calculate the scale factor between two touchLists (fingers)\n     * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out\n     * @param   {Array}     start\n     * @param   {Array}     end\n     * @returns {Number}    scale\n     */\n    getScale: function getScale(start, end) {\n      // need two fingers...\n      if (start.length >= 2 && end.length >= 2) {\n        return this.getDistance(end[0], end[1]) / this.getDistance(start[0], start[1]);\n      }\n      return 1;\n    },\n\n    /**\n     * calculate the rotation degrees between two touchLists (fingers)\n     * @param   {Array}     start\n     * @param   {Array}     end\n     * @returns {Number}    rotation\n     */\n    getRotation: function getRotation(start, end) {\n      // need two fingers\n      if (start.length >= 2 && end.length >= 2) {\n        return this.getAngle(end[1], end[0]) - this.getAngle(start[1], start[0]);\n      }\n      return 0;\n    },\n\n    /**\n     * boolean if the direction is vertical\n     * @param    {String}    direction\n     * @returns  {Boolean}   is_vertical\n     */\n    isVertical: function isVertical(direction) {\n      return direction == Hammer.DIRECTION_UP || direction == Hammer.DIRECTION_DOWN;\n    },\n\n    /**\n     * stop browser default behavior with css props\n     * @param   {HtmlElement}   element\n     * @param   {Object}        css_props\n     */\n    stopDefaultBrowserBehavior: function stopDefaultBrowserBehavior(element, css_props) {\n      if (!css_props || !element || !element.style) {\n        return;\n      }\n\n      // with css properties for modern browsers\n      Hammer.utils.each(['webkit', 'khtml', 'moz', 'Moz', 'ms', 'o', ''], function (vendor) {\n        Hammer.utils.each(css_props, function (value, prop) {\n          // vender prefix at the property\n          if (vendor) {\n            prop = vendor + prop.substring(0, 1).toUpperCase() + prop.substring(1);\n          }\n          // set the style\n          if (prop in element.style) {\n            element.style[prop] = value;\n          }\n        });\n      });\n\n      // also the disable onselectstart\n      if (css_props.userSelect == 'none') {\n        element.onselectstart = function () {\n          return false;\n        };\n      }\n\n      // and disable ondragstart\n      if (css_props.userDrag == 'none') {\n        element.ondragstart = function () {\n          return false;\n        };\n      }\n    }\n  };\n\n  /**\n   * create new hammer instance\n   * all methods should return the instance itself, so it is chainable.\n   * @param   {HTMLElement}       element\n   * @param   {Object}            [options={}]\n   * @returns {Hammer.Instance}\n   * @constructor\n   */\n  Hammer.Instance = function (element, options) {\n    var self = this;\n\n    // setup HammerJS window events and register all gestures\n    // this also sets up the default options\n    setup();\n\n    this.element = element;\n\n    // start/stop detection option\n    this.enabled = true;\n\n    // merge options\n    this.options = Hammer.utils.extend(Hammer.utils.extend({}, Hammer.defaults), options || {});\n\n    // add some css to the element to prevent the browser from doing its native behavoir\n    if (this.options.stop_browser_behavior) {\n      Hammer.utils.stopDefaultBrowserBehavior(this.element, this.options.stop_browser_behavior);\n    }\n\n    // start detection on touchstart\n    Hammer.event.onTouch(element, Hammer.EVENT_START, function (ev) {\n      if (self.enabled) {\n        Hammer.detection.startDetect(self, ev);\n      }\n    });\n\n    // return instance\n    return this;\n  };\n\n  Hammer.Instance.prototype = {\n    /**\n     * bind events to the instance\n     * @param   {String}      gesture\n     * @param   {Function}    handler\n     * @returns {Hammer.Instance}\n     */\n    on: function onEvent(gesture, handler) {\n      var gestures = gesture.split(' ');\n      Hammer.utils.each(gestures, function (gesture) {\n        this.element.addEventListener(gesture, handler, false);\n      }, this);\n      return this;\n    },\n\n    /**\n     * unbind events to the instance\n     * @param   {String}      gesture\n     * @param   {Function}    handler\n     * @returns {Hammer.Instance}\n     */\n    off: function offEvent(gesture, handler) {\n      var gestures = gesture.split(' ');\n      Hammer.utils.each(gestures, function (gesture) {\n        this.element.removeEventListener(gesture, handler, false);\n      }, this);\n      return this;\n    },\n\n    /**\n     * trigger gesture event\n     * @param   {String}      gesture\n     * @param   {Object}      [eventData]\n     * @returns {Hammer.Instance}\n     */\n    trigger: function triggerEvent(gesture, eventData) {\n      // optional\n      if (!eventData) {\n        eventData = {};\n      }\n\n      // create DOM event\n      var event = Hammer.DOCUMENT.createEvent('Event');\n      event.initEvent(gesture, true, true);\n      event.gesture = eventData;\n\n      // trigger on the target if it is in the instance element,\n      // this is for event delegation tricks\n      var element = this.element;\n      if (Hammer.utils.hasParent(eventData.target, element)) {\n        element = eventData.target;\n      }\n\n      element.dispatchEvent(event);\n      return this;\n    },\n\n    /**\n     * enable of disable hammer.js detection\n     * @param   {Boolean}   state\n     * @returns {Hammer.Instance}\n     */\n    enable: function enable(state) {\n      this.enabled = state;\n      return this;\n    }\n  };\n\n  /**\n   * this holds the last move event,\n   * used to fix empty touchend issue\n   * see the onTouch event for an explanation\n   * @type {Object}\n   */\n  var last_move_event = null;\n\n  /**\n   * when the mouse is hold down, this is true\n   * @type {Boolean}\n   */\n  var enable_detect = false;\n\n  /**\n   * when touch events have been fired, this is true\n   * @type {Boolean}\n   */\n  var touch_triggered = false;\n\n  Hammer.event = {\n    /**\n     * simple addEventListener\n     * @param   {HTMLElement}   element\n     * @param   {String}        type\n     * @param   {Function}      handler\n     */\n    bindDom: function bindDom(element, type, handler) {\n      var types = type.split(' ');\n      Hammer.utils.each(types, function (type) {\n        element.addEventListener(type, handler, false);\n      });\n    },\n\n    /**\n     * touch events with mouse fallback\n     * @param   {HTMLElement}   element\n     * @param   {String}        eventType        like Hammer.EVENT_MOVE\n     * @param   {Function}      handler\n     */\n    onTouch: function onTouch(element, eventType, handler) {\n      var self = this;\n\n      this.bindDom(element, Hammer.EVENT_TYPES[eventType], function bindDomOnTouch(ev) {\n        var sourceEventType = ev.type.toLowerCase();\n\n        // onmouseup, but when touchend has been fired we do nothing.\n        // this is for touchdevices which also fire a mouseup on touchend\n        if (sourceEventType.match(/mouse/) && touch_triggered) {\n          return;\n        }\n\n        // mousebutton must be down or a touch event\n        else if (sourceEventType.match(/touch/) || // touch events are always on screen\n          sourceEventType.match(/pointerdown/) || // pointerevents touch\n          sourceEventType.match(/mouse/) && ev.which === 1 // mouse is pressed\n          ) {\n              enable_detect = true;\n            }\n\n            // mouse isn't pressed\n          else if (sourceEventType.match(/mouse/) && !ev.which) {\n              enable_detect = false;\n            }\n\n        // we are in a touch event, set the touch triggered bool to true,\n        // this for the conflicts that may occur on ios and android\n        if (sourceEventType.match(/touch|pointer/)) {\n          touch_triggered = true;\n        }\n\n        // count the total touches on the screen\n        var count_touches = 0;\n\n        // when touch has been triggered in this detection session\n        // and we are now handling a mouse event, we stop that to prevent conflicts\n        if (enable_detect) {\n          // update pointerevent\n          if (Hammer.HAS_POINTEREVENTS && eventType != Hammer.EVENT_END) {\n            count_touches = Hammer.PointerEvent.updatePointer(eventType, ev);\n          }\n          // touch\n          else if (sourceEventType.match(/touch/)) {\n              count_touches = ev.touches.length;\n            }\n            // mouse\n            else if (!touch_triggered) {\n                count_touches = sourceEventType.match(/up/) ? 0 : 1;\n              }\n\n          // if we are in a end event, but when we remove one touch and\n          // we still have enough, set eventType to move\n          if (count_touches > 0 && eventType == Hammer.EVENT_END) {\n            eventType = Hammer.EVENT_MOVE;\n          }\n          // no touches, force the end event\n          else if (!count_touches) {\n              eventType = Hammer.EVENT_END;\n            }\n\n          // store the last move event\n          if (count_touches || last_move_event === null) {\n            last_move_event = ev;\n          }\n\n          // trigger the handler\n          handler.call(Hammer.detection, self.collectEventData(element, eventType, self.getTouchList(last_move_event, eventType), ev));\n\n          // remove pointerevent from list\n          if (Hammer.HAS_POINTEREVENTS && eventType == Hammer.EVENT_END) {\n            count_touches = Hammer.PointerEvent.updatePointer(eventType, ev);\n          }\n        }\n\n        // on the end we reset everything\n        if (!count_touches) {\n          last_move_event = null;\n          enable_detect = false;\n          touch_triggered = false;\n          Hammer.PointerEvent.reset();\n        }\n      }, { passive: true });\n      // FIXME - PASSIVE\n    },\n\n    /**\n     * we have different events for each device/browser\n     * determine what we need and set them in the Hammer.EVENT_TYPES constant\n     */\n    determineEventTypes: function determineEventTypes() {\n      // determine the eventtype we want to set\n      var types;\n\n      // pointerEvents magic\n      if (Hammer.HAS_POINTEREVENTS) {\n        types = Hammer.PointerEvent.getEvents();\n      }\n      // on Android, iOS, blackberry, windows mobile we dont want any mouseevents\n      else if (Hammer.NO_MOUSEEVENTS) {\n          types = ['touchstart', 'touchmove', 'touchend touchcancel'];\n        }\n        // for non pointer events browsers and mixed browsers,\n        // like chrome on windows8 touch laptop\n        else {\n            types = ['touchstart mousedown', 'touchmove mousemove', 'touchend touchcancel mouseup'];\n          }\n\n      Hammer.EVENT_TYPES[Hammer.EVENT_START] = types[0];\n      Hammer.EVENT_TYPES[Hammer.EVENT_MOVE] = types[1];\n      Hammer.EVENT_TYPES[Hammer.EVENT_END] = types[2];\n    },\n\n    /**\n     * create touchlist depending on the event\n     * @param   {Object}    ev\n     * @param   {String}    eventType   used by the fakemultitouch plugin\n     */\n    getTouchList: function getTouchList(ev /*, eventType*/) {\n      // get the fake pointerEvent touchlist\n      if (Hammer.HAS_POINTEREVENTS) {\n        return Hammer.PointerEvent.getTouchList();\n      }\n      // get the touchlist\n      else if (ev.touches) {\n          return ev.touches;\n        }\n        // make fake touchlist from mouse position\n        else {\n            ev.identifier = 1;\n            return [ev];\n          }\n    },\n\n    /**\n     * collect event data for Hammer js\n     * @param   {HTMLElement}   element\n     * @param   {String}        eventType        like Hammer.EVENT_MOVE\n     * @param   {Object}        eventData\n     */\n    collectEventData: function collectEventData(element, eventType, touches, ev) {\n      // find out pointerType\n      var pointerType = Hammer.POINTER_TOUCH;\n      if (ev.type.match(/mouse/) || Hammer.PointerEvent.matchType(Hammer.POINTER_MOUSE, ev)) {\n        pointerType = Hammer.POINTER_MOUSE;\n      }\n\n      return {\n        center: Hammer.utils.getCenter(touches),\n        timeStamp: new Date().getTime(),\n        target: ev.target,\n        touches: touches,\n        eventType: eventType,\n        pointerType: pointerType,\n        srcEvent: ev,\n\n        /**\n         * prevent the browser default actions\n         * mostly used to disable scrolling of the browser\n         */\n        preventDefault: function preventDefault() {\n          if (this.srcEvent.preventManipulation) {\n            this.srcEvent.preventManipulation();\n          }\n\n          if (this.srcEvent.preventDefault) {\n            this.srcEvent.preventDefault();\n          }\n        },\n\n        /**\n         * stop bubbling the event up to its parents\n         */\n        stopPropagation: function stopPropagation() {\n          this.srcEvent.stopPropagation();\n        },\n\n        /**\n         * immediately stop gesture detection\n         * might be useful after a swipe was detected\n         * @return {*}\n         */\n        stopDetect: function stopDetect() {\n          return Hammer.detection.stopDetect();\n        }\n      };\n    }\n  };\n\n  Hammer.PointerEvent = {\n    /**\n     * holds all pointers\n     * @type {Object}\n     */\n    pointers: {},\n\n    /**\n     * get a list of pointers\n     * @returns {Array}     touchlist\n     */\n    getTouchList: function getTouchList() {\n      var self = this;\n      var touchlist = [];\n\n      // we can use forEach since pointerEvents only is in IE10\n      Hammer.utils.each(self.pointers, function (pointer) {\n        touchlist.push(pointer);\n      });\n\n      return touchlist;\n    },\n\n    /**\n     * update the position of a pointer\n     * @param   {String}   type             Hammer.EVENT_END\n     * @param   {Object}   pointerEvent\n     */\n    updatePointer: function updatePointer(type, pointerEvent) {\n      if (type == Hammer.EVENT_END) {\n        this.pointers = {};\n      } else {\n        pointerEvent.identifier = pointerEvent.pointerId;\n        this.pointers[pointerEvent.pointerId] = pointerEvent;\n      }\n\n      return Object.keys(this.pointers).length;\n    },\n\n    /**\n     * check if ev matches pointertype\n     * @param   {String}        pointerType     Hammer.POINTER_MOUSE\n     * @param   {PointerEvent}  ev\n     */\n    matchType: function matchType(pointerType, ev) {\n      if (!ev.pointerType) {\n        return false;\n      }\n\n      var pt = ev.pointerType,\n          types = {};\n      types[Hammer.POINTER_MOUSE] = pt === ev.MSPOINTER_TYPE_MOUSE || pt === Hammer.POINTER_MOUSE;\n      types[Hammer.POINTER_TOUCH] = pt === ev.MSPOINTER_TYPE_TOUCH || pt === Hammer.POINTER_TOUCH;\n      types[Hammer.POINTER_PEN] = pt === ev.MSPOINTER_TYPE_PEN || pt === Hammer.POINTER_PEN;\n      return types[pointerType];\n    },\n\n    /**\n     * get events\n     */\n    getEvents: function getEvents() {\n      return ['pointerdown MSPointerDown', 'pointermove MSPointerMove', 'pointerup pointercancel MSPointerUp MSPointerCancel'];\n    },\n\n    /**\n     * reset the list\n     */\n    reset: function reset() {\n      this.pointers = {};\n    }\n  };\n\n  Hammer.detection = {\n    // contains all registred Hammer.gestures in the correct order\n    gestures: [],\n\n    // data of the current Hammer.gesture detection session\n    current: null,\n\n    // the previous Hammer.gesture session data\n    // is a full clone of the previous gesture.current object\n    previous: null,\n\n    // when this becomes true, no gestures are fired\n    stopped: false,\n\n    /**\n     * start Hammer.gesture detection\n     * @param   {Hammer.Instance}   inst\n     * @param   {Object}            eventData\n     */\n    startDetect: function startDetect(inst, eventData) {\n      // already busy with a Hammer.gesture detection on an element\n      if (this.current) {\n        return;\n      }\n\n      this.stopped = false;\n\n      this.current = {\n        inst: inst, // reference to HammerInstance we're working for\n        startEvent: Hammer.utils.extend({}, eventData), // start eventData for distances, timing etc\n        lastEvent: false, // last eventData\n        name: '' // current gesture we're in/detected, can be 'tap', 'hold' etc\n      };\n\n      this.detect(eventData);\n    },\n\n    /**\n     * Hammer.gesture detection\n     * @param   {Object}    eventData\n     */\n    detect: function detect(eventData) {\n      if (!this.current || this.stopped) {\n        return;\n      }\n\n      // extend event data with calculations about scale, distance etc\n      eventData = this.extendEventData(eventData);\n\n      // instance options\n      var inst_options = this.current.inst.options;\n\n      // call Hammer.gesture handlers\n      Hammer.utils.each(this.gestures, function (gesture) {\n        // only when the instance options have enabled this gesture\n        if (!this.stopped && inst_options[gesture.name] !== false) {\n          // if a handler returns false, we stop with the detection\n          if (gesture.handler.call(gesture, eventData, this.current.inst) === false) {\n            this.stopDetect();\n            return false;\n          }\n        }\n      }, this);\n\n      // store as previous event event\n      if (this.current) {\n        this.current.lastEvent = eventData;\n      }\n\n      // endevent, but not the last touch, so dont stop\n      if (eventData.eventType == Hammer.EVENT_END && !eventData.touches.length - 1) {\n        this.stopDetect();\n      }\n\n      return eventData;\n    },\n\n    /**\n     * clear the Hammer.gesture vars\n     * this is called on endDetect, but can also be used when a final Hammer.gesture has been detected\n     * to stop other Hammer.gestures from being fired\n     */\n    stopDetect: function stopDetect() {\n      // clone current data to the store as the previous gesture\n      // used for the double tap gesture, since this is an other gesture detect session\n      this.previous = Hammer.utils.extend({}, this.current);\n\n      // reset the current\n      this.current = null;\n\n      // stopped!\n      this.stopped = true;\n    },\n\n    /**\n     * extend eventData for Hammer.gestures\n     * @param   {Object}   ev\n     * @returns {Object}   ev\n     */\n    extendEventData: function extendEventData(ev) {\n      var startEv = this.current.startEvent;\n\n      // if the touches change, set the new touches over the startEvent touches\n      // this because touchevents don't have all the touches on touchstart, or the\n      // user must place his fingers at the EXACT same time on the screen, which is not realistic\n      // but, sometimes it happens that both fingers are touching at the EXACT same time\n      if (startEv && (ev.touches.length != startEv.touches.length || ev.touches === startEv.touches)) {\n        // extend 1 level deep to get the touchlist with the touch objects\n        startEv.touches = [];\n        Hammer.utils.each(ev.touches, function (touch) {\n          startEv.touches.push(Hammer.utils.extend({}, touch));\n        });\n      }\n\n      var delta_time = ev.timeStamp - startEv.timeStamp,\n          delta_x = ev.center.pageX - startEv.center.pageX,\n          delta_y = ev.center.pageY - startEv.center.pageY,\n          velocity = Hammer.utils.getVelocity(delta_time, delta_x, delta_y),\n          interimAngle,\n          interimDirection;\n\n      // end events (e.g. dragend) don't have useful values for interimDirection & interimAngle\n      // because the previous event has exactly the same coordinates\n      // so for end events, take the previous values of interimDirection & interimAngle\n      // instead of recalculating them and getting a spurious '0'\n      if (ev.eventType === 'end') {\n        interimAngle = this.current.lastEvent && this.current.lastEvent.interimAngle;\n        interimDirection = this.current.lastEvent && this.current.lastEvent.interimDirection;\n      } else {\n        interimAngle = this.current.lastEvent && Hammer.utils.getAngle(this.current.lastEvent.center, ev.center);\n        interimDirection = this.current.lastEvent && Hammer.utils.getDirection(this.current.lastEvent.center, ev.center);\n      }\n\n      Hammer.utils.extend(ev, {\n        deltaTime: delta_time,\n\n        deltaX: delta_x,\n        deltaY: delta_y,\n\n        velocityX: velocity.x,\n        velocityY: velocity.y,\n\n        distance: Hammer.utils.getDistance(startEv.center, ev.center),\n\n        angle: Hammer.utils.getAngle(startEv.center, ev.center),\n        interimAngle: interimAngle,\n\n        direction: Hammer.utils.getDirection(startEv.center, ev.center),\n        interimDirection: interimDirection,\n\n        scale: Hammer.utils.getScale(startEv.touches, ev.touches),\n        rotation: Hammer.utils.getRotation(startEv.touches, ev.touches),\n\n        startEvent: startEv\n      });\n\n      return ev;\n    },\n\n    /**\n     * register new gesture\n     * @param   {Object}    gesture object, see gestures.js for documentation\n     * @returns {Array}     gestures\n     */\n    register: function register(gesture) {\n      // add an enable gesture options if there is no given\n      var options = gesture.defaults || {};\n      if (options[gesture.name] === undefined) {\n        options[gesture.name] = true;\n      }\n\n      // extend Hammer default options with the Hammer.gesture options\n      Hammer.utils.extend(Hammer.defaults, options, true);\n\n      // set its index\n      gesture.index = gesture.index || 1000;\n\n      // add Hammer.gesture to the list\n      this.gestures.push(gesture);\n\n      // sort the list by index\n      this.gestures.sort(function (a, b) {\n        if (a.index < b.index) {\n          return -1;\n        }\n        if (a.index > b.index) {\n          return 1;\n        }\n        return 0;\n      });\n\n      return this.gestures;\n    }\n  };\n\n  /**\n   * Drag\n   * Move with x fingers (default 1) around on the page. Blocking the scrolling when\n   * moving left and right is a good practice. When all the drag events are blocking\n   * you disable scrolling on that area.\n   * @events  drag, drapleft, dragright, dragup, dragdown\n   */\n  Hammer.gestures.Drag = {\n    name: 'drag',\n    index: 50,\n    defaults: {\n      drag_min_distance: 10,\n\n      // Set correct_for_drag_min_distance to true to make the starting point of the drag\n      // be calculated from where the drag was triggered, not from where the touch started.\n      // Useful to avoid a jerk-starting drag, which can make fine-adjustments\n      // through dragging difficult, and be visually unappealing.\n      correct_for_drag_min_distance: true,\n\n      // set 0 for unlimited, but this can conflict with transform\n      drag_max_touches: 1,\n\n      // prevent default browser behavior when dragging occurs\n      // be careful with it, it makes the element a blocking element\n      // when you are using the drag gesture, it is a good practice to set this true\n      drag_block_horizontal: false,\n      drag_block_vertical: false,\n\n      // drag_lock_to_axis keeps the drag gesture on the axis that it started on,\n      // It disallows vertical directions if the initial direction was horizontal, and vice versa.\n      drag_lock_to_axis: false,\n\n      // drag lock only kicks in when distance > drag_lock_min_distance\n      // This way, locking occurs only when the distance has become large enough to reliably determine the direction\n      drag_lock_min_distance: 25\n    },\n\n    triggered: false,\n    handler: function dragGesture(ev, inst) {\n      // current gesture isnt drag, but dragged is true\n      // this means an other gesture is busy. now call dragend\n      if (Hammer.detection.current.name != this.name && this.triggered) {\n        inst.trigger(this.name + 'end', ev);\n        this.triggered = false;\n        return;\n      }\n\n      // max touches\n      if (inst.options.drag_max_touches > 0 && ev.touches.length > inst.options.drag_max_touches) {\n        return;\n      }\n\n      switch (ev.eventType) {\n        case Hammer.EVENT_START:\n          this.triggered = false;\n          break;\n\n        case Hammer.EVENT_MOVE:\n          // when the distance we moved is too small we skip this gesture\n          // or we can be already in dragging\n          if (ev.distance < inst.options.drag_min_distance && Hammer.detection.current.name != this.name) {\n            return;\n          }\n\n          // we are dragging!\n          if (Hammer.detection.current.name != this.name) {\n            Hammer.detection.current.name = this.name;\n            if (inst.options.correct_for_drag_min_distance && ev.distance > 0) {\n              // When a drag is triggered, set the event center to drag_min_distance pixels from the original event center.\n              // Without this correction, the dragged distance would jumpstart at drag_min_distance pixels instead of at 0.\n              // It might be useful to save the original start point somewhere\n              var factor = Math.abs(inst.options.drag_min_distance / ev.distance);\n              Hammer.detection.current.startEvent.center.pageX += ev.deltaX * factor;\n              Hammer.detection.current.startEvent.center.pageY += ev.deltaY * factor;\n\n              // recalculate event data using new start point\n              ev = Hammer.detection.extendEventData(ev);\n            }\n          }\n\n          // lock drag to axis?\n          if (Hammer.detection.current.lastEvent.drag_locked_to_axis || inst.options.drag_lock_to_axis && inst.options.drag_lock_min_distance <= ev.distance) {\n            ev.drag_locked_to_axis = true;\n          }\n          var last_direction = Hammer.detection.current.lastEvent.direction;\n          if (ev.drag_locked_to_axis && last_direction !== ev.direction) {\n            // keep direction on the axis that the drag gesture started on\n            if (Hammer.utils.isVertical(last_direction)) {\n              ev.direction = ev.deltaY < 0 ? Hammer.DIRECTION_UP : Hammer.DIRECTION_DOWN;\n            } else {\n              ev.direction = ev.deltaX < 0 ? Hammer.DIRECTION_LEFT : Hammer.DIRECTION_RIGHT;\n            }\n          }\n\n          // first time, trigger dragstart event\n          if (!this.triggered) {\n            inst.trigger(this.name + 'start', ev);\n            this.triggered = true;\n          }\n\n          // trigger normal event\n          inst.trigger(this.name, ev);\n\n          // direction event, like dragdown\n          inst.trigger(this.name + ev.direction, ev);\n\n          // block the browser events\n          if (inst.options.drag_block_vertical && Hammer.utils.isVertical(ev.direction) || inst.options.drag_block_horizontal && !Hammer.utils.isVertical(ev.direction)) {\n            ev.preventDefault();\n          }\n          break;\n\n        case Hammer.EVENT_END:\n          // trigger dragend\n          if (this.triggered) {\n            inst.trigger(this.name + 'end', ev);\n          }\n\n          this.triggered = false;\n          break;\n      }\n    }\n  };\n\n  /**\n   * Hold\n   * Touch stays at the same place for x time\n   * @events  hold\n   */\n  Hammer.gestures.Hold = {\n    name: 'hold',\n    index: 10,\n    defaults: {\n      hold_timeout: 500,\n      hold_threshold: 1\n    },\n    timer: null,\n    handler: function holdGesture(ev, inst) {\n      switch (ev.eventType) {\n        case Hammer.EVENT_START:\n          // clear any running timers\n          clearTimeout(this.timer);\n\n          // set the gesture so we can check in the timeout if it still is\n          Hammer.detection.current.name = this.name;\n\n          // set timer and if after the timeout it still is hold,\n          // we trigger the hold event\n          this.timer = setTimeout(function () {\n            if (Hammer.detection.current.name == 'hold') {\n              inst.trigger('hold', ev);\n            }\n          }, inst.options.hold_timeout);\n          break;\n\n        // when you move or end we clear the timer\n        case Hammer.EVENT_MOVE:\n          if (ev.distance > inst.options.hold_threshold) {\n            clearTimeout(this.timer);\n          }\n          break;\n\n        case Hammer.EVENT_END:\n          clearTimeout(this.timer);\n          break;\n      }\n    }\n  };\n\n  /**\n   * Release\n   * Called as last, tells the user has released the screen\n   * @events  release\n   */\n  Hammer.gestures.Release = {\n    name: 'release',\n    index: Infinity,\n    handler: function releaseGesture(ev, inst) {\n      if (ev.eventType == Hammer.EVENT_END) {\n        inst.trigger(this.name, ev);\n      }\n    }\n  };\n\n  /**\n   * Swipe\n   * triggers swipe events when the end velocity is above the threshold\n   * @events  swipe, swipeleft, swiperight, swipeup, swipedown\n   */\n  Hammer.gestures.Swipe = {\n    name: 'swipe',\n    index: 40,\n    defaults: {\n      // set 0 for unlimited, but this can conflict with transform\n      swipe_min_touches: 1,\n      swipe_max_touches: 1,\n      swipe_velocity: 0.7\n    },\n    handler: function swipeGesture(ev, inst) {\n      if (ev.eventType == Hammer.EVENT_END) {\n        // max touches\n        if (inst.options.swipe_max_touches > 0 && ev.touches.length < inst.options.swipe_min_touches && ev.touches.length > inst.options.swipe_max_touches) {\n          return;\n        }\n\n        // when the distance we moved is too small we skip this gesture\n        // or we can be already in dragging\n        if (ev.velocityX > inst.options.swipe_velocity || ev.velocityY > inst.options.swipe_velocity) {\n          // trigger swipe events\n          inst.trigger(this.name, ev);\n          inst.trigger(this.name + ev.direction, ev);\n        }\n      }\n    }\n  };\n\n  /**\n   * Tap/DoubleTap\n   * Quick touch at a place or double at the same place\n   * @events  tap, doubletap\n   */\n  Hammer.gestures.Tap = {\n    name: 'tap',\n    index: 100,\n    defaults: {\n      tap_max_touchtime: 250,\n      tap_max_distance: 10,\n      tap_always: true,\n      doubletap_distance: 20,\n      doubletap_interval: 300\n    },\n    handler: function tapGesture(ev, inst) {\n      if (ev.eventType == Hammer.EVENT_END && ev.srcEvent.type != 'touchcancel') {\n        // previous gesture, for the double tap since these are two different gesture detections\n        var prev = Hammer.detection.previous,\n            did_doubletap = false;\n\n        // when the touchtime is higher then the max touch time\n        // or when the moving distance is too much\n        if (ev.deltaTime > inst.options.tap_max_touchtime || ev.distance > inst.options.tap_max_distance) {\n          return;\n        }\n\n        // check if double tap\n        if (prev && prev.name == 'tap' && ev.timeStamp - prev.lastEvent.timeStamp < inst.options.doubletap_interval && ev.distance < inst.options.doubletap_distance) {\n          inst.trigger('doubletap', ev);\n          did_doubletap = true;\n        }\n\n        // do a single tap\n        if (!did_doubletap || inst.options.tap_always) {\n          Hammer.detection.current.name = 'tap';\n          inst.trigger(Hammer.detection.current.name, ev);\n        }\n      }\n    }\n  };\n\n  /**\n   * Touch\n   * Called as first, tells the user has touched the screen\n   * @events  touch\n   */\n  Hammer.gestures.Touch = {\n    name: 'touch',\n    index: -Infinity,\n    defaults: {\n      // call preventDefault at touchstart, and makes the element blocking by\n      // disabling the scrolling of the page, but it improves gestures like\n      // transforming and dragging.\n      // be careful with using this, it can be very annoying for users to be stuck\n      // on the page\n      prevent_default: false,\n\n      // disable mouse events, so only touch (or pen!) input triggers events\n      prevent_mouseevents: false\n    },\n    handler: function touchGesture(ev, inst) {\n      if (inst.options.prevent_mouseevents && ev.pointerType == Hammer.POINTER_MOUSE) {\n        ev.stopDetect();\n        return;\n      }\n\n      if (inst.options.prevent_default) {\n        ev.preventDefault();\n      }\n\n      if (ev.eventType == Hammer.EVENT_START) {\n        inst.trigger(this.name, ev);\n      }\n    }\n  };\n\n  /**\n   * Transform\n   * User want to scale or rotate with 2 fingers\n   * @events  transform, pinch, pinchin, pinchout, rotate\n   */\n  Hammer.gestures.Transform = {\n    name: 'transform',\n    index: 45,\n    defaults: {\n      // factor, no scale is 1, zoomin is to 0 and zoomout until higher then 1\n      transform_min_scale: 0.01,\n      // rotation in degrees\n      transform_min_rotation: 1,\n      // prevent default browser behavior when two touches are on the screen\n      // but it makes the element a blocking element\n      // when you are using the transform gesture, it is a good practice to set this true\n      transform_always_block: false\n    },\n    triggered: false,\n    handler: function transformGesture(ev, inst) {\n      // current gesture isnt drag, but dragged is true\n      // this means an other gesture is busy. now call dragend\n      if (Hammer.detection.current.name != this.name && this.triggered) {\n        inst.trigger(this.name + 'end', ev);\n        this.triggered = false;\n        return;\n      }\n\n      // atleast multitouch\n      if (ev.touches.length < 2) {\n        return;\n      }\n\n      // prevent default when two fingers are on the screen\n      if (inst.options.transform_always_block) {\n        ev.preventDefault();\n      }\n\n      switch (ev.eventType) {\n        case Hammer.EVENT_START:\n          this.triggered = false;\n          break;\n\n        case Hammer.EVENT_MOVE:\n          var scale_threshold = Math.abs(1 - ev.scale);\n          var rotation_threshold = Math.abs(ev.rotation);\n\n          // when the distance we moved is too small we skip this gesture\n          // or we can be already in dragging\n          if (scale_threshold < inst.options.transform_min_scale && rotation_threshold < inst.options.transform_min_rotation) {\n            return;\n          }\n\n          // we are transforming!\n          Hammer.detection.current.name = this.name;\n\n          // first time, trigger dragstart event\n          if (!this.triggered) {\n            inst.trigger(this.name + 'start', ev);\n            this.triggered = true;\n          }\n\n          inst.trigger(this.name, ev); // basic transform event\n\n          // trigger rotate event\n          if (rotation_threshold > inst.options.transform_min_rotation) {\n            inst.trigger('rotate', ev);\n          }\n\n          // trigger pinch event\n          if (scale_threshold > inst.options.transform_min_scale) {\n            inst.trigger('pinch', ev);\n            inst.trigger('pinch' + (ev.scale < 1 ? 'in' : 'out'), ev);\n          }\n          break;\n\n        case Hammer.EVENT_END:\n          // trigger dragend\n          if (this.triggered) {\n            inst.trigger(this.name + 'end', ev);\n          }\n\n          this.triggered = false;\n          break;\n      }\n    }\n  };\n\n  // Based off Lo-Dash's excellent UMD wrapper (slightly modified) - https://github.com/bestiejs/lodash/blob/master/lodash.js#L5515-L5543\n  // some AMD build optimizers, like r.js, check for specific condition patterns like the following:\n  if (typeof define == 'function' && __webpack_require__(/*! !webpack amd options */ \"./node_modules/webpack/buildin/amd-options.js\")) {\n    // define as an anonymous module\n    define(function () {\n      return Hammer;\n    });\n  }\n\n  // check for `exports` after `define` in case a build optimizer adds an `exports` object\n  else if (typeof module === 'object' && module.exports) {\n      module.exports = Hammer;\n    } else {\n      window.Hammer = Hammer;\n    }\n\n  return Hammer;\n}(window);\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Hammer);\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../node_modules/webpack/buildin/harmony-module.js */ \"./node_modules/webpack/buildin/harmony-module.js\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9qcy9oYW1tZXIuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vanMvaGFtbWVyLmpzPzcwNjUiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIEhhbW1lci5KUyAtIHYxLjAuN2RldiAtIDIwMTQtMDEtMTVcbiAqIGh0dHA6Ly9laWdodG1lZGlhLmdpdGh1Yi5jb20vaGFtbWVyLmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE0IEpvcmlrIFRhbmdlbGRlciA8ai50YW5nZWxkZXJAZ21haWwuY29tPjtcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSAqL1xuXG5jb25zdCBIYW1tZXIgPSAoZnVuY3Rpb24od2luZG93LCB1bmRlZmluZWQpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEhhbW1lclxuICogdXNlIHRoaXMgdG8gY3JlYXRlIGluc3RhbmNlc1xuICogQHBhcmFtICAge0hUTUxFbGVtZW50fSAgIGVsZW1lbnRcbiAqIEBwYXJhbSAgIHtPYmplY3R9ICAgICAgICBvcHRpb25zXG4gKiBAcmV0dXJucyB7SGFtbWVyLkluc3RhbmNlfVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBIYW1tZXIgPSBmdW5jdGlvbihlbGVtZW50LCBvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgSGFtbWVyLkluc3RhbmNlKGVsZW1lbnQsIG9wdGlvbnMgfHwge30pO1xufTtcblxuLy8gZGVmYXVsdCBzZXR0aW5nc1xuSGFtbWVyLmRlZmF1bHRzID0ge1xuICAvLyBhZGQgc3R5bGVzIGFuZCBhdHRyaWJ1dGVzIHRvIHRoZSBlbGVtZW50IHRvIHByZXZlbnQgdGhlIGJyb3dzZXIgZnJvbSBkb2luZ1xuICAvLyBpdHMgbmF0aXZlIGJlaGF2aW9yLiB0aGlzIGRvZXNudCBwcmV2ZW50IHRoZSBzY3JvbGxpbmcsIGJ1dCBjYW5jZWxzXG4gIC8vIHRoZSBjb250ZXh0bWVudSwgdGFwIGhpZ2hsaWdodGluZyBldGNcbiAgLy8gc2V0IHRvIGZhbHNlIHRvIGRpc2FibGUgdGhpc1xuICBzdG9wX2Jyb3dzZXJfYmVoYXZpb3I6IHtcbiAgICAvLyB0aGlzIGFsc28gdHJpZ2dlcnMgb25zZWxlY3RzdGFydD1mYWxzZSBmb3IgSUVcbiAgICB1c2VyU2VsZWN0ICAgICAgIDogJ25vbmUnLFxuICAgIC8vIHRoaXMgbWFrZXMgdGhlIGVsZW1lbnQgYmxvY2tpbmcgaW4gSUUxMCA+LCB5b3UgY291bGQgZXhwZXJpbWVudCB3aXRoIHRoZSB2YWx1ZVxuICAgIC8vIHNlZSBmb3IgbW9yZSBvcHRpb25zIHRoaXMgaXNzdWU7IGh0dHBzOi8vZ2l0aHViLmNvbS9FaWdodE1lZGlhL2hhbW1lci5qcy9pc3N1ZXMvMjQxXG4gICAgdG91Y2hBY3Rpb24gICAgICA6ICdub25lJyxcbiAgICB0b3VjaENhbGxvdXQgICAgIDogJ25vbmUnLFxuICAgIGNvbnRlbnRab29taW5nICAgOiAnbm9uZScsXG4gICAgdXNlckRyYWcgICAgICAgICA6ICdub25lJyxcbiAgICB0YXBIaWdobGlnaHRDb2xvcjogJ3JnYmEoMCwwLDAsMCknXG4gIH1cblxuICAvL1xuICAvLyBtb3JlIHNldHRpbmdzIGFyZSBkZWZpbmVkIHBlciBnZXN0dXJlIGF0IGdlc3R1cmVzLmpzXG4gIC8vXG59O1xuXG4vLyBkZXRlY3QgdG91Y2hldmVudHNcbkhhbW1lci5IQVNfUE9JTlRFUkVWRU5UUyA9IHdpbmRvdy5uYXZpZ2F0b3IucG9pbnRlckVuYWJsZWQgfHwgd2luZG93Lm5hdmlnYXRvci5tc1BvaW50ZXJFbmFibGVkO1xuSGFtbWVyLkhBU19UT1VDSEVWRU5UUyA9ICgnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cpO1xuXG4vLyBkb250IHVzZSBtb3VzZWV2ZW50cyBvbiBtb2JpbGUgZGV2aWNlc1xuSGFtbWVyLk1PQklMRV9SRUdFWCA9IC9tb2JpbGV8dGFibGV0fGlwKGFkfGhvbmV8b2QpfGFuZHJvaWR8c2lsay9pO1xuSGFtbWVyLk5PX01PVVNFRVZFTlRTID0gSGFtbWVyLkhBU19UT1VDSEVWRU5UUyAmJiB3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaChIYW1tZXIuTU9CSUxFX1JFR0VYKTtcblxuLy8gZXZlbnR0eXBlcyBwZXIgdG91Y2hldmVudCAoc3RhcnQsIG1vdmUsIGVuZClcbi8vIGFyZSBmaWxsZWQgYnkgSGFtbWVyLmV2ZW50LmRldGVybWluZUV2ZW50VHlwZXMgb24gc2V0dXBcbkhhbW1lci5FVkVOVF9UWVBFUyA9IHt9O1xuXG4vLyBkaXJlY3Rpb24gZGVmaW5lc1xuSGFtbWVyLkRJUkVDVElPTl9ET1dOID0gJ2Rvd24nO1xuSGFtbWVyLkRJUkVDVElPTl9MRUZUID0gJ2xlZnQnO1xuSGFtbWVyLkRJUkVDVElPTl9VUCA9ICd1cCc7XG5IYW1tZXIuRElSRUNUSU9OX1JJR0hUID0gJ3JpZ2h0JztcblxuLy8gcG9pbnRlciB0eXBlXG5IYW1tZXIuUE9JTlRFUl9NT1VTRSA9ICdtb3VzZSc7XG5IYW1tZXIuUE9JTlRFUl9UT1VDSCA9ICd0b3VjaCc7XG5IYW1tZXIuUE9JTlRFUl9QRU4gPSAncGVuJztcblxuLy8gdG91Y2ggZXZlbnQgZGVmaW5lc1xuSGFtbWVyLkVWRU5UX1NUQVJUID0gJ3N0YXJ0JztcbkhhbW1lci5FVkVOVF9NT1ZFID0gJ21vdmUnO1xuSGFtbWVyLkVWRU5UX0VORCA9ICdlbmQnO1xuXG4vLyBoYW1tZXIgZG9jdW1lbnQgd2hlcmUgdGhlIGJhc2UgZXZlbnRzIGFyZSBhZGRlZCBhdFxuSGFtbWVyLkRPQ1VNRU5UID0gd2luZG93LmRvY3VtZW50O1xuXG4vLyBwbHVnaW5zIGFuZCBnZXN0dXJlcyBuYW1lc3BhY2VzXG5IYW1tZXIucGx1Z2lucyA9IEhhbW1lci5wbHVnaW5zIHx8IHt9O1xuSGFtbWVyLmdlc3R1cmVzID0gSGFtbWVyLmdlc3R1cmVzIHx8IHt9O1xuXG4vLyBpZiB0aGUgd2luZG93IGV2ZW50cyBhcmUgc2V0Li4uXG5IYW1tZXIuUkVBRFkgPSBmYWxzZTtcblxuLyoqXG4gKiBzZXR1cCBldmVudHMgdG8gZGV0ZWN0IGdlc3R1cmVzIG9uIHRoZSBkb2N1bWVudFxuICovXG5mdW5jdGlvbiBzZXR1cCgpIHtcbiAgaWYoSGFtbWVyLlJFQURZKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gZmluZCB3aGF0IGV2ZW50dHlwZXMgd2UgYWRkIGxpc3RlbmVycyB0b1xuICBIYW1tZXIuZXZlbnQuZGV0ZXJtaW5lRXZlbnRUeXBlcygpO1xuXG4gIC8vIFJlZ2lzdGVyIGFsbCBnZXN0dXJlcyBpbnNpZGUgSGFtbWVyLmdlc3R1cmVzXG4gIEhhbW1lci51dGlscy5lYWNoKEhhbW1lci5nZXN0dXJlcywgZnVuY3Rpb24oZ2VzdHVyZSl7XG4gICAgSGFtbWVyLmRldGVjdGlvbi5yZWdpc3RlcihnZXN0dXJlKTtcbiAgfSk7XG5cbiAgLy8gQWRkIHRvdWNoIGV2ZW50cyBvbiB0aGUgZG9jdW1lbnRcbiAgSGFtbWVyLmV2ZW50Lm9uVG91Y2goSGFtbWVyLkRPQ1VNRU5ULCBIYW1tZXIuRVZFTlRfTU9WRSwgSGFtbWVyLmRldGVjdGlvbi5kZXRlY3QpO1xuICBIYW1tZXIuZXZlbnQub25Ub3VjaChIYW1tZXIuRE9DVU1FTlQsIEhhbW1lci5FVkVOVF9FTkQsIEhhbW1lci5kZXRlY3Rpb24uZGV0ZWN0KTtcblxuICAvLyBIYW1tZXIgaXMgcmVhZHkuLi4hXG4gIEhhbW1lci5SRUFEWSA9IHRydWU7XG59XG5cbkhhbW1lci51dGlscyA9IHtcbiAgLyoqXG4gICAqIGV4dGVuZCBtZXRob2QsXG4gICAqIGFsc28gdXNlZCBmb3IgY2xvbmluZyB3aGVuIGRlc3QgaXMgYW4gZW1wdHkgb2JqZWN0XG4gICAqIEBwYXJhbSAgIHtPYmplY3R9ICAgIGRlc3RcbiAgICogQHBhcmFtICAge09iamVjdH0gICAgc3JjXG4gICAqIEBwYXJtICB7Qm9vbGVhbn0gIG1lcmdlICAgIGRvIGEgbWVyZ2VcbiAgICogQHJldHVybnMge09iamVjdH0gICAgZGVzdFxuICAgKi9cbiAgZXh0ZW5kOiBmdW5jdGlvbiBleHRlbmQoZGVzdCwgc3JjLCBtZXJnZSkge1xuICAgIGZvcih2YXIga2V5IGluIHNyYykge1xuICAgICAgaWYoZGVzdFtrZXldICE9PSB1bmRlZmluZWQgJiYgbWVyZ2UpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBkZXN0W2tleV0gPSBzcmNba2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIGRlc3Q7XG4gIH0sXG5cblxuICAvKipcbiAgICogZm9yIGVhY2hcbiAgICogQHBhcmFtIG9ialxuICAgKiBAcGFyYW0gaXRlcmF0b3JcbiAgICovXG4gIGVhY2g6IGZ1bmN0aW9uKG9iaiwgaXRlcmF0b3IsIGNvbnRleHQpIHtcbiAgICB2YXIgaSwgbGVuZ3RoO1xuICAgIC8vIG5hdGl2ZSBmb3JFYWNoIG9uIGFycmF5c1xuICAgIGlmICgnZm9yRWFjaCcgaW4gb2JqKSB7XG4gICAgICBvYmouZm9yRWFjaChpdGVyYXRvciwgY29udGV4dCk7XG4gICAgfVxuICAgIC8vIGFycmF5c1xuICAgIGVsc2UgaWYob2JqLmxlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBvYmoubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGl0ZXJhdG9yLmNhbGwoY29udGV4dCwgb2JqW2ldLCBpLCBvYmopID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBvYmplY3RzXG4gICAgZWxzZSB7XG4gICAgICBmb3IgKGkgaW4gb2JqKSB7XG4gICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoaSkgJiYgaXRlcmF0b3IuY2FsbChjb250ZXh0LCBvYmpbaV0sIGksIG9iaikgPT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBmaW5kIGlmIGEgbm9kZSBpcyBpbiB0aGUgZ2l2ZW4gcGFyZW50XG4gICAqIHVzZWQgZm9yIGV2ZW50IGRlbGVnYXRpb24gdHJpY2tzXG4gICAqIEBwYXJhbSAgIHtIVE1MRWxlbWVudH0gICBub2RlXG4gICAqIEBwYXJhbSAgIHtIVE1MRWxlbWVudH0gICBwYXJlbnRcbiAgICogQHJldHVybnMge2Jvb2xlYW59ICAgICAgIGhhc19wYXJlbnRcbiAgICovXG4gIGhhc1BhcmVudDogZnVuY3Rpb24obm9kZSwgcGFyZW50KSB7XG4gICAgd2hpbGUobm9kZSkge1xuICAgICAgaWYobm9kZSA9PSBwYXJlbnQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG5cblxuICAvKipcbiAgICogZ2V0IHRoZSBjZW50ZXIgb2YgYWxsIHRoZSB0b3VjaGVzXG4gICAqIEBwYXJhbSAgIHtBcnJheX0gICAgIHRvdWNoZXNcbiAgICogQHJldHVybnMge09iamVjdH0gICAgY2VudGVyXG4gICAqL1xuICBnZXRDZW50ZXI6IGZ1bmN0aW9uIGdldENlbnRlcih0b3VjaGVzKSB7XG4gICAgdmFyIHZhbHVlc1ggPSBbXSwgdmFsdWVzWSA9IFtdO1xuXG4gICAgSGFtbWVyLnV0aWxzLmVhY2godG91Y2hlcywgZnVuY3Rpb24odG91Y2gpIHtcbiAgICAgIC8vIEkgcHJlZmVyIGNsaWVudFggYmVjYXVzZSBpdCBpZ25vcmUgdGhlIHNjcm9sbGluZyBwb3NpdGlvblxuICAgICAgdmFsdWVzWC5wdXNoKHR5cGVvZiB0b3VjaC5jbGllbnRYICE9PSAndW5kZWZpbmVkJyA/IHRvdWNoLmNsaWVudFggOiB0b3VjaC5wYWdlWCApO1xuICAgICAgdmFsdWVzWS5wdXNoKHR5cGVvZiB0b3VjaC5jbGllbnRZICE9PSAndW5kZWZpbmVkJyA/IHRvdWNoLmNsaWVudFkgOiB0b3VjaC5wYWdlWSApO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIHBhZ2VYOiAoKE1hdGgubWluLmFwcGx5KE1hdGgsIHZhbHVlc1gpICsgTWF0aC5tYXguYXBwbHkoTWF0aCwgdmFsdWVzWCkpIC8gMiksXG4gICAgICBwYWdlWTogKChNYXRoLm1pbi5hcHBseShNYXRoLCB2YWx1ZXNZKSArIE1hdGgubWF4LmFwcGx5KE1hdGgsIHZhbHVlc1kpKSAvIDIpXG4gICAgfTtcbiAgfSxcblxuXG4gIC8qKlxuICAgKiBjYWxjdWxhdGUgdGhlIHZlbG9jaXR5IGJldHdlZW4gdHdvIHBvaW50c1xuICAgKiBAcGFyYW0gICB7TnVtYmVyfSAgICBkZWx0YV90aW1lXG4gICAqIEBwYXJhbSAgIHtOdW1iZXJ9ICAgIGRlbHRhX3hcbiAgICogQHBhcmFtICAge051bWJlcn0gICAgZGVsdGFfeVxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSAgICB2ZWxvY2l0eVxuICAgKi9cbiAgZ2V0VmVsb2NpdHk6IGZ1bmN0aW9uIGdldFZlbG9jaXR5KGRlbHRhX3RpbWUsIGRlbHRhX3gsIGRlbHRhX3kpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogTWF0aC5hYnMoZGVsdGFfeCAvIGRlbHRhX3RpbWUpIHx8IDAsXG4gICAgICB5OiBNYXRoLmFicyhkZWx0YV95IC8gZGVsdGFfdGltZSkgfHwgMFxuICAgIH07XG4gIH0sXG5cblxuICAvKipcbiAgICogY2FsY3VsYXRlIHRoZSBhbmdsZSBiZXR3ZWVuIHR3byBjb29yZGluYXRlc1xuICAgKiBAcGFyYW0gICB7VG91Y2h9ICAgICB0b3VjaDFcbiAgICogQHBhcmFtICAge1RvdWNofSAgICAgdG91Y2gyXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9ICAgIGFuZ2xlXG4gICAqL1xuICBnZXRBbmdsZTogZnVuY3Rpb24gZ2V0QW5nbGUodG91Y2gxLCB0b3VjaDIpIHtcbiAgICB2YXIgeSA9IHRvdWNoMi5wYWdlWSAtIHRvdWNoMS5wYWdlWSxcbiAgICAgIHggPSB0b3VjaDIucGFnZVggLSB0b3VjaDEucGFnZVg7XG4gICAgcmV0dXJuIE1hdGguYXRhbjIoeSwgeCkgKiAxODAgLyBNYXRoLlBJO1xuICB9LFxuXG5cbiAgLyoqXG4gICAqIGFuZ2xlIHRvIGRpcmVjdGlvbiBkZWZpbmVcbiAgICogQHBhcmFtICAge1RvdWNofSAgICAgdG91Y2gxXG4gICAqIEBwYXJhbSAgIHtUb3VjaH0gICAgIHRvdWNoMlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSAgICBkaXJlY3Rpb24gY29uc3RhbnQsIGxpa2UgSGFtbWVyLkRJUkVDVElPTl9MRUZUXG4gICAqL1xuICBnZXREaXJlY3Rpb246IGZ1bmN0aW9uIGdldERpcmVjdGlvbih0b3VjaDEsIHRvdWNoMikge1xuICAgIHZhciB4ID0gTWF0aC5hYnModG91Y2gxLnBhZ2VYIC0gdG91Y2gyLnBhZ2VYKSxcbiAgICAgIHkgPSBNYXRoLmFicyh0b3VjaDEucGFnZVkgLSB0b3VjaDIucGFnZVkpO1xuXG4gICAgaWYoeCA+PSB5KSB7XG4gICAgICByZXR1cm4gdG91Y2gxLnBhZ2VYIC0gdG91Y2gyLnBhZ2VYID4gMCA/IEhhbW1lci5ESVJFQ1RJT05fTEVGVCA6IEhhbW1lci5ESVJFQ1RJT05fUklHSFQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIHRvdWNoMS5wYWdlWSAtIHRvdWNoMi5wYWdlWSA+IDAgPyBIYW1tZXIuRElSRUNUSU9OX1VQIDogSGFtbWVyLkRJUkVDVElPTl9ET1dOO1xuICAgIH1cbiAgfSxcblxuXG4gIC8qKlxuICAgKiBjYWxjdWxhdGUgdGhlIGRpc3RhbmNlIGJldHdlZW4gdHdvIHRvdWNoZXNcbiAgICogQHBhcmFtICAge1RvdWNofSAgICAgdG91Y2gxXG4gICAqIEBwYXJhbSAgIHtUb3VjaH0gICAgIHRvdWNoMlxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSAgICBkaXN0YW5jZVxuICAgKi9cbiAgZ2V0RGlzdGFuY2U6IGZ1bmN0aW9uIGdldERpc3RhbmNlKHRvdWNoMSwgdG91Y2gyKSB7XG4gICAgdmFyIHggPSB0b3VjaDIucGFnZVggLSB0b3VjaDEucGFnZVgsXG4gICAgICB5ID0gdG91Y2gyLnBhZ2VZIC0gdG91Y2gxLnBhZ2VZO1xuICAgIHJldHVybiBNYXRoLnNxcnQoKHggKiB4KSArICh5ICogeSkpO1xuICB9LFxuXG5cbiAgLyoqXG4gICAqIGNhbGN1bGF0ZSB0aGUgc2NhbGUgZmFjdG9yIGJldHdlZW4gdHdvIHRvdWNoTGlzdHMgKGZpbmdlcnMpXG4gICAqIG5vIHNjYWxlIGlzIDEsIGFuZCBnb2VzIGRvd24gdG8gMCB3aGVuIHBpbmNoZWQgdG9nZXRoZXIsIGFuZCBiaWdnZXIgd2hlbiBwaW5jaGVkIG91dFxuICAgKiBAcGFyYW0gICB7QXJyYXl9ICAgICBzdGFydFxuICAgKiBAcGFyYW0gICB7QXJyYXl9ICAgICBlbmRcbiAgICogQHJldHVybnMge051bWJlcn0gICAgc2NhbGVcbiAgICovXG4gIGdldFNjYWxlOiBmdW5jdGlvbiBnZXRTY2FsZShzdGFydCwgZW5kKSB7XG4gICAgLy8gbmVlZCB0d28gZmluZ2Vycy4uLlxuICAgIGlmKHN0YXJ0Lmxlbmd0aCA+PSAyICYmIGVuZC5sZW5ndGggPj0gMikge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0RGlzdGFuY2UoZW5kWzBdLCBlbmRbMV0pIC9cbiAgICAgICAgdGhpcy5nZXREaXN0YW5jZShzdGFydFswXSwgc3RhcnRbMV0pO1xuICAgIH1cbiAgICByZXR1cm4gMTtcbiAgfSxcblxuXG4gIC8qKlxuICAgKiBjYWxjdWxhdGUgdGhlIHJvdGF0aW9uIGRlZ3JlZXMgYmV0d2VlbiB0d28gdG91Y2hMaXN0cyAoZmluZ2VycylcbiAgICogQHBhcmFtICAge0FycmF5fSAgICAgc3RhcnRcbiAgICogQHBhcmFtICAge0FycmF5fSAgICAgZW5kXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9ICAgIHJvdGF0aW9uXG4gICAqL1xuICBnZXRSb3RhdGlvbjogZnVuY3Rpb24gZ2V0Um90YXRpb24oc3RhcnQsIGVuZCkge1xuICAgIC8vIG5lZWQgdHdvIGZpbmdlcnNcbiAgICBpZihzdGFydC5sZW5ndGggPj0gMiAmJiBlbmQubGVuZ3RoID49IDIpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldEFuZ2xlKGVuZFsxXSwgZW5kWzBdKSAtXG4gICAgICAgIHRoaXMuZ2V0QW5nbGUoc3RhcnRbMV0sIHN0YXJ0WzBdKTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH0sXG5cblxuICAvKipcbiAgICogYm9vbGVhbiBpZiB0aGUgZGlyZWN0aW9uIGlzIHZlcnRpY2FsXG4gICAqIEBwYXJhbSAgICB7U3RyaW5nfSAgICBkaXJlY3Rpb25cbiAgICogQHJldHVybnMgIHtCb29sZWFufSAgIGlzX3ZlcnRpY2FsXG4gICAqL1xuICBpc1ZlcnRpY2FsOiBmdW5jdGlvbiBpc1ZlcnRpY2FsKGRpcmVjdGlvbikge1xuICAgIHJldHVybiAoZGlyZWN0aW9uID09IEhhbW1lci5ESVJFQ1RJT05fVVAgfHwgZGlyZWN0aW9uID09IEhhbW1lci5ESVJFQ1RJT05fRE9XTik7XG4gIH0sXG5cblxuICAvKipcbiAgICogc3RvcCBicm93c2VyIGRlZmF1bHQgYmVoYXZpb3Igd2l0aCBjc3MgcHJvcHNcbiAgICogQHBhcmFtICAge0h0bWxFbGVtZW50fSAgIGVsZW1lbnRcbiAgICogQHBhcmFtICAge09iamVjdH0gICAgICAgIGNzc19wcm9wc1xuICAgKi9cbiAgc3RvcERlZmF1bHRCcm93c2VyQmVoYXZpb3I6IGZ1bmN0aW9uIHN0b3BEZWZhdWx0QnJvd3NlckJlaGF2aW9yKGVsZW1lbnQsIGNzc19wcm9wcykge1xuICAgIGlmKCFjc3NfcHJvcHMgfHwgIWVsZW1lbnQgfHwgIWVsZW1lbnQuc3R5bGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyB3aXRoIGNzcyBwcm9wZXJ0aWVzIGZvciBtb2Rlcm4gYnJvd3NlcnNcbiAgICBIYW1tZXIudXRpbHMuZWFjaChbJ3dlYmtpdCcsICdraHRtbCcsICdtb3onLCAnTW96JywgJ21zJywgJ28nLCAnJ10sIGZ1bmN0aW9uKHZlbmRvcikge1xuICAgICAgSGFtbWVyLnV0aWxzLmVhY2goY3NzX3Byb3BzLCBmdW5jdGlvbih2YWx1ZSwgcHJvcCkge1xuICAgICAgICAgIC8vIHZlbmRlciBwcmVmaXggYXQgdGhlIHByb3BlcnR5XG4gICAgICAgICAgaWYodmVuZG9yKSB7XG4gICAgICAgICAgICBwcm9wID0gdmVuZG9yICsgcHJvcC5zdWJzdHJpbmcoMCwgMSkudG9VcHBlckNhc2UoKSArIHByb3Auc3Vic3RyaW5nKDEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBzZXQgdGhlIHN0eWxlXG4gICAgICAgICAgaWYocHJvcCBpbiBlbGVtZW50LnN0eWxlKSB7XG4gICAgICAgICAgICBlbGVtZW50LnN0eWxlW3Byb3BdID0gdmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvLyBhbHNvIHRoZSBkaXNhYmxlIG9uc2VsZWN0c3RhcnRcbiAgICBpZihjc3NfcHJvcHMudXNlclNlbGVjdCA9PSAnbm9uZScpIHtcbiAgICAgIGVsZW1lbnQub25zZWxlY3RzdGFydCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIGFuZCBkaXNhYmxlIG9uZHJhZ3N0YXJ0XG4gICAgaWYoY3NzX3Byb3BzLnVzZXJEcmFnID09ICdub25lJykge1xuICAgICAgZWxlbWVudC5vbmRyYWdzdGFydCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9O1xuICAgIH1cbiAgfVxufTtcblxuXG4vKipcbiAqIGNyZWF0ZSBuZXcgaGFtbWVyIGluc3RhbmNlXG4gKiBhbGwgbWV0aG9kcyBzaG91bGQgcmV0dXJuIHRoZSBpbnN0YW5jZSBpdHNlbGYsIHNvIGl0IGlzIGNoYWluYWJsZS5cbiAqIEBwYXJhbSAgIHtIVE1MRWxlbWVudH0gICAgICAgZWxlbWVudFxuICogQHBhcmFtICAge09iamVjdH0gICAgICAgICAgICBbb3B0aW9ucz17fV1cbiAqIEByZXR1cm5zIHtIYW1tZXIuSW5zdGFuY2V9XG4gKiBAY29uc3RydWN0b3JcbiAqL1xuSGFtbWVyLkluc3RhbmNlID0gZnVuY3Rpb24oZWxlbWVudCwgb3B0aW9ucykge1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgLy8gc2V0dXAgSGFtbWVySlMgd2luZG93IGV2ZW50cyBhbmQgcmVnaXN0ZXIgYWxsIGdlc3R1cmVzXG4gIC8vIHRoaXMgYWxzbyBzZXRzIHVwIHRoZSBkZWZhdWx0IG9wdGlvbnNcbiAgc2V0dXAoKTtcblxuICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuXG4gIC8vIHN0YXJ0L3N0b3AgZGV0ZWN0aW9uIG9wdGlvblxuICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xuXG4gIC8vIG1lcmdlIG9wdGlvbnNcbiAgdGhpcy5vcHRpb25zID0gSGFtbWVyLnV0aWxzLmV4dGVuZChcbiAgICBIYW1tZXIudXRpbHMuZXh0ZW5kKHt9LCBIYW1tZXIuZGVmYXVsdHMpLFxuICAgIG9wdGlvbnMgfHwge30pO1xuXG4gIC8vIGFkZCBzb21lIGNzcyB0byB0aGUgZWxlbWVudCB0byBwcmV2ZW50IHRoZSBicm93c2VyIGZyb20gZG9pbmcgaXRzIG5hdGl2ZSBiZWhhdm9pclxuICBpZih0aGlzLm9wdGlvbnMuc3RvcF9icm93c2VyX2JlaGF2aW9yKSB7XG4gICAgSGFtbWVyLnV0aWxzLnN0b3BEZWZhdWx0QnJvd3NlckJlaGF2aW9yKHRoaXMuZWxlbWVudCwgdGhpcy5vcHRpb25zLnN0b3BfYnJvd3Nlcl9iZWhhdmlvcik7XG4gIH1cblxuICAvLyBzdGFydCBkZXRlY3Rpb24gb24gdG91Y2hzdGFydFxuICBIYW1tZXIuZXZlbnQub25Ub3VjaChlbGVtZW50LCBIYW1tZXIuRVZFTlRfU1RBUlQsIGZ1bmN0aW9uKGV2KSB7XG4gICAgaWYoc2VsZi5lbmFibGVkKSB7XG4gICAgICBIYW1tZXIuZGV0ZWN0aW9uLnN0YXJ0RGV0ZWN0KHNlbGYsIGV2KTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIHJldHVybiBpbnN0YW5jZVxuICByZXR1cm4gdGhpcztcbn07XG5cblxuSGFtbWVyLkluc3RhbmNlLnByb3RvdHlwZSA9IHtcbiAgLyoqXG4gICAqIGJpbmQgZXZlbnRzIHRvIHRoZSBpbnN0YW5jZVxuICAgKiBAcGFyYW0gICB7U3RyaW5nfSAgICAgIGdlc3R1cmVcbiAgICogQHBhcmFtICAge0Z1bmN0aW9ufSAgICBoYW5kbGVyXG4gICAqIEByZXR1cm5zIHtIYW1tZXIuSW5zdGFuY2V9XG4gICAqL1xuICBvbjogZnVuY3Rpb24gb25FdmVudChnZXN0dXJlLCBoYW5kbGVyKSB7XG4gICAgdmFyIGdlc3R1cmVzID0gZ2VzdHVyZS5zcGxpdCgnICcpO1xuICAgIEhhbW1lci51dGlscy5lYWNoKGdlc3R1cmVzLCBmdW5jdGlvbihnZXN0dXJlKSB7XG4gICAgICB0aGlzLmVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihnZXN0dXJlLCBoYW5kbGVyLCBmYWxzZSk7XG4gICAgfSwgdGhpcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cblxuICAvKipcbiAgICogdW5iaW5kIGV2ZW50cyB0byB0aGUgaW5zdGFuY2VcbiAgICogQHBhcmFtICAge1N0cmluZ30gICAgICBnZXN0dXJlXG4gICAqIEBwYXJhbSAgIHtGdW5jdGlvbn0gICAgaGFuZGxlclxuICAgKiBAcmV0dXJucyB7SGFtbWVyLkluc3RhbmNlfVxuICAgKi9cbiAgb2ZmOiBmdW5jdGlvbiBvZmZFdmVudChnZXN0dXJlLCBoYW5kbGVyKSB7XG4gICAgdmFyIGdlc3R1cmVzID0gZ2VzdHVyZS5zcGxpdCgnICcpO1xuICAgIEhhbW1lci51dGlscy5lYWNoKGdlc3R1cmVzLCBmdW5jdGlvbihnZXN0dXJlKSB7XG4gICAgICB0aGlzLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihnZXN0dXJlLCBoYW5kbGVyLCBmYWxzZSk7XG4gICAgfSwgdGhpcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cblxuICAvKipcbiAgICogdHJpZ2dlciBnZXN0dXJlIGV2ZW50XG4gICAqIEBwYXJhbSAgIHtTdHJpbmd9ICAgICAgZ2VzdHVyZVxuICAgKiBAcGFyYW0gICB7T2JqZWN0fSAgICAgIFtldmVudERhdGFdXG4gICAqIEByZXR1cm5zIHtIYW1tZXIuSW5zdGFuY2V9XG4gICAqL1xuICB0cmlnZ2VyOiBmdW5jdGlvbiB0cmlnZ2VyRXZlbnQoZ2VzdHVyZSwgZXZlbnREYXRhKSB7XG4gICAgLy8gb3B0aW9uYWxcbiAgICBpZighZXZlbnREYXRhKSB7XG4gICAgICBldmVudERhdGEgPSB7fTtcbiAgICB9XG5cbiAgICAvLyBjcmVhdGUgRE9NIGV2ZW50XG4gICAgdmFyIGV2ZW50ID0gSGFtbWVyLkRPQ1VNRU5ULmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xuICAgIGV2ZW50LmluaXRFdmVudChnZXN0dXJlLCB0cnVlLCB0cnVlKTtcbiAgICBldmVudC5nZXN0dXJlID0gZXZlbnREYXRhO1xuXG4gICAgLy8gdHJpZ2dlciBvbiB0aGUgdGFyZ2V0IGlmIGl0IGlzIGluIHRoZSBpbnN0YW5jZSBlbGVtZW50LFxuICAgIC8vIHRoaXMgaXMgZm9yIGV2ZW50IGRlbGVnYXRpb24gdHJpY2tzXG4gICAgdmFyIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XG4gICAgaWYoSGFtbWVyLnV0aWxzLmhhc1BhcmVudChldmVudERhdGEudGFyZ2V0LCBlbGVtZW50KSkge1xuICAgICAgZWxlbWVudCA9IGV2ZW50RGF0YS50YXJnZXQ7XG4gICAgfVxuXG4gICAgZWxlbWVudC5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuXG4gIC8qKlxuICAgKiBlbmFibGUgb2YgZGlzYWJsZSBoYW1tZXIuanMgZGV0ZWN0aW9uXG4gICAqIEBwYXJhbSAgIHtCb29sZWFufSAgIHN0YXRlXG4gICAqIEByZXR1cm5zIHtIYW1tZXIuSW5zdGFuY2V9XG4gICAqL1xuICBlbmFibGU6IGZ1bmN0aW9uIGVuYWJsZShzdGF0ZSkge1xuICAgIHRoaXMuZW5hYmxlZCA9IHN0YXRlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59O1xuXG5cbi8qKlxuICogdGhpcyBob2xkcyB0aGUgbGFzdCBtb3ZlIGV2ZW50LFxuICogdXNlZCB0byBmaXggZW1wdHkgdG91Y2hlbmQgaXNzdWVcbiAqIHNlZSB0aGUgb25Ub3VjaCBldmVudCBmb3IgYW4gZXhwbGFuYXRpb25cbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbnZhciBsYXN0X21vdmVfZXZlbnQgPSBudWxsO1xuXG5cbi8qKlxuICogd2hlbiB0aGUgbW91c2UgaXMgaG9sZCBkb3duLCB0aGlzIGlzIHRydWVcbiAqIEB0eXBlIHtCb29sZWFufVxuICovXG52YXIgZW5hYmxlX2RldGVjdCA9IGZhbHNlO1xuXG5cbi8qKlxuICogd2hlbiB0b3VjaCBldmVudHMgaGF2ZSBiZWVuIGZpcmVkLCB0aGlzIGlzIHRydWVcbiAqIEB0eXBlIHtCb29sZWFufVxuICovXG52YXIgdG91Y2hfdHJpZ2dlcmVkID0gZmFsc2U7XG5cblxuSGFtbWVyLmV2ZW50ID0ge1xuICAvKipcbiAgICogc2ltcGxlIGFkZEV2ZW50TGlzdGVuZXJcbiAgICogQHBhcmFtICAge0hUTUxFbGVtZW50fSAgIGVsZW1lbnRcbiAgICogQHBhcmFtICAge1N0cmluZ30gICAgICAgIHR5cGVcbiAgICogQHBhcmFtICAge0Z1bmN0aW9ufSAgICAgIGhhbmRsZXJcbiAgICovXG4gIGJpbmREb206IGZ1bmN0aW9uKGVsZW1lbnQsIHR5cGUsIGhhbmRsZXIpIHtcbiAgICB2YXIgdHlwZXMgPSB0eXBlLnNwbGl0KCcgJyk7XG4gICAgSGFtbWVyLnV0aWxzLmVhY2godHlwZXMsIGZ1bmN0aW9uKHR5cGUpe1xuICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIGZhbHNlKTtcbiAgICB9KTtcbiAgfSxcblxuXG4gIC8qKlxuICAgKiB0b3VjaCBldmVudHMgd2l0aCBtb3VzZSBmYWxsYmFja1xuICAgKiBAcGFyYW0gICB7SFRNTEVsZW1lbnR9ICAgZWxlbWVudFxuICAgKiBAcGFyYW0gICB7U3RyaW5nfSAgICAgICAgZXZlbnRUeXBlICAgICAgICBsaWtlIEhhbW1lci5FVkVOVF9NT1ZFXG4gICAqIEBwYXJhbSAgIHtGdW5jdGlvbn0gICAgICBoYW5kbGVyXG4gICAqL1xuICBvblRvdWNoOiBmdW5jdGlvbiBvblRvdWNoKGVsZW1lbnQsIGV2ZW50VHlwZSwgaGFuZGxlcikge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIHRoaXMuYmluZERvbShlbGVtZW50LCBIYW1tZXIuRVZFTlRfVFlQRVNbZXZlbnRUeXBlXSwgZnVuY3Rpb24gYmluZERvbU9uVG91Y2goZXYpIHtcbiAgICAgIHZhciBzb3VyY2VFdmVudFR5cGUgPSBldi50eXBlLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgIC8vIG9ubW91c2V1cCwgYnV0IHdoZW4gdG91Y2hlbmQgaGFzIGJlZW4gZmlyZWQgd2UgZG8gbm90aGluZy5cbiAgICAgIC8vIHRoaXMgaXMgZm9yIHRvdWNoZGV2aWNlcyB3aGljaCBhbHNvIGZpcmUgYSBtb3VzZXVwIG9uIHRvdWNoZW5kXG4gICAgICBpZihzb3VyY2VFdmVudFR5cGUubWF0Y2goL21vdXNlLykgJiYgdG91Y2hfdHJpZ2dlcmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gbW91c2VidXR0b24gbXVzdCBiZSBkb3duIG9yIGEgdG91Y2ggZXZlbnRcbiAgICAgIGVsc2UgaWYoc291cmNlRXZlbnRUeXBlLm1hdGNoKC90b3VjaC8pIHx8ICAgLy8gdG91Y2ggZXZlbnRzIGFyZSBhbHdheXMgb24gc2NyZWVuXG4gICAgICAgIHNvdXJjZUV2ZW50VHlwZS5tYXRjaCgvcG9pbnRlcmRvd24vKSB8fCAvLyBwb2ludGVyZXZlbnRzIHRvdWNoXG4gICAgICAgIChzb3VyY2VFdmVudFR5cGUubWF0Y2goL21vdXNlLykgJiYgZXYud2hpY2ggPT09IDEpICAgLy8gbW91c2UgaXMgcHJlc3NlZFxuICAgICAgICApIHtcbiAgICAgICAgZW5hYmxlX2RldGVjdCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vIG1vdXNlIGlzbid0IHByZXNzZWRcbiAgICAgIGVsc2UgaWYoc291cmNlRXZlbnRUeXBlLm1hdGNoKC9tb3VzZS8pICYmICFldi53aGljaCkge1xuICAgICAgICBlbmFibGVfZGV0ZWN0ID0gZmFsc2U7XG4gICAgICB9XG5cblxuICAgICAgLy8gd2UgYXJlIGluIGEgdG91Y2ggZXZlbnQsIHNldCB0aGUgdG91Y2ggdHJpZ2dlcmVkIGJvb2wgdG8gdHJ1ZSxcbiAgICAgIC8vIHRoaXMgZm9yIHRoZSBjb25mbGljdHMgdGhhdCBtYXkgb2NjdXIgb24gaW9zIGFuZCBhbmRyb2lkXG4gICAgICBpZihzb3VyY2VFdmVudFR5cGUubWF0Y2goL3RvdWNofHBvaW50ZXIvKSkge1xuICAgICAgICB0b3VjaF90cmlnZ2VyZWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBjb3VudCB0aGUgdG90YWwgdG91Y2hlcyBvbiB0aGUgc2NyZWVuXG4gICAgICB2YXIgY291bnRfdG91Y2hlcyA9IDA7XG5cbiAgICAgIC8vIHdoZW4gdG91Y2ggaGFzIGJlZW4gdHJpZ2dlcmVkIGluIHRoaXMgZGV0ZWN0aW9uIHNlc3Npb25cbiAgICAgIC8vIGFuZCB3ZSBhcmUgbm93IGhhbmRsaW5nIGEgbW91c2UgZXZlbnQsIHdlIHN0b3AgdGhhdCB0byBwcmV2ZW50IGNvbmZsaWN0c1xuICAgICAgaWYoZW5hYmxlX2RldGVjdCkge1xuICAgICAgICAvLyB1cGRhdGUgcG9pbnRlcmV2ZW50XG4gICAgICAgIGlmKEhhbW1lci5IQVNfUE9JTlRFUkVWRU5UUyAmJiBldmVudFR5cGUgIT0gSGFtbWVyLkVWRU5UX0VORCkge1xuICAgICAgICAgIGNvdW50X3RvdWNoZXMgPSBIYW1tZXIuUG9pbnRlckV2ZW50LnVwZGF0ZVBvaW50ZXIoZXZlbnRUeXBlLCBldik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdG91Y2hcbiAgICAgICAgZWxzZSBpZihzb3VyY2VFdmVudFR5cGUubWF0Y2goL3RvdWNoLykpIHtcbiAgICAgICAgICBjb3VudF90b3VjaGVzID0gZXYudG91Y2hlcy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbW91c2VcbiAgICAgICAgZWxzZSBpZighdG91Y2hfdHJpZ2dlcmVkKSB7XG4gICAgICAgICAgY291bnRfdG91Y2hlcyA9IHNvdXJjZUV2ZW50VHlwZS5tYXRjaCgvdXAvKSA/IDAgOiAxO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgd2UgYXJlIGluIGEgZW5kIGV2ZW50LCBidXQgd2hlbiB3ZSByZW1vdmUgb25lIHRvdWNoIGFuZFxuICAgICAgICAvLyB3ZSBzdGlsbCBoYXZlIGVub3VnaCwgc2V0IGV2ZW50VHlwZSB0byBtb3ZlXG4gICAgICAgIGlmKGNvdW50X3RvdWNoZXMgPiAwICYmIGV2ZW50VHlwZSA9PSBIYW1tZXIuRVZFTlRfRU5EKSB7XG4gICAgICAgICAgZXZlbnRUeXBlID0gSGFtbWVyLkVWRU5UX01PVkU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbm8gdG91Y2hlcywgZm9yY2UgdGhlIGVuZCBldmVudFxuICAgICAgICBlbHNlIGlmKCFjb3VudF90b3VjaGVzKSB7XG4gICAgICAgICAgZXZlbnRUeXBlID0gSGFtbWVyLkVWRU5UX0VORDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHN0b3JlIHRoZSBsYXN0IG1vdmUgZXZlbnRcbiAgICAgICAgaWYoY291bnRfdG91Y2hlcyB8fCBsYXN0X21vdmVfZXZlbnQgPT09IG51bGwpIHtcbiAgICAgICAgICBsYXN0X21vdmVfZXZlbnQgPSBldjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRyaWdnZXIgdGhlIGhhbmRsZXJcbiAgICAgICAgaGFuZGxlci5jYWxsKEhhbW1lci5kZXRlY3Rpb24sIHNlbGYuY29sbGVjdEV2ZW50RGF0YShlbGVtZW50LCBldmVudFR5cGUsIHNlbGYuZ2V0VG91Y2hMaXN0KGxhc3RfbW92ZV9ldmVudCwgZXZlbnRUeXBlKSwgZXYpKTtcblxuICAgICAgICAvLyByZW1vdmUgcG9pbnRlcmV2ZW50IGZyb20gbGlzdFxuICAgICAgICBpZihIYW1tZXIuSEFTX1BPSU5URVJFVkVOVFMgJiYgZXZlbnRUeXBlID09IEhhbW1lci5FVkVOVF9FTkQpIHtcbiAgICAgICAgICBjb3VudF90b3VjaGVzID0gSGFtbWVyLlBvaW50ZXJFdmVudC51cGRhdGVQb2ludGVyKGV2ZW50VHlwZSwgZXYpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIG9uIHRoZSBlbmQgd2UgcmVzZXQgZXZlcnl0aGluZ1xuICAgICAgaWYoIWNvdW50X3RvdWNoZXMpIHtcbiAgICAgICAgbGFzdF9tb3ZlX2V2ZW50ID0gbnVsbDtcbiAgICAgICAgZW5hYmxlX2RldGVjdCA9IGZhbHNlO1xuICAgICAgICB0b3VjaF90cmlnZ2VyZWQgPSBmYWxzZTtcbiAgICAgICAgSGFtbWVyLlBvaW50ZXJFdmVudC5yZXNldCgpO1xuICAgICAgfVxuICAgIH0se3Bhc3NpdmU6dHJ1ZX0pO1xuICAgIC8vIEZJWE1FIC0gUEFTU0lWRVxuICB9LFxuXG5cbiAgLyoqXG4gICAqIHdlIGhhdmUgZGlmZmVyZW50IGV2ZW50cyBmb3IgZWFjaCBkZXZpY2UvYnJvd3NlclxuICAgKiBkZXRlcm1pbmUgd2hhdCB3ZSBuZWVkIGFuZCBzZXQgdGhlbSBpbiB0aGUgSGFtbWVyLkVWRU5UX1RZUEVTIGNvbnN0YW50XG4gICAqL1xuICBkZXRlcm1pbmVFdmVudFR5cGVzOiBmdW5jdGlvbiBkZXRlcm1pbmVFdmVudFR5cGVzKCkge1xuICAgIC8vIGRldGVybWluZSB0aGUgZXZlbnR0eXBlIHdlIHdhbnQgdG8gc2V0XG4gICAgdmFyIHR5cGVzO1xuXG4gICAgLy8gcG9pbnRlckV2ZW50cyBtYWdpY1xuICAgIGlmKEhhbW1lci5IQVNfUE9JTlRFUkVWRU5UUykge1xuICAgICAgdHlwZXMgPSBIYW1tZXIuUG9pbnRlckV2ZW50LmdldEV2ZW50cygpO1xuICAgIH1cbiAgICAvLyBvbiBBbmRyb2lkLCBpT1MsIGJsYWNrYmVycnksIHdpbmRvd3MgbW9iaWxlIHdlIGRvbnQgd2FudCBhbnkgbW91c2VldmVudHNcbiAgICBlbHNlIGlmKEhhbW1lci5OT19NT1VTRUVWRU5UUykge1xuICAgICAgdHlwZXMgPSBbXG4gICAgICAgICd0b3VjaHN0YXJ0JyxcbiAgICAgICAgJ3RvdWNobW92ZScsXG4gICAgICAgICd0b3VjaGVuZCB0b3VjaGNhbmNlbCddO1xuICAgIH1cbiAgICAvLyBmb3Igbm9uIHBvaW50ZXIgZXZlbnRzIGJyb3dzZXJzIGFuZCBtaXhlZCBicm93c2VycyxcbiAgICAvLyBsaWtlIGNocm9tZSBvbiB3aW5kb3dzOCB0b3VjaCBsYXB0b3BcbiAgICBlbHNlIHtcbiAgICAgIHR5cGVzID0gW1xuICAgICAgICAndG91Y2hzdGFydCBtb3VzZWRvd24nLFxuICAgICAgICAndG91Y2htb3ZlIG1vdXNlbW92ZScsXG4gICAgICAgICd0b3VjaGVuZCB0b3VjaGNhbmNlbCBtb3VzZXVwJ107XG4gICAgfVxuXG4gICAgSGFtbWVyLkVWRU5UX1RZUEVTW0hhbW1lci5FVkVOVF9TVEFSVF0gPSB0eXBlc1swXTtcbiAgICBIYW1tZXIuRVZFTlRfVFlQRVNbSGFtbWVyLkVWRU5UX01PVkVdID0gdHlwZXNbMV07XG4gICAgSGFtbWVyLkVWRU5UX1RZUEVTW0hhbW1lci5FVkVOVF9FTkRdID0gdHlwZXNbMl07XG4gIH0sXG5cblxuICAvKipcbiAgICogY3JlYXRlIHRvdWNobGlzdCBkZXBlbmRpbmcgb24gdGhlIGV2ZW50XG4gICAqIEBwYXJhbSAgIHtPYmplY3R9ICAgIGV2XG4gICAqIEBwYXJhbSAgIHtTdHJpbmd9ICAgIGV2ZW50VHlwZSAgIHVzZWQgYnkgdGhlIGZha2VtdWx0aXRvdWNoIHBsdWdpblxuICAgKi9cbiAgZ2V0VG91Y2hMaXN0OiBmdW5jdGlvbiBnZXRUb3VjaExpc3QoZXYvKiwgZXZlbnRUeXBlKi8pIHtcbiAgICAvLyBnZXQgdGhlIGZha2UgcG9pbnRlckV2ZW50IHRvdWNobGlzdFxuICAgIGlmKEhhbW1lci5IQVNfUE9JTlRFUkVWRU5UUykge1xuICAgICAgcmV0dXJuIEhhbW1lci5Qb2ludGVyRXZlbnQuZ2V0VG91Y2hMaXN0KCk7XG4gICAgfVxuICAgIC8vIGdldCB0aGUgdG91Y2hsaXN0XG4gICAgZWxzZSBpZihldi50b3VjaGVzKSB7XG4gICAgICByZXR1cm4gZXYudG91Y2hlcztcbiAgICB9XG4gICAgLy8gbWFrZSBmYWtlIHRvdWNobGlzdCBmcm9tIG1vdXNlIHBvc2l0aW9uXG4gICAgZWxzZSB7XG4gICAgICBldi5pZGVudGlmaWVyID0gMTtcbiAgICAgIHJldHVybiBbZXZdO1xuICAgIH1cbiAgfSxcblxuXG4gIC8qKlxuICAgKiBjb2xsZWN0IGV2ZW50IGRhdGEgZm9yIEhhbW1lciBqc1xuICAgKiBAcGFyYW0gICB7SFRNTEVsZW1lbnR9ICAgZWxlbWVudFxuICAgKiBAcGFyYW0gICB7U3RyaW5nfSAgICAgICAgZXZlbnRUeXBlICAgICAgICBsaWtlIEhhbW1lci5FVkVOVF9NT1ZFXG4gICAqIEBwYXJhbSAgIHtPYmplY3R9ICAgICAgICBldmVudERhdGFcbiAgICovXG4gIGNvbGxlY3RFdmVudERhdGE6IGZ1bmN0aW9uIGNvbGxlY3RFdmVudERhdGEoZWxlbWVudCwgZXZlbnRUeXBlLCB0b3VjaGVzLCBldikge1xuICAgIC8vIGZpbmQgb3V0IHBvaW50ZXJUeXBlXG4gICAgdmFyIHBvaW50ZXJUeXBlID0gSGFtbWVyLlBPSU5URVJfVE9VQ0g7XG4gICAgaWYoZXYudHlwZS5tYXRjaCgvbW91c2UvKSB8fCBIYW1tZXIuUG9pbnRlckV2ZW50Lm1hdGNoVHlwZShIYW1tZXIuUE9JTlRFUl9NT1VTRSwgZXYpKSB7XG4gICAgICBwb2ludGVyVHlwZSA9IEhhbW1lci5QT0lOVEVSX01PVVNFO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBjZW50ZXIgICAgIDogSGFtbWVyLnV0aWxzLmdldENlbnRlcih0b3VjaGVzKSxcbiAgICAgIHRpbWVTdGFtcCAgOiBuZXcgRGF0ZSgpLmdldFRpbWUoKSxcbiAgICAgIHRhcmdldCAgICAgOiBldi50YXJnZXQsXG4gICAgICB0b3VjaGVzICAgIDogdG91Y2hlcyxcbiAgICAgIGV2ZW50VHlwZSAgOiBldmVudFR5cGUsXG4gICAgICBwb2ludGVyVHlwZTogcG9pbnRlclR5cGUsXG4gICAgICBzcmNFdmVudCAgIDogZXYsXG5cbiAgICAgIC8qKlxuICAgICAgICogcHJldmVudCB0aGUgYnJvd3NlciBkZWZhdWx0IGFjdGlvbnNcbiAgICAgICAqIG1vc3RseSB1c2VkIHRvIGRpc2FibGUgc2Nyb2xsaW5nIG9mIHRoZSBicm93c2VyXG4gICAgICAgKi9cbiAgICAgIHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYodGhpcy5zcmNFdmVudC5wcmV2ZW50TWFuaXB1bGF0aW9uKSB7XG4gICAgICAgICAgdGhpcy5zcmNFdmVudC5wcmV2ZW50TWFuaXB1bGF0aW9uKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZih0aGlzLnNyY0V2ZW50LnByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgICAgdGhpcy5zcmNFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIHN0b3AgYnViYmxpbmcgdGhlIGV2ZW50IHVwIHRvIGl0cyBwYXJlbnRzXG4gICAgICAgKi9cbiAgICAgIHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuc3JjRXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIGltbWVkaWF0ZWx5IHN0b3AgZ2VzdHVyZSBkZXRlY3Rpb25cbiAgICAgICAqIG1pZ2h0IGJlIHVzZWZ1bCBhZnRlciBhIHN3aXBlIHdhcyBkZXRlY3RlZFxuICAgICAgICogQHJldHVybiB7Kn1cbiAgICAgICAqL1xuICAgICAgc3RvcERldGVjdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBIYW1tZXIuZGV0ZWN0aW9uLnN0b3BEZXRlY3QoKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59O1xuXG5IYW1tZXIuUG9pbnRlckV2ZW50ID0ge1xuICAvKipcbiAgICogaG9sZHMgYWxsIHBvaW50ZXJzXG4gICAqIEB0eXBlIHtPYmplY3R9XG4gICAqL1xuICBwb2ludGVyczoge30sXG5cbiAgLyoqXG4gICAqIGdldCBhIGxpc3Qgb2YgcG9pbnRlcnNcbiAgICogQHJldHVybnMge0FycmF5fSAgICAgdG91Y2hsaXN0XG4gICAqL1xuICBnZXRUb3VjaExpc3Q6IGZ1bmN0aW9uKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgdG91Y2hsaXN0ID0gW107XG5cbiAgICAvLyB3ZSBjYW4gdXNlIGZvckVhY2ggc2luY2UgcG9pbnRlckV2ZW50cyBvbmx5IGlzIGluIElFMTBcbiAgICBIYW1tZXIudXRpbHMuZWFjaChzZWxmLnBvaW50ZXJzLCBmdW5jdGlvbihwb2ludGVyKXtcbiAgICAgIHRvdWNobGlzdC5wdXNoKHBvaW50ZXIpO1xuICAgIH0pO1xuICAgIFxuICAgIHJldHVybiB0b3VjaGxpc3Q7XG4gIH0sXG5cbiAgLyoqXG4gICAqIHVwZGF0ZSB0aGUgcG9zaXRpb24gb2YgYSBwb2ludGVyXG4gICAqIEBwYXJhbSAgIHtTdHJpbmd9ICAgdHlwZSAgICAgICAgICAgICBIYW1tZXIuRVZFTlRfRU5EXG4gICAqIEBwYXJhbSAgIHtPYmplY3R9ICAgcG9pbnRlckV2ZW50XG4gICAqL1xuICB1cGRhdGVQb2ludGVyOiBmdW5jdGlvbih0eXBlLCBwb2ludGVyRXZlbnQpIHtcbiAgICBpZih0eXBlID09IEhhbW1lci5FVkVOVF9FTkQpIHtcbiAgICAgIHRoaXMucG9pbnRlcnMgPSB7fTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBwb2ludGVyRXZlbnQuaWRlbnRpZmllciA9IHBvaW50ZXJFdmVudC5wb2ludGVySWQ7XG4gICAgICB0aGlzLnBvaW50ZXJzW3BvaW50ZXJFdmVudC5wb2ludGVySWRdID0gcG9pbnRlckV2ZW50O1xuICAgIH1cblxuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLnBvaW50ZXJzKS5sZW5ndGg7XG4gIH0sXG5cbiAgLyoqXG4gICAqIGNoZWNrIGlmIGV2IG1hdGNoZXMgcG9pbnRlcnR5cGVcbiAgICogQHBhcmFtICAge1N0cmluZ30gICAgICAgIHBvaW50ZXJUeXBlICAgICBIYW1tZXIuUE9JTlRFUl9NT1VTRVxuICAgKiBAcGFyYW0gICB7UG9pbnRlckV2ZW50fSAgZXZcbiAgICovXG4gIG1hdGNoVHlwZTogZnVuY3Rpb24ocG9pbnRlclR5cGUsIGV2KSB7XG4gICAgaWYoIWV2LnBvaW50ZXJUeXBlKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIHB0ID0gZXYucG9pbnRlclR5cGUsXG4gICAgICB0eXBlcyA9IHt9O1xuICAgIHR5cGVzW0hhbW1lci5QT0lOVEVSX01PVVNFXSA9IChwdCA9PT0gZXYuTVNQT0lOVEVSX1RZUEVfTU9VU0UgfHwgcHQgPT09IEhhbW1lci5QT0lOVEVSX01PVVNFKTtcbiAgICB0eXBlc1tIYW1tZXIuUE9JTlRFUl9UT1VDSF0gPSAocHQgPT09IGV2Lk1TUE9JTlRFUl9UWVBFX1RPVUNIIHx8IHB0ID09PSBIYW1tZXIuUE9JTlRFUl9UT1VDSCk7XG4gICAgdHlwZXNbSGFtbWVyLlBPSU5URVJfUEVOXSA9IChwdCA9PT0gZXYuTVNQT0lOVEVSX1RZUEVfUEVOIHx8IHB0ID09PSBIYW1tZXIuUE9JTlRFUl9QRU4pO1xuICAgIHJldHVybiB0eXBlc1twb2ludGVyVHlwZV07XG4gIH0sXG5cblxuICAvKipcbiAgICogZ2V0IGV2ZW50c1xuICAgKi9cbiAgZ2V0RXZlbnRzOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gW1xuICAgICAgJ3BvaW50ZXJkb3duIE1TUG9pbnRlckRvd24nLFxuICAgICAgJ3BvaW50ZXJtb3ZlIE1TUG9pbnRlck1vdmUnLFxuICAgICAgJ3BvaW50ZXJ1cCBwb2ludGVyY2FuY2VsIE1TUG9pbnRlclVwIE1TUG9pbnRlckNhbmNlbCdcbiAgICBdO1xuICB9LFxuXG4gIC8qKlxuICAgKiByZXNldCB0aGUgbGlzdFxuICAgKi9cbiAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMucG9pbnRlcnMgPSB7fTtcbiAgfVxufTtcblxuXG5IYW1tZXIuZGV0ZWN0aW9uID0ge1xuICAvLyBjb250YWlucyBhbGwgcmVnaXN0cmVkIEhhbW1lci5nZXN0dXJlcyBpbiB0aGUgY29ycmVjdCBvcmRlclxuICBnZXN0dXJlczogW10sXG5cbiAgLy8gZGF0YSBvZiB0aGUgY3VycmVudCBIYW1tZXIuZ2VzdHVyZSBkZXRlY3Rpb24gc2Vzc2lvblxuICBjdXJyZW50IDogbnVsbCxcblxuICAvLyB0aGUgcHJldmlvdXMgSGFtbWVyLmdlc3R1cmUgc2Vzc2lvbiBkYXRhXG4gIC8vIGlzIGEgZnVsbCBjbG9uZSBvZiB0aGUgcHJldmlvdXMgZ2VzdHVyZS5jdXJyZW50IG9iamVjdFxuICBwcmV2aW91czogbnVsbCxcblxuICAvLyB3aGVuIHRoaXMgYmVjb21lcyB0cnVlLCBubyBnZXN0dXJlcyBhcmUgZmlyZWRcbiAgc3RvcHBlZCA6IGZhbHNlLFxuXG5cbiAgLyoqXG4gICAqIHN0YXJ0IEhhbW1lci5nZXN0dXJlIGRldGVjdGlvblxuICAgKiBAcGFyYW0gICB7SGFtbWVyLkluc3RhbmNlfSAgIGluc3RcbiAgICogQHBhcmFtICAge09iamVjdH0gICAgICAgICAgICBldmVudERhdGFcbiAgICovXG4gIHN0YXJ0RGV0ZWN0OiBmdW5jdGlvbiBzdGFydERldGVjdChpbnN0LCBldmVudERhdGEpIHtcbiAgICAvLyBhbHJlYWR5IGJ1c3kgd2l0aCBhIEhhbW1lci5nZXN0dXJlIGRldGVjdGlvbiBvbiBhbiBlbGVtZW50XG4gICAgaWYodGhpcy5jdXJyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5zdG9wcGVkID0gZmFsc2U7XG5cbiAgICB0aGlzLmN1cnJlbnQgPSB7XG4gICAgICBpbnN0ICAgICAgOiBpbnN0LCAvLyByZWZlcmVuY2UgdG8gSGFtbWVySW5zdGFuY2Ugd2UncmUgd29ya2luZyBmb3JcbiAgICAgIHN0YXJ0RXZlbnQ6IEhhbW1lci51dGlscy5leHRlbmQoe30sIGV2ZW50RGF0YSksIC8vIHN0YXJ0IGV2ZW50RGF0YSBmb3IgZGlzdGFuY2VzLCB0aW1pbmcgZXRjXG4gICAgICBsYXN0RXZlbnQgOiBmYWxzZSwgLy8gbGFzdCBldmVudERhdGFcbiAgICAgIG5hbWUgICAgICA6ICcnIC8vIGN1cnJlbnQgZ2VzdHVyZSB3ZSdyZSBpbi9kZXRlY3RlZCwgY2FuIGJlICd0YXAnLCAnaG9sZCcgZXRjXG4gICAgfTtcblxuICAgIHRoaXMuZGV0ZWN0KGV2ZW50RGF0YSk7XG4gIH0sXG5cblxuICAvKipcbiAgICogSGFtbWVyLmdlc3R1cmUgZGV0ZWN0aW9uXG4gICAqIEBwYXJhbSAgIHtPYmplY3R9ICAgIGV2ZW50RGF0YVxuICAgKi9cbiAgZGV0ZWN0OiBmdW5jdGlvbiBkZXRlY3QoZXZlbnREYXRhKSB7XG4gICAgaWYoIXRoaXMuY3VycmVudCB8fCB0aGlzLnN0b3BwZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBleHRlbmQgZXZlbnQgZGF0YSB3aXRoIGNhbGN1bGF0aW9ucyBhYm91dCBzY2FsZSwgZGlzdGFuY2UgZXRjXG4gICAgZXZlbnREYXRhID0gdGhpcy5leHRlbmRFdmVudERhdGEoZXZlbnREYXRhKTtcblxuICAgIC8vIGluc3RhbmNlIG9wdGlvbnNcbiAgICB2YXIgaW5zdF9vcHRpb25zID0gdGhpcy5jdXJyZW50Lmluc3Qub3B0aW9ucztcblxuICAgIC8vIGNhbGwgSGFtbWVyLmdlc3R1cmUgaGFuZGxlcnNcbiAgICBIYW1tZXIudXRpbHMuZWFjaCh0aGlzLmdlc3R1cmVzLCBmdW5jdGlvbihnZXN0dXJlKSB7XG4gICAgICAvLyBvbmx5IHdoZW4gdGhlIGluc3RhbmNlIG9wdGlvbnMgaGF2ZSBlbmFibGVkIHRoaXMgZ2VzdHVyZVxuICAgICAgaWYoIXRoaXMuc3RvcHBlZCAmJiBpbnN0X29wdGlvbnNbZ2VzdHVyZS5uYW1lXSAhPT0gZmFsc2UpIHtcbiAgICAgICAgLy8gaWYgYSBoYW5kbGVyIHJldHVybnMgZmFsc2UsIHdlIHN0b3Agd2l0aCB0aGUgZGV0ZWN0aW9uXG4gICAgICAgIGlmKGdlc3R1cmUuaGFuZGxlci5jYWxsKGdlc3R1cmUsIGV2ZW50RGF0YSwgdGhpcy5jdXJyZW50Lmluc3QpID09PSBmYWxzZSkge1xuICAgICAgICAgIHRoaXMuc3RvcERldGVjdCgpO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIHRoaXMpO1xuXG4gICAgLy8gc3RvcmUgYXMgcHJldmlvdXMgZXZlbnQgZXZlbnRcbiAgICBpZih0aGlzLmN1cnJlbnQpIHtcbiAgICAgIHRoaXMuY3VycmVudC5sYXN0RXZlbnQgPSBldmVudERhdGE7XG4gICAgfVxuXG4gICAgLy8gZW5kZXZlbnQsIGJ1dCBub3QgdGhlIGxhc3QgdG91Y2gsIHNvIGRvbnQgc3RvcFxuICAgIGlmKGV2ZW50RGF0YS5ldmVudFR5cGUgPT0gSGFtbWVyLkVWRU5UX0VORCAmJiAhZXZlbnREYXRhLnRvdWNoZXMubGVuZ3RoIC0gMSkge1xuICAgICAgdGhpcy5zdG9wRGV0ZWN0KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGV2ZW50RGF0YTtcbiAgfSxcblxuXG4gIC8qKlxuICAgKiBjbGVhciB0aGUgSGFtbWVyLmdlc3R1cmUgdmFyc1xuICAgKiB0aGlzIGlzIGNhbGxlZCBvbiBlbmREZXRlY3QsIGJ1dCBjYW4gYWxzbyBiZSB1c2VkIHdoZW4gYSBmaW5hbCBIYW1tZXIuZ2VzdHVyZSBoYXMgYmVlbiBkZXRlY3RlZFxuICAgKiB0byBzdG9wIG90aGVyIEhhbW1lci5nZXN0dXJlcyBmcm9tIGJlaW5nIGZpcmVkXG4gICAqL1xuICBzdG9wRGV0ZWN0OiBmdW5jdGlvbiBzdG9wRGV0ZWN0KCkge1xuICAgIC8vIGNsb25lIGN1cnJlbnQgZGF0YSB0byB0aGUgc3RvcmUgYXMgdGhlIHByZXZpb3VzIGdlc3R1cmVcbiAgICAvLyB1c2VkIGZvciB0aGUgZG91YmxlIHRhcCBnZXN0dXJlLCBzaW5jZSB0aGlzIGlzIGFuIG90aGVyIGdlc3R1cmUgZGV0ZWN0IHNlc3Npb25cbiAgICB0aGlzLnByZXZpb3VzID0gSGFtbWVyLnV0aWxzLmV4dGVuZCh7fSwgdGhpcy5jdXJyZW50KTtcblxuICAgIC8vIHJlc2V0IHRoZSBjdXJyZW50XG4gICAgdGhpcy5jdXJyZW50ID0gbnVsbDtcblxuICAgIC8vIHN0b3BwZWQhXG4gICAgdGhpcy5zdG9wcGVkID0gdHJ1ZTtcbiAgfSxcblxuXG4gIC8qKlxuICAgKiBleHRlbmQgZXZlbnREYXRhIGZvciBIYW1tZXIuZ2VzdHVyZXNcbiAgICogQHBhcmFtICAge09iamVjdH0gICBldlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSAgIGV2XG4gICAqL1xuICBleHRlbmRFdmVudERhdGE6IGZ1bmN0aW9uIGV4dGVuZEV2ZW50RGF0YShldikge1xuICAgIHZhciBzdGFydEV2ID0gdGhpcy5jdXJyZW50LnN0YXJ0RXZlbnQ7XG5cbiAgICAvLyBpZiB0aGUgdG91Y2hlcyBjaGFuZ2UsIHNldCB0aGUgbmV3IHRvdWNoZXMgb3ZlciB0aGUgc3RhcnRFdmVudCB0b3VjaGVzXG4gICAgLy8gdGhpcyBiZWNhdXNlIHRvdWNoZXZlbnRzIGRvbid0IGhhdmUgYWxsIHRoZSB0b3VjaGVzIG9uIHRvdWNoc3RhcnQsIG9yIHRoZVxuICAgIC8vIHVzZXIgbXVzdCBwbGFjZSBoaXMgZmluZ2VycyBhdCB0aGUgRVhBQ1Qgc2FtZSB0aW1lIG9uIHRoZSBzY3JlZW4sIHdoaWNoIGlzIG5vdCByZWFsaXN0aWNcbiAgICAvLyBidXQsIHNvbWV0aW1lcyBpdCBoYXBwZW5zIHRoYXQgYm90aCBmaW5nZXJzIGFyZSB0b3VjaGluZyBhdCB0aGUgRVhBQ1Qgc2FtZSB0aW1lXG4gICAgaWYoc3RhcnRFdiAmJiAoZXYudG91Y2hlcy5sZW5ndGggIT0gc3RhcnRFdi50b3VjaGVzLmxlbmd0aCB8fCBldi50b3VjaGVzID09PSBzdGFydEV2LnRvdWNoZXMpKSB7XG4gICAgICAvLyBleHRlbmQgMSBsZXZlbCBkZWVwIHRvIGdldCB0aGUgdG91Y2hsaXN0IHdpdGggdGhlIHRvdWNoIG9iamVjdHNcbiAgICAgIHN0YXJ0RXYudG91Y2hlcyA9IFtdO1xuICAgICAgSGFtbWVyLnV0aWxzLmVhY2goZXYudG91Y2hlcywgZnVuY3Rpb24odG91Y2gpIHtcbiAgICAgICAgc3RhcnRFdi50b3VjaGVzLnB1c2goSGFtbWVyLnV0aWxzLmV4dGVuZCh7fSwgdG91Y2gpKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciBkZWx0YV90aW1lID0gZXYudGltZVN0YW1wIC0gc3RhcnRFdi50aW1lU3RhbXBcbiAgICAgICwgZGVsdGFfeCA9IGV2LmNlbnRlci5wYWdlWCAtIHN0YXJ0RXYuY2VudGVyLnBhZ2VYXG4gICAgICAsIGRlbHRhX3kgPSBldi5jZW50ZXIucGFnZVkgLSBzdGFydEV2LmNlbnRlci5wYWdlWVxuICAgICAgLCB2ZWxvY2l0eSA9IEhhbW1lci51dGlscy5nZXRWZWxvY2l0eShkZWx0YV90aW1lLCBkZWx0YV94LCBkZWx0YV95KVxuICAgICAgLCBpbnRlcmltQW5nbGVcbiAgICAgICwgaW50ZXJpbURpcmVjdGlvbjtcblxuICAgIC8vIGVuZCBldmVudHMgKGUuZy4gZHJhZ2VuZCkgZG9uJ3QgaGF2ZSB1c2VmdWwgdmFsdWVzIGZvciBpbnRlcmltRGlyZWN0aW9uICYgaW50ZXJpbUFuZ2xlXG4gICAgLy8gYmVjYXVzZSB0aGUgcHJldmlvdXMgZXZlbnQgaGFzIGV4YWN0bHkgdGhlIHNhbWUgY29vcmRpbmF0ZXNcbiAgICAvLyBzbyBmb3IgZW5kIGV2ZW50cywgdGFrZSB0aGUgcHJldmlvdXMgdmFsdWVzIG9mIGludGVyaW1EaXJlY3Rpb24gJiBpbnRlcmltQW5nbGVcbiAgICAvLyBpbnN0ZWFkIG9mIHJlY2FsY3VsYXRpbmcgdGhlbSBhbmQgZ2V0dGluZyBhIHNwdXJpb3VzICcwJ1xuICAgIGlmKGV2LmV2ZW50VHlwZSA9PT0gJ2VuZCcpIHtcbiAgICAgIGludGVyaW1BbmdsZSA9IHRoaXMuY3VycmVudC5sYXN0RXZlbnQgJiYgdGhpcy5jdXJyZW50Lmxhc3RFdmVudC5pbnRlcmltQW5nbGU7XG4gICAgICBpbnRlcmltRGlyZWN0aW9uID0gdGhpcy5jdXJyZW50Lmxhc3RFdmVudCAmJiB0aGlzLmN1cnJlbnQubGFzdEV2ZW50LmludGVyaW1EaXJlY3Rpb247XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgaW50ZXJpbUFuZ2xlID0gdGhpcy5jdXJyZW50Lmxhc3RFdmVudCAmJiBIYW1tZXIudXRpbHMuZ2V0QW5nbGUodGhpcy5jdXJyZW50Lmxhc3RFdmVudC5jZW50ZXIsIGV2LmNlbnRlcik7XG4gICAgICBpbnRlcmltRGlyZWN0aW9uID0gdGhpcy5jdXJyZW50Lmxhc3RFdmVudCAmJiBIYW1tZXIudXRpbHMuZ2V0RGlyZWN0aW9uKHRoaXMuY3VycmVudC5sYXN0RXZlbnQuY2VudGVyLCBldi5jZW50ZXIpO1xuICAgIH1cblxuICAgIEhhbW1lci51dGlscy5leHRlbmQoZXYsIHtcbiAgICAgIGRlbHRhVGltZTogZGVsdGFfdGltZSxcblxuICAgICAgZGVsdGFYOiBkZWx0YV94LFxuICAgICAgZGVsdGFZOiBkZWx0YV95LFxuXG4gICAgICB2ZWxvY2l0eVg6IHZlbG9jaXR5LngsXG4gICAgICB2ZWxvY2l0eVk6IHZlbG9jaXR5LnksXG5cbiAgICAgIGRpc3RhbmNlOiBIYW1tZXIudXRpbHMuZ2V0RGlzdGFuY2Uoc3RhcnRFdi5jZW50ZXIsIGV2LmNlbnRlciksXG5cbiAgICAgIGFuZ2xlOiBIYW1tZXIudXRpbHMuZ2V0QW5nbGUoc3RhcnRFdi5jZW50ZXIsIGV2LmNlbnRlciksXG4gICAgICBpbnRlcmltQW5nbGU6IGludGVyaW1BbmdsZSxcblxuICAgICAgZGlyZWN0aW9uOiBIYW1tZXIudXRpbHMuZ2V0RGlyZWN0aW9uKHN0YXJ0RXYuY2VudGVyLCBldi5jZW50ZXIpLFxuICAgICAgaW50ZXJpbURpcmVjdGlvbjogaW50ZXJpbURpcmVjdGlvbixcblxuICAgICAgc2NhbGU6IEhhbW1lci51dGlscy5nZXRTY2FsZShzdGFydEV2LnRvdWNoZXMsIGV2LnRvdWNoZXMpLFxuICAgICAgcm90YXRpb246IEhhbW1lci51dGlscy5nZXRSb3RhdGlvbihzdGFydEV2LnRvdWNoZXMsIGV2LnRvdWNoZXMpLFxuXG4gICAgICBzdGFydEV2ZW50OiBzdGFydEV2XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZXY7XG4gIH0sXG5cblxuICAvKipcbiAgICogcmVnaXN0ZXIgbmV3IGdlc3R1cmVcbiAgICogQHBhcmFtICAge09iamVjdH0gICAgZ2VzdHVyZSBvYmplY3QsIHNlZSBnZXN0dXJlcy5qcyBmb3IgZG9jdW1lbnRhdGlvblxuICAgKiBAcmV0dXJucyB7QXJyYXl9ICAgICBnZXN0dXJlc1xuICAgKi9cbiAgcmVnaXN0ZXI6IGZ1bmN0aW9uIHJlZ2lzdGVyKGdlc3R1cmUpIHtcbiAgICAvLyBhZGQgYW4gZW5hYmxlIGdlc3R1cmUgb3B0aW9ucyBpZiB0aGVyZSBpcyBubyBnaXZlblxuICAgIHZhciBvcHRpb25zID0gZ2VzdHVyZS5kZWZhdWx0cyB8fCB7fTtcbiAgICBpZihvcHRpb25zW2dlc3R1cmUubmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgb3B0aW9uc1tnZXN0dXJlLm5hbWVdID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBleHRlbmQgSGFtbWVyIGRlZmF1bHQgb3B0aW9ucyB3aXRoIHRoZSBIYW1tZXIuZ2VzdHVyZSBvcHRpb25zXG4gICAgSGFtbWVyLnV0aWxzLmV4dGVuZChIYW1tZXIuZGVmYXVsdHMsIG9wdGlvbnMsIHRydWUpO1xuXG4gICAgLy8gc2V0IGl0cyBpbmRleFxuICAgIGdlc3R1cmUuaW5kZXggPSBnZXN0dXJlLmluZGV4IHx8IDEwMDA7XG5cbiAgICAvLyBhZGQgSGFtbWVyLmdlc3R1cmUgdG8gdGhlIGxpc3RcbiAgICB0aGlzLmdlc3R1cmVzLnB1c2goZ2VzdHVyZSk7XG5cbiAgICAvLyBzb3J0IHRoZSBsaXN0IGJ5IGluZGV4XG4gICAgdGhpcy5nZXN0dXJlcy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgIGlmKGEuaW5kZXggPCBiLmluZGV4KSB7IHJldHVybiAtMTsgfVxuICAgICAgaWYoYS5pbmRleCA+IGIuaW5kZXgpIHsgcmV0dXJuIDE7IH1cbiAgICAgIHJldHVybiAwO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXMuZ2VzdHVyZXM7XG4gIH1cbn07XG5cblxuLyoqXG4gKiBEcmFnXG4gKiBNb3ZlIHdpdGggeCBmaW5nZXJzIChkZWZhdWx0IDEpIGFyb3VuZCBvbiB0aGUgcGFnZS4gQmxvY2tpbmcgdGhlIHNjcm9sbGluZyB3aGVuXG4gKiBtb3ZpbmcgbGVmdCBhbmQgcmlnaHQgaXMgYSBnb29kIHByYWN0aWNlLiBXaGVuIGFsbCB0aGUgZHJhZyBldmVudHMgYXJlIGJsb2NraW5nXG4gKiB5b3UgZGlzYWJsZSBzY3JvbGxpbmcgb24gdGhhdCBhcmVhLlxuICogQGV2ZW50cyAgZHJhZywgZHJhcGxlZnQsIGRyYWdyaWdodCwgZHJhZ3VwLCBkcmFnZG93blxuICovXG5IYW1tZXIuZ2VzdHVyZXMuRHJhZyA9IHtcbiAgbmFtZSAgICAgOiAnZHJhZycsXG4gIGluZGV4ICAgIDogNTAsXG4gIGRlZmF1bHRzIDoge1xuICAgIGRyYWdfbWluX2Rpc3RhbmNlICAgICAgICAgICAgOiAxMCxcblxuICAgIC8vIFNldCBjb3JyZWN0X2Zvcl9kcmFnX21pbl9kaXN0YW5jZSB0byB0cnVlIHRvIG1ha2UgdGhlIHN0YXJ0aW5nIHBvaW50IG9mIHRoZSBkcmFnXG4gICAgLy8gYmUgY2FsY3VsYXRlZCBmcm9tIHdoZXJlIHRoZSBkcmFnIHdhcyB0cmlnZ2VyZWQsIG5vdCBmcm9tIHdoZXJlIHRoZSB0b3VjaCBzdGFydGVkLlxuICAgIC8vIFVzZWZ1bCB0byBhdm9pZCBhIGplcmstc3RhcnRpbmcgZHJhZywgd2hpY2ggY2FuIG1ha2UgZmluZS1hZGp1c3RtZW50c1xuICAgIC8vIHRocm91Z2ggZHJhZ2dpbmcgZGlmZmljdWx0LCBhbmQgYmUgdmlzdWFsbHkgdW5hcHBlYWxpbmcuXG4gICAgY29ycmVjdF9mb3JfZHJhZ19taW5fZGlzdGFuY2U6IHRydWUsXG5cbiAgICAvLyBzZXQgMCBmb3IgdW5saW1pdGVkLCBidXQgdGhpcyBjYW4gY29uZmxpY3Qgd2l0aCB0cmFuc2Zvcm1cbiAgICBkcmFnX21heF90b3VjaGVzICAgICAgICAgICAgIDogMSxcblxuICAgIC8vIHByZXZlbnQgZGVmYXVsdCBicm93c2VyIGJlaGF2aW9yIHdoZW4gZHJhZ2dpbmcgb2NjdXJzXG4gICAgLy8gYmUgY2FyZWZ1bCB3aXRoIGl0LCBpdCBtYWtlcyB0aGUgZWxlbWVudCBhIGJsb2NraW5nIGVsZW1lbnRcbiAgICAvLyB3aGVuIHlvdSBhcmUgdXNpbmcgdGhlIGRyYWcgZ2VzdHVyZSwgaXQgaXMgYSBnb29kIHByYWN0aWNlIHRvIHNldCB0aGlzIHRydWVcbiAgICBkcmFnX2Jsb2NrX2hvcml6b250YWwgICAgICAgIDogZmFsc2UsXG4gICAgZHJhZ19ibG9ja192ZXJ0aWNhbCAgICAgICAgICA6IGZhbHNlLFxuXG4gICAgLy8gZHJhZ19sb2NrX3RvX2F4aXMga2VlcHMgdGhlIGRyYWcgZ2VzdHVyZSBvbiB0aGUgYXhpcyB0aGF0IGl0IHN0YXJ0ZWQgb24sXG4gICAgLy8gSXQgZGlzYWxsb3dzIHZlcnRpY2FsIGRpcmVjdGlvbnMgaWYgdGhlIGluaXRpYWwgZGlyZWN0aW9uIHdhcyBob3Jpem9udGFsLCBhbmQgdmljZSB2ZXJzYS5cbiAgICBkcmFnX2xvY2tfdG9fYXhpcyAgICAgICAgICAgIDogZmFsc2UsXG5cbiAgICAvLyBkcmFnIGxvY2sgb25seSBraWNrcyBpbiB3aGVuIGRpc3RhbmNlID4gZHJhZ19sb2NrX21pbl9kaXN0YW5jZVxuICAgIC8vIFRoaXMgd2F5LCBsb2NraW5nIG9jY3VycyBvbmx5IHdoZW4gdGhlIGRpc3RhbmNlIGhhcyBiZWNvbWUgbGFyZ2UgZW5vdWdoIHRvIHJlbGlhYmx5IGRldGVybWluZSB0aGUgZGlyZWN0aW9uXG4gICAgZHJhZ19sb2NrX21pbl9kaXN0YW5jZSAgICAgICA6IDI1XG4gIH0sXG5cbiAgdHJpZ2dlcmVkOiBmYWxzZSxcbiAgaGFuZGxlciAgOiBmdW5jdGlvbiBkcmFnR2VzdHVyZShldiwgaW5zdCkge1xuICAgIC8vIGN1cnJlbnQgZ2VzdHVyZSBpc250IGRyYWcsIGJ1dCBkcmFnZ2VkIGlzIHRydWVcbiAgICAvLyB0aGlzIG1lYW5zIGFuIG90aGVyIGdlc3R1cmUgaXMgYnVzeS4gbm93IGNhbGwgZHJhZ2VuZFxuICAgIGlmKEhhbW1lci5kZXRlY3Rpb24uY3VycmVudC5uYW1lICE9IHRoaXMubmFtZSAmJiB0aGlzLnRyaWdnZXJlZCkge1xuICAgICAgaW5zdC50cmlnZ2VyKHRoaXMubmFtZSArICdlbmQnLCBldik7XG4gICAgICB0aGlzLnRyaWdnZXJlZCA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIG1heCB0b3VjaGVzXG4gICAgaWYoaW5zdC5vcHRpb25zLmRyYWdfbWF4X3RvdWNoZXMgPiAwICYmXG4gICAgICBldi50b3VjaGVzLmxlbmd0aCA+IGluc3Qub3B0aW9ucy5kcmFnX21heF90b3VjaGVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgc3dpdGNoKGV2LmV2ZW50VHlwZSkge1xuICAgICAgY2FzZSBIYW1tZXIuRVZFTlRfU1RBUlQ6XG4gICAgICAgIHRoaXMudHJpZ2dlcmVkID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIEhhbW1lci5FVkVOVF9NT1ZFOlxuICAgICAgICAvLyB3aGVuIHRoZSBkaXN0YW5jZSB3ZSBtb3ZlZCBpcyB0b28gc21hbGwgd2Ugc2tpcCB0aGlzIGdlc3R1cmVcbiAgICAgICAgLy8gb3Igd2UgY2FuIGJlIGFscmVhZHkgaW4gZHJhZ2dpbmdcbiAgICAgICAgaWYoZXYuZGlzdGFuY2UgPCBpbnN0Lm9wdGlvbnMuZHJhZ19taW5fZGlzdGFuY2UgJiZcbiAgICAgICAgICBIYW1tZXIuZGV0ZWN0aW9uLmN1cnJlbnQubmFtZSAhPSB0aGlzLm5hbWUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyB3ZSBhcmUgZHJhZ2dpbmchXG4gICAgICAgIGlmKEhhbW1lci5kZXRlY3Rpb24uY3VycmVudC5uYW1lICE9IHRoaXMubmFtZSkge1xuICAgICAgICAgIEhhbW1lci5kZXRlY3Rpb24uY3VycmVudC5uYW1lID0gdGhpcy5uYW1lO1xuICAgICAgICAgIGlmKGluc3Qub3B0aW9ucy5jb3JyZWN0X2Zvcl9kcmFnX21pbl9kaXN0YW5jZSAmJiBldi5kaXN0YW5jZSA+IDApIHtcbiAgICAgICAgICAgIC8vIFdoZW4gYSBkcmFnIGlzIHRyaWdnZXJlZCwgc2V0IHRoZSBldmVudCBjZW50ZXIgdG8gZHJhZ19taW5fZGlzdGFuY2UgcGl4ZWxzIGZyb20gdGhlIG9yaWdpbmFsIGV2ZW50IGNlbnRlci5cbiAgICAgICAgICAgIC8vIFdpdGhvdXQgdGhpcyBjb3JyZWN0aW9uLCB0aGUgZHJhZ2dlZCBkaXN0YW5jZSB3b3VsZCBqdW1wc3RhcnQgYXQgZHJhZ19taW5fZGlzdGFuY2UgcGl4ZWxzIGluc3RlYWQgb2YgYXQgMC5cbiAgICAgICAgICAgIC8vIEl0IG1pZ2h0IGJlIHVzZWZ1bCB0byBzYXZlIHRoZSBvcmlnaW5hbCBzdGFydCBwb2ludCBzb21ld2hlcmVcbiAgICAgICAgICAgIHZhciBmYWN0b3IgPSBNYXRoLmFicyhpbnN0Lm9wdGlvbnMuZHJhZ19taW5fZGlzdGFuY2UgLyBldi5kaXN0YW5jZSk7XG4gICAgICAgICAgICBIYW1tZXIuZGV0ZWN0aW9uLmN1cnJlbnQuc3RhcnRFdmVudC5jZW50ZXIucGFnZVggKz0gZXYuZGVsdGFYICogZmFjdG9yO1xuICAgICAgICAgICAgSGFtbWVyLmRldGVjdGlvbi5jdXJyZW50LnN0YXJ0RXZlbnQuY2VudGVyLnBhZ2VZICs9IGV2LmRlbHRhWSAqIGZhY3RvcjtcblxuICAgICAgICAgICAgLy8gcmVjYWxjdWxhdGUgZXZlbnQgZGF0YSB1c2luZyBuZXcgc3RhcnQgcG9pbnRcbiAgICAgICAgICAgIGV2ID0gSGFtbWVyLmRldGVjdGlvbi5leHRlbmRFdmVudERhdGEoZXYpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGxvY2sgZHJhZyB0byBheGlzP1xuICAgICAgICBpZihIYW1tZXIuZGV0ZWN0aW9uLmN1cnJlbnQubGFzdEV2ZW50LmRyYWdfbG9ja2VkX3RvX2F4aXMgfHwgKGluc3Qub3B0aW9ucy5kcmFnX2xvY2tfdG9fYXhpcyAmJiBpbnN0Lm9wdGlvbnMuZHJhZ19sb2NrX21pbl9kaXN0YW5jZSA8PSBldi5kaXN0YW5jZSkpIHtcbiAgICAgICAgICBldi5kcmFnX2xvY2tlZF90b19heGlzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGFzdF9kaXJlY3Rpb24gPSBIYW1tZXIuZGV0ZWN0aW9uLmN1cnJlbnQubGFzdEV2ZW50LmRpcmVjdGlvbjtcbiAgICAgICAgaWYoZXYuZHJhZ19sb2NrZWRfdG9fYXhpcyAmJiBsYXN0X2RpcmVjdGlvbiAhPT0gZXYuZGlyZWN0aW9uKSB7XG4gICAgICAgICAgLy8ga2VlcCBkaXJlY3Rpb24gb24gdGhlIGF4aXMgdGhhdCB0aGUgZHJhZyBnZXN0dXJlIHN0YXJ0ZWQgb25cbiAgICAgICAgICBpZihIYW1tZXIudXRpbHMuaXNWZXJ0aWNhbChsYXN0X2RpcmVjdGlvbikpIHtcbiAgICAgICAgICAgIGV2LmRpcmVjdGlvbiA9IChldi5kZWx0YVkgPCAwKSA/IEhhbW1lci5ESVJFQ1RJT05fVVAgOiBIYW1tZXIuRElSRUNUSU9OX0RPV047XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZXYuZGlyZWN0aW9uID0gKGV2LmRlbHRhWCA8IDApID8gSGFtbWVyLkRJUkVDVElPTl9MRUZUIDogSGFtbWVyLkRJUkVDVElPTl9SSUdIVDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBmaXJzdCB0aW1lLCB0cmlnZ2VyIGRyYWdzdGFydCBldmVudFxuICAgICAgICBpZighdGhpcy50cmlnZ2VyZWQpIHtcbiAgICAgICAgICBpbnN0LnRyaWdnZXIodGhpcy5uYW1lICsgJ3N0YXJ0JywgZXYpO1xuICAgICAgICAgIHRoaXMudHJpZ2dlcmVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRyaWdnZXIgbm9ybWFsIGV2ZW50XG4gICAgICAgIGluc3QudHJpZ2dlcih0aGlzLm5hbWUsIGV2KTtcblxuICAgICAgICAvLyBkaXJlY3Rpb24gZXZlbnQsIGxpa2UgZHJhZ2Rvd25cbiAgICAgICAgaW5zdC50cmlnZ2VyKHRoaXMubmFtZSArIGV2LmRpcmVjdGlvbiwgZXYpO1xuXG4gICAgICAgIC8vIGJsb2NrIHRoZSBicm93c2VyIGV2ZW50c1xuICAgICAgICBpZigoaW5zdC5vcHRpb25zLmRyYWdfYmxvY2tfdmVydGljYWwgJiYgSGFtbWVyLnV0aWxzLmlzVmVydGljYWwoZXYuZGlyZWN0aW9uKSkgfHxcbiAgICAgICAgICAoaW5zdC5vcHRpb25zLmRyYWdfYmxvY2tfaG9yaXpvbnRhbCAmJiAhSGFtbWVyLnV0aWxzLmlzVmVydGljYWwoZXYuZGlyZWN0aW9uKSkpIHtcbiAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIEhhbW1lci5FVkVOVF9FTkQ6XG4gICAgICAgIC8vIHRyaWdnZXIgZHJhZ2VuZFxuICAgICAgICBpZih0aGlzLnRyaWdnZXJlZCkge1xuICAgICAgICAgIGluc3QudHJpZ2dlcih0aGlzLm5hbWUgKyAnZW5kJywgZXYpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50cmlnZ2VyZWQgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEhvbGRcbiAqIFRvdWNoIHN0YXlzIGF0IHRoZSBzYW1lIHBsYWNlIGZvciB4IHRpbWVcbiAqIEBldmVudHMgIGhvbGRcbiAqL1xuSGFtbWVyLmdlc3R1cmVzLkhvbGQgPSB7XG4gIG5hbWUgICAgOiAnaG9sZCcsXG4gIGluZGV4ICAgOiAxMCxcbiAgZGVmYXVsdHM6IHtcbiAgICBob2xkX3RpbWVvdXQgIDogNTAwLFxuICAgIGhvbGRfdGhyZXNob2xkOiAxXG4gIH0sXG4gIHRpbWVyICAgOiBudWxsLFxuICBoYW5kbGVyIDogZnVuY3Rpb24gaG9sZEdlc3R1cmUoZXYsIGluc3QpIHtcbiAgICBzd2l0Y2goZXYuZXZlbnRUeXBlKSB7XG4gICAgICBjYXNlIEhhbW1lci5FVkVOVF9TVEFSVDpcbiAgICAgICAgLy8gY2xlYXIgYW55IHJ1bm5pbmcgdGltZXJzXG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVyKTtcblxuICAgICAgICAvLyBzZXQgdGhlIGdlc3R1cmUgc28gd2UgY2FuIGNoZWNrIGluIHRoZSB0aW1lb3V0IGlmIGl0IHN0aWxsIGlzXG4gICAgICAgIEhhbW1lci5kZXRlY3Rpb24uY3VycmVudC5uYW1lID0gdGhpcy5uYW1lO1xuXG4gICAgICAgIC8vIHNldCB0aW1lciBhbmQgaWYgYWZ0ZXIgdGhlIHRpbWVvdXQgaXQgc3RpbGwgaXMgaG9sZCxcbiAgICAgICAgLy8gd2UgdHJpZ2dlciB0aGUgaG9sZCBldmVudFxuICAgICAgICB0aGlzLnRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICBpZihIYW1tZXIuZGV0ZWN0aW9uLmN1cnJlbnQubmFtZSA9PSAnaG9sZCcpIHtcbiAgICAgICAgICAgIGluc3QudHJpZ2dlcignaG9sZCcsIGV2KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIGluc3Qub3B0aW9ucy5ob2xkX3RpbWVvdXQpO1xuICAgICAgICBicmVhaztcblxuICAgICAgLy8gd2hlbiB5b3UgbW92ZSBvciBlbmQgd2UgY2xlYXIgdGhlIHRpbWVyXG4gICAgICBjYXNlIEhhbW1lci5FVkVOVF9NT1ZFOlxuICAgICAgICBpZihldi5kaXN0YW5jZSA+IGluc3Qub3B0aW9ucy5ob2xkX3RocmVzaG9sZCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRpbWVyKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBIYW1tZXIuRVZFTlRfRU5EOlxuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50aW1lcik7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBSZWxlYXNlXG4gKiBDYWxsZWQgYXMgbGFzdCwgdGVsbHMgdGhlIHVzZXIgaGFzIHJlbGVhc2VkIHRoZSBzY3JlZW5cbiAqIEBldmVudHMgIHJlbGVhc2VcbiAqL1xuSGFtbWVyLmdlc3R1cmVzLlJlbGVhc2UgPSB7XG4gIG5hbWUgICA6ICdyZWxlYXNlJyxcbiAgaW5kZXggIDogSW5maW5pdHksXG4gIGhhbmRsZXI6IGZ1bmN0aW9uIHJlbGVhc2VHZXN0dXJlKGV2LCBpbnN0KSB7XG4gICAgaWYoZXYuZXZlbnRUeXBlID09IEhhbW1lci5FVkVOVF9FTkQpIHtcbiAgICAgIGluc3QudHJpZ2dlcih0aGlzLm5hbWUsIGV2KTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogU3dpcGVcbiAqIHRyaWdnZXJzIHN3aXBlIGV2ZW50cyB3aGVuIHRoZSBlbmQgdmVsb2NpdHkgaXMgYWJvdmUgdGhlIHRocmVzaG9sZFxuICogQGV2ZW50cyAgc3dpcGUsIHN3aXBlbGVmdCwgc3dpcGVyaWdodCwgc3dpcGV1cCwgc3dpcGVkb3duXG4gKi9cbkhhbW1lci5nZXN0dXJlcy5Td2lwZSA9IHtcbiAgbmFtZSAgICA6ICdzd2lwZScsXG4gIGluZGV4ICAgOiA0MCxcbiAgZGVmYXVsdHM6IHtcbiAgICAvLyBzZXQgMCBmb3IgdW5saW1pdGVkLCBidXQgdGhpcyBjYW4gY29uZmxpY3Qgd2l0aCB0cmFuc2Zvcm1cbiAgICBzd2lwZV9taW5fdG91Y2hlczogMSxcbiAgICBzd2lwZV9tYXhfdG91Y2hlczogMSxcbiAgICBzd2lwZV92ZWxvY2l0eSAgIDogMC43XG4gIH0sXG4gIGhhbmRsZXIgOiBmdW5jdGlvbiBzd2lwZUdlc3R1cmUoZXYsIGluc3QpIHtcbiAgICBpZihldi5ldmVudFR5cGUgPT0gSGFtbWVyLkVWRU5UX0VORCkge1xuICAgICAgLy8gbWF4IHRvdWNoZXNcbiAgICAgIGlmKGluc3Qub3B0aW9ucy5zd2lwZV9tYXhfdG91Y2hlcyA+IDAgJiZcbiAgICAgICAgZXYudG91Y2hlcy5sZW5ndGggPCBpbnN0Lm9wdGlvbnMuc3dpcGVfbWluX3RvdWNoZXMgJiZcbiAgICAgICAgZXYudG91Y2hlcy5sZW5ndGggPiBpbnN0Lm9wdGlvbnMuc3dpcGVfbWF4X3RvdWNoZXMpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyB3aGVuIHRoZSBkaXN0YW5jZSB3ZSBtb3ZlZCBpcyB0b28gc21hbGwgd2Ugc2tpcCB0aGlzIGdlc3R1cmVcbiAgICAgIC8vIG9yIHdlIGNhbiBiZSBhbHJlYWR5IGluIGRyYWdnaW5nXG4gICAgICBpZihldi52ZWxvY2l0eVggPiBpbnN0Lm9wdGlvbnMuc3dpcGVfdmVsb2NpdHkgfHxcbiAgICAgICAgZXYudmVsb2NpdHlZID4gaW5zdC5vcHRpb25zLnN3aXBlX3ZlbG9jaXR5KSB7XG4gICAgICAgIC8vIHRyaWdnZXIgc3dpcGUgZXZlbnRzXG4gICAgICAgIGluc3QudHJpZ2dlcih0aGlzLm5hbWUsIGV2KTtcbiAgICAgICAgaW5zdC50cmlnZ2VyKHRoaXMubmFtZSArIGV2LmRpcmVjdGlvbiwgZXYpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBUYXAvRG91YmxlVGFwXG4gKiBRdWljayB0b3VjaCBhdCBhIHBsYWNlIG9yIGRvdWJsZSBhdCB0aGUgc2FtZSBwbGFjZVxuICogQGV2ZW50cyAgdGFwLCBkb3VibGV0YXBcbiAqL1xuSGFtbWVyLmdlc3R1cmVzLlRhcCA9IHtcbiAgbmFtZSAgICA6ICd0YXAnLFxuICBpbmRleCAgIDogMTAwLFxuICBkZWZhdWx0czoge1xuICAgIHRhcF9tYXhfdG91Y2h0aW1lIDogMjUwLFxuICAgIHRhcF9tYXhfZGlzdGFuY2UgIDogMTAsXG4gICAgdGFwX2Fsd2F5cyAgICAgICAgOiB0cnVlLFxuICAgIGRvdWJsZXRhcF9kaXN0YW5jZTogMjAsXG4gICAgZG91YmxldGFwX2ludGVydmFsOiAzMDBcbiAgfSxcbiAgaGFuZGxlciA6IGZ1bmN0aW9uIHRhcEdlc3R1cmUoZXYsIGluc3QpIHtcbiAgICBpZihldi5ldmVudFR5cGUgPT0gSGFtbWVyLkVWRU5UX0VORCAmJiBldi5zcmNFdmVudC50eXBlICE9ICd0b3VjaGNhbmNlbCcpIHtcbiAgICAgIC8vIHByZXZpb3VzIGdlc3R1cmUsIGZvciB0aGUgZG91YmxlIHRhcCBzaW5jZSB0aGVzZSBhcmUgdHdvIGRpZmZlcmVudCBnZXN0dXJlIGRldGVjdGlvbnNcbiAgICAgIHZhciBwcmV2ID0gSGFtbWVyLmRldGVjdGlvbi5wcmV2aW91cyxcbiAgICAgICAgZGlkX2RvdWJsZXRhcCA9IGZhbHNlO1xuXG4gICAgICAvLyB3aGVuIHRoZSB0b3VjaHRpbWUgaXMgaGlnaGVyIHRoZW4gdGhlIG1heCB0b3VjaCB0aW1lXG4gICAgICAvLyBvciB3aGVuIHRoZSBtb3ZpbmcgZGlzdGFuY2UgaXMgdG9vIG11Y2hcbiAgICAgIGlmKGV2LmRlbHRhVGltZSA+IGluc3Qub3B0aW9ucy50YXBfbWF4X3RvdWNodGltZSB8fFxuICAgICAgICBldi5kaXN0YW5jZSA+IGluc3Qub3B0aW9ucy50YXBfbWF4X2Rpc3RhbmNlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gY2hlY2sgaWYgZG91YmxlIHRhcFxuICAgICAgaWYocHJldiAmJiBwcmV2Lm5hbWUgPT0gJ3RhcCcgJiZcbiAgICAgICAgKGV2LnRpbWVTdGFtcCAtIHByZXYubGFzdEV2ZW50LnRpbWVTdGFtcCkgPCBpbnN0Lm9wdGlvbnMuZG91YmxldGFwX2ludGVydmFsICYmXG4gICAgICAgIGV2LmRpc3RhbmNlIDwgaW5zdC5vcHRpb25zLmRvdWJsZXRhcF9kaXN0YW5jZSkge1xuICAgICAgICBpbnN0LnRyaWdnZXIoJ2RvdWJsZXRhcCcsIGV2KTtcbiAgICAgICAgZGlkX2RvdWJsZXRhcCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIC8vIGRvIGEgc2luZ2xlIHRhcFxuICAgICAgaWYoIWRpZF9kb3VibGV0YXAgfHwgaW5zdC5vcHRpb25zLnRhcF9hbHdheXMpIHtcbiAgICAgICAgSGFtbWVyLmRldGVjdGlvbi5jdXJyZW50Lm5hbWUgPSAndGFwJztcbiAgICAgICAgaW5zdC50cmlnZ2VyKEhhbW1lci5kZXRlY3Rpb24uY3VycmVudC5uYW1lLCBldik7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIFRvdWNoXG4gKiBDYWxsZWQgYXMgZmlyc3QsIHRlbGxzIHRoZSB1c2VyIGhhcyB0b3VjaGVkIHRoZSBzY3JlZW5cbiAqIEBldmVudHMgIHRvdWNoXG4gKi9cbkhhbW1lci5nZXN0dXJlcy5Ub3VjaCA9IHtcbiAgbmFtZSAgICA6ICd0b3VjaCcsXG4gIGluZGV4ICAgOiAtSW5maW5pdHksXG4gIGRlZmF1bHRzOiB7XG4gICAgLy8gY2FsbCBwcmV2ZW50RGVmYXVsdCBhdCB0b3VjaHN0YXJ0LCBhbmQgbWFrZXMgdGhlIGVsZW1lbnQgYmxvY2tpbmcgYnlcbiAgICAvLyBkaXNhYmxpbmcgdGhlIHNjcm9sbGluZyBvZiB0aGUgcGFnZSwgYnV0IGl0IGltcHJvdmVzIGdlc3R1cmVzIGxpa2VcbiAgICAvLyB0cmFuc2Zvcm1pbmcgYW5kIGRyYWdnaW5nLlxuICAgIC8vIGJlIGNhcmVmdWwgd2l0aCB1c2luZyB0aGlzLCBpdCBjYW4gYmUgdmVyeSBhbm5veWluZyBmb3IgdXNlcnMgdG8gYmUgc3R1Y2tcbiAgICAvLyBvbiB0aGUgcGFnZVxuICAgIHByZXZlbnRfZGVmYXVsdCAgICA6IGZhbHNlLFxuXG4gICAgLy8gZGlzYWJsZSBtb3VzZSBldmVudHMsIHNvIG9ubHkgdG91Y2ggKG9yIHBlbiEpIGlucHV0IHRyaWdnZXJzIGV2ZW50c1xuICAgIHByZXZlbnRfbW91c2VldmVudHM6IGZhbHNlXG4gIH0sXG4gIGhhbmRsZXIgOiBmdW5jdGlvbiB0b3VjaEdlc3R1cmUoZXYsIGluc3QpIHtcbiAgICBpZihpbnN0Lm9wdGlvbnMucHJldmVudF9tb3VzZWV2ZW50cyAmJiBldi5wb2ludGVyVHlwZSA9PSBIYW1tZXIuUE9JTlRFUl9NT1VTRSkge1xuICAgICAgZXYuc3RvcERldGVjdCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmKGluc3Qub3B0aW9ucy5wcmV2ZW50X2RlZmF1bHQpIHtcbiAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuXG4gICAgaWYoZXYuZXZlbnRUeXBlID09IEhhbW1lci5FVkVOVF9TVEFSVCkge1xuICAgICAgaW5zdC50cmlnZ2VyKHRoaXMubmFtZSwgZXYpO1xuICAgIH1cbiAgfVxufTtcblxuXG4vKipcbiAqIFRyYW5zZm9ybVxuICogVXNlciB3YW50IHRvIHNjYWxlIG9yIHJvdGF0ZSB3aXRoIDIgZmluZ2Vyc1xuICogQGV2ZW50cyAgdHJhbnNmb3JtLCBwaW5jaCwgcGluY2hpbiwgcGluY2hvdXQsIHJvdGF0ZVxuICovXG5IYW1tZXIuZ2VzdHVyZXMuVHJhbnNmb3JtID0ge1xuICBuYW1lICAgICA6ICd0cmFuc2Zvcm0nLFxuICBpbmRleCAgICA6IDQ1LFxuICBkZWZhdWx0cyA6IHtcbiAgICAvLyBmYWN0b3IsIG5vIHNjYWxlIGlzIDEsIHpvb21pbiBpcyB0byAwIGFuZCB6b29tb3V0IHVudGlsIGhpZ2hlciB0aGVuIDFcbiAgICB0cmFuc2Zvcm1fbWluX3NjYWxlICAgOiAwLjAxLFxuICAgIC8vIHJvdGF0aW9uIGluIGRlZ3JlZXNcbiAgICB0cmFuc2Zvcm1fbWluX3JvdGF0aW9uOiAxLFxuICAgIC8vIHByZXZlbnQgZGVmYXVsdCBicm93c2VyIGJlaGF2aW9yIHdoZW4gdHdvIHRvdWNoZXMgYXJlIG9uIHRoZSBzY3JlZW5cbiAgICAvLyBidXQgaXQgbWFrZXMgdGhlIGVsZW1lbnQgYSBibG9ja2luZyBlbGVtZW50XG4gICAgLy8gd2hlbiB5b3UgYXJlIHVzaW5nIHRoZSB0cmFuc2Zvcm0gZ2VzdHVyZSwgaXQgaXMgYSBnb29kIHByYWN0aWNlIHRvIHNldCB0aGlzIHRydWVcbiAgICB0cmFuc2Zvcm1fYWx3YXlzX2Jsb2NrOiBmYWxzZVxuICB9LFxuICB0cmlnZ2VyZWQ6IGZhbHNlLFxuICBoYW5kbGVyICA6IGZ1bmN0aW9uIHRyYW5zZm9ybUdlc3R1cmUoZXYsIGluc3QpIHtcbiAgICAvLyBjdXJyZW50IGdlc3R1cmUgaXNudCBkcmFnLCBidXQgZHJhZ2dlZCBpcyB0cnVlXG4gICAgLy8gdGhpcyBtZWFucyBhbiBvdGhlciBnZXN0dXJlIGlzIGJ1c3kuIG5vdyBjYWxsIGRyYWdlbmRcbiAgICBpZihIYW1tZXIuZGV0ZWN0aW9uLmN1cnJlbnQubmFtZSAhPSB0aGlzLm5hbWUgJiYgdGhpcy50cmlnZ2VyZWQpIHtcbiAgICAgIGluc3QudHJpZ2dlcih0aGlzLm5hbWUgKyAnZW5kJywgZXYpO1xuICAgICAgdGhpcy50cmlnZ2VyZWQgPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBhdGxlYXN0IG11bHRpdG91Y2hcbiAgICBpZihldi50b3VjaGVzLmxlbmd0aCA8IDIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBwcmV2ZW50IGRlZmF1bHQgd2hlbiB0d28gZmluZ2VycyBhcmUgb24gdGhlIHNjcmVlblxuICAgIGlmKGluc3Qub3B0aW9ucy50cmFuc2Zvcm1fYWx3YXlzX2Jsb2NrKSB7XG4gICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cblxuICAgIHN3aXRjaChldi5ldmVudFR5cGUpIHtcbiAgICAgIGNhc2UgSGFtbWVyLkVWRU5UX1NUQVJUOlxuICAgICAgICB0aGlzLnRyaWdnZXJlZCA9IGZhbHNlO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBIYW1tZXIuRVZFTlRfTU9WRTpcbiAgICAgICAgdmFyIHNjYWxlX3RocmVzaG9sZCA9IE1hdGguYWJzKDEgLSBldi5zY2FsZSk7XG4gICAgICAgIHZhciByb3RhdGlvbl90aHJlc2hvbGQgPSBNYXRoLmFicyhldi5yb3RhdGlvbik7XG5cbiAgICAgICAgLy8gd2hlbiB0aGUgZGlzdGFuY2Ugd2UgbW92ZWQgaXMgdG9vIHNtYWxsIHdlIHNraXAgdGhpcyBnZXN0dXJlXG4gICAgICAgIC8vIG9yIHdlIGNhbiBiZSBhbHJlYWR5IGluIGRyYWdnaW5nXG4gICAgICAgIGlmKHNjYWxlX3RocmVzaG9sZCA8IGluc3Qub3B0aW9ucy50cmFuc2Zvcm1fbWluX3NjYWxlICYmXG4gICAgICAgICAgcm90YXRpb25fdGhyZXNob2xkIDwgaW5zdC5vcHRpb25zLnRyYW5zZm9ybV9taW5fcm90YXRpb24pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyB3ZSBhcmUgdHJhbnNmb3JtaW5nIVxuICAgICAgICBIYW1tZXIuZGV0ZWN0aW9uLmN1cnJlbnQubmFtZSA9IHRoaXMubmFtZTtcblxuICAgICAgICAvLyBmaXJzdCB0aW1lLCB0cmlnZ2VyIGRyYWdzdGFydCBldmVudFxuICAgICAgICBpZighdGhpcy50cmlnZ2VyZWQpIHtcbiAgICAgICAgICBpbnN0LnRyaWdnZXIodGhpcy5uYW1lICsgJ3N0YXJ0JywgZXYpO1xuICAgICAgICAgIHRoaXMudHJpZ2dlcmVkID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGluc3QudHJpZ2dlcih0aGlzLm5hbWUsIGV2KTsgLy8gYmFzaWMgdHJhbnNmb3JtIGV2ZW50XG5cbiAgICAgICAgLy8gdHJpZ2dlciByb3RhdGUgZXZlbnRcbiAgICAgICAgaWYocm90YXRpb25fdGhyZXNob2xkID4gaW5zdC5vcHRpb25zLnRyYW5zZm9ybV9taW5fcm90YXRpb24pIHtcbiAgICAgICAgICBpbnN0LnRyaWdnZXIoJ3JvdGF0ZScsIGV2KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHRyaWdnZXIgcGluY2ggZXZlbnRcbiAgICAgICAgaWYoc2NhbGVfdGhyZXNob2xkID4gaW5zdC5vcHRpb25zLnRyYW5zZm9ybV9taW5fc2NhbGUpIHtcbiAgICAgICAgICBpbnN0LnRyaWdnZXIoJ3BpbmNoJywgZXYpO1xuICAgICAgICAgIGluc3QudHJpZ2dlcigncGluY2gnICsgKChldi5zY2FsZSA8IDEpID8gJ2luJyA6ICdvdXQnKSwgZXYpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIEhhbW1lci5FVkVOVF9FTkQ6XG4gICAgICAgIC8vIHRyaWdnZXIgZHJhZ2VuZFxuICAgICAgICBpZih0aGlzLnRyaWdnZXJlZCkge1xuICAgICAgICAgIGluc3QudHJpZ2dlcih0aGlzLm5hbWUgKyAnZW5kJywgZXYpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy50cmlnZ2VyZWQgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59O1xuXG4gIC8vIEJhc2VkIG9mZiBMby1EYXNoJ3MgZXhjZWxsZW50IFVNRCB3cmFwcGVyIChzbGlnaHRseSBtb2RpZmllZCkgLSBodHRwczovL2dpdGh1Yi5jb20vYmVzdGllanMvbG9kYXNoL2Jsb2IvbWFzdGVyL2xvZGFzaC5qcyNMNTUxNS1MNTU0M1xuICAvLyBzb21lIEFNRCBidWlsZCBvcHRpbWl6ZXJzLCBsaWtlIHIuanMsIGNoZWNrIGZvciBzcGVjaWZpYyBjb25kaXRpb24gcGF0dGVybnMgbGlrZSB0aGUgZm9sbG93aW5nOlxuICBpZih0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIC8vIGRlZmluZSBhcyBhbiBhbm9ueW1vdXMgbW9kdWxlXG4gICAgZGVmaW5lKGZ1bmN0aW9uKCkgeyByZXR1cm4gSGFtbWVyOyB9KTtcbiAgfVxuXG4gIC8vIGNoZWNrIGZvciBgZXhwb3J0c2AgYWZ0ZXIgYGRlZmluZWAgaW4gY2FzZSBhIGJ1aWxkIG9wdGltaXplciBhZGRzIGFuIGBleHBvcnRzYCBvYmplY3RcbiAgZWxzZSBpZih0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gSGFtbWVyO1xuICB9XG5cbiAgZWxzZSB7XG4gICAgd2luZG93LkhhbW1lciA9IEhhbW1lcjtcbiAgfVxuXG4gIHJldHVybiBIYW1tZXI7XG59KSh3aW5kb3cpO1xuXG5leHBvcnQgZGVmYXVsdCBIYW1tZXI7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBZEE7QUFDQTtBQWdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7O0FBS0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFFQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBRUE7Ozs7OztBQU1BO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7QUFNQTtBQUNBO0FBQUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7OztBQU1BO0FBQ0E7QUFBQTtBQUVBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFwT0E7QUFDQTtBQXVPQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBcEVBO0FBQ0E7QUF1RUE7Ozs7OztBQU1BO0FBQ0E7QUFFQTs7OztBQUlBO0FBQ0E7QUFFQTs7OztBQUlBO0FBQ0E7QUFFQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUlBO0FBQ0E7QUFDQTtBQVBBO0FBU0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQXJDQTtBQXVDQTtBQXhOQTtBQUNBO0FBME5BO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTs7O0FBR0E7QUFDQTtBQUtBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBM0VBO0FBQ0E7QUE4RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFwQkE7QUFDQTtBQXNCQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBbE1BO0FBQ0E7QUFxTUE7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXhCQTtBQUNBO0FBMEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF0RUE7QUF3RUE7QUF0SEE7QUFDQTtBQXdIQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUExQkE7QUE0QkE7QUFyQ0E7QUFDQTtBQXVDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFDQTtBQVNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBM0JBO0FBQ0E7QUE2QkE7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXJDQTtBQUNBO0FBdUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVEE7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBM0JBO0FBQ0E7QUE4QkE7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUkE7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUE5Q0E7QUFnREE7QUFqRkE7QUFDQTtBQW1GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./js/hammer.js\n");

/***/ }),

/***/ "./js/jsandbox.js":
/*!************************!*\
  !*** ./js/jsandbox.js ***!
  \************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/*\n * JSandbox JavaScript Library v0.2.3\n *\n * With modifications to create a worker function inline so that\n * we can just include this single file\n *\n * 2009-01-25\n * By Elijah Grey, http://eligrey.com\n * Licensed under the X11/MIT License\n *   See LICENSE.md\n */\n\n/*global self */\n\n/*jslint undef: true, nomen: true, eqeqeq: true, bitwise: true, regexp: true,\nnewcap: true, immed: true, maxerr: 1000, strict: true */\n\n/*! @source http://purl.eligrey.com/github/jsandbox/blob/master/src/jsandbox.js*/\n\n\n\nvar JSandbox = function (self) {\n\tvar undef_type = \"undefined\",\n\t    doc = self.document,\n\t    Worker = self.Worker;\n\n\tif (typeof Worker === undef_type) {\n\t\treturn;\n\t}\n\n\tvar\n\t// repeatedly used properties/strings (for minification)\n\t$eval = \"eval\",\n\t    $exec = \"exec\",\n\t    $load = \"load\",\n\t    $requests = \"requests\",\n\t    $input = \"input\",\n\t    $terminate = \"terminate\",\n\t    $data = \"data\",\n\t    $callback = \"callback\",\n\t    $onerror = \"onerror\",\n\t    $worker = \"worker\",\n\t    $onresponse = \"onresponse\",\n\t    $prototype = \"prototype\",\n\t    $call = \"call\",\n\t    str_type = \"string\",\n\t    fun_type = \"function\",\n\t    Sandbox = function Sandbox() {\n\t\tvar sandbox = this;\n\n\t\tif (!(sandbox instanceof Sandbox)) {\n\t\t\treturn new Sandbox();\n\t\t}\n\t\ttry {\n\t\t\tsandbox[$worker] = new Worker(Sandbox.url);\n\t\t} catch (exception) {\n\t\t\t// Internet Explorer closes the BLOB before we can use it\n\t\t\tif (exception.name === \"SecurityError\") {\n\t\t\t\tsandbox[$worker] = new Worker(window.URL.createObjectURL(new Blob(['(' + default_worker_function.toString() + '(self,eval))'], { 'type': 'text/javascript' })));\n\t\t\t}\n\t\t}\n\t\tsandbox[$requests] = {};\n\n\t\tsandbox[$worker].onmessage = function (event) {\n\t\t\tvar data = event[$data],\n\t\t\t    request;\n\t\t\tif (typeof data !== \"object\") {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (data.id == \"log\") {\n\t\t\t\tconsole.log(data.message);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\trequest = sandbox[$requests][data.id];\n\t\t\tif (request) {\n\t\t\t\tif (data.error) {\n\t\t\t\t\tif (typeof sandbox[$onerror] === fun_type) {\n\t\t\t\t\t\tsandbox[$onerror](data, request);\n\t\t\t\t\t}\n\t\t\t\t\tif (typeof request[$onerror] === fun_type) {\n\t\t\t\t\t\trequest[$onerror][$call](sandbox, data.error);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (typeof sandbox[$onresponse] === fun_type) {\n\t\t\t\t\t\tsandbox[$onresponse](data, request);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (typeof request[$callback] === fun_type) {\n\t\t\t\t\t\trequest[$callback][$call](sandbox, data.results);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdelete sandbox[$requests][data.id];\n\t\t\t}\n\t\t};\n\t},\n\t    proto = Sandbox[$prototype],\n\t    createRequestMethod = function createRequestMethod(method) {\n\t\tproto[method] = function (options, callback, input, onerror) {\n\t\t\tif (typeof options === str_type || Object[$prototype].toString[$call](options) === \"[object Array]\" || arguments.length > 1) {\n\t\t\t\t// called in (data, callback, input, onerror) style\n\t\t\t\toptions = {\n\t\t\t\t\tdata: options,\n\t\t\t\t\tinput: input,\n\t\t\t\t\tcallback: callback,\n\t\t\t\t\tonerror: onerror\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (method === $load && typeof options[$data] === str_type) {\n\t\t\t\toptions[$data] = [options[$data]];\n\t\t\t}\n\n\t\t\tvar data = options[$data],\n\t\t\t    id = this.createRequestID();\n\n\t\t\tinput = options[$input];\n\n\t\t\tdelete options[$data];\n\t\t\tdelete options[$input];\n\n\t\t\tthis[$requests][id] = options;\n\n\t\t\tthis[$worker].postMessage({\n\t\t\t\tid: id,\n\t\t\t\tmethod: method,\n\t\t\t\tdata: data,\n\t\t\t\tinput: input\n\t\t\t});\n\n\t\t\treturn id;\n\t\t};\n\t\tSandbox[method] = function () {\n\t\t\tvar sandbox = new Sandbox();\n\n\t\t\tsandbox[$onresponse] = sandbox[$onerror] = function () {\n\t\t\t\tsandbox[$terminate]();\n\t\t\t\tsandbox = null;\n\t\t\t};\n\n\t\t\tSandbox[$prototype][method].apply(sandbox, Array[$prototype].slice[$call](arguments));\n\t\t\treturn Sandbox;\n\t\t};\n\t},\n\t    methods = [$eval, $load, $exec],\n\t    i = 3; // methods.length\n\n\twhile (i--) {\n\t\tcreateRequestMethod(methods[i]);\n\t}\n\n\tproto[$terminate] = function () {\n\t\tthis[$requests] = {};\n\t\tthis[$worker].onmessage = null;\n\t\tthis[$worker][$terminate]();\n\t};\n\n\tproto.abort = function (id) {\n\t\tdelete this[$requests][id];\n\t};\n\n\tproto.createRequestID = function () {\n\t\tvar id = Math.random().toString();\n\t\tif (id in this[$requests]) {\n\t\t\treturn this.createRequestID();\n\t\t}\n\t\treturn id;\n\t};\n\n\tif (typeof doc !== undef_type) {\n\t\tvar linkElems = doc.getElementsByTagName(\"link\");\n\t\ti = linkElems.length;\n\t\twhile (i--) {\n\t\t\tif (linkElems[i].getAttribute(\"rel\") === \"jsandbox\") {\n\t\t\t\tSandbox.url = linkElems[i].getAttribute(\"href\");\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tvar default_worker_function = function default_worker_function(self, globalEval) {\n\t\t\"use strict\";\n\n\t\tvar postMessage = self.postMessage,\n\t\t    importScripts = self.importScripts,\n\t\t    messageEventType = \"message\",\n\t\t    messageHandler = function messageHandler(event) {\n\t\t\tvar request = event.data,\n\t\t\t    response = {};\n\n\t\t\tresponse.id = request.id;\n\n\t\t\tvar data = request.data;\n\t\t\tself.input = request.input || {};\n\n\t\t\ttry {\n\t\t\t\tswitch (request.method) {\n\n\t\t\t\t\tcase \"eval\":\n\t\t\t\t\t\t// JSLint has something against indenting cases\n\t\t\t\t\t\tresponse.results = globalEval(data);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"exec\":\n\t\t\t\t\t\timportScripts(\"data:application/javascript,\" + encodeURIComponent(data));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"load\":\n\t\t\t\t\t\timportScripts.apply(self, data);\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\tresponse.code = e.message;\n\t\t\t\tresponse.error = e.stack;\n\t\t\t\tresponse.line = e.lineNumber;\n\t\t\t\tresponse.fileName = e.fileName;\n\t\t\t}\n\n\t\t\tdelete self.input;\n\t\t\ttry {\n\t\t\t\tdelete self.onmessage; // in case the code defined it\n\t\t\t} catch (e) {}\n\n\t\t\tpostMessage(response);\n\t\t};\n\n\t\tif (self.addEventListener) {\n\t\t\tself.addEventListener(messageEventType, messageHandler, false);\n\t\t} else if (self.attachEvent) {\n\t\t\t// for future compatibility with IE\n\t\t\tself.attachEvent(\"on\" + messageEventType, messageHandler);\n\t\t}\n\n\t\tself.window = self; // provide a window object for scripts\n\t\tself.console = { log: function log(message) {\n\t\t\t\tpostMessage({ \"id\": \"log\", \"message\": message });\n\t\t\t} };\n\n\t\t// dereference unsafe functions\n\t\t// some might not be dereferenced: https://bugzilla.mozilla.org/show_bug.cgi?id=512464\n\t\tself.Worker = self.addEventListener = self.removeEventListener = self.importScripts = self.XMLHttpRequest = self.postMessage =\n\t\t//self.dispatchEvent       =\n\t\t// in case IE implements web workers\n\t\tself.attachEvent = self.detachEvent = self.ActiveXObject = undefined;\n\t};\n\n\tif (!Sandbox.url) {\n\t\tSandbox.url = window.URL.createObjectURL(new Blob(['(' + default_worker_function.toString() + '(self,eval))'], { 'type': 'text/javascript' }));\n\t}\n\treturn Sandbox;\n}(self),\n    Sandbox = JSandbox;\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (JSandbox);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9qcy9qc2FuZGJveC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9qcy9qc2FuZGJveC5qcz9kNjZmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBKU2FuZGJveCBKYXZhU2NyaXB0IExpYnJhcnkgdjAuMi4zXG4gKlxuICogV2l0aCBtb2RpZmljYXRpb25zIHRvIGNyZWF0ZSBhIHdvcmtlciBmdW5jdGlvbiBpbmxpbmUgc28gdGhhdFxuICogd2UgY2FuIGp1c3QgaW5jbHVkZSB0aGlzIHNpbmdsZSBmaWxlXG4gKlxuICogMjAwOS0wMS0yNVxuICogQnkgRWxpamFoIEdyZXksIGh0dHA6Ly9lbGlncmV5LmNvbVxuICogTGljZW5zZWQgdW5kZXIgdGhlIFgxMS9NSVQgTGljZW5zZVxuICogICBTZWUgTElDRU5TRS5tZFxuICovXG5cbi8qZ2xvYmFsIHNlbGYgKi9cblxuLypqc2xpbnQgdW5kZWY6IHRydWUsIG5vbWVuOiB0cnVlLCBlcWVxZXE6IHRydWUsIGJpdHdpc2U6IHRydWUsIHJlZ2V4cDogdHJ1ZSxcbm5ld2NhcDogdHJ1ZSwgaW1tZWQ6IHRydWUsIG1heGVycjogMTAwMCwgc3RyaWN0OiB0cnVlICovXG5cbi8qISBAc291cmNlIGh0dHA6Ly9wdXJsLmVsaWdyZXkuY29tL2dpdGh1Yi9qc2FuZGJveC9ibG9iL21hc3Rlci9zcmMvanNhbmRib3guanMqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIEpTYW5kYm94ID0gKGZ1bmN0aW9uIChzZWxmKSB7XG5cdHZhciB1bmRlZl90eXBlID0gXCJ1bmRlZmluZWRcIixcblx0ZG9jICAgICAgICAgICAgPSBzZWxmLmRvY3VtZW50LFxuXHRXb3JrZXIgICAgICAgICA9IHNlbGYuV29ya2VyO1xuXHRcblx0aWYgKHR5cGVvZiBXb3JrZXIgPT09IHVuZGVmX3R5cGUpIHtcblx0XHRyZXR1cm47XG5cdH1cblx0XG5cdHZhclxuXHQvLyByZXBlYXRlZGx5IHVzZWQgcHJvcGVydGllcy9zdHJpbmdzIChmb3IgbWluaWZpY2F0aW9uKVxuXHQkZXZhbCAgICAgICA9IFwiZXZhbFwiLFxuXHQkZXhlYyAgICAgICA9IFwiZXhlY1wiLFxuXHQkbG9hZCAgICAgICA9IFwibG9hZFwiLFxuXHQkcmVxdWVzdHMgICA9IFwicmVxdWVzdHNcIixcblx0JGlucHV0ICAgICAgPSBcImlucHV0XCIsXG5cdCR0ZXJtaW5hdGUgID0gXCJ0ZXJtaW5hdGVcIixcblx0JGRhdGEgICAgICAgPSBcImRhdGFcIixcblx0JGNhbGxiYWNrICAgPSBcImNhbGxiYWNrXCIsXG5cdCRvbmVycm9yICAgID0gXCJvbmVycm9yXCIsXG5cdCR3b3JrZXIgICAgID0gXCJ3b3JrZXJcIixcblx0JG9ucmVzcG9uc2UgPSBcIm9ucmVzcG9uc2VcIixcblx0JHByb3RvdHlwZSAgPSBcInByb3RvdHlwZVwiLFxuXHQkY2FsbCAgICAgICA9IFwiY2FsbFwiLFxuXHRcblx0c3RyX3R5cGUgICA9IFwic3RyaW5nXCIsXG5cdGZ1bl90eXBlICAgPSBcImZ1bmN0aW9uXCIsXG5cdFxuXHRcblx0U2FuZGJveCA9IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgc2FuZGJveCA9IHRoaXM7XG5cdFx0XG5cdFx0aWYgKCEoc2FuZGJveCBpbnN0YW5jZW9mIFNhbmRib3gpKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFNhbmRib3goKTtcblx0XHR9XG5cdFx0dHJ5IHtcblx0XHRcdHNhbmRib3hbJHdvcmtlcl0gPSBuZXcgV29ya2VyKFNhbmRib3gudXJsKTtcblx0XHR9IGNhdGNoKGV4Y2VwdGlvbikge1xuXHRcdFx0Ly8gSW50ZXJuZXQgRXhwbG9yZXIgY2xvc2VzIHRoZSBCTE9CIGJlZm9yZSB3ZSBjYW4gdXNlIGl0XG5cdFx0XHRpZiAoZXhjZXB0aW9uLm5hbWUgPT09IFwiU2VjdXJpdHlFcnJvclwiKSB7XG5cdFx0XHRcdHNhbmRib3hbJHdvcmtlcl0gPSBuZXcgV29ya2VyKHdpbmRvdy5VUkwuY3JlYXRlT2JqZWN0VVJMKG5ldyBCbG9iKFsnKCcrZGVmYXVsdF93b3JrZXJfZnVuY3Rpb24udG9TdHJpbmcoKSsnKHNlbGYsZXZhbCkpJ10sIHsndHlwZScgOiAndGV4dC9qYXZhc2NyaXB0J30pKSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHNhbmRib3hbJHJlcXVlc3RzXSA9IHt9O1xuXHRcdFxuXHRcdHNhbmRib3hbJHdvcmtlcl0ub25tZXNzYWdlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG5cdFx0XHR2YXIgZGF0YSA9IGV2ZW50WyRkYXRhXSwgcmVxdWVzdDtcblx0XHRcdGlmICh0eXBlb2YgZGF0YSAhPT0gXCJvYmplY3RcIikge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRpZiAoZGF0YS5pZCA9PSBcImxvZ1wiKSB7XG5cdFx0XHRcdGNvbnNvbGUubG9nKGRhdGEubWVzc2FnZSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHJlcXVlc3QgPSBzYW5kYm94WyRyZXF1ZXN0c11bZGF0YS5pZF07XG5cdFx0XHRpZiAocmVxdWVzdCkge1xuXHRcdFx0XHRpZiAoZGF0YS5lcnJvcikge1xuXHRcdFx0XHRcdGlmICh0eXBlb2Ygc2FuZGJveFskb25lcnJvcl0gPT09IGZ1bl90eXBlKSB7XG5cdFx0XHRcdFx0XHRzYW5kYm94WyRvbmVycm9yXShkYXRhLCByZXF1ZXN0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKHR5cGVvZiByZXF1ZXN0WyRvbmVycm9yXSA9PT0gZnVuX3R5cGUpIHtcblx0XHRcdFx0XHRcdHJlcXVlc3RbJG9uZXJyb3JdWyRjYWxsXShzYW5kYm94LCBkYXRhLmVycm9yKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYgKHR5cGVvZiBzYW5kYm94WyRvbnJlc3BvbnNlXSA9PT0gZnVuX3R5cGUpIHtcblx0XHRcdFx0XHRcdHNhbmRib3hbJG9ucmVzcG9uc2VdKGRhdGEsIHJlcXVlc3QpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XG5cdFx0XHRcdFx0aWYgKHR5cGVvZiByZXF1ZXN0WyRjYWxsYmFja10gPT09IGZ1bl90eXBlKSB7XG5cdFx0XHRcdFx0XHRyZXF1ZXN0WyRjYWxsYmFja11bJGNhbGxdKHNhbmRib3gsIGRhdGEucmVzdWx0cyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGRlbGV0ZSBzYW5kYm94WyRyZXF1ZXN0c11bZGF0YS5pZF07XG5cdFx0XHR9XG5cdFx0fTtcblx0fSxcblx0cHJvdG8gPSBTYW5kYm94WyRwcm90b3R5cGVdLFxuXHRcblx0Y3JlYXRlUmVxdWVzdE1ldGhvZCA9IGZ1bmN0aW9uIChtZXRob2QpIHtcblx0XHRwcm90b1ttZXRob2RdID0gZnVuY3Rpb24gKG9wdGlvbnMsIGNhbGxiYWNrLCBpbnB1dCwgb25lcnJvcikge1xuXHRcdFx0aWYgKHR5cGVvZiBvcHRpb25zID09PSBzdHJfdHlwZSB8fFxuXHRcdFx0ICAgIE9iamVjdFskcHJvdG90eXBlXS50b1N0cmluZ1skY2FsbF0ob3B0aW9ucykgPT09IFwiW29iamVjdCBBcnJheV1cIiB8fFxuXHRcdFx0ICAgIGFyZ3VtZW50cy5sZW5ndGggPiAxKVxuXHRcdFx0eyAvLyBjYWxsZWQgaW4gKGRhdGEsIGNhbGxiYWNrLCBpbnB1dCwgb25lcnJvcikgc3R5bGVcblx0XHRcdFx0b3B0aW9ucyA9IHtcblx0XHRcdFx0XHRkYXRhICAgICA6IG9wdGlvbnMsXG5cdFx0XHRcdFx0aW5wdXQgICAgOiBpbnB1dCxcblx0XHRcdFx0XHRjYWxsYmFjayA6IGNhbGxiYWNrLFxuXHRcdFx0XHRcdG9uZXJyb3IgIDogb25lcnJvclxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRpZiAobWV0aG9kID09PSAkbG9hZCAmJiB0eXBlb2Ygb3B0aW9uc1skZGF0YV0gPT09IHN0cl90eXBlKSB7XG5cdFx0XHRcdG9wdGlvbnNbJGRhdGFdID0gW29wdGlvbnNbJGRhdGFdXTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0dmFyIGRhdGEgID0gb3B0aW9uc1skZGF0YV0sXG5cdFx0XHRcdGlkICAgID0gdGhpcy5jcmVhdGVSZXF1ZXN0SUQoKTtcblx0XHRcdFxuXHRcdFx0aW5wdXQgPSBvcHRpb25zWyRpbnB1dF07XG5cdFx0XHRcblx0XHRcdGRlbGV0ZSBvcHRpb25zWyRkYXRhXTtcblx0XHRcdGRlbGV0ZSBvcHRpb25zWyRpbnB1dF07XG5cdFx0XHRcblx0XHRcdHRoaXNbJHJlcXVlc3RzXVtpZF0gPSBvcHRpb25zO1xuXHRcdFx0XG5cdFx0XHR0aGlzWyR3b3JrZXJdLnBvc3RNZXNzYWdlKHtcblx0XHRcdFx0aWQgICAgICAgOiBpZCxcblx0XHRcdFx0bWV0aG9kICAgOiBtZXRob2QsXG5cdFx0XHRcdGRhdGEgICAgIDogZGF0YSxcblx0XHRcdFx0aW5wdXQgICAgOiBpbnB1dFxuXHRcdFx0fSk7XG5cdFx0XG5cdFx0XHRyZXR1cm4gaWQ7XG5cdFx0fTtcblx0XHRTYW5kYm94W21ldGhvZF0gPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgc2FuZGJveCA9IG5ldyBTYW5kYm94KCk7XG5cdFx0XG5cdFx0XHRzYW5kYm94WyRvbnJlc3BvbnNlXSA9IHNhbmRib3hbJG9uZXJyb3JdID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRzYW5kYm94WyR0ZXJtaW5hdGVdKCk7XG5cdFx0XHRcdHNhbmRib3ggPSBudWxsO1xuXHRcdFx0fTtcblx0XHRcblx0XHRcdFNhbmRib3hbJHByb3RvdHlwZV1bbWV0aG9kXS5hcHBseShcblx0XHRcdFx0c2FuZGJveCxcblx0XHRcdFx0QXJyYXlbJHByb3RvdHlwZV0uc2xpY2VbJGNhbGxdKGFyZ3VtZW50cylcblx0XHRcdCk7XG5cdFx0XHRyZXR1cm4gU2FuZGJveDtcblx0XHR9O1xuXHR9LFxuXHRtZXRob2RzID0gWyRldmFsLCAkbG9hZCwgJGV4ZWNdLFxuXHRpID0gMzsgLy8gbWV0aG9kcy5sZW5ndGhcblx0XG5cdHdoaWxlIChpLS0pIHtcblx0XHRjcmVhdGVSZXF1ZXN0TWV0aG9kKG1ldGhvZHNbaV0pO1xuXHR9XG5cdFxuXHRwcm90b1skdGVybWluYXRlXSA9IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzWyRyZXF1ZXN0c10gPSB7fTtcblx0XHR0aGlzWyR3b3JrZXJdLm9ubWVzc2FnZSA9IG51bGw7XG5cdFx0dGhpc1skd29ya2VyXVskdGVybWluYXRlXSgpO1xuXHR9O1xuXHRcblx0cHJvdG8uYWJvcnQgPSBmdW5jdGlvbiAoaWQpIHtcblx0XHRkZWxldGUgdGhpc1skcmVxdWVzdHNdW2lkXTtcblx0fTtcblx0XG5cdHByb3RvLmNyZWF0ZVJlcXVlc3RJRCA9IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgaWQgPSBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKCk7XG5cdFx0aWYgKGlkIGluIHRoaXNbJHJlcXVlc3RzXSkge1xuXHRcdFx0cmV0dXJuIHRoaXMuY3JlYXRlUmVxdWVzdElEKCk7XG5cdFx0fVxuXHRcdHJldHVybiBpZDtcblx0fTtcblx0XG5cdGlmICh0eXBlb2YgZG9jICE9PSB1bmRlZl90eXBlKSB7XG5cdFx0dmFyIGxpbmtFbGVtcyA9IGRvYy5nZXRFbGVtZW50c0J5VGFnTmFtZShcImxpbmtcIik7XG5cdFx0aSA9IGxpbmtFbGVtcy5sZW5ndGg7XG5cdFx0d2hpbGUgKGktLSkge1xuXHRcdFx0aWYgKGxpbmtFbGVtc1tpXS5nZXRBdHRyaWJ1dGUoXCJyZWxcIikgPT09IFwianNhbmRib3hcIilcblx0XHRcdHtcblx0XHRcdFx0U2FuZGJveC51cmwgPSBsaW5rRWxlbXNbaV0uZ2V0QXR0cmlidXRlKFwiaHJlZlwiKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0dmFyIGRlZmF1bHRfd29ya2VyX2Z1bmN0aW9uID0gZnVuY3Rpb24gKHNlbGYsIGdsb2JhbEV2YWwpIHtcblx0XHRcInVzZSBzdHJpY3RcIjtcblx0XHRcblx0XHR2YXJcblx0XHRwb3N0TWVzc2FnZSAgID0gc2VsZi5wb3N0TWVzc2FnZSxcblx0XHRpbXBvcnRTY3JpcHRzID0gc2VsZi5pbXBvcnRTY3JpcHRzLFxuXHRcdFxuXHRcdG1lc3NhZ2VFdmVudFR5cGUgID0gXCJtZXNzYWdlXCIsXG5cdFx0XG5cdFx0bWVzc2FnZUhhbmRsZXIgPSBmdW5jdGlvbiAoZXZlbnQpIHtcblx0XHRcdHZhciByZXF1ZXN0ID0gZXZlbnQuZGF0YSxcblx0XHRcdHJlc3BvbnNlID0ge1xuXHRcdFx0fTtcblx0XHRcdFxuXHRcdFx0cmVzcG9uc2UuaWQgPSByZXF1ZXN0LmlkO1xuXHRcdFx0XG5cdFx0XHR2YXIgZGF0YSA9IHJlcXVlc3QuZGF0YTtcblx0XHRcdHNlbGYuaW5wdXQgPSByZXF1ZXN0LmlucHV0IHx8IHt9O1xuXHRcdFx0XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRzd2l0Y2ggKHJlcXVlc3QubWV0aG9kKSB7XG5cdFx0XHRcdFxuXHRcdFx0XHRjYXNlIFwiZXZhbFwiOiAvLyBKU0xpbnQgaGFzIHNvbWV0aGluZyBhZ2FpbnN0IGluZGVudGluZyBjYXNlc1xuXHRcdFx0XHRcdHJlc3BvbnNlLnJlc3VsdHMgPSBnbG9iYWxFdmFsKGRhdGEpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlIFwiZXhlY1wiOlxuXHRcdFx0XHRcdGltcG9ydFNjcmlwdHMoXCJkYXRhOmFwcGxpY2F0aW9uL2phdmFzY3JpcHQsXCIgK1xuXHRcdFx0XHRcdCAgICAgICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KGRhdGEpKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSBcImxvYWRcIjpcblx0XHRcdFx0XHRpbXBvcnRTY3JpcHRzLmFwcGx5KHNlbGYsIGRhdGEpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcblx0XHRcdFx0fVxuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRyZXNwb25zZS5jb2RlID0gZS5tZXNzYWdlO1xuXHRcdFx0XHRyZXNwb25zZS5lcnJvciA9IGUuc3RhY2s7XG5cdFx0XHRcdHJlc3BvbnNlLmxpbmUgPSBlLmxpbmVOdW1iZXI7XG5cdFx0XHRcdHJlc3BvbnNlLmZpbGVOYW1lID0gZS5maWxlTmFtZTtcblx0XHRcdH1cblx0XHRcdFxuXHRcdFx0ZGVsZXRlIHNlbGYuaW5wdXQ7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRkZWxldGUgc2VsZi5vbm1lc3NhZ2U7IC8vIGluIGNhc2UgdGhlIGNvZGUgZGVmaW5lZCBpdFxuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHRwb3N0TWVzc2FnZShyZXNwb25zZSk7XG5cdFx0fTtcblx0XHRcblx0XHRpZiAoc2VsZi5hZGRFdmVudExpc3RlbmVyKSB7XG5cdFx0XHRzZWxmLmFkZEV2ZW50TGlzdGVuZXIobWVzc2FnZUV2ZW50VHlwZSwgbWVzc2FnZUhhbmRsZXIsIGZhbHNlKTtcblx0XHR9IGVsc2UgaWYgKHNlbGYuYXR0YWNoRXZlbnQpIHsgLy8gZm9yIGZ1dHVyZSBjb21wYXRpYmlsaXR5IHdpdGggSUVcblx0XHRcdHNlbGYuYXR0YWNoRXZlbnQoXCJvblwiICsgbWVzc2FnZUV2ZW50VHlwZSwgbWVzc2FnZUhhbmRsZXIpO1xuXHRcdH1cblx0XHRcblx0XHRzZWxmLndpbmRvdyA9IHNlbGY7IC8vIHByb3ZpZGUgYSB3aW5kb3cgb2JqZWN0IGZvciBzY3JpcHRzXG5cdFx0c2VsZi5jb25zb2xlID0geyBsb2cgOiBmdW5jdGlvbihtZXNzYWdlKSB7IHBvc3RNZXNzYWdlKHsgXCJpZFwiIDogXCJsb2dcIiwgXCJtZXNzYWdlXCIgOiBtZXNzYWdlICB9KTsgfSB9O1xuXHRcdFxuXHRcdC8vIGRlcmVmZXJlbmNlIHVuc2FmZSBmdW5jdGlvbnNcblx0XHQvLyBzb21lIG1pZ2h0IG5vdCBiZSBkZXJlZmVyZW5jZWQ6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTUxMjQ2NFxuXHRcdHNlbGYuV29ya2VyICAgICAgICAgICAgICA9XG5cdFx0c2VsZi5hZGRFdmVudExpc3RlbmVyICAgID0gXG5cdFx0c2VsZi5yZW1vdmVFdmVudExpc3RlbmVyID1cblx0XHRzZWxmLmltcG9ydFNjcmlwdHMgICAgICAgPVxuXHRcdHNlbGYuWE1MSHR0cFJlcXVlc3QgICAgICA9XG5cdFx0c2VsZi5wb3N0TWVzc2FnZSAgICAgICAgID1cblx0XHQvL3NlbGYuZGlzcGF0Y2hFdmVudCAgICAgICA9XG5cdFx0Ly8gaW4gY2FzZSBJRSBpbXBsZW1lbnRzIHdlYiB3b3JrZXJzXG5cdFx0c2VsZi5hdHRhY2hFdmVudCAgICAgICAgID1cblx0XHRzZWxmLmRldGFjaEV2ZW50ICAgICAgICAgPVxuXHRcdHNlbGYuQWN0aXZlWE9iamVjdCAgICAgICA9XG5cdFx0XG5cdFx0dW5kZWZpbmVkO1xuXHRcblx0fTtcblxuXG5cdGlmICggISBTYW5kYm94LnVybCApIHtcblx0XHRTYW5kYm94LnVybCA9IHdpbmRvdy5VUkwuY3JlYXRlT2JqZWN0VVJMKG5ldyBCbG9iKFsnKCcrZGVmYXVsdF93b3JrZXJfZnVuY3Rpb24udG9TdHJpbmcoKSsnKHNlbGYsZXZhbCkpJ10sIHsndHlwZScgOiAndGV4dC9qYXZhc2NyaXB0J30pKTtcblx0fVxuXHRyZXR1cm4gU2FuZGJveDtcbn0oc2VsZikpLFxuU2FuZGJveCA9IEpTYW5kYm94O1xuXG5leHBvcnQgZGVmYXVsdCBKU2FuZGJveDtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTs7Ozs7Ozs7Ozs7O0FBWUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQXFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBbEVBO0FBQUE7QUFzRUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUF4SEE7QUFBQTtBQUNBO0FBMkhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBT0E7QUFBQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFaQTtBQWNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFDQTtBQU1BO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBelBBO0FBQ0E7QUEyUEEiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./js/jsandbox.js\n");

/***/ }),

/***/ "./js/lib/ClustalRunner.js":
/*!*********************************!*\
  !*** ./js/lib/ClustalRunner.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Service__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Service */ \"./js/lib/Service.js\");\n/* harmony import */ var _bean__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../bean */ \"./js/bean.js\");\n/** @fileOverview   Classes for reading data from the Clustal tool\n */\n\n\n\n/** Default class constructor\n *  @class      Service class that will retrieve data from Clustal for given sequences\n *  @param      {String} endpointURL    Endpoint URL for this service\n *  @extends    MASCP.Service\n */\nconst ClustalRunner = _Service__WEBPACK_IMPORTED_MODULE_0__[\"default\"].buildService(function (data) {\n    this._raw_data = data;\n    if (data && typeof data == 'string') {\n        this._raw_data = { 'data': { 'sequences': this.getSequences(), 'alignment': this.getAlignment() } };\n    }\n    return this;\n});\n\nClustalRunner.SERVICE_URL = 'http://www.ebi.ac.uk/Tools/services/rest/clustalw2/run/';\n\nClustalRunner.hash = function (str) {\n    var hash = 0;\n    for (i = 0; i < str.length; i++) {\n        char = str.charCodeAt(i);\n        hash = char + (hash << 6) + (hash << 16) - hash;\n    }\n    return hash;\n};\n\nClustalRunner.prototype.requestData = function () {\n    var sequences = [].concat(this.sequences || []);\n    var self = this;\n    this.agi = ClustalRunner.hash(this.sequences.join(',')) + '';\n    if (!ClustalRunner.SERVICE_URL.match(/ebi/)) {\n        return {\n            type: \"POST\",\n            dataType: \"json\",\n            api_key: MASCP.GATOR_CLIENT_ID,\n            data: {\n                'sequences': sequences.join(\",\")\n            }\n        };\n    }\n    _bean__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fire(self, 'running');\n    if (this.job_id) {\n        return {\n            type: \"GET\",\n            dataType: \"txt\",\n            url: 'http://www.ebi.ac.uk/Tools/services/rest/clustalw2/status/' + this.job_id\n        };\n    }\n    if (this.result_id) {\n        return {\n            type: \"GET\",\n            dataType: \"txt\",\n            url: 'http://www.ebi.ac.uk/Tools/services/rest/clustalw2/result/' + this.result_id + '/aln-clustalw'\n        };\n    }\n\n    for (var i = 0; i < sequences.length; i++) {\n        sequences[i] = \">seq\" + i + \"\\n\" + sequences[i];\n    }\n    return {\n        type: \"POST\",\n        dataType: \"txt\",\n        data: { 'sequence': escape(sequences.join(\"\\n\") + \"\\n\"),\n            'email': 'joshi%40sund.ku.dk'\n        }\n    };\n};\n\n(function (serv) {\n    var defaultDataReceived = serv.prototype._dataReceived;\n\n    serv.prototype._dataReceived = function (data, status) {\n        if (data === null) {\n            return defaultDataReceived.call(this, null, status);\n        }\n        if (typeof data == \"object\") {\n            if (data.status && data.status == \"RUNNING\") {\n                var self = this;\n                _bean__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fire(self, \"running\");\n                setTimeout(function () {\n                    self.retrieve(self.agi);\n                }, 5000);\n                console.log(\"Got back running status\");\n                return;\n            }\n            return defaultDataReceived.call(this, data, status);\n        }\n\n        if (typeof data == \"string\" && data.match(/^clustalw/)) {\n            this.job_id = data;\n            this.retrieve(this.agi);\n            return;\n        }\n        if (data.match(/FINISHED/)) {\n            this.result_id = this.job_id;\n            this.job_id = null;\n            var self = this;\n            setTimeout(function () {\n                self.retrieve(self.agi);\n            }, 500);\n            return;\n        }\n        if (data.match(/RUNNING/)) {\n            var self = this;\n            setTimeout(function () {\n                self.retrieve(self.agi);\n            }, 500);\n            return;\n        }\n\n        return defaultDataReceived.call(this, data, status);\n    };\n})(ClustalRunner);\n\n(function () {\n    var normalise_insertions = function normalise_insertions(inserts) {\n        var pos;\n        var positions = [];\n        var result_data = {};\n        for (pos in inserts) {\n            if (inserts.hasOwnProperty(pos) && parseInt(pos) >= -1) {\n                positions.push(parseInt(pos));\n            }\n        }\n        positions = positions.sort(function sortfunction(a, b) {\n            return a - b;\n        });\n\n        // From highest to lowest position, loop through and\n        // subtract the lengths of previous subtratctions from\n        // the final position value.\n\n        for (var i = positions.length - 1; i >= 0; i--) {\n            var j = i - 1;\n            pos = parseInt(positions[i]);\n            var value = inserts[pos];\n            while (j >= 0) {\n                pos -= inserts[positions[j]].length;\n                j--;\n            }\n            if (!value.match(/^\\s+$/)) {\n                result_data[pos + 1] = value + (result_data[pos + 1] || '');\n            }\n        }\n        //    delete result_data[0];\n        return result_data;\n    };\n\n    var splice_char = function splice_char(seqs, index, insertions) {\n        for (var i = 0; i < seqs.length; i++) {\n            var seq = seqs[i].toString();\n            if (seq.charAt(index) != '-') {\n                if (!insertions[i]) {\n                    insertions[i] = {};\n                    insertions[i][-1] = '';\n                }\n                insertions[i][index - 1] = seq.charAt(index);\n                if (insertions[i][index] && insertions[i][index].match(/\\w/)) {\n                    insertions[i][index - 1] += insertions[i][index];\n                    delete insertions[i][index];\n                }\n            } else {\n                if (insertions[i]) {\n                    insertions[i][index - 1] = ' ';\n                    if ((insertions[i][index] || '').match(/^\\s+$/)) {\n                        insertions[i][index - 1] += insertions[i][index];\n                        delete insertions[i][index];\n                    }\n                }\n            }\n            seqs[i] = seq.slice(0, index) + seq.slice(index + 1);\n        }\n    };\n\n    ClustalRunner.Result.prototype.alignToSequence = function (seq_index) {\n        if (!this._orig_raw_data) {\n            this._orig_raw_data = JSON.stringify(this._raw_data);\n        } else {\n            this._raw_data = JSON.parse(this._orig_raw_data);\n        }\n        var seqs = this._raw_data.data.sequences.concat([this._raw_data.data.alignment]);\n        var insertions = [];\n        var aligning_seq = seqs[seq_index],\n            i = aligning_seq.length - 1;\n        for (i; i >= 0; i--) {\n            if (aligning_seq.charAt(i) == '-') {\n                splice_char(seqs, i, insertions);\n            }\n        }\n        for (i = 0; i < seqs.length; i++) {\n            if (insertions[i] && i != seq_index) {\n                insertions[i] = normalise_insertions(insertions[i]);\n                var seq = seqs[i];\n                seqs[i] = { 'sequence': seq, 'insertions': insertions[i] };\n                seqs[i].toString = function () {\n                    return this.sequence;\n                };\n            }\n        }\n        this._raw_data.data.alignment = seqs.pop();\n        this._raw_data.data.sequences = seqs;\n    };\n\n    /*\n    \n    Test suite for calculating positions\n    \n    var aligner = 0;\n    foo = new ClustalRunner.Result();\n    foo._raw_data = {\"data\" : { \"alignment\" : \"****************\" , \"sequences\" : [ \"----12345678----\", \"XXXXXXXXXXXXXXXX\", \"ABCDABC---ABCDAB\" ] }};\n    foo.alignToSequence(aligner);\n    console.log(foo.getSequences());\n    console.log(foo.calculatePositionForSequence(0,1));\n    console.log(foo.calculatePositionForSequence(0,2));\n    console.log(foo.calculatePositionForSequence(0,3));\n    console.log(foo.calculatePositionForSequence(0,4));\n    console.log(foo.calculatePositionForSequence(0,5));\n    console.log(foo.calculatePositionForSequence(0,6));\n    console.log(foo.calculatePositionForSequence(0,7));\n    console.log(foo.calculatePositionForSequence(0,8));\n    \n    */\n    ClustalRunner.Result.prototype.calculatePositionForSequence = function (idx, pos) {\n        var inserts = this._raw_data.data.sequences[idx].insertions || {};\n        var result = pos;\n        var actual_position = 0;\n        var seq = this._raw_data.data.sequences[idx].toString();\n        for (var i = 0; i < seq.length; i++) {\n            if (inserts[i]) {\n                actual_position += inserts[i].length;\n            }\n            actual_position += 1;\n            if (seq.charAt(i) == '-') {\n                actual_position -= 1;\n            }\n            if (pos <= actual_position) {\n                if (pos == actual_position) {\n                    return i + 1;\n                } else {\n                    if (i == 0) {\n                        i = 1;\n                    }\n                    return -1 * i;\n                }\n            }\n        }\n        return -1 * seq.length;\n    };\n\n    ClustalRunner.Result.prototype.calculateSequencePositionFromPosition = function (idx, pos) {\n        var inserts = this._raw_data.data.sequences[idx].insertions || {};\n        var result = pos;\n        var actual_position = 0;\n        var seq = this._raw_data.data.sequences[idx].toString();\n        for (var i = 0; i < pos; i++) {\n            if (inserts[i]) {\n                actual_position += inserts[i].length;\n            }\n            actual_position += 1;\n            if (seq.charAt(i) == '-') {\n                actual_position -= 1;\n            }\n        }\n        if (actual_position == 0) {\n            actual_position += 1;\n        }\n        return actual_position;\n    };\n})();\n//1265 (P)\n\nClustalRunner.prototype.setupSequenceRenderer = function (renderer) {\n    var self = this;\n\n    renderer.sequences = self.sequences;\n    renderer.addAxisScale('clustal', function (pos, layer, inverse) {\n        let idx = null;\n        let seq_identifiers = self.sequences.map(function (seq) {\n            return seq.agi;\n        });\n        while (seq_identifiers.length > 0) {\n            idx = idx || 0;\n            let acc = seq_identifiers.shift();\n            if (layer.scales.has(acc)) {\n                break;\n            }\n            idx++;\n            if (seq_identifiers.length === 0) {\n                idx = null;\n            }\n        }\n        if (layer.name === 'primarySequence') {\n            idx = self.result.aligned_idx;\n        }\n        if (idx === null) {\n            return pos;\n        }\n        if (inverse) {\n            return self.result.calculateSequencePositionFromPosition(idx, pos);\n        }\n\n        return self.result.calculatePositionForSequence(idx, pos);\n    });\n\n    var rendered_bits = [];\n    var controller_name = 'isoforms';\n    var group_name = 'isoforms';\n\n    var draw_discontinuity = function draw_discontinuity(canvas, size) {\n        var top = -3;\n        var left = -2;\n        var group = canvas.group();\n        var line;\n        line = canvas.line(left + 1, top + 4, left + 3, top + 1);\n        line.setAttribute('stroke', '#fcc');\n        line.setAttribute('stroke-width', '10');\n        group.push(line);\n        line = canvas.line(left + 1, top + 6, left + 3, top + 3);\n        line.setAttribute('stroke', '#fcc');\n        line.setAttribute('stroke-width', '10');\n        group.push(line);\n        line = canvas.line(left + 1, top + 4, left + 3, top + 3);\n        line.setAttribute('stroke', '#fcc');\n        line.setAttribute('stroke-width', '5');\n        group.push(line);\n        line = canvas.line(left + 1, top + 5.3, left + 1, top + 5.8);\n        line.setAttribute('stroke', '#fcc');\n        line.setAttribute('stroke-width', '10');\n        group.push(line);\n        line = canvas.line(left + 1, top + 5.9, left + 1.5, top + 5.9);\n        line.setAttribute('stroke', '#fcc');\n        line.setAttribute('stroke-width', '10');\n        group.push(line);\n        var circle = canvas.circle(left + 2.8, top + 1.75, 1);\n        circle.setAttribute('fill', '#fff');\n        circle.setAttribute('stroke', '#ccc');\n        circle.setAttribute('stroke-width', '10');\n        group.push(circle);\n        var minus = canvas.text(left + 2.25, top + 2.25, (size || '÷') + \"\");\n        minus.setAttribute('fill', '#ccc');\n        minus.setAttribute('font-size', 75);\n        group.push(minus);\n        canvas.firstChild.nextSibling.appendChild(group);\n        return group;\n    };\n\n    var check_values = function check_values(seq, idx, seqs) {\n        var positives = 0;\n        var aa = seq.toString().charAt(idx);\n        for (var i = 1; i < seqs.length; i++) {\n            if (seqs[i].toString().charAt(idx) == aa) {\n                positives += 1;\n            }\n        }\n        return positives / (seqs.length - 1);\n    };\n\n    var redraw_alignments = function redraw_alignments(sequence_index) {\n        var result = self.result;\n\n        while (rendered_bits.length > 0) {\n            var bit = rendered_bits.shift();\n            renderer.remove(bit.layer, bit);\n        }\n        result.alignToSequence(sequence_index || 0);\n\n        var aligned = result.getSequences();\n\n        if (!renderer.sequence) {\n            renderer.setSequence(aligned[sequence_index])(function () {\n                renderer.sequences = self.sequences;\n                MASCP.registerGroup(group_name, 'Aligned');\n                MASCP.registerLayer(controller_name, { 'fullname': 'Conservation', 'color': '#000000' });\n                if (renderer.trackOrder.indexOf(controller_name) < 0) {\n                    renderer.trackOrder = renderer.trackOrder.concat([controller_name]);\n                }\n                renderer.showLayer(controller_name);\n                renderer.createGroupController(controller_name, group_name);\n                redraw_alignments(sequence_index);\n            });\n            return;\n        } else {\n            renderer.sequence = aligned[sequence_index];\n            renderer.redrawAxis();\n        }\n        var alignments = result.getAlignment().split('');\n        rendered_bits = rendered_bits.concat(renderer.renderTextTrack(controller_name, result.getAlignment().replace(/ /g, ' ')));\n        rendered_bits.slice(-1)[0].setAttribute('data-spaces', 'true');\n        rendered_bits.slice(-1)[0].layer = controller_name;\n        var idxs = [\"*\", \":\", \".\", \" \"].reverse();\n        for (var i = 0; i < alignments.length; i++) {\n            rendered_bits.push(renderer.getAA(i + 1, controller_name).addBoxOverlay(controller_name, 1, idxs.indexOf(alignments[i]) / 4, { \"merge\": true }));\n            rendered_bits.slice(-1)[0].layer = controller_name;\n        }\n        for (var i = 0; i < aligned.length; i++) {\n            var layname = self.sequences[i].agi.toUpperCase() || \"missing\" + i;\n            var lay = MASCP.registerLayer(layname, { 'fullname': self.sequences[i].name || layname.toUpperCase(), 'group': group_name, 'color': '#ff0000', 'accession': self.sequences[i].agi });\n            lay.scales.clear();\n            lay.scales.add(self.sequences[i].agi);\n\n            lay.fullname = self.sequences[i].name || layname.toUpperCase();\n            var text_array = renderer.renderTextTrack(layname, aligned[i].toString());\n            rendered_bits = rendered_bits.concat(text_array);\n            rendered_bits.slice(-1)[0].layer = layname;\n            if (renderer.trackOrder.indexOf(layname.toUpperCase()) < 0) {\n                renderer.trackOrder = renderer.trackOrder.concat([group_name]);\n            }\n            var name = \"Isoform \" + (i + 1);\n            if (aligned[i].insertions) {\n                for (var insert in aligned[i].insertions) {\n                    var insertions = aligned[i].insertions;\n                    if (insert == 0 && insertions[insert] == \"\") {\n                        continue;\n                    }\n                    if (insertions[insert].length < 1) {\n                        continue;\n                    }\n                    var size = insertions[insert].length;\n                    if (insert == 0) {\n                        insert = 1;\n                    }\n                    var content = draw_discontinuity(renderer._canvas, size);\n                    content.setAttribute('fill', '#ffff00');\n                    var an_anno = renderer.getAA(insert, controller_name).addToLayer(layname, { 'content': content, //'+'+insertions[insert].length,\n                        'bare_element': true,\n                        'height': 10,\n                        'offset': -5,\n                        'no_tracer': true\n                    })[1];\n                    an_anno.container.setAttribute('height', '300');\n                    an_anno.container.setAttribute('viewBox', '-50 -100 200 300');\n                    rendered_bits.push(an_anno);\n                    rendered_bits.slice(-1)[0].layer = layname;\n                }\n            }\n        }\n        renderer.zoom = 1;\n        renderer.showGroup(group_name);\n        renderer.refresh();\n    };\n\n    this.bind('resultReceived', function () {\n        var self = this;\n        redraw_alignments(0);\n        self.result.aligned_idx = 0;\n        var accs = [];\n        self.sequences.forEach(function (seq) {\n            accs.push(seq.agi.toUpperCase());\n        });\n        var current_order = [];\n        renderer.bind('orderChanged', function (order) {\n            if (self.result) {\n                var new_order = order.slice(order.indexOf(controller_name) + 1, order.length).filter(function (track) {\n                    return accs.indexOf(track) >= 0;\n                });\n                if (new_order.join(',') == current_order.join(',')) {\n                    return;\n                }\n                current_order = new_order;\n                self.result.aligned_idx = accs.indexOf(current_order[0]);\n\n                redraw_alignments(self.result.aligned_idx);\n                renderer.refreshScale();\n            }\n        });\n    });\n};\n\nClustalRunner.Result.prototype.getSequences = function () {\n    if (this._raw_data && this._raw_data.data && this._raw_data.data.sequences) {\n        return [].concat(this._raw_data.data.sequences);\n    }\n    var bits = this._raw_data.match(/seq\\d+(.*)/g);\n    var results = [];\n    for (var i = 0; i < bits.length; i++) {\n        var seqbits = bits[i].match(/seq(\\d+)\\s+(.*)/);\n        if (!results[seqbits[1]]) {\n            results[seqbits[1]] = '';\n        }\n        results[seqbits[1]] += seqbits[2];\n    }\n    return results;\n};\n\nClustalRunner.Result.prototype.getAlignment = function () {\n    if (this._raw_data && this._raw_data.data && this._raw_data.data.alignment) {\n        return this._raw_data.data.alignment.toString();\n    }\n    this._text_data = this._raw_data;\n    var re = / {16}(.*)/g;\n    var result = \"\";\n    var match = re.exec(this._raw_data);\n    while (match !== null) {\n        result += match[1];\n        match = re.exec(this._raw_data);\n    }\n\n    return result;\n};\n\nlet onlyUnique = (val, idx, arr) => arr.indexOf(val) === idx;\n\nlet clustal_emulator = sequences => {\n    if (sequences.length == 0) {\n        return { data: { sequences: [], alignment: \"\" } };\n    }\n    let all_aas = sequences.map(seq => seq.split(''));\n    let alignment = all_aas[0].map((aa, pos) => all_aas.map(aas => aas[pos]).filter(onlyUnique).length == 1 ? '*' : ':').join('');\n    return { data: { sequences: sequences, alignment: alignment } };\n};\n\nClustalRunner.EmulatedClustalRunner = function (renderer) {\n    let runner = new ClustalRunner();\n    runner.retrieve = function () {\n        let datablock = clustal_emulator(this.sequences || []);\n        this._dataReceived(datablock);\n        this.sequences = this.sequences.map((seq, idx) => {\n            return { agi: 'seq' + idx, toString: () => seq };\n        });\n        this.gotResult();\n        this.requestComplete();\n    };\n    if (renderer) {\n        runner.registerSequenceRenderer(renderer);\n    }\n    return runner;\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (ClustalRunner);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9qcy9saWIvQ2x1c3RhbFJ1bm5lci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9qcy9saWIvQ2x1c3RhbFJ1bm5lci5qcz80ZGViIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKiBAZmlsZU92ZXJ2aWV3ICAgQ2xhc3NlcyBmb3IgcmVhZGluZyBkYXRhIGZyb20gdGhlIENsdXN0YWwgdG9vbFxuICovXG5pbXBvcnQgU2VydmljZSBmcm9tICcuL1NlcnZpY2UnO1xuaW1wb3J0IGJlYW4gZnJvbSAnLi4vYmVhbic7XG5cblxuLyoqIERlZmF1bHQgY2xhc3MgY29uc3RydWN0b3JcbiAqICBAY2xhc3MgICAgICBTZXJ2aWNlIGNsYXNzIHRoYXQgd2lsbCByZXRyaWV2ZSBkYXRhIGZyb20gQ2x1c3RhbCBmb3IgZ2l2ZW4gc2VxdWVuY2VzXG4gKiAgQHBhcmFtICAgICAge1N0cmluZ30gZW5kcG9pbnRVUkwgICAgRW5kcG9pbnQgVVJMIGZvciB0aGlzIHNlcnZpY2VcbiAqICBAZXh0ZW5kcyAgICBNQVNDUC5TZXJ2aWNlXG4gKi9cbmNvbnN0IENsdXN0YWxSdW5uZXIgPSBTZXJ2aWNlLmJ1aWxkU2VydmljZShmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9yYXdfZGF0YSA9IGRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YSAmJiB0eXBlb2YgZGF0YSA9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Jhd19kYXRhID0geyAnZGF0YScgOiB7ICdzZXF1ZW5jZXMnIDogdGhpcy5nZXRTZXF1ZW5jZXMoKSwgJ2FsaWdubWVudCcgOiB0aGlzLmdldEFsaWdubWVudCgpIH0gfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuQ2x1c3RhbFJ1bm5lci5TRVJWSUNFX1VSTCA9ICdodHRwOi8vd3d3LmViaS5hYy51ay9Ub29scy9zZXJ2aWNlcy9yZXN0L2NsdXN0YWx3Mi9ydW4vJztcblxuQ2x1c3RhbFJ1bm5lci5oYXNoID0gZnVuY3Rpb24oc3RyKXtcbiAgICB2YXIgaGFzaCA9IDA7XG4gICAgZm9yIChpID0gMDsgaSA8IHN0ci5sZW5ndGg7IGkrKykge1xuICAgICAgICBjaGFyID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGhhc2ggPSBjaGFyICsgKGhhc2ggPDwgNikgKyAoaGFzaCA8PCAxNikgLSBoYXNoO1xuICAgIH1cbiAgICByZXR1cm4gaGFzaDtcbn07XG5cbkNsdXN0YWxSdW5uZXIucHJvdG90eXBlLnJlcXVlc3REYXRhID0gZnVuY3Rpb24oKVxue1xuICAgIHZhciBzZXF1ZW5jZXMgPSBbXS5jb25jYXQodGhpcy5zZXF1ZW5jZXMgfHwgW10pO1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLmFnaSA9IENsdXN0YWxSdW5uZXIuaGFzaCh0aGlzLnNlcXVlbmNlcy5qb2luKCcsJykpKycnO1xuICAgIGlmICghIENsdXN0YWxSdW5uZXIuU0VSVklDRV9VUkwubWF0Y2goL2ViaS8pKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcIlBPU1RcIixcbiAgICAgICAgICAgIGRhdGFUeXBlOiBcImpzb25cIixcbiAgICAgICAgICAgIGFwaV9rZXk6IE1BU0NQLkdBVE9SX0NMSUVOVF9JRCxcbiAgICAgICAgICAgIGRhdGEgOiB7XG4gICAgICAgICAgICAgICAgJ3NlcXVlbmNlcycgOiBzZXF1ZW5jZXMuam9pbihcIixcIilcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgYmVhbi5maXJlKHNlbGYsJ3J1bm5pbmcnKTtcbiAgICBpZiAodGhpcy5qb2JfaWQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwiR0VUXCIsXG4gICAgICAgICAgICBkYXRhVHlwZTogXCJ0eHRcIixcbiAgICAgICAgICAgIHVybDogJ2h0dHA6Ly93d3cuZWJpLmFjLnVrL1Rvb2xzL3NlcnZpY2VzL3Jlc3QvY2x1c3RhbHcyL3N0YXR1cy8nK3RoaXMuam9iX2lkXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmICh0aGlzLnJlc3VsdF9pZCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJHRVRcIixcbiAgICAgICAgICAgIGRhdGFUeXBlOiBcInR4dFwiLFxuICAgICAgICAgICAgdXJsOiAnaHR0cDovL3d3dy5lYmkuYWMudWsvVG9vbHMvc2VydmljZXMvcmVzdC9jbHVzdGFsdzIvcmVzdWx0LycrdGhpcy5yZXN1bHRfaWQrJy9hbG4tY2x1c3RhbHcnXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZXF1ZW5jZXMubGVuZ3RoOyBpKysgKSB7XG4gICAgICAgIHNlcXVlbmNlc1tpXSA9IFwiPnNlcVwiK2krXCJcXG5cIitzZXF1ZW5jZXNbaV07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IFwiUE9TVFwiLFxuICAgICAgICBkYXRhVHlwZTogXCJ0eHRcIixcbiAgICAgICAgZGF0YTogeyAnc2VxdWVuY2UnIDogZXNjYXBlKHNlcXVlbmNlcy5qb2luKFwiXFxuXCIpK1wiXFxuXCIpLFxuICAgICAgICAgICAgICAgICdlbWFpbCcgICAgOiAnam9zaGklNDBzdW5kLmt1LmRrJ1xuICAgICAgICB9XG4gICAgfTtcbn07XG5cbihmdW5jdGlvbihzZXJ2KSB7XG4gICAgdmFyIGRlZmF1bHREYXRhUmVjZWl2ZWQgPSBzZXJ2LnByb3RvdHlwZS5fZGF0YVJlY2VpdmVkO1xuXG4gICAgc2Vydi5wcm90b3R5cGUuX2RhdGFSZWNlaXZlZCA9IGZ1bmN0aW9uKGRhdGEsc3RhdHVzKVxuICAgIHtcbiAgICAgICAgaWYgKGRhdGEgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWZhdWx0RGF0YVJlY2VpdmVkLmNhbGwodGhpcyxudWxsLHN0YXR1cyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIGlmIChkYXRhLnN0YXR1cyAmJiBkYXRhLnN0YXR1cyA9PSBcIlJVTk5JTkdcIikge1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICBiZWFuLmZpcmUoc2VsZixcInJ1bm5pbmdcIik7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5yZXRyaWV2ZShzZWxmLmFnaSk7XG4gICAgICAgICAgICAgICAgfSw1MDAwKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkdvdCBiYWNrIHJ1bm5pbmcgc3RhdHVzXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkZWZhdWx0RGF0YVJlY2VpdmVkLmNhbGwodGhpcyxkYXRhLHN0YXR1cyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT0gXCJzdHJpbmdcIiAmJiBkYXRhLm1hdGNoKC9eY2x1c3RhbHcvKSkge1xuICAgICAgICAgICAgdGhpcy5qb2JfaWQgPSBkYXRhO1xuICAgICAgICAgICAgdGhpcy5yZXRyaWV2ZSh0aGlzLmFnaSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEubWF0Y2goL0ZJTklTSEVELykpIHtcbiAgICAgICAgICAgIHRoaXMucmVzdWx0X2lkID0gdGhpcy5qb2JfaWQ7XG4gICAgICAgICAgICB0aGlzLmpvYl9pZCA9IG51bGw7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHNlbGYucmV0cmlldmUoc2VsZi5hZ2kpO1xuICAgICAgICAgICAgfSw1MDApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLm1hdGNoKC9SVU5OSU5HLykpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5yZXRyaWV2ZShzZWxmLmFnaSk7XG4gICAgICAgICAgICB9LDUwMCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZGVmYXVsdERhdGFSZWNlaXZlZC5jYWxsKHRoaXMsZGF0YSxzdGF0dXMpO1xuICAgIH07XG5cbn0pKENsdXN0YWxSdW5uZXIpO1xuXG4oZnVuY3Rpb24oKSB7XG52YXIgbm9ybWFsaXNlX2luc2VydGlvbnMgPSBmdW5jdGlvbihpbnNlcnRzKSB7XG4gICAgdmFyIHBvcztcbiAgICB2YXIgcG9zaXRpb25zID0gW107XG4gICAgdmFyIHJlc3VsdF9kYXRhID0ge307XG4gICAgZm9yIChwb3MgaW4gaW5zZXJ0cykge1xuICAgICAgICBpZiAoaW5zZXJ0cy5oYXNPd25Qcm9wZXJ0eShwb3MpICYmIHBhcnNlSW50KHBvcykgPj0gLTEpIHtcbiAgICAgICAgICAgIHBvc2l0aW9ucy5wdXNoKHBhcnNlSW50KHBvcykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHBvc2l0aW9ucyA9IHBvc2l0aW9ucy5zb3J0KGZ1bmN0aW9uIHNvcnRmdW5jdGlvbihhLCBiKXtcbiAgICAgICAgcmV0dXJuIChhIC0gYik7XG4gICAgfSk7XG5cbiAgICAvLyBGcm9tIGhpZ2hlc3QgdG8gbG93ZXN0IHBvc2l0aW9uLCBsb29wIHRocm91Z2ggYW5kXG4gICAgLy8gc3VidHJhY3QgdGhlIGxlbmd0aHMgb2YgcHJldmlvdXMgc3VidHJhdGN0aW9ucyBmcm9tXG4gICAgLy8gdGhlIGZpbmFsIHBvc2l0aW9uIHZhbHVlLlxuXG4gICAgZm9yICh2YXIgaSA9IHBvc2l0aW9ucy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB2YXIgaiA9IGkgLSAxO1xuICAgICAgICBwb3MgPSBwYXJzZUludChwb3NpdGlvbnNbaV0pO1xuICAgICAgICB2YXIgdmFsdWUgPSBpbnNlcnRzW3Bvc107XG4gICAgICAgIHdoaWxlIChqID49IDApIHtcbiAgICAgICAgICAgIHBvcyAtPSBpbnNlcnRzW3Bvc2l0aW9uc1tqXV0ubGVuZ3RoO1xuICAgICAgICAgICAgai0tO1xuICAgICAgICB9XG4gICAgICAgIGlmICghIHZhbHVlLm1hdGNoKC9eXFxzKyQvKSkge1xuICAgICAgICAgICAgcmVzdWx0X2RhdGFbcG9zKzFdID0gdmFsdWUgKyAocmVzdWx0X2RhdGFbcG9zKzFdIHx8ICcnKTtcbiAgICAgICAgfVxuICAgIH1cbi8vICAgIGRlbGV0ZSByZXN1bHRfZGF0YVswXTtcbiAgICByZXR1cm4gcmVzdWx0X2RhdGE7XG59O1xuXG52YXIgc3BsaWNlX2NoYXIgPSBmdW5jdGlvbihzZXFzLGluZGV4LGluc2VydGlvbnMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlcXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHNlcSA9IHNlcXNbaV0udG9TdHJpbmcoKTtcbiAgICAgICAgaWYgKHNlcS5jaGFyQXQoaW5kZXgpICE9ICctJykge1xuICAgICAgICAgICAgaWYgKCAhIGluc2VydGlvbnNbaV0gKSB7XG4gICAgICAgICAgICAgICAgaW5zZXJ0aW9uc1tpXSA9IHt9O1xuICAgICAgICAgICAgICAgIGluc2VydGlvbnNbaV1bLTFdID0gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbnNlcnRpb25zW2ldW2luZGV4IC0gMV0gPSBzZXEuY2hhckF0KGluZGV4KTtcbiAgICAgICAgICAgIGlmIChpbnNlcnRpb25zW2ldW2luZGV4XSAmJiBpbnNlcnRpb25zW2ldW2luZGV4XS5tYXRjaCgvXFx3LykpIHtcbiAgICAgICAgICAgICAgICBpbnNlcnRpb25zW2ldW2luZGV4LTFdICs9IGluc2VydGlvbnNbaV1baW5kZXhdO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBpbnNlcnRpb25zW2ldW2luZGV4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICggaW5zZXJ0aW9uc1tpXSApIHtcbiAgICAgICAgICAgICAgICBpbnNlcnRpb25zW2ldW2luZGV4IC0gMV0gPSAnICc7XG4gICAgICAgICAgICAgICAgaWYgKChpbnNlcnRpb25zW2ldW2luZGV4XSB8fCAnJykubWF0Y2goL15cXHMrJC8pKSB7XG4gICAgICAgICAgICAgICAgICAgIGluc2VydGlvbnNbaV1baW5kZXgtMV0gKz0gaW5zZXJ0aW9uc1tpXVtpbmRleF07XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBpbnNlcnRpb25zW2ldW2luZGV4XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2Vxc1tpXSA9IHNlcS5zbGljZSgwLGluZGV4KSArIHNlcS5zbGljZShpbmRleCsxKTtcbiAgICB9XG59XG5cbkNsdXN0YWxSdW5uZXIuUmVzdWx0LnByb3RvdHlwZS5hbGlnblRvU2VxdWVuY2UgPSBmdW5jdGlvbihzZXFfaW5kZXgpIHtcbiAgICBpZiAoICEgdGhpcy5fb3JpZ19yYXdfZGF0YSApIHtcbiAgICAgICAgdGhpcy5fb3JpZ19yYXdfZGF0YSA9IEpTT04uc3RyaW5naWZ5KHRoaXMuX3Jhd19kYXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9yYXdfZGF0YSA9IEpTT04ucGFyc2UodGhpcy5fb3JpZ19yYXdfZGF0YSk7XG4gICAgfVxuICAgIHZhciBzZXFzID0gdGhpcy5fcmF3X2RhdGEuZGF0YS5zZXF1ZW5jZXMuY29uY2F0KFt0aGlzLl9yYXdfZGF0YS5kYXRhLmFsaWdubWVudF0pO1xuICAgIHZhciBpbnNlcnRpb25zID0gW107XG4gICAgdmFyIGFsaWduaW5nX3NlcSA9IHNlcXNbc2VxX2luZGV4XSwgaSA9IGFsaWduaW5nX3NlcS5sZW5ndGggLSAxO1xuICAgIGZvciAoaTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgaWYgKGFsaWduaW5nX3NlcS5jaGFyQXQoaSkgPT0gJy0nKSB7XG4gICAgICAgICAgICBzcGxpY2VfY2hhcihzZXFzLGksaW5zZXJ0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IHNlcXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGluc2VydGlvbnNbaV0gJiYgaSAhPSBzZXFfaW5kZXgpIHtcbiAgICAgICAgICAgIGluc2VydGlvbnNbaV0gPSBub3JtYWxpc2VfaW5zZXJ0aW9ucyhpbnNlcnRpb25zW2ldKTtcbiAgICAgICAgICAgIHZhciBzZXEgPSBzZXFzW2ldO1xuICAgICAgICAgICAgc2Vxc1tpXSA9IHsgJ3NlcXVlbmNlJyA6IHNlcSwgJ2luc2VydGlvbnMnIDogaW5zZXJ0aW9uc1tpXSB9O1xuICAgICAgICAgICAgc2Vxc1tpXS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNlcXVlbmNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9yYXdfZGF0YS5kYXRhLmFsaWdubWVudCA9IHNlcXMucG9wKCk7XG4gICAgdGhpcy5fcmF3X2RhdGEuZGF0YS5zZXF1ZW5jZXMgPSBzZXFzO1xufTtcblxuLypcblxuVGVzdCBzdWl0ZSBmb3IgY2FsY3VsYXRpbmcgcG9zaXRpb25zXG5cbnZhciBhbGlnbmVyID0gMDtcbmZvbyA9IG5ldyBDbHVzdGFsUnVubmVyLlJlc3VsdCgpO1xuZm9vLl9yYXdfZGF0YSA9IHtcImRhdGFcIiA6IHsgXCJhbGlnbm1lbnRcIiA6IFwiKioqKioqKioqKioqKioqKlwiICwgXCJzZXF1ZW5jZXNcIiA6IFsgXCItLS0tMTIzNDU2NzgtLS0tXCIsIFwiWFhYWFhYWFhYWFhYWFhYWFwiLCBcIkFCQ0RBQkMtLS1BQkNEQUJcIiBdIH19O1xuZm9vLmFsaWduVG9TZXF1ZW5jZShhbGlnbmVyKTtcbmNvbnNvbGUubG9nKGZvby5nZXRTZXF1ZW5jZXMoKSk7XG5jb25zb2xlLmxvZyhmb28uY2FsY3VsYXRlUG9zaXRpb25Gb3JTZXF1ZW5jZSgwLDEpKTtcbmNvbnNvbGUubG9nKGZvby5jYWxjdWxhdGVQb3NpdGlvbkZvclNlcXVlbmNlKDAsMikpO1xuY29uc29sZS5sb2coZm9vLmNhbGN1bGF0ZVBvc2l0aW9uRm9yU2VxdWVuY2UoMCwzKSk7XG5jb25zb2xlLmxvZyhmb28uY2FsY3VsYXRlUG9zaXRpb25Gb3JTZXF1ZW5jZSgwLDQpKTtcbmNvbnNvbGUubG9nKGZvby5jYWxjdWxhdGVQb3NpdGlvbkZvclNlcXVlbmNlKDAsNSkpO1xuY29uc29sZS5sb2coZm9vLmNhbGN1bGF0ZVBvc2l0aW9uRm9yU2VxdWVuY2UoMCw2KSk7XG5jb25zb2xlLmxvZyhmb28uY2FsY3VsYXRlUG9zaXRpb25Gb3JTZXF1ZW5jZSgwLDcpKTtcbmNvbnNvbGUubG9nKGZvby5jYWxjdWxhdGVQb3NpdGlvbkZvclNlcXVlbmNlKDAsOCkpO1xuXG4qL1xuQ2x1c3RhbFJ1bm5lci5SZXN1bHQucHJvdG90eXBlLmNhbGN1bGF0ZVBvc2l0aW9uRm9yU2VxdWVuY2UgPSBmdW5jdGlvbihpZHgscG9zKSB7XG4gICAgdmFyIGluc2VydHMgPSB0aGlzLl9yYXdfZGF0YS5kYXRhLnNlcXVlbmNlc1tpZHhdLmluc2VydGlvbnMgfHwge307XG4gICAgdmFyIHJlc3VsdCA9IHBvcztcbiAgICB2YXIgYWN0dWFsX3Bvc2l0aW9uID0gMDtcbiAgICB2YXIgc2VxID0gdGhpcy5fcmF3X2RhdGEuZGF0YS5zZXF1ZW5jZXNbaWR4XS50b1N0cmluZygpO1xuICAgIGZvciAodmFyIGkgPSAwIDsgaSA8IHNlcS5sZW5ndGg7IGkrKyApIHtcbiAgICAgICAgaWYgKGluc2VydHNbaV0pIHtcbiAgICAgICAgICAgIGFjdHVhbF9wb3NpdGlvbiArPSBpbnNlcnRzW2ldLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBhY3R1YWxfcG9zaXRpb24gKz0gMTtcbiAgICAgICAgaWYgKHNlcS5jaGFyQXQoaSkgPT0gJy0nKSB7XG4gICAgICAgICAgICBhY3R1YWxfcG9zaXRpb24gLT0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9zIDw9IGFjdHVhbF9wb3NpdGlvbikge1xuICAgICAgICAgICAgaWYgKHBvcyA9PSBhY3R1YWxfcG9zaXRpb24pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKGkrMSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChpID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgaSA9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAtMSAqIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xICogc2VxLmxlbmd0aDtcbn07XG5cbkNsdXN0YWxSdW5uZXIuUmVzdWx0LnByb3RvdHlwZS5jYWxjdWxhdGVTZXF1ZW5jZVBvc2l0aW9uRnJvbVBvc2l0aW9uID0gZnVuY3Rpb24oaWR4LHBvcykge1xuICAgIHZhciBpbnNlcnRzID0gdGhpcy5fcmF3X2RhdGEuZGF0YS5zZXF1ZW5jZXNbaWR4XS5pbnNlcnRpb25zIHx8IHt9O1xuICAgIHZhciByZXN1bHQgPSBwb3M7XG4gICAgdmFyIGFjdHVhbF9wb3NpdGlvbiA9IDA7XG4gICAgdmFyIHNlcSA9IHRoaXMuX3Jhd19kYXRhLmRhdGEuc2VxdWVuY2VzW2lkeF0udG9TdHJpbmcoKTtcbiAgICBmb3IgKHZhciBpID0gMCA7IGkgPCBwb3M7IGkrKyApIHtcbiAgICAgICAgaWYgKGluc2VydHNbaV0pIHtcbiAgICAgICAgICAgIGFjdHVhbF9wb3NpdGlvbiArPSBpbnNlcnRzW2ldLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBhY3R1YWxfcG9zaXRpb24gKz0gMTtcbiAgICAgICAgaWYgKHNlcS5jaGFyQXQoaSkgPT0gJy0nKSB7XG4gICAgICAgICAgICBhY3R1YWxfcG9zaXRpb24gLT0gMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoYWN0dWFsX3Bvc2l0aW9uID09IDApIHtcbiAgICAgICAgYWN0dWFsX3Bvc2l0aW9uICs9IDE7XG4gICAgfVxuICAgIHJldHVybiBhY3R1YWxfcG9zaXRpb247XG59O1xuXG5cbn0pKCk7XG4vLzEyNjUgKFApXG5cbkNsdXN0YWxSdW5uZXIucHJvdG90eXBlLnNldHVwU2VxdWVuY2VSZW5kZXJlciA9IGZ1bmN0aW9uKHJlbmRlcmVyKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgcmVuZGVyZXIuc2VxdWVuY2VzID0gc2VsZi5zZXF1ZW5jZXM7XG4gICAgcmVuZGVyZXIuYWRkQXhpc1NjYWxlKCdjbHVzdGFsJyxmdW5jdGlvbihwb3MsbGF5ZXIsaW52ZXJzZSkge1xuICAgICAgICBsZXQgaWR4ID0gbnVsbDtcbiAgICAgICAgbGV0IHNlcV9pZGVudGlmaWVycyA9IHNlbGYuc2VxdWVuY2VzLm1hcChmdW5jdGlvbihzZXEpIHsgcmV0dXJuIHNlcS5hZ2k7IH0pO1xuICAgICAgICB3aGlsZSAoc2VxX2lkZW50aWZpZXJzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIGlkeCA9IGlkeCB8fCAwO1xuICAgICAgICAgICAgbGV0IGFjYyA9IHNlcV9pZGVudGlmaWVycy5zaGlmdCgpO1xuICAgICAgICAgICAgaWYgKGxheWVyLnNjYWxlcy5oYXMoYWNjKSkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWR4Kys7XG4gICAgICAgICAgICBpZiAoIHNlcV9pZGVudGlmaWVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBpZHggPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChsYXllci5uYW1lID09PSAncHJpbWFyeVNlcXVlbmNlJykge1xuICAgICAgICAgICAgaWR4ID0gc2VsZi5yZXN1bHQuYWxpZ25lZF9pZHg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlkeCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHBvcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIGludmVyc2UgKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5yZXN1bHQuY2FsY3VsYXRlU2VxdWVuY2VQb3NpdGlvbkZyb21Qb3NpdGlvbihpZHgscG9zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBzZWxmLnJlc3VsdC5jYWxjdWxhdGVQb3NpdGlvbkZvclNlcXVlbmNlKGlkeCxwb3MpO1xuICAgIH0pO1xuXG4gICAgdmFyIHJlbmRlcmVkX2JpdHMgPSBbXTtcbiAgICB2YXIgY29udHJvbGxlcl9uYW1lID0gJ2lzb2Zvcm1zJztcbiAgICB2YXIgZ3JvdXBfbmFtZSA9ICdpc29mb3Jtcyc7XG5cbiAgICB2YXIgZHJhd19kaXNjb250aW51aXR5ID0gZnVuY3Rpb24oY2FudmFzLHNpemUpIHtcbiAgICAgICAgdmFyIHRvcCA9IC0zO1xuICAgICAgICB2YXIgbGVmdCA9IC0yO1xuICAgICAgICB2YXIgZ3JvdXAgPSBjYW52YXMuZ3JvdXAoKTtcbiAgICAgICAgdmFyIGxpbmU7XG4gICAgICAgIGxpbmUgPSBjYW52YXMubGluZShsZWZ0KzEsdG9wKzQsbGVmdCszLHRvcCsxKTtcbiAgICAgICAgbGluZS5zZXRBdHRyaWJ1dGUoJ3N0cm9rZScsJyNmY2MnKTtcbiAgICAgICAgbGluZS5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS13aWR0aCcsJzEwJyk7XG4gICAgICAgIGdyb3VwLnB1c2gobGluZSk7XG4gICAgICAgIGxpbmUgPSBjYW52YXMubGluZShsZWZ0KzEsdG9wKzYsbGVmdCszLHRvcCszKTtcbiAgICAgICAgbGluZS5zZXRBdHRyaWJ1dGUoJ3N0cm9rZScsJyNmY2MnKTtcbiAgICAgICAgbGluZS5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS13aWR0aCcsJzEwJyk7XG4gICAgICAgIGdyb3VwLnB1c2gobGluZSk7XG4gICAgICAgIGxpbmUgPSBjYW52YXMubGluZShsZWZ0KzEsdG9wKzQsbGVmdCszLHRvcCszKTtcbiAgICAgICAgbGluZS5zZXRBdHRyaWJ1dGUoJ3N0cm9rZScsJyNmY2MnKTtcbiAgICAgICAgbGluZS5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS13aWR0aCcsJzUnKTtcbiAgICAgICAgZ3JvdXAucHVzaChsaW5lKTtcbiAgICAgICAgbGluZSA9IGNhbnZhcy5saW5lKGxlZnQrMSx0b3ArNS4zLGxlZnQrMSx0b3ArNS44KTtcbiAgICAgICAgbGluZS5zZXRBdHRyaWJ1dGUoJ3N0cm9rZScsJyNmY2MnKTtcbiAgICAgICAgbGluZS5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS13aWR0aCcsJzEwJyk7XG4gICAgICAgIGdyb3VwLnB1c2gobGluZSk7XG4gICAgICAgIGxpbmUgPSBjYW52YXMubGluZShsZWZ0KzEsdG9wKzUuOSxsZWZ0KzEuNSx0b3ArNS45KTtcbiAgICAgICAgbGluZS5zZXRBdHRyaWJ1dGUoJ3N0cm9rZScsJyNmY2MnKTtcbiAgICAgICAgbGluZS5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS13aWR0aCcsJzEwJyk7XG4gICAgICAgIGdyb3VwLnB1c2gobGluZSk7XG4gICAgICAgIHZhciBjaXJjbGUgPSBjYW52YXMuY2lyY2xlKGxlZnQrMi44LHRvcCsxLjc1LDEpO1xuICAgICAgICBjaXJjbGUuc2V0QXR0cmlidXRlKCdmaWxsJywnI2ZmZicpO1xuICAgICAgICBjaXJjbGUuc2V0QXR0cmlidXRlKCdzdHJva2UnLCcjY2NjJyk7XG4gICAgICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS13aWR0aCcsJzEwJyk7XG4gICAgICAgIGdyb3VwLnB1c2goY2lyY2xlKTtcbiAgICAgICAgdmFyIG1pbnVzID0gY2FudmFzLnRleHQobGVmdCsyLjI1LHRvcCsyLjI1LChzaXplIHx8ICfDtycpK1wiXCIpO1xuICAgICAgICBtaW51cy5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLCcjY2NjJyk7XG4gICAgICAgIG1pbnVzLnNldEF0dHJpYnV0ZSgnZm9udC1zaXplJyw3NSk7XG4gICAgICAgIGdyb3VwLnB1c2gobWludXMpO1xuICAgICAgICBjYW52YXMuZmlyc3RDaGlsZC5uZXh0U2libGluZy5hcHBlbmRDaGlsZChncm91cCk7XG4gICAgICAgIHJldHVybiBncm91cDtcbiAgICB9O1xuXG4gICAgdmFyIGNoZWNrX3ZhbHVlcyA9IGZ1bmN0aW9uKHNlcSxpZHgsc2Vxcykge1xuICAgICAgICB2YXIgcG9zaXRpdmVzID0gMDtcbiAgICAgICAgdmFyIGFhID0gc2VxLnRvU3RyaW5nKCkuY2hhckF0KGlkeCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgc2Vxcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChzZXFzW2ldLnRvU3RyaW5nKCkuY2hhckF0KGlkeCkgPT0gYWEpIHtcbiAgICAgICAgICAgIHBvc2l0aXZlcyArPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKHBvc2l0aXZlcyAvIChzZXFzLmxlbmd0aCAtIDEpKTtcbiAgICB9O1xuXG5cbiAgICB2YXIgcmVkcmF3X2FsaWdubWVudHMgPSBmdW5jdGlvbihzZXF1ZW5jZV9pbmRleCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gc2VsZi5yZXN1bHQ7XG5cbiAgICAgICAgd2hpbGUgKHJlbmRlcmVkX2JpdHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIGJpdCA9IHJlbmRlcmVkX2JpdHMuc2hpZnQoKTtcbiAgICAgICAgICAgIHJlbmRlcmVyLnJlbW92ZShiaXQubGF5ZXIsYml0KTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQuYWxpZ25Ub1NlcXVlbmNlKHNlcXVlbmNlX2luZGV4IHx8IDApO1xuXG4gICAgICAgIHZhciBhbGlnbmVkID0gcmVzdWx0LmdldFNlcXVlbmNlcygpO1xuXG4gICAgICAgIGlmICggISByZW5kZXJlci5zZXF1ZW5jZSApIHtcbiAgICAgICAgICAgIHJlbmRlcmVyLnNldFNlcXVlbmNlKGFsaWduZWRbc2VxdWVuY2VfaW5kZXhdKShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZW5kZXJlci5zZXF1ZW5jZXMgPSBzZWxmLnNlcXVlbmNlcztcbiAgICAgICAgICAgICAgICBNQVNDUC5yZWdpc3Rlckdyb3VwKGdyb3VwX25hbWUsICdBbGlnbmVkJyk7XG4gICAgICAgICAgICAgICAgTUFTQ1AucmVnaXN0ZXJMYXllcihjb250cm9sbGVyX25hbWUsIHsgJ2Z1bGxuYW1lJyA6ICdDb25zZXJ2YXRpb24nLCAnY29sb3InIDogJyMwMDAwMDAnIH0pO1xuICAgICAgICAgICAgICAgIGlmIChyZW5kZXJlci50cmFja09yZGVyLmluZGV4T2YoY29udHJvbGxlcl9uYW1lKSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyZXIudHJhY2tPcmRlciA9IHJlbmRlcmVyLnRyYWNrT3JkZXIuY29uY2F0KFtjb250cm9sbGVyX25hbWVdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVuZGVyZXIuc2hvd0xheWVyKGNvbnRyb2xsZXJfbmFtZSk7XG4gICAgICAgICAgICAgICAgcmVuZGVyZXIuY3JlYXRlR3JvdXBDb250cm9sbGVyKGNvbnRyb2xsZXJfbmFtZSxncm91cF9uYW1lKTtcbiAgICAgICAgICAgICAgICByZWRyYXdfYWxpZ25tZW50cyhzZXF1ZW5jZV9pbmRleCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlbmRlcmVyLnNlcXVlbmNlID0gYWxpZ25lZFtzZXF1ZW5jZV9pbmRleF07XG4gICAgICAgICAgICByZW5kZXJlci5yZWRyYXdBeGlzKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFsaWdubWVudHMgPSByZXN1bHQuZ2V0QWxpZ25tZW50KCkuc3BsaXQoJycpO1xuICAgICAgICByZW5kZXJlZF9iaXRzID0gcmVuZGVyZWRfYml0cy5jb25jYXQocmVuZGVyZXIucmVuZGVyVGV4dFRyYWNrKGNvbnRyb2xsZXJfbmFtZSxyZXN1bHQuZ2V0QWxpZ25tZW50KCkucmVwbGFjZSgvIC9nLCfCoCcpKSk7XG4gICAgICAgIHJlbmRlcmVkX2JpdHMuc2xpY2UoLTEpWzBdLnNldEF0dHJpYnV0ZSgnZGF0YS1zcGFjZXMnLCd0cnVlJyk7XG4gICAgICAgIHJlbmRlcmVkX2JpdHMuc2xpY2UoLTEpWzBdLmxheWVyID0gY29udHJvbGxlcl9uYW1lO1xuICAgICAgICB2YXIgaWR4cyA9IFtcIipcIixcIjpcIixcIi5cIixcIiBcIl0ucmV2ZXJzZSgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMCA7IGkgPCBhbGlnbm1lbnRzLmxlbmd0aDsgaSsrICkge1xuICAgICAgICAgICAgcmVuZGVyZWRfYml0cy5wdXNoKHJlbmRlcmVyLmdldEFBKGkrMSxjb250cm9sbGVyX25hbWUpLmFkZEJveE92ZXJsYXkoY29udHJvbGxlcl9uYW1lLDEsaWR4cy5pbmRleE9mKGFsaWdubWVudHNbaV0pLzQse1wibWVyZ2VcIiA6IHRydWV9KSk7XG4gICAgICAgICAgICByZW5kZXJlZF9iaXRzLnNsaWNlKC0xKVswXS5sYXllciA9IGNvbnRyb2xsZXJfbmFtZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMCA7IGkgPCBhbGlnbmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbGF5bmFtZSA9IHNlbGYuc2VxdWVuY2VzW2ldLmFnaS50b1VwcGVyQ2FzZSgpIHx8IFwibWlzc2luZ1wiK2k7XG4gICAgICAgICAgICB2YXIgbGF5ID0gTUFTQ1AucmVnaXN0ZXJMYXllcihsYXluYW1lLHsnZnVsbG5hbWUnOiBzZWxmLnNlcXVlbmNlc1tpXS5uYW1lIHx8IGxheW5hbWUudG9VcHBlckNhc2UoKSwgJ2dyb3VwJyA6IGdyb3VwX25hbWUsICdjb2xvcicgOiAnI2ZmMDAwMCcsICdhY2Nlc3Npb24nIDogc2VsZi5zZXF1ZW5jZXNbaV0uYWdpIH0pO1xuICAgICAgICAgICAgbGF5LnNjYWxlcy5jbGVhcigpO1xuICAgICAgICAgICAgbGF5LnNjYWxlcy5hZGQoc2VsZi5zZXF1ZW5jZXNbaV0uYWdpKTtcblxuICAgICAgICAgICAgbGF5LmZ1bGxuYW1lID0gc2VsZi5zZXF1ZW5jZXNbaV0ubmFtZSB8fCBsYXluYW1lLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICB2YXIgdGV4dF9hcnJheSA9IHJlbmRlcmVyLnJlbmRlclRleHRUcmFjayhsYXluYW1lLGFsaWduZWRbaV0udG9TdHJpbmcoKSk7XG4gICAgICAgICAgICByZW5kZXJlZF9iaXRzID0gcmVuZGVyZWRfYml0cy5jb25jYXQodGV4dF9hcnJheSk7XG4gICAgICAgICAgICByZW5kZXJlZF9iaXRzLnNsaWNlKC0xKVswXS5sYXllciA9IGxheW5hbWU7XG4gICAgICAgICAgICBpZiAocmVuZGVyZXIudHJhY2tPcmRlci5pbmRleE9mKGxheW5hbWUudG9VcHBlckNhc2UoKSkgPCAwKSB7XG4gICAgICAgICAgICAgIHJlbmRlcmVyLnRyYWNrT3JkZXIgPSByZW5kZXJlci50cmFja09yZGVyLmNvbmNhdChbZ3JvdXBfbmFtZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG5hbWUgPSBcIklzb2Zvcm0gXCIrKGkrMSk7XG4gICAgICAgICAgICBpZiAoYWxpZ25lZFtpXS5pbnNlcnRpb25zKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIGluc2VydCBpbiBhbGlnbmVkW2ldLmluc2VydGlvbnMpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5zZXJ0aW9ucyA9IGFsaWduZWRbaV0uaW5zZXJ0aW9ucztcbiAgICAgICAgICAgICAgICBpZiAoaW5zZXJ0ID09IDAgJiYgaW5zZXJ0aW9uc1tpbnNlcnRdID09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaW5zZXJ0aW9uc1tpbnNlcnRdLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBzaXplID0gaW5zZXJ0aW9uc1tpbnNlcnRdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAoaW5zZXJ0ID09IDApIHtcbiAgICAgICAgICAgICAgICAgIGluc2VydCA9IDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBjb250ZW50ID0gZHJhd19kaXNjb250aW51aXR5KHJlbmRlcmVyLl9jYW52YXMsc2l6ZSk7XG4gICAgICAgICAgICAgICAgY29udGVudC5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLCcjZmZmZjAwJyk7XG4gICAgICAgICAgICAgICAgdmFyIGFuX2Fubm8gPSByZW5kZXJlci5nZXRBQShpbnNlcnQsY29udHJvbGxlcl9uYW1lKS5hZGRUb0xheWVyKGxheW5hbWUsXG4gICAgICAgICAgICAgICAgICB7ICdjb250ZW50JyA6IGNvbnRlbnQsLy8nKycraW5zZXJ0aW9uc1tpbnNlcnRdLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgJ2JhcmVfZWxlbWVudCc6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICdoZWlnaHQnIDogMTAsXG4gICAgICAgICAgICAgICAgICAgICdvZmZzZXQnIDogLTUsXG4gICAgICAgICAgICAgICAgICAgICdub190cmFjZXInIDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgfSlbMV07XG4gICAgICAgICAgICAgICAgYW5fYW5uby5jb250YWluZXIuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCczMDAnKTtcbiAgICAgICAgICAgICAgICBhbl9hbm5vLmNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnLCctNTAgLTEwMCAyMDAgMzAwJyk7XG4gICAgICAgICAgICAgICAgcmVuZGVyZWRfYml0cy5wdXNoKGFuX2Fubm8pO1xuICAgICAgICAgICAgICAgIHJlbmRlcmVkX2JpdHMuc2xpY2UoLTEpWzBdLmxheWVyID0gbGF5bmFtZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlbmRlcmVyLnpvb20gPSAxO1xuICAgICAgICByZW5kZXJlci5zaG93R3JvdXAoZ3JvdXBfbmFtZSk7XG4gICAgICAgIHJlbmRlcmVyLnJlZnJlc2goKTtcblxuICAgIH07XG5cbiAgICB0aGlzLmJpbmQoJ3Jlc3VsdFJlY2VpdmVkJyxmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICByZWRyYXdfYWxpZ25tZW50cygwKTtcbiAgICAgICAgc2VsZi5yZXN1bHQuYWxpZ25lZF9pZHggPSAwO1xuICAgICAgICB2YXIgYWNjcyA9IFtdO1xuICAgICAgICBzZWxmLnNlcXVlbmNlcy5mb3JFYWNoKGZ1bmN0aW9uKHNlcSkge1xuICAgICAgICAgICAgYWNjcy5wdXNoKHNlcS5hZ2kudG9VcHBlckNhc2UoKSk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgY3VycmVudF9vcmRlciA9IFtdO1xuICAgICAgICByZW5kZXJlci5iaW5kKCdvcmRlckNoYW5nZWQnLGZ1bmN0aW9uKG9yZGVyKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5yZXN1bHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmV3X29yZGVyID0gb3JkZXIuc2xpY2UoKG9yZGVyLmluZGV4T2YoY29udHJvbGxlcl9uYW1lKSsxKSxvcmRlci5sZW5ndGgpLmZpbHRlciggZnVuY3Rpb24odHJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFjY3MuaW5kZXhPZih0cmFjaykgPj0gMDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAobmV3X29yZGVyLmpvaW4oJywnKSA9PSBjdXJyZW50X29yZGVyLmpvaW4oJywnKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGN1cnJlbnRfb3JkZXIgPSBuZXdfb3JkZXI7XG4gICAgICAgICAgICAgICAgc2VsZi5yZXN1bHQuYWxpZ25lZF9pZHggPSBhY2NzLmluZGV4T2YoY3VycmVudF9vcmRlclswXSk7XG5cbiAgICAgICAgICAgICAgICByZWRyYXdfYWxpZ25tZW50cyhzZWxmLnJlc3VsdC5hbGlnbmVkX2lkeCk7XG4gICAgICAgICAgICAgICAgcmVuZGVyZXIucmVmcmVzaFNjYWxlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG59XG5cbkNsdXN0YWxSdW5uZXIuUmVzdWx0LnByb3RvdHlwZS5nZXRTZXF1ZW5jZXMgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5fcmF3X2RhdGEgJiYgdGhpcy5fcmF3X2RhdGEuZGF0YSAmJiB0aGlzLl9yYXdfZGF0YS5kYXRhLnNlcXVlbmNlcykge1xuICAgICAgICByZXR1cm4gW10uY29uY2F0KHRoaXMuX3Jhd19kYXRhLmRhdGEuc2VxdWVuY2VzKTtcbiAgICB9XG4gICAgdmFyIGJpdHMgPSB0aGlzLl9yYXdfZGF0YS5tYXRjaCgvc2VxXFxkKyguKikvZyk7XG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJpdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHNlcWJpdHMgPSBiaXRzW2ldLm1hdGNoKC9zZXEoXFxkKylcXHMrKC4qKS8pO1xuICAgICAgICBpZiAoISByZXN1bHRzW3NlcWJpdHNbMV1dKSB7XG4gICAgICAgICAgICByZXN1bHRzW3NlcWJpdHNbMV1dID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0c1tzZXFiaXRzWzFdXSArPSBzZXFiaXRzWzJdO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cztcbn07XG5cbkNsdXN0YWxSdW5uZXIuUmVzdWx0LnByb3RvdHlwZS5nZXRBbGlnbm1lbnQgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5fcmF3X2RhdGEgJiYgdGhpcy5fcmF3X2RhdGEuZGF0YSAmJiB0aGlzLl9yYXdfZGF0YS5kYXRhLmFsaWdubWVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmF3X2RhdGEuZGF0YS5hbGlnbm1lbnQudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgdGhpcy5fdGV4dF9kYXRhID0gdGhpcy5fcmF3X2RhdGE7XG4gICAgdmFyIHJlID0gLyB7MTZ9KC4qKS9nO1xuICAgIHZhciByZXN1bHQgPSBcIlwiO1xuICAgIHZhciBtYXRjaCA9IHJlLmV4ZWModGhpcy5fcmF3X2RhdGEpO1xuICAgIHdoaWxlIChtYXRjaCAhPT0gbnVsbCkge1xuICAgICAgICByZXN1bHQgKz0gbWF0Y2hbMV07XG4gICAgICAgIG1hdGNoID0gcmUuZXhlYyh0aGlzLl9yYXdfZGF0YSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbmxldCBvbmx5VW5pcXVlID0gKHZhbCxpZHgsYXJyKSA9PiBhcnIuaW5kZXhPZih2YWwpID09PSBpZHg7XG5cbmxldCBjbHVzdGFsX2VtdWxhdG9yID0gKHNlcXVlbmNlcykgPT4ge1xuICAgIGlmIChzZXF1ZW5jZXMubGVuZ3RoID09IDApIHtcbiAgICAgICAgcmV0dXJuIHsgZGF0YTogeyBzZXF1ZW5jZXM6IFtdLCBhbGlnbm1lbnQ6IFwiXCIgfSB9O1xuICAgIH1cbiAgICBsZXQgYWxsX2FhcyA9IHNlcXVlbmNlcy5tYXAoIHNlcSA9PiBzZXEuc3BsaXQoJycpICk7XG4gICAgbGV0IGFsaWdubWVudCA9IGFsbF9hYXNbMF0ubWFwKCAoYWEscG9zKSA9PiAgYWxsX2Fhcy5tYXAoIGFhcyA9PiBhYXNbcG9zXSApLmZpbHRlcihvbmx5VW5pcXVlKS5sZW5ndGggPT0gMSA/ICcqJyA6ICc6JyApLmpvaW4oJycpO1xuICAgIHJldHVybiB7IGRhdGE6IHsgc2VxdWVuY2VzOiBzZXF1ZW5jZXMsIGFsaWdubWVudDogYWxpZ25tZW50IH19O1xufTtcblxuQ2x1c3RhbFJ1bm5lci5FbXVsYXRlZENsdXN0YWxSdW5uZXIgPSBmdW5jdGlvbihyZW5kZXJlcikge1xuICAgIGxldCBydW5uZXIgPSBuZXcgQ2x1c3RhbFJ1bm5lcigpO1xuICAgIHJ1bm5lci5yZXRyaWV2ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBsZXQgZGF0YWJsb2NrID0gY2x1c3RhbF9lbXVsYXRvcih0aGlzLnNlcXVlbmNlcyB8fCBbXSk7XG4gICAgICAgIHRoaXMuX2RhdGFSZWNlaXZlZChkYXRhYmxvY2spO1xuICAgICAgICB0aGlzLnNlcXVlbmNlcyA9IHRoaXMuc2VxdWVuY2VzLm1hcCgoc2VxLGlkeCkgPT4geyByZXR1cm4geyAgYWdpOiAnc2VxJytpZHgsIHRvU3RyaW5nOiAoKSA9PiBzZXEgfSB9KTtcbiAgICAgICAgdGhpcy5nb3RSZXN1bHQoKTtcbiAgICAgICAgdGhpcy5yZXF1ZXN0Q29tcGxldGUoKTtcbiAgICB9O1xuICAgIGlmIChyZW5kZXJlcikge1xuICAgICAgICBydW5uZXIucmVnaXN0ZXJTZXF1ZW5jZVJlbmRlcmVyKHJlbmRlcmVyKTtcbiAgICB9XG4gICAgcmV0dXJuIHJ1bm5lcjtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IENsdXN0YWxSdW5uZXI7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBOztBQUVBO0FBQ0E7QUFDQTtBQUVBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBSkE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBSEE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBa0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./js/lib/ClustalRunner.js\n");

/***/ }),

/***/ "./js/lib/CondensedSequenceRenderer.js":
/*!*********************************************!*\
  !*** ./js/lib/CondensedSequenceRenderer.js ***!
  \*********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _MASCP__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MASCP */ \"./js/lib/MASCP.js\");\n/* harmony import */ var _SequenceRenderer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SequenceRenderer */ \"./js/lib/SequenceRenderer.js\");\n/* harmony import */ var _CondensedSequenceRendererNavigation__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./CondensedSequenceRendererNavigation */ \"./js/lib/CondensedSequenceRendererNavigation.js\");\n/* harmony import */ var _bean__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../bean */ \"./js/bean.js\");\n/* harmony import */ var _SVGCanvas__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./SVGCanvas */ \"./js/lib/SVGCanvas.js\");\n/**\n *  @fileOverview   Basic classes and definitions for an SVG-based sequence renderer\n */\n\n\n\n\n\n\n\nconst svgns = 'http://www.w3.org/2000/svg';\n\n/** Default class constructor\n *  @class      Renders a sequence using a condensed track-based display\n *  @param      {Element} sequenceContainer Container element that the sequence currently is found in, and also \n *              the container that data will be re-inserted into.\n *  @extends    MASCP.SequenceRenderer\n */\nconst CondensedSequenceRenderer = function CondensedSequenceRenderer(sequenceContainer) {\n    this._RS = 50;\n    _SequenceRenderer__WEBPACK_IMPORTED_MODULE_1__[\"default\"].apply(this, arguments);\n    var self = this;\n\n    // Create a common layer for the primary sequence\n    _MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"].registerLayer('primarySequence', { 'fullname': 'Primary Sequence' });\n\n    CondensedSequenceRenderer.Zoom(self);\n    var resizeTimeout;\n    var resize_callback = function resize_callback() {\n        sequenceContainer.cached_width = sequenceContainer.getBoundingClientRect().width;\n    };\n    window.addEventListener('resize', function () {\n        clearTimeout(resizeTimeout);\n        if (window.requestAnimationFrame) {\n            window.requestAnimationFrame(resize_callback);\n        } else {\n            resizeTimeout = setTimeout(resize_callback, 100);\n        }\n    }, true);\n    sequenceContainer.cached_width = sequenceContainer.getBoundingClientRect().width;\n\n    // We want to unbind the default handler for sequence change that we get from\n    // inheriting from CondensedSequenceRenderer\n    _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].remove(this, 'sequenceChange');\n\n    _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].add(this, 'sequenceChange', function () {\n        for (var layername in _MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"].layers) {\n            if (_MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"].layers.hasOwnProperty(layername)) {\n                _MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"].layers[layername].disabled = true;\n            }\n        }\n        self.zoom = self.zoom;\n    });\n\n    return this;\n};\n\nCondensedSequenceRenderer.prototype = new _SequenceRenderer__WEBPACK_IMPORTED_MODULE_1__[\"default\"]();\n\n(function (clazz) {\n    var createCanvasObject = function createCanvasObject() {\n        var renderer = this;\n\n        if (this._object) {\n            if (typeof svgweb != 'undefined') {\n                svgweb.removeChild(this._object, this._object.parentNode);\n            } else {\n                this._object.parentNode.removeChild(this._object);\n            }\n            this._canvas = null;\n            this._object = null;\n        }\n        var canvas;\n        if (document.implementation.hasFeature(\"http://www.w3.org/TR/SVG11/feature#BasicStructure\", \"1.1\")) {\n            var native_canvas = this.win().document.createElementNS(svgns, 'svg');\n            native_canvas.setAttribute('width', '100%');\n            native_canvas.setAttribute('height', '100%');\n            this._container.appendChild(native_canvas);\n            this._canvas = native_canvas;\n            canvas = {\n                'addEventListener': function addEventListener(name, load_func) {\n                    native_canvas.contentDocument = { 'rootElement': native_canvas };\n                    load_func.call(native_canvas);\n                }\n            };\n        }\n\n        canvas.addEventListener('load', function () {\n            var container_canv = this;\n            Object(_SVGCanvas__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(container_canv);\n            if (renderer.font_order) {\n                container_canv.font_order = renderer.font_order;\n            }\n            var group = container_canv.makeEl('g');\n\n            var canv = container_canv.makeEl('svg');\n            canv.RS = renderer._RS;\n            Object(_SVGCanvas__WEBPACK_IMPORTED_MODULE_4__[\"default\"])(canv);\n            if (renderer.font_order) {\n                canv.font_order = renderer.font_order;\n            }\n            group.appendChild(canv);\n            container_canv.appendChild(group);\n\n            var supports_events = true;\n\n            try {\n                var noop = canv.addEventListener;\n            } catch (err) {\n                supports_events = false;\n            }\n\n            var canvas_rect = canv.makeEl('rect', { 'x': '-10%',\n                'y': '-10%',\n                'width': '120%',\n                'height': '120%',\n                'style': 'fill: #ffffff;' });\n\n            var left_fade = container_canv.makeEl('rect', { 'x': '0',\n                'y': '0',\n                'width': '50',\n                'height': '100%',\n                'style': 'fill: url(#left_fade);' });\n\n            var right_fade = container_canv.makeEl('rect', { 'x': '100%',\n                'y': '0',\n                'width': '25',\n                'height': '100%',\n                'transform': 'translate(-15,0)',\n                'style': 'fill: url(#right_fade);' });\n\n            container_canv.appendChild(left_fade);\n            container_canv.appendChild(right_fade);\n\n            _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].add(canv, 'pan', function () {\n                if (canv.currentTranslateCache.x >= 0) {\n                    left_fade.setAttribute('visibility', 'hidden');\n                } else {\n                    left_fade.setAttribute('visibility', 'visible');\n                }\n                if (renderer.rightVisibleResidue() < renderer.sequence.length) {\n                    right_fade.setAttribute('visibility', 'visible');\n                } else {\n                    right_fade.setAttribute('visibility', 'hidden');\n                }\n            });\n\n            _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].add(canv, '_anim_begin', function () {\n                left_fade.setAttribute('visibility', 'hidden');\n                right_fade.setAttribute('visibility', 'hidden');\n            });\n\n            _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].add(canv, '_anim_end', function () {\n                _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].fire(canv, 'pan');\n            });\n\n            canv.currentTranslateCache = { x: 0, y: 0 };\n\n            if (canv.currentTranslateCache.x >= 0) {\n                left_fade.setAttribute('visibility', 'hidden');\n            }\n            right_fade.setAttribute('visibility', 'hidden');\n\n            var nav_group = container_canv.makeEl('g');\n            container_canv.appendChild(nav_group);\n            var nav_canvas = container_canv.makeEl('svg');\n            nav_group.appendChild(nav_canvas);\n\n            group.style.willChange = 'transform';\n\n            canv.setScale = function (scale) {\n                var curr_transform = (group._cached_transform || '').replace(/scale\\([^\\)]+\\)/, '');\n                if (scale !== null) {\n                    curr_transform = (' scale(' + scale + ') ' + curr_transform).replace(/\\s+/g, ' ');\n                }\n                group._cached_transform = curr_transform;\n                group.style.transform = curr_transform;\n            };\n\n            nav_canvas.setScale = function (scale) {\n                var curr_transform = (nav_group._cached_transform || '').replace(/scale\\([^\\)]+\\)/, '');\n                if (scale !== null) {\n                    curr_transform = (curr_transform + ' scale(' + scale + ') ').replace(/\\s+/g, ' ');\n                }\n                nav_group._cached_transform = curr_transform;\n                nav_group.style.transform = curr_transform;\n            };\n            _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].add(canv, 'zoomChange', () => {\n                if (!renderer.fixed_size) {\n                    return;\n                }\n                canv.setScale(1);\n                nav_canvas.setScale(1);\n                requestAnimationFrame(() => {\n                    let container_height = container_canv.getBoundingClientRect().height;\n                    let canv_height = canv.getBoundingClientRect().height;\n                    let current_scale = (group._cached_transform || 'scale(1)').match(/scale\\(([\\d\\.]+)\\)/) || '1';\n                    canv.setScale((1 * container_height / canv_height).toFixed(2));\n                    nav_canvas.setScale((1 * container_height / canv_height).toFixed(2));\n                });\n            });\n\n            var ua = window.navigator.userAgent;\n            var is_explorer = false;\n            if (ua.indexOf('Edge/') >= 0) {\n                is_explorer = true;\n            }\n\n            canv.setCurrentTranslateXY = function (x, y) {\n                var curr_transform = group._cached_transform || '';\n                curr_transform = (curr_transform.replace(/translate\\([^\\)]+\\)/, '') + ' translate(' + x + 'px, ' + y + 'px) ').replace(/\\s+/g, ' ');\n                group._cached_transform = curr_transform;\n                if (!is_explorer) {\n                    group.style.transform = curr_transform;\n                } else {\n                    group.setAttribute('transform', curr_transform.replace(/px/g, ''));\n                }\n\n                this.currentTranslateCache.x = x;\n                this.currentTranslateCache.y = y;\n            };\n            canv.setCurrentTranslateXY(0, 0);\n\n            nav_canvas.setCurrentTranslateXY = function (x, y) {\n                var curr_transform = (nav_group.getAttribute('transform') || '').replace(/translate\\([^\\)]+\\)/, '');\n                curr_transform = curr_transform + ' translate(' + x + ', ' + y + ') ';\n                nav_group.setAttribute('transform', curr_transform);\n                this.currentTranslate.x = x;\n                this.currentTranslate.y = y;\n            };\n            nav_canvas.setCurrentTranslateXY(0, 0);\n\n            addNav.call(renderer, nav_canvas);\n\n            var nav = renderer.navigation;\n            var old_show = nav.show,\n                old_hide = nav.hide;\n            nav.show = function () {\n                old_show.apply(nav, arguments);\n                canv.style.GomapScrollLeftMargin = 100 * renderer._RS / renderer.zoom;\n            };\n\n            nav.hide = function () {\n                old_hide.apply(nav, arguments);\n                canv.style.GomapScrollLeftMargin = 1000;\n            };\n\n            renderer._container_canvas = container_canv;\n            container_canv.setAttribute('preserveAspectRatio', 'xMinYMin meet');\n            container_canv.setAttribute('width', '100%');\n            container_canv.setAttribute('height', '100%');\n            canv.appendChild(canv.makeEl('rect', { 'x': 0, 'y': 0, 'opacity': 0, 'width': '100%', 'height': '100%', 'stroke-width': '0', 'fill': '#ffffff' }));\n            renderer._object = this;\n            renderer._canvas = canv;\n            renderer._canvas._canvas_height = 0;\n            _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].fire(renderer, 'svgready');\n        }, false);\n\n        return canvas;\n    };\n\n    var wheel_fn = function wheel_fn(e) {\n        e.stopPropagation();\n        return true;\n    };\n\n    var addNav = function addNav(nav_canvas) {\n        this.navigation = new CondensedSequenceRenderer.Navigation(nav_canvas, this);\n        var nav = this.navigation;\n        var self = this;\n\n        var hide_chrome = function hide_chrome() {\n            nav.demote();\n        };\n\n        var show_chrome = function show_chrome() {\n            nav.promote();\n            nav.refresh();\n        };\n\n        if (!_MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"].IE) {\n            _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].add(this._canvas, 'panstart', hide_chrome);\n            _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].add(this._canvas, 'panend', show_chrome);\n            _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].add(this._canvas, '_anim_begin', hide_chrome);\n            _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].add(this._canvas, '_anim_end', show_chrome);\n            nav_canvas.addEventListener('DOMMouseScroll', wheel_fn, false);\n            nav_canvas.addEventListener('wheel', wheel_fn, false);\n            nav_canvas.onmousewheel = wheel_fn;\n        }\n    };\n    var drawAminoAcids = function drawAminoAcids() {\n        var renderer = this;\n        var aas = renderer.addTextTrack(this.sequence, this._canvas.set());\n        aas.attr({ 'y': 0.5 * renderer._axis_height * renderer._RS });\n        renderer.select = function () {\n            var vals = Array.prototype.slice.call(arguments);\n            var from = vals[0];\n            var to = vals[1];\n            this.moveHighlight.apply(this, vals);\n        };\n        var zoomchange = function zoomchange() {\n            aas.attr({ 'y': 0.5 * renderer._axis_height * renderer._RS });\n        };\n        var canvas = renderer._canvas;\n        _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].add(canvas, 'zoomChange', zoomchange);\n        _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].add(aas, 'removed', function () {\n            _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].remove(canvas, 'zoomChange', zoomchange);\n        });\n        return aas;\n    };\n    var mainDrawAxis;\n    var drawAxis = mainDrawAxis = function mainDrawAxis(canvas, lineLength) {\n        var RS = this._RS;\n        var self = this;\n        var x = 0,\n            i = 0;\n\n        var axis = canvas.set();\n\n        var axis_back = canvas.rect(0, 0, lineLength, 1.5);\n        axis_back.setAttribute('fill', \"url('#\" + self.axis_pattern_id + \"')\");\n        axis_back.removeAttribute('stroke');\n        axis_back.removeAttribute('stroke-width');\n        axis_back.setAttribute('id', 'axis_back');\n\n        var base_axis_height = 30;\n\n        var all_labels = canvas.set();\n        var major_mark_labels = canvas.set();\n        var minor_mark_labels = canvas.set();\n        var thousand_mark_labels = canvas.set();\n        var minor_mark = 10;\n        var major_mark = 20;\n\n        if (this.sequence.length > 5000) {\n            minor_mark = 100;\n            major_mark = 200;\n        }\n        if (this.sequence.length > 1000) {\n            minor_mark = 20;\n            major_mark = 40;\n        }\n        for (i = 0; i < lineLength / 5; i++) {\n\n            var a_text = canvas.text(x - 0.5, 0, \"\" + x);\n            all_labels.push(a_text);\n\n            if (x % major_mark === 0 && x !== 0) {\n                major_mark_labels.push(a_text);\n            } else if (x % minor_mark === 0 && x !== 0) {\n                minor_mark_labels.push(a_text);\n            }\n            if (x % (250 * parseInt(this.sequence.length / 500)) === 0 && x !== 0) {\n                thousand_mark_labels.push(a_text);\n            }\n            x += 5;\n        }\n\n        for (i = 0; i < all_labels.length; i++) {\n            all_labels[i].style.textAnchor = 'middle';\n            all_labels[i].firstChild.setAttribute('dy', '1.5ex');\n        }\n\n        all_labels.attr({ 'pointer-events': 'none', 'text-anchor': 'middle', 'font-size': 7 * RS + 'pt' });\n        all_labels.hide();\n\n        self._axis_height = parseInt(base_axis_height / self.zoom);\n\n        var zoom_status = null;\n        var zoomchange = function zoomchange() {\n            var renderer = self;\n            renderer._axis_height = parseInt(base_axis_height / renderer.zoom);\n            var pattern = renderer._canvas.ownerSVGElement.getElementById(renderer.axis_pattern_id);\n\n            thousand_mark_labels.forEach(function (label) {\n                label.setAttribute('visibility', 'hidden');\n            });\n\n            if (this.zoom > 3.6) {\n                axis_back.setAttribute('transform', 'translate(-5,' + 0.3 * renderer._axis_height * RS + ')');\n                axis_back.setAttribute('height', 0.25 * renderer._axis_height * RS);\n                pattern.setAttribute('width', 10 * RS);\n                pattern.firstChild.setAttribute('x', 9.5 * RS);\n                pattern.firstChild.setAttribute('width', RS / renderer.zoom);\n\n                minor_mark_labels.show();\n                major_mark_labels.show();\n                var text_scale = 0.15 * self._axis_height;\n                if (text_scale < 1) {\n                    text_scale = 1;\n                }\n                minor_mark_labels.attr({ 'font-size': text_scale * RS + 'pt', 'text-anchor': 'end' });\n                major_mark_labels.attr({ 'font-size': text_scale * RS + 'pt', 'text-anchor': 'end' });\n                if (this._visibleTracers && this._visibleTracers()) {\n                    this._visibleTracers().show();\n                }\n            } else if (this.zoom > 1.8) {\n\n                minor_mark_labels.hide();\n                major_mark_labels.show();\n                major_mark_labels.attr({ 'font-size': 0.5 * RS * self._axis_height + 'pt', 'text-anchor': 'middle' });\n                axis_back.setAttribute('transform', 'translate(-25,' + 0.5 * renderer._axis_height * RS + ')');\n                axis_back.setAttribute('height', 0.3 * renderer._axis_height * RS);\n                pattern.setAttribute('width', 20 * RS);\n                pattern.firstChild.setAttribute('width', RS / renderer.zoom);\n                pattern.firstChild.setAttribute('x', '0');\n                if (this.tracers) {\n                    this.tracers.hide();\n                }\n            } else if (this.zoom > 0.2) {\n\n                if (this.tracers) {\n                    this.tracers.hide();\n                }\n                minor_mark_labels.hide();\n                major_mark_labels.show();\n                major_mark_labels.attr({ 'font-size': 0.5 * RS * self._axis_height + 'pt', 'text-anchor': 'middle' });\n                axis_back.setAttribute('transform', 'translate(-25,' + 0.5 * renderer._axis_height * RS + ')');\n                axis_back.setAttribute('height', 0.3 * renderer._axis_height * RS);\n                pattern.setAttribute('width', 50 * RS);\n                pattern.firstChild.setAttribute('width', RS / renderer.zoom);\n\n                var last_right = -10000;\n                var changed = false;\n                major_mark_labels.forEach(function (label) {\n                    if (!label.cached_bbox) {\n                        label.cached_bbox = label.getBBox();\n                    }\n                    if (label.cached_bbox.x <= last_right + RS * 10 || parseInt(label.textContent) % 50 != 0) {\n                        label.setAttribute('visibility', 'hidden');\n                        changed = true;\n                    } else {\n                        label.setAttribute('visibility', 'visible');\n                        last_right = label.cached_bbox.x + label.cached_bbox.width;\n                    }\n                });\n                if (changed) {\n                    major_mark_labels[0].setAttribute('visibility', 'hidden');\n                }\n            } else {\n                if (this.tracers) {\n                    this.tracers.hide();\n                }\n                minor_mark_labels.hide();\n                major_mark_labels.hide();\n                thousand_mark_labels.show();\n                thousand_mark_labels.attr({ 'font-size': 0.5 * RS * self._axis_height + 'pt', 'text-anchor': 'middle' });\n\n                axis_back.setAttribute('transform', 'translate(-50,' + 0.85 * renderer._axis_height * RS + ')');\n                axis_back.setAttribute('height', 0.1 * renderer._axis_height * RS);\n                pattern.setAttribute('width', 250 * RS);\n                pattern.firstChild.setAttribute('width', RS / renderer.zoom);\n\n                var last_right = -10000;\n                var changed = false;\n                thousand_mark_labels.forEach(function (label) {\n                    if (!label.cached_bbox) {\n                        label.cached_bbox = label.getBBox();\n                    }\n                    if (label.cached_bbox.x <= last_right + RS * 10 || parseInt(label.textContent) % 250 != 0) {\n                        label.setAttribute('visibility', 'hidden');\n                    } else {\n                        label.setAttribute('visibility', 'visible');\n                        last_right = label.cached_bbox.x + label.cached_bbox.width;\n                    }\n                });\n                if (changed) {\n                    thousand_mark_labels[0].setAttribute('visibility', 'hidden');\n                }\n            }\n        };\n        _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].add(canvas, 'zoomChange', zoomchange);\n        _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].add(axis, 'removed', function () {\n            _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].remove(canvas, 'zoomChange', zoomchange);\n            var remover = function remover(el) {\n                if (el.parentNode) {\n                    el.parentNode.removeChild(el);\n                }\n            };\n            axis_back.parentNode.removeChild(axis_back);\n            all_labels.forEach(remover);\n        });\n        return axis;\n    };\n\n    clazz.prototype.panTo = function (end, callback) {\n        var renderer = this;\n        var pos = renderer.leftVisibleResidue();\n        var delta = 1;\n        if (pos == end) {\n            if (callback) {\n                callback.call(null);\n            }\n            return;\n        }\n        if (pos > end) {\n            delta = -1;\n        }\n        requestAnimationFrame(function () {\n            renderer.setLeftVisibleResidue(pos);\n            pos += delta;\n            _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].fire(renderer._canvas, 'panend');\n            if (pos !== end) {\n                requestAnimationFrame(arguments.callee);\n            } else {\n                if (callback) {\n                    callback.call(null);\n                }\n            }\n        });\n    };\n\n    clazz.prototype.zoomTo = function (zoom, residue, callback) {\n        var renderer = this;\n        var curr = renderer.zoom;\n        var delta = (zoom - curr) / 50;\n        let zoomchange = function zoomchange() {\n            _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].remove(renderer, 'zoomChange', zoomchange);\n            delete renderer.zoomCenter;\n            if (callback) {\n                callback.call(null);\n            }\n        };\n        _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].add(renderer, 'zoomChange', zoomchange);\n        if (residue) {\n            renderer.zoomCenter = residue == 'center' ? residue : { 'x': renderer._RS * residue };\n        } else {\n            renderer.zoom = zoom;\n            return;\n        }\n        requestAnimationFrame(function () {\n            renderer.zoom = curr;\n            curr += delta;\n            if (Math.abs(curr - zoom) > 0.01) {\n                requestAnimationFrame(arguments.callee);\n            }\n        });\n    };\n\n    clazz.prototype.setLeftVisibleResidue = function (val) {\n        var self = this;\n        self._canvas.setCurrentTranslateXY(self._canvas.width.baseVal.value * (1 - val / (self.sequence.length + self.padding + 2)) - self._canvas.width.baseVal.value, 0);\n    };\n\n    clazz.prototype.leftVisibleResidue = function () {\n        var self = this;\n        var val = Math.floor((self.sequence.length + self.padding + 2) * (1 - (self._canvas.width.baseVal.value + self._canvas.currentTranslateCache.x) / self._canvas.width.baseVal.value)) - 1;\n        if (val < 0) {\n            val = 0;\n        }\n        return val;\n    };\n\n    clazz.prototype.rightVisibleResidue = function () {\n        var self = this;\n        var container_width = self._container_canvas.parentNode.cached_width;\n        if (!container_width) {\n            container_width = self._container_canvas.parentNode.getBoundingClientRect().width;\n        }\n        var val = Math.floor(self.leftVisibleResidue() + (self.sequence.length + self.padding + 2) * (container_width / self._canvas.width.baseVal.value));\n        if (val > self.sequence.length) {\n            val = self.sequence.length;\n        }\n        return val;\n    };\n\n    clazz.prototype.addAxisScale = function (identifier, scaler) {\n        if (!this._scalers) {\n            this._scalers = [];\n        }\n        let scalers = this._scalers.filter(scale => scale.identifier !== identifier);\n        scalers.push(scaler);\n        this._scalers = scalers;\n        scaler.identifier = identifier;\n        return scaler;\n    };\n\n    clazz.prototype.refreshScale = function () {\n        var self = this;\n        var lays = Object.keys(this._layer_containers);\n        lays.forEach(function (lay) {\n            self._layer_containers[lay].forEach(function (el) {\n                if (el.move && el.aa) {\n                    var aa = self.scalePosition(el.aa, lay);\n                    var aa_width = self.scalePosition(el.aa + el.aa_width, lay);\n                    if (aa < 0) {\n                        aa *= -1;\n                    }\n                    if (aa_width < 0) {\n                        aa_width *= -1;\n                    }\n                    el.move(aa - 1, aa_width - aa);\n                }\n            });\n        });\n    };\n\n    clazz.prototype.scalePosition = function (aa, layer, inverse) {\n        var layer_obj = _MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getLayer(layer);\n        if (!layer_obj) {\n            console.log('Missing layer object for layer identifier', layer, 'making dummy layer scaled with identifier', layer);\n            layer_obj = { 'name': layer, 'scales': new Set() };\n            layer_obj.scales.add(layer);\n        }\n        let scaler_funcs = (this._scalers || []).concat([]);\n        var new_aa = (inverse ? scaler_funcs.reverse() : scaler_funcs).reduce((val, fn) => {\n            return fn(val, layer_obj, inverse);\n        }, aa);\n        return new_aa;\n    };\n\n    clazz.prototype.getAA = function (aa, layer, scale_name) {\n        return this.getAminoAcidsByPosition([aa], layer, scale_name).shift();\n    };\n\n    clazz.prototype.getAminoAcidsByPosition = function (aas, layer) {\n        var self = this;\n        var new_aas = aas.map(function (aa) {\n            return Math.abs(self.scalePosition(aa, layer));\n        });\n        var results = _SequenceRenderer__WEBPACK_IMPORTED_MODULE_1__[\"default\"].prototype.getAminoAcidsByPosition.call(this, new_aas);\n\n        for (var i = 0; i < new_aas.length; i++) {\n            if (results[i]) {\n                results[i].original_index = aas[i];\n            }\n        }\n        return results;\n    };\n\n    clazz.prototype.getAminoAcidsByPeptide = function (peptide, layer) {\n        layer = _MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getLayer(layer);\n        var self = this;\n        var positions = [];\n        var self_seq;\n        var identifier = layer.accession;\n        if (self.sequences) {\n            self_seq = self.sequences[self.sequences.map(function (seq) {\n                return (seq.agi || seq.acc || \"\").toLowerCase();\n            }).indexOf(identifier.toLowerCase())].toString();\n        } else {\n            self_seq = self.sequence;\n        }\n        var start = self_seq.indexOf(peptide);\n        for (var i = 0; i < peptide.length; i++) {\n            positions.push(start + i);\n        }\n        var results = self.getAminoAcidsByPosition(positions, layer);\n        if (results.length) {\n            results.addToLayer = function (layername, fraction, options) {\n                return results[0].addBoxOverlay(layername, results.length, fraction, options);\n            };\n        } else {\n            results.addToLayer = function () {};\n        }\n        return results;\n    };\n\n    clazz.prototype.win = function () {\n        if (this._container && this._container.ownerDocument && this._container.ownerDocument.defaultView) {\n            var return_val = this._container.ownerDocument.defaultView;\n            if (typeof return_val === 'object' && return_val.constructor !== Window) {\n                return_val = return_val[Object.keys(return_val)[0]];\n            }\n            return return_val;\n        }\n        return null;\n    };\n\n    clazz.prototype.setSequence = function (sequence) {\n        var new_sequence = this._cleanSequence(sequence);\n        if (new_sequence == this.sequence && new_sequence !== null) {\n            _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].fire(this, 'sequenceChange');\n            return;\n        }\n\n        if (!new_sequence) {\n            return;\n        }\n\n        this.sequence = new_sequence;\n\n        delete this.sequences;\n\n        var seq_chars = this.sequence.split('');\n        var line_length = seq_chars.length;\n\n        if (line_length === 0) {\n            return;\n        }\n\n        var renderer = this;\n\n        var build_sequence_els = function build_sequence_els() {\n            var seq_els = [];\n            renderer.sequence.split('').forEach(function (aa, i) {\n                var el = {};\n                el._index = i;\n                el._renderer = renderer;\n                renderer._extendElement(el);\n                el.amino_acid = aa;\n                seq_els.push(el);\n            });\n            renderer._sequence_els = seq_els;\n        };\n\n        build_sequence_els();\n\n        var RS = this._RS;\n\n        _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].remove(this, 'svgready');\n        _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].add(this, 'svgready', function (cnv) {\n            var canv = renderer._canvas;\n            canv.RS = RS;\n            canv.setAttribute('background', '#000000');\n            canv.setAttribute('preserveAspectRatio', 'xMinYMin meet');\n\n            var defs = canv.makeEl('defs');\n            renderer._container_canvas.appendChild(defs);\n\n            defs.appendChild(canv.make_gradient('track_shine', '0%', '100%', ['#111111', '#aaaaaa', '#111111'], [0.5, 0.5, 0.5]));\n            defs.appendChild(canv.make_gradient('simple_gradient', '0%', '100%', ['#aaaaaa', '#888888'], [1, 1]));\n            defs.appendChild(canv.make_gradient('left_fade', '100%', '0%', ['#ffffff', '#ffffff'], [1, 0]));\n            defs.appendChild(canv.make_gradient('right_fade', '100%', '0%', ['#ffffff', '#ffffff'], [0, 1]));\n            defs.appendChild(canv.make_gradient('red_3d', '0%', '100%', ['#CF0000', '#540000'], [1, 1]));\n\n            renderer.gradients = [];\n            renderer.add3dGradient = function (color) {\n                defs.appendChild(canv.make_gradient('grad_' + color, '0%', '100%', [color, '#ffffff', color], [1, 1, 1]));\n                renderer.gradients.push(color);\n            };\n\n            var shadow = canv.makeEl('filter', {\n                'id': 'drop_shadow',\n                'filterUnits': 'objectBoundingBox',\n                'x': '-50%',\n                'y': '-50%',\n                'width': '200%',\n                'height': '200%'\n            });\n\n            shadow.appendChild(canv.makeEl('feGaussianBlur', { 'in': 'SourceGraphic', 'stdDeviation': '4', 'result': 'blur_out' }));\n            shadow.appendChild(canv.makeEl('feOffset', { 'in': 'blur_out', 'result': 'the_shadow', 'dx': '3', 'dy': '1' }));\n            shadow.appendChild(canv.makeEl('feBlend', { 'in': 'SourceGraphic', 'in2': 'the_shadow', 'mode': 'normal' }));\n\n            defs.appendChild(shadow);\n            var link_icon = canv.makeEl('svg', {\n                'width': '100%',\n                'height': '100%',\n                'id': 'new_link_icon',\n                'viewBox': '0 0 100 100',\n                'preserveAspectRatio': 'xMinYMin meet'\n            });\n\n            defs.appendChild(link_icon);\n\n            link_icon.appendChild(canv.makeEl('rect', {\n                'x': '12.5',\n                'y': '37.5',\n                'stroke-width': '3',\n                'width': '50',\n                'height': '50',\n                'stroke': '#ffffff',\n                'fill': 'none'\n            }));\n            link_icon.appendChild(canv.makeEl('path', {\n                'd': 'M 50.0,16.7 L 83.3,16.7 L 83.3,50.0 L 79.2,56.2 L 68.8,39.6 L 43.8,66.7 L 33.3,56.2 L 60.4,31.2 L 43.8,20.8 L 50.0,16.7 z',\n                'stroke-width': '3',\n                'stroke': '#999999',\n                'fill': '#ffffff'\n            }));\n\n            var plus_icon = canv.makeEl('svg', {\n                'width': '100%',\n                'height': '100%',\n                'id': 'plus_icon',\n                'viewBox': '0 0 100 100',\n                'preserveAspectRatio': 'xMinYMin meet'\n            });\n            plus_icon.appendChild(canv.plus(0, 0, 100 / canv.RS));\n\n            defs.appendChild(plus_icon);\n\n            var minus_icon = canv.makeEl('svg', {\n                'width': '100%',\n                'height': '100%',\n                'id': 'minus_icon',\n                'viewBox': '0 0 100 100',\n                'preserveAspectRatio': 'xMinYMin meet'\n            });\n            minus_icon.appendChild(canv.minus(0, 0, 100 / canv.RS));\n\n            defs.appendChild(minus_icon);\n            var axis_pattern_id = 'axis_pattern_' + new Date().getTime();\n            var pattern = canv.makeEl('pattern', {\n                'patternUnits': 'userSpaceOnUse',\n                'x': '0',\n                'y': '0',\n                'width': 10 * canv.RS,\n                'height': 2 * canv.RS,\n                'id': axis_pattern_id\n            });\n            renderer.axis_pattern_id = axis_pattern_id;\n\n            var line = canv.makeEl('rect', {\n                'x': '0',\n                'y': '0',\n                'width': '10%',\n                'height': '1000%',\n                'fill': '#000',\n                'stroke': '0'\n            });\n            pattern.appendChild(line);\n\n            defs.appendChild(pattern);\n\n            var self = this;\n            renderer._axis_height = 10;\n            var aas = drawAminoAcids.call(self, canv);\n            renderer.hideAxis = function () {\n                drawAxis = function drawAxis(canv) {\n                    _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].add(canv, 'zoomChange', function () {\n                        self._axis_height = 10 / self.zoom;\n                    });\n                    return {};\n                };\n                self._axis_height = 10 / self.zoom;\n                this.redrawAxis();\n            };\n            renderer.showAxis = function () {\n                drawAxis = mainDrawAxis;\n                this.redrawAxis();\n            };\n\n            var axis = drawAxis.call(self, canv, line_length);\n            renderer.redrawAxis = function () {\n                _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].fire(axis, 'removed');\n                aas.forEach(function (aa) {\n                    if (aa.parentNode) {\n                        aa.parentNode.removeChild(aa);\n                    }\n                });\n                _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].fire(aas, 'removed');\n                axis = drawAxis.call(self, canv, renderer.sequence.length);\n                aas = drawAminoAcids.call(self, canv);\n\n                build_sequence_els();\n                renderer.refresh();\n            };\n            if (!renderer.hide_axis) {\n                this.showAxis();\n            } else {\n                this.hideAxis();\n            }\n\n            renderer._layer_containers = {};\n            renderer.enablePrintResizing();\n            renderer.enableScaling();\n            renderer.enableSelection();\n\n            // When we have a layer registered with the global MASCP object\n            // add a track within this renderer.\n            _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].add(_MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"], 'layerRegistered', function (layer, rend) {\n                if (!rend || rend === renderer) {\n                    renderer.addTrack(layer);\n                }\n            });\n\n            _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].fire(renderer, 'sequenceChange');\n        });\n        var canvas = createCanvasObject.call(this);\n        if (!this._canvas) {\n            if (typeof svgweb != 'undefined') {\n                svgweb.appendChild(canvas, this._container);\n            } else {\n                this._container.appendChild(canvas);\n            }\n        }\n\n        var rend = this;\n        this.EnableHighlights();\n\n        var seq_change_func = function seq_change_func(other_func) {\n            if (!rend._canvas) {\n                _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].add(rend, 'sequenceChange', function () {\n                    _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].remove(rend, 'sequenceChange', arguments.callee);\n                    other_func.apply();\n                });\n            } else {\n                other_func.apply();\n            }\n        };\n\n        seq_change_func.ready = function (other_func) {\n            this.call(this, other_func);\n        };\n\n        return seq_change_func;\n    };\n})(CondensedSequenceRenderer);\n\n(function () {\n    var svgns = 'http://www.w3.org/2000/svg';\n    var add_import = function add_import(ownerdoc) {\n        if (!ownerdoc.ELEMENT_NODE) {\n            ownerdoc.ELEMENT_NODE = 1;\n            ownerdoc.ATTRIBUTE_NODE = 2;\n            ownerdoc.TEXT_NODE = 3;\n            ownerdoc.CDATA_SECTION_NODE = 4;\n            ownerdoc.ENTITY_REFERENCE_NODE = 5;\n            ownerdoc.ENTITY_NODE = 6;\n            ownerdoc.PROCESSING_INSTRUCTION_NODE = 7;\n            ownerdoc.COMMENT_NODE = 8;\n            ownerdoc.DOCUMENT_NODE = 9;\n            ownerdoc.DOCUMENT_TYPE_NODE = 10;\n            ownerdoc.DOCUMENT_FRAGMENT_NODE = 11;\n            ownerdoc.NOTATION_NODE = 12;\n        }\n\n        ownerdoc._importNode = function (node, allChildren) {\n            switch (node.nodeType) {\n                case ownerdoc.ELEMENT_NODE:\n                    var newNode = ownerdoc.createElementNS(svgns, node.nodeName);\n                    /* does the node have any attributes to add? */\n                    if (node.attributes && node.attributes.length > 0) for (var i = 0, il = node.attributes.length; i < il;) {\n                        if (!/^on/.test(node.attributes[i].nodeName)) {\n                            newNode.setAttribute(node.attributes[i].nodeName, node.getAttribute(node.attributes[i++].nodeName));\n                        }\n                    }\n                    /* are we going after children too, and does the node have any? */\n                    if (allChildren && node.childNodes && node.childNodes.length > 0) for (var i = 0, il = node.childNodes.length; i < il;) {\n                        if (node.childNodes[i].nodeName !== 'USE' && node.childNodes[i].nodeName.toUpperCase() !== 'SCRIPT') {\n                            newNode.appendChild(ownerdoc._importNode(node.childNodes[i++], allChildren));\n                        }\n                    }\n                    return newNode;\n                    break;\n                case ownerdoc.TEXT_NODE:\n                case ownerdoc.CDATA_SECTION_NODE:\n                case ownerdoc.COMMENT_NODE:\n                    return ownerdoc.createTextNode(node.nodeValue);\n                    break;\n            }\n        };\n    };\n\n    var fix_child_links = function fix_child_links(node, prefix) {\n        if (node.childNodes && node.childNodes.length > 0) {\n            for (var i = 0, il = node.childNodes.length; i < il;) {\n                if (node.childNodes[i].nodeName.toUpperCase() === 'USE') {\n                    var linkval = node.childNodes[i].getAttribute('xlink:href');\n                    node.childNodes[i].setAttribute('xlink:href', linkval.replace(/^#/, '#' + prefix + '_'));\n                }\n                i++;\n            }\n        }\n    };\n\n    CondensedSequenceRenderer.prototype.importIcons = function (namespace, doc, alt_url) {\n        var new_owner = this._container_canvas.ownerDocument;\n        if (this._container_canvas.getElementById('defs_' + namespace)) {\n            return;\n        }\n        this._container_canvas.appendChild(new_owner.createElement('defs'));\n        this._container_canvas.lastChild.setAttribute('id', 'defs_' + namespace);\n        var defs_block = this._container_canvas.lastChild;\n\n        if (!new_owner._importNode) {\n            add_import(new_owner);\n        }\n        var ua = window.navigator.userAgent;\n        if (ua.indexOf('Edge/') >= 0) {\n            this.icons_failed = this.icons_failed || {};\n            this.icons_failed[namespace] = alt_url;\n            return;\n        }\n        var new_nodes = new_owner._importNode(doc, true);\n        if (typeof XPathResult !== 'undefined') {\n            var iterator = new_owner.evaluate('//svg:defs/*', new_nodes, function (ns) {\n                return svgns;\n            }, XPathResult.ANY_TYPE, null);\n            var el = iterator.iterateNext();\n            var to_append = [];\n            while (el) {\n                to_append.push(el);\n                el = iterator.iterateNext();\n            }\n            if (to_append.length === 0) {\n                this.icons_failed = this.icons_failed || {};\n                this.icons_failed[namespace] = alt_url;\n            }\n            to_append.forEach(function (el) {\n                el.setAttribute('id', namespace + '_' + el.getAttribute('id'));\n                fix_child_links(el, namespace);\n                defs_block.appendChild(el);\n            });\n        } else {\n            var els = new_nodes.querySelectorAll('defs > *');\n            for (var i = 0; i < els.length; i++) {\n                els[i].setAttribute('id', namespace + '_' + els[i].getAttribute('id'));\n                fix_child_links(el, namespace);\n                defs_block.appendChild(els[i]);\n            }\n        }\n    };\n})();\n\nCondensedSequenceRenderer.prototype.addValuesToLayer = function (layerName, values, options) {\n    var RS = this._RS;\n\n    var canvas = this._canvas;\n\n    if (!canvas) {\n        var orig_func = arguments.callee;\n        var self = this;\n        _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].add(this._renderer, 'sequencechange', function () {\n            _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].remove(this._renderer, 'sequencechange', arguments.callee);\n            orig_func.call(self, layerName, values);\n        });\n        log(\"Delaying rendering, waiting for sequence change\");\n        return;\n    }\n\n    var max_value;\n    var min_value;\n    var height_scale = 1;\n\n    options = options || {};\n\n    if (options.height) {\n        height_scale = options.height / this._layer_containers[layerName].track_height;\n    }\n\n    var offset_scale = 0;\n    if (options.offset) {\n        offset_scale = options.offset / this._layer_containers[layerName].track_height;\n    }\n    var recalculate_plot = function recalculate_plot(scale) {\n        var plot_path = ' m' + -0.5 * RS + ' 0';\n        var last_value = null;\n        values.forEach(function (value) {\n            if (typeof last_value == 'undefined') {} else {\n                plot_path += ' l' + RS + ' ' + -1 * RS * scale * height_scale * (value - last_value);\n            }\n            last_value = value;\n            if (isNaN(max_value) || value > max_value) {\n                max_value = value;\n            }\n            if (isNaN(min_value) || value < min_value) {\n                min_value = value;\n            }\n        });\n        return plot_path;\n    };\n    var plot = this._canvas.path('M0 0 M0 0 m0 ' + (max_value || 0) * RS + ' ' + recalculate_plot(1));\n    var abs_min_val = min_value;\n    var abs_max_val = max_value;\n    plot.setAttribute('stroke', options.color || '#ff0000');\n    plot.setAttribute('stroke-width', (options.thickness || 0.35) * RS);\n    plot.setAttribute('fill', 'none');\n    plot.setAttribute('visibility', 'hidden');\n    plot.setAttribute('pointer-events', 'none');\n    this._layer_containers[layerName].push(plot);\n    plot.setAttribute('transform', 'translate(1,10) scale(1,1)');\n    if (!options.hide_axis) {\n        var axis = this._canvas.path('M0 0 m0 ' + RS * ((max_value || 0) - (min_value || 0)) + ' l' + this._sequence_els.length * RS + ' 0');\n        axis.setAttribute('stroke-width', 0.2 * RS);\n        axis.setAttribute('visibility', 'hidden');\n        axis.setAttribute('transform', 'translate(1,0)');\n        axis.setAttribute('pointer-events', 'none');\n        axis.setHeight = function (height) {\n            if (abs_min_val < 0 && abs_max_val > 0) {\n                axis.setAttribute('d', 'M0 0 M0 0 m0 ' + height * offset_scale + ' m0 ' + 0.5 * height * height_scale + ' l' + renderer._sequence_els.length * RS + ' 0');\n            } else {\n                axis.setAttribute('d', 'M0 0 M0 0 m0 ' + height * offset_scale + ' m0 ' + 0.5 * (1 - abs_min_val) * height * height_scale + ' l' + renderer._sequence_els.length * RS + ' 0');\n            }\n            axis.setAttribute('stroke-width', 0.2 * RS / renderer.zoom);\n        };\n        this._layer_containers[layerName].push(axis);\n    }\n    var renderer = this;\n\n    if (options.label) {\n        var text = this._canvas.text(0, 0, options.label.max || options.label.min);\n        text.setAttribute('transform', 'translate(0,0)');\n        text.setAttribute('font-size', 4 * RS + 'pt');\n        text.setHeight = function (height) {\n            text.setAttribute('y', height * offset_scale);\n            text.setAttribute('font-size', 4 * RS / renderer.zoom + 'pt');\n        };\n        this._layer_containers[layerName].push(text);\n    }\n\n    plot.setHeight = function (height) {\n        var path_vals = recalculate_plot(0.5 * height / RS);\n        plot.setAttribute('d', 'M0 0 M0 0 m0 ' + height * offset_scale + ' m0 ' + 0.5 * height * height_scale + ' ' + path_vals);\n        plot.setAttribute('stroke-width', (options.thickness || 0.35) * RS / renderer.zoom);\n    };\n    return plot;\n};\n\n(function () {\n    var addElementToLayer = function addElementToLayer(layerName, opts) {\n        var canvas = this._renderer._canvas;\n\n        if (!canvas) {\n            var orig_func = arguments.callee;\n            var self = this;\n            _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].add(this._renderer, 'sequencechange', function () {\n                _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].remove(this._renderer, 'sequencechange', arguments.callee);\n                orig_func.call(self, layerName);\n            });\n            log(\"Delaying rendering, waiting for sequence change\");\n            return;\n        }\n\n        var tracer = null;\n        var tracer_marker = null;\n        var renderer = this._renderer;\n\n        if (!opts) {\n            opts = {};\n        }\n\n        var scale = 1;\n        if (opts.height) {\n            opts.height = parseFloat(opts.height);\n            if (typeof opts.height !== 'undefined' && opts.bare_element) {\n                opts.height *= 2;\n            }\n            scale = opts.height / this._renderer._layer_containers[layerName].track_height;\n            if (typeof opts.offset !== 'undefined') {\n                opts.offset = -1.25 - 1.25 + opts.offset / opts.height * 5; // ( -250/4 + (x / height) * 250 ) where 250 is growing marker height\n            }\n        }\n\n        var tracer_marker = canvas.growingMarker(0, 0, opts.content || layerName.charAt(0).toUpperCase(), opts);\n        tracer_marker.setAttribute('transform', 'translate(' + (this._index + 0.5) * this._renderer._RS + ',0.01) scale(' + scale + ')');\n        tracer_marker.setAttribute('height', '250');\n        tracer_marker.firstChild.setAttribute('transform', 'translate(-100,0) rotate(0,100,0.001)');\n        if (opts.break_viewbox) {\n            tracer_marker.container.removeAttribute('viewBox');\n            tracer_marker.container.setAttribute('width', '100%');\n            tracer_marker.container.setAttribute('height', '100%');\n        }\n        if (!opts.no_tracer) {\n\n            var bobble = canvas.circle(this._index + 0.5, 10, 0.25);\n            bobble.setAttribute('visibility', 'hidden');\n            bobble.style.opacity = '0.4';\n            tracer = canvas.rect(this._index + 0.5, 10, 0.05, 0);\n            tracer._index = this._index;\n            tracer.style.strokeWidth = '0';\n            tracer.style.fill = _MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"].layers[layerName].color;\n            tracer.setAttribute('visibility', 'hidden');\n            canvas.insertBefore(tracer, canvas.firstChild.nextSibling);\n            var renderer = this._renderer;\n\n            if (!this._renderer._layer_containers[layerName].tracers) {\n                this._renderer._layer_containers[layerName].tracers = canvas.set();\n            }\n            if (!canvas.tracers) {\n                canvas.tracers = canvas.set();\n                canvas._visibleTracers = function () {\n                    return renderer._visibleTracers();\n                };\n            }\n            tracer.setHeight = function (height) {\n                if (tracer.getAttribute('visibility') == 'hidden') {\n                    return;\n                }\n\n                var transform_attr = tracer_marker.getAttribute('transform');\n                var matches = /translate\\(.*[,\\s](.*)\\) scale\\((.*)\\)/.exec(transform_attr);\n                if (matches[1] && matches[2]) {\n                    var scale = parseFloat(matches[2]);\n                    var y = parseFloat(matches[1]);\n                    var new_height = y + scale * ((tracer_marker.offset || 0) * 50 + 125) - parseInt(this.getAttribute('y'));\n                    this.setAttribute('height', new_height < 0 ? 0 : new_height);\n                } else {\n                    this.setAttribute('height', height);\n                }\n            };\n            this._renderer._layer_containers[layerName].tracers.push(tracer);\n            this._renderer._layer_containers[layerName].tracers.push(bobble);\n            tracer.setAttribute('pointer-events', 'none');\n            bobble.setAttribute('pointer-events', 'none');\n            canvas.tracers.push(tracer);\n        }\n        if (typeof opts.offset == 'undefined' || opts.offset === null) {\n            // tracer_marker.offset = 2.5*this._renderer._layer_containers[layerName].track_height;\n        } else {\n            tracer_marker.offset = opts.offset;\n        }\n\n        // tracer_marker.setAttribute('transform','scale(0.5)');\n        // tracer_marker.zoom_level = 'text';\n        tracer_marker.setAttribute('visibility', 'hidden');\n\n        this._renderer._layer_containers[layerName].push(tracer_marker);\n        var result = [tracer, tracer_marker, bobble];\n        tracer_marker.setAttribute('class', layerName);\n        result.move = function (x, width) {\n            var transform_attr = tracer_marker.getAttribute('transform');\n            var matches = /translate\\(.*[,\\s](.*)\\) scale\\((.*)\\)/.exec(transform_attr);\n            if (matches[1] && matches[2]) {\n                tracer_marker.setAttribute('transform', 'translate(' + (x + 0.5) * renderer._RS + ',' + matches[1] + ') scale(' + matches[2] + ')');\n            }\n            if (tracer) {\n                tracer.move(x + 0.5, 0.05);\n                bobble.move(x + 0.5);\n            }\n        };\n        if (tracer) {\n            tracer_marker.tracer = tracer;\n            tracer_marker.bobble = bobble;\n        }\n        this._renderer._layer_containers[layerName].push(result);\n        return result;\n    };\n\n    var addBoxOverlayToElement = function addBoxOverlayToElement(layerName, width, fraction, opts) {\n\n        var canvas = this._renderer._canvas;\n        var renderer = this._renderer;\n        if (!opts) {\n            opts = {};\n        }\n        if (!canvas) {\n            var orig_func = arguments.callee;\n            var self = this;\n            _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].add(this._renderer, 'sequencechange', function () {\n                _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].remove(this._renderer, 'sequencechange', arguments.callee);\n                orig_func.call(self, layerName, width, opts);\n            });\n            log(\"Delaying rendering, waiting for sequence change\");\n            return;\n        }\n\n        var rect = canvas.rect(-0.25 + this._index, 60, width || 1, opts.height || 4, opts);\n        var rect_x = parseFloat(rect.getAttribute('x'));\n        var rect_max_x = rect_x + parseFloat(rect.getAttribute('width'));\n        var container = this._renderer._layer_containers[layerName];\n        if (typeof opts.merge !== 'undefined' && opts.merge) {\n            for (var i = 0; i < container.length; i++) {\n                if (container[i].value != fraction) {\n                    continue;\n                }\n                var el_x = parseFloat(container[i].getAttribute('x'));\n                var el_max_x = el_x + parseFloat(container[i].getAttribute('width'));\n                if (el_x <= rect_x && rect_x <= el_max_x || rect_x <= el_x && el_x <= rect_max_x) {\n                    container[i].setAttribute('x', \"\" + Math.min(el_x, rect_x));\n                    container[i].setAttribute('width', \"\" + (Math.max(el_max_x, rect_max_x) - Math.min(el_x, rect_x)));\n                    rect.parentNode.removeChild(rect);\n                    return container[i];\n                }\n            }\n        }\n        this._renderer._layer_containers[layerName].push(rect);\n        rect.setAttribute('class', layerName);\n        rect.setAttribute('visibility', 'hidden');\n        rect.setAttribute('stroke-width', '0px');\n        if (typeof fraction !== 'undefined') {\n            rect.setAttribute('opacity', fraction);\n            rect.value = fraction;\n        }\n        rect.setAttribute('fill', opts.fill || _MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"].layers[layerName].color);\n        rect.position_start = this._index;\n        rect.position_end = this._index + width;\n        if (typeof opts.offset !== \"undefined\" || opts.height_scale) {\n            var offset_val = opts.offset;\n            rect.setHeight = function (hght) {\n                var height_val = opts.height ? opts.height * renderer._RS / renderer.zoom : hght * (opts.height_scale || 1);\n                if (opts.align == 'bottom') {\n                    this.setAttribute('y', offset_val * renderer._RS / renderer.zoom - hght * (opts.height_scale || 1));\n                    this.setAttribute('height', height_val);\n                } else {\n                    this.setAttribute('y', offset_val * renderer._RS / renderer.zoom);\n                    this.setAttribute('height', height_val);\n                }\n            };\n        }\n        return rect;\n    };\n\n    var addTextToElement = function addTextToElement(layerName, width, opts) {\n        var canvas = this._renderer._canvas;\n        var renderer = this._renderer;\n        if (!canvas) {\n            var orig_func = arguments.callee;\n            var self = this;\n            _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].add(this._renderer, 'sequencechange', function () {\n                _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].remove(this._renderer, 'sequencechange', arguments.callee);\n                orig_func.call(self, layerName, width, opts);\n            });\n            log(\"Delaying rendering, waiting for sequence change\");\n            return;\n        }\n        if (!opts) {\n            opts = {};\n        }\n        if (opts.height) {\n            opts.height = opts.height * this._renderer._RS;\n        }\n        var height = opts.height || this._renderer._layer_containers[layerName].trackHeight || 4;\n        var position = this._index;\n        if (width > 1) {\n            position = position + Math.floor(0.5 * width);\n        }\n        var text_scale = 4 / 3;\n        var text = canvas.text(position, 0, opts.txt || opts.content || \"Text\");\n        text.setAttribute('font-size', text_scale * height);\n        text.cached_width = text.getComputedTextLength() / height;\n        text.setAttribute('font-weight', 'bolder');\n        text.setAttribute('fill', opts.fill || '#ffffff');\n        text.setAttribute('stroke', '#000000');\n        if (!(\"stroke_width\" in opts)) {\n            opts.stroke_width = 5;\n        }\n        text.setAttribute('stroke-width', opts.stroke_width + '');\n        text.setAttribute('style', 'font-family: ' + canvas.font_order);\n        text.firstChild.setAttribute('dy', '1.3ex');\n        text.setAttribute('text-anchor', 'middle');\n        if (opts.align) {\n            if (opts.align == \"left\") {\n                text.setAttribute('text-anchor', 'start');\n            }\n            if (opts.align == 'right') {\n                text.setAttribute('text-anchor', 'end');\n            }\n        }\n        if (width > 1) {\n            var clip = canvas.clipPath();\n            var mask = canvas.rect(-0.5 * width, opts.offset || 0, width, height);\n            clip.push(mask);\n            mask.removeAttribute('y');\n            var mask_id = 'id' + new Date().getTime() + \"_\" + clip.parentNode.childNodes.length;\n            clip.setAttribute('id', mask_id);\n            text.setAttribute('clip-path', 'url(#' + mask_id + ')');\n        }\n        if (typeof opts.offset !== 'undefined') {\n            text.setAttribute('transform', 'translate(' + text.getAttribute('x') + ',' + text.getAttribute('y') + ')');\n            text.offset = opts.offset;\n            text.setHeight = function (height) {\n                var top_offset = this.offset;\n                this.setAttribute('x', 0);\n                this.setAttribute('y', top_offset * renderer._RS / renderer.zoom);\n                if (mask) mask.setAttribute('y', this.getAttribute('y'));\n                this.setAttribute('stroke-width', 5 / renderer.zoom);\n                if (opts.height) {\n                    this.setAttribute('font-size', text_scale * opts.height / renderer.zoom);\n                    if (mask) mask.setAttribute('height', opts.height / renderer.zoom);\n                } else {\n                    this.setAttribute('font-size', text_scale * height);\n                    if (mask) mask.setAttribute('height', height);\n                }\n                // If we have a mask, we want to move the text to the left.\n                if (mask) {\n                    if (this.cached_width * height > width * 50) {\n                        this.setAttribute('x', -0.5 * width * 50);\n                        this.setAttribute('text-anchor', 'start');\n                    } else {\n                        this.setAttribute('x', '0');\n                        this.setAttribute('text-anchor', 'middle');\n                    }\n                } else {\n                    this.setAttribute('x', '0');\n                    this.setAttribute('text-anchor', 'middle');\n                }\n            };\n        } else {\n            text.setHeight = function (height) {\n                text.setAttribute('stroke-width', 5 / renderer.zoom);\n                if (opts.height) {\n                    text.setAttribute('font-size', text_scale * opts.height / renderer.zoom);\n                    if (mask) mask.setAttribute('height', opts.height / renderer.zoom);\n                } else {\n                    text.setAttribute('font-size', text_scale * height);\n                    if (mask) mask.setAttribute('height', height);\n                }\n            };\n        }\n        if (width > 1) {\n            text.move = function (new_x, new_width) {\n                if (mask) mask.setAttribute('x', -1 * new_width * renderer._RS * 0.5);\n                if (mask) mask.setAttribute('width', new_width * renderer._RS);\n                text.setAttribute('x', (new_x + parseInt(0.5 * new_width)) * renderer._RS);\n            };\n        }\n        this._renderer._layer_containers[layerName].push(text);\n        return text;\n    };\n\n    var addShapeToElement = function addShapeToElement(layerName, width, opts) {\n        var canvas = this._renderer._canvas;\n        var renderer = this._renderer;\n\n        if (!canvas) {\n            var orig_func = arguments.callee;\n            var self = this;\n            _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].add(this._renderer, 'sequencechange', function () {\n                _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].remove(this._renderer, 'sequencechange', arguments.callee);\n                orig_func.call(self, layerName, width, opts);\n            });\n            log(\"Delaying rendering, waiting for sequence change\");\n            return;\n        }\n\n        var methods = {\n            \"pentagon\": canvas.pentagon,\n            \"hexagon\": canvas.hexagon,\n            \"rectangle\": canvas.rect,\n            \"ellipse\": canvas.ellipticalRect,\n            \"roundrect\": function roundrect(x, y, width, height) {\n                return canvas.roundRect(x, y, width, height, 0.25 * height);\n            }\n        };\n        if (!opts.rotate) {\n            opts.rotate = 0;\n        }\n        var shape = null;\n        var shape_name = (opts.shape.split('-') || '')[0];\n        if (shape_name in methods) {\n            var is_rotated = opts.shape.split('-')[1];\n            if (is_rotated == 'left' && !opts.rotate) {\n                opts.rotate = 90;\n            }\n            if (is_rotated == 'right' && !opts.rotate) {\n                opts.rotate = 270;\n            }\n            if (is_rotated == 'flip' && !opts.rotate) {\n                opts.rotate = 180;\n            }\n            shape = methods[shape_name].call(canvas, this._index, 60, width || 1, opts.height || 4, opts.rotate);\n        } else {\n            return;\n        }\n        if (typeof opts.offset !== 'undefined') {\n            var x_pos = shape.getAttribute('x');\n            var y_pos = shape.getAttribute('y');\n            shape.setAttribute('transform', 'translate(' + x_pos + ',' + y_pos + ')');\n            shape.setAttribute('x', '0');\n            var offset_val = opts.offset || 0;\n            var orig_height = opts.height || 4;\n            shape.setAttribute('y', offset_val * this._renderer._RS);\n            shape.setHeight = function (height) {\n                if (!this._orig_stroke_width) {\n                    this._orig_stroke_width = parseInt(this.getAttribute('stroke-width'));\n                }\n                shape.setAttribute('y', offset_val * renderer._RS / renderer.zoom);\n                shape.setAttribute('height', orig_height * renderer._RS / renderer.zoom);\n                shape.setAttribute('stroke-width', this._orig_stroke_width / renderer.zoom);\n                if (opts.shape == 'ellipse') {\n                    shape.setAttribute('ry', 0.5 * (orig_height * renderer._RS) / renderer.zoom);\n                }\n                if (opts.shape == 'roundrect') {\n                    shape.setAttribute('rx', 0.25 * (orig_height * renderer._RS) / renderer.zoom);\n                    shape.setAttribute('ry', 0.25 * (orig_height * renderer._RS) / renderer.zoom);\n                }\n            };\n            shape.move = function (new_x, new_width) {\n                var transform_attr = this.getAttribute('transform');\n                var matches = /translate\\(.*[,\\s](.*)\\)/.exec(transform_attr);\n                if (matches[1]) {\n                    this.setAttribute('transform', 'translate(' + new_x * renderer._RS + ',' + matches[1] + ')');\n                }\n                this.setAttribute('width', new_width * renderer._RS);\n            };\n        }\n\n        if (typeof opts.offset !== 'undefined' && (opts.shape == \"hexagon\" || opts.shape == \"pentagon\")) {\n            var offset_val = opts.offset || 0;\n            var orig_height = opts.height || 4;\n            var adjustment_g = canvas.group();\n            adjustment_g.setAttribute('transform', shape.getAttribute('transform'));\n            adjustment_g.push(shape);\n            shape.setAttribute('transform', 'translate(0,0)');\n            adjustment_g.setHeight = function (height) {\n                if (!shape._orig_stroke_width) {\n                    shape._orig_stroke_width = parseInt(shape.getAttribute('stroke-width')) || 0;\n                }\n                shape.setHeight(orig_height * renderer._RS / renderer.zoom);\n                shape.setAttribute('stroke-width', this._orig_stroke_width / renderer.zoom);\n                shape.setAttribute('transform', 'translate(0,0)');\n            };\n            this._renderer._layer_containers[layerName].push(adjustment_g);\n            adjustment_g.setAttribute('visibility', 'hidden');\n            adjustment_g.setAttribute('class', layerName);\n            adjustment_g.position_start = this._index;\n            adjustment_g.position_end = this._index + width;\n        } else {\n            this._renderer._layer_containers[layerName].push(shape);\n            shape.setAttribute('visibility', 'hidden');\n            shape.setAttribute('class', layerName);\n            shape.position_start = this._index;\n            shape.position_end = this._index + width;\n        }\n        shape.setAttribute('fill', opts.fill || _MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"].layers[layerName].color);\n        if (opts.stroke) {\n            shape.setAttribute('stroke', opts.stroke);\n        }\n        if (opts.stroke_width) {\n            shape.setAttribute('stroke-width', renderer._RS * opts.stroke_width);\n        } else {\n            shape.style.strokeWidth = '0';\n        }\n        return shape;\n    };\n\n    var addElementToLayerWithLink = function addElementToLayerWithLink(layerName, url, width) {\n        var canvas = this._renderer._canvas;\n\n        if (!canvas) {\n            var orig_func = arguments.callee;\n            var self = this;\n            _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].add(this._renderer, 'sequencechange', function () {\n                _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].remove(this._renderer, 'sequencechange', arguments.callee);\n                orig_func.call(self, layerName, url, width);\n            });\n            log(\"Delaying rendering, waiting for sequence change\");\n            return;\n        }\n\n        var rect = canvas.rect(-0.25 + this._index, 60, width || 1, 4);\n        this._renderer._layer_containers[layerName].push(rect);\n        rect.style.strokeWidth = '0px';\n        rect.setAttribute('fill', _MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"].layers[layerName].color);\n        rect.setAttribute('visibility', 'hidden');\n        rect.setAttribute('class', layerName);\n        return rect;\n    };\n\n    var addCalloutToLayer = function addCalloutToLayer(layerName, element, opts) {\n        var canvas = this._renderer._canvas;\n\n        var renderer = this._renderer;\n\n        if (typeof element == 'string') {\n            var a_el = document.createElement('div');\n            renderer.fillTemplate(element, opts, function (err, el) {\n                a_el.innerHTML = el;\n            });\n            element = a_el;\n        }\n\n        if (!canvas) {\n            var orig_func = arguments.callee;\n            var self = this;\n            _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].add(this._renderer, 'sequencechange', function () {\n                _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].remove(this._renderer, 'sequencechange', arguments.callee);\n                orig_func.call(self, layerName, width, opts);\n            });\n            log(\"Delaying rendering, waiting for sequence change\");\n            return;\n        }\n        var callout = canvas.callout(this._index + 0.5, 0.01, element, { 'width': 10 * opts.width || 100, 'height': opts.height * 10 || 100, 'align': opts.align, 'font-size': opts['font-size'] });\n        callout.setHeight(opts.height * this._renderer._RS);\n        this._renderer._canvas_callout_padding = Math.max(10 * opts.height || 100, this._renderer._canvas_callout_padding || 0);\n        this._renderer._layer_containers[layerName].push(callout);\n        callout.clear = function () {\n            var cont = renderer._layer_containers[layerName];\n            if (cont.indexOf(callout) > 0) {\n                cont.splice(cont.indexOf(callout), 1);\n            }\n            callout.parentNode.removeChild(callout);\n        };\n        return callout;\n    };\n\n    var scaledAddShapeOverlay = function scaledAddShapeOverlay(layername, width, opts) {\n        var start = this._index;\n        var end = Math.abs(this._renderer.scalePosition(this.original_index + width, layername)) - 1;\n        var res = addShapeToElement.call(start < end ? this : this._renderer._sequence_els[end], layername, Math.abs(end - start), opts);\n        res.aa = this.original_index;\n        res.aa_width = width;\n        return res;\n    };\n\n    var scaledAddBoxOverlay = function scaledAddBoxOverlay(layername, width, fraction, opts) {\n        var start = this._index;\n        var end = Math.abs(this._renderer.scalePosition(this.original_index + width, layername)) - 1;\n\n        var res = addBoxOverlayToElement.call(start < end ? this : this._renderer._sequence_els[end], layername, Math.abs(end - start), fraction, opts);\n\n        if (!(opts || {}).merge) {\n            res.aa_width = width;\n            res.aa = this.original_index;\n        } else {\n            res.aa_width = parseInt(res.getAttribute('width')) / this._renderer._RS;\n            if (res.aa_width == width) {\n                res.aa = this.original_index;\n            }\n        }\n        return res;\n    };\n\n    var scaledAddTextOverlay = function scaledAddTextOverlay(layername, width, opts) {\n        var start = this._index;\n        var end = Math.abs(this._renderer.scalePosition(this.original_index + width, layername)) - 1;\n        var res = addTextToElement.call(start < end ? this : this._renderer._sequence_els[end], layername, Math.abs(end - start), opts);\n        res.aa = this.original_index;\n        res.aa_width = width;\n        return res;\n    };\n\n    var scaledAddToLayerWithLink = function scaledAddToLayerWithLink(layername, url, width) {\n        var start = this._index;\n        var end = Math.abs(this._renderer.scalePosition(this.original_index + width, layername)) - 1;\n        var res = addElementToLayerWithLink.call(start < end ? this : this._renderer._sequence_els[end], layername, url, Math.abs(end - start));\n        res.aa = this.original_index;\n        return res;\n    };\n\n    var scaledAddToLayer = function scaledAddToLayer(layername, opts) {\n        var res = addElementToLayer.call(this, layername, opts);\n        res.aa = this.original_index;\n        res.aa_width = 1;\n        return res;\n    };\n\n    CondensedSequenceRenderer.prototype.enableScaling = function () {\n        _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].add(this, 'readerRegistered', function (reader) {\n            console.log('Enabling scaling for legacy readers');\n            var old_result = reader.gotResult;\n            var renderer = this;\n            reader.gotResult = function () {\n                var wanted_id = reader.acc || reader.agi || \"\";\n\n                var old_get_aas = CondensedSequenceRenderer.prototype.getAminoAcidsByPosition;\n                var old_get_pep = CondensedSequenceRenderer.prototype.getAminoAcidsByPeptide;\n                var old_sequence = renderer.sequence;\n                if (renderer.sequences) {\n                    renderer.sequence = (renderer.sequences[renderer.sequences.map(function (seq) {\n                        return (seq.agi || seq.acc || \"\").toLowerCase();\n                    }).indexOf(wanted_id.toLowerCase())] || \"\").toString();\n                } else {\n                    old_sequence = null;\n                }\n                renderer.getAminoAcidsByPosition = function (aas, lay, accession) {\n                    if (!lay && !accession) {\n                        console.log('Guessing scaling identifier as', wanted_id);\n                    }\n                    return old_get_aas.call(this, aas, lay || wanted_id, accession || wanted_id);\n                };\n                renderer.getAminoAcidsByPeptide = function (peptide, lay, accession) {\n                    if (!lay && !accession) {\n                        console.log('Guessing scaling identifier as', wanted_id);\n                    }\n                    return old_get_pep.call(this, peptide, lay || wanted_id, accession || wanted_id);\n                };\n                old_result.call(reader);\n\n                if (old_sequence) {\n                    renderer.sequence = old_sequence;\n                }\n\n                renderer.getAminoAcidsByPosition = old_get_aas;\n                renderer.getAminoAcidsByPeptide = old_get_pep;\n            };\n        });\n    };\n\n    CondensedSequenceRenderer.prototype._extendElement = function (el) {\n        el.addToLayer = scaledAddToLayer;\n        el.addBoxOverlay = scaledAddBoxOverlay;\n        el.addShapeOverlay = scaledAddShapeOverlay;\n        el.addTextOverlay = scaledAddTextOverlay;\n        el.addToLayerWithLink = scaledAddToLayerWithLink;\n        el.callout = addCalloutToLayer;\n        el['_renderer'] = this;\n    };\n\n    CondensedSequenceRenderer.prototype.remove = function (lay, el) {\n        if (!el) {\n            return false;\n        }\n        if (this._layer_containers[lay] && this._layer_containers[lay].indexOf(el) >= 0) {\n            this._layer_containers[lay].splice(this._layer_containers[lay].indexOf(el), 1);\n            _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].fire(el, 'removed');\n            if (el.parentNode) {\n                el.parentNode.removeChild(el);\n            }\n            if (el.tracer && el.tracer.parentNode) {\n                el.tracer.parentNode.removeChild(el.tracer);\n            }\n            if (el.bobble && el.bobble.parentNode) {\n                el.bobble.parentNode.removeChild(el.bobble);\n            }\n            return true;\n        }\n        return false;\n    };\n\n    var mark_groups = function mark_groups(renderer, objects) {\n        var group = [];\n        var new_objects = [];\n        for (i = 0; i < objects.length; i++) {\n            var current = objects[i],\n                next = null;\n            if (!current) {\n                continue;\n            }\n            if (objects[i + 1]) {\n                next = objects[i + 1];\n            }\n            if (!next || parseInt(next.aa) - parseInt(current.aa) > 10 || renderer.sequence.substring(current, next - 1).match(/[ST]/)) {\n                if (group.length < 3) {\n                    group.push(current);\n                } else {\n                    group.push(current);\n                    group.forEach(function (site) {\n                        site.options.zoom_level = 'text';\n                    });\n                    var coalesce_options = group[0].coalesce || objects[0].coalesce;\n                    new_objects.push({\n                        'aa': group[0].aa,\n                        'type': 'shape',\n                        'width': parseInt(current.aa) - parseInt(group[0].aa) + 1,\n                        'options': { 'zoom_level': 'summary',\n                            'shape': 'roundrect',\n                            'fill': coalesce_options.fill,\n                            'stroke': coalesce_options.stroke,\n                            'stroke_width': coalesce_options.stroke_width,\n                            'height': group[0].options.height,\n                            'offset': group[0].options.offset\n                        }\n                    });\n                }\n                group = [];\n            } else {\n                group.push(current);\n            }\n        }\n        new_objects.forEach(function (obj) {\n            objects.push(obj);\n        });\n    };\n\n    CondensedSequenceRenderer.prototype.fix_icons = function (icon_ref) {\n        if (!this.icons_failed) {\n            return icon_ref;\n        }\n        if (typeof icon_ref === 'string') {\n            var vals = icon_ref.split('_');\n            if (vals[0] && this.icons_failed[vals[0].replace('#', '')]) {\n                vals[0] = this.icons_failed[vals[0].replace('#', '')] + '#';\n                var start = vals.shift();\n                console.log(icon_ref, start + vals.join('_'));\n                return start + vals.join('_');\n            }\n        }\n        return icon_ref;\n    };\n\n    CondensedSequenceRenderer.prototype.renderObjects = function (track, objects) {\n        var renderer = this;\n        if (objects.length > 0 && objects[0].coalesce) {\n            mark_groups(renderer, objects);\n        }\n        var results = [];\n        objects.forEach(function (object) {\n            var potential_height = object.options ? (object.options.height || renderer._layer_containers[track].track_height) + (object.options.offset + object.options.height || 0) : 0;\n            if (object.options && potential_height > renderer._layer_containers[track].track_height) {\n                var new_height = renderer._layer_containers[track].track_height + object.options.offset + (object.options.height || renderer._layer_containers[track].track_height);\n                if ((renderer._layer_containers[track].fixed_track_height || 0) < new_height) {\n                    renderer._layer_containers[track].fixed_track_height = new_height;\n                }\n            }\n\n            var click_reveal;\n            var rendered;\n            if (object.aa && !renderer.getAA(parseInt(object.aa), track)) {\n                return;\n            }\n            if (typeof object.aa !== 'undefined' && isNaN(object.aa)) {\n                return;\n            }\n            if (object.type == \"text\") {\n                if (object.aa) {\n                    if (object.width) {\n                        rendered = renderer.getAA(parseInt(object.aa), track).addTextOverlay(track, object.width, object.options);\n                    } else {\n                        rendered = renderer.getAA(parseInt(object.aa), track).addTextOverlay(track, 1, object.options);\n                    }\n                } else if (object.peptide) {\n                    rendered = renderer.getAminoAcidsByPeptide(object.peptide, track).addTextOverlay(track, 1, object.options);\n                }\n            }\n            if (object.type === \"box\") {\n                if (object.aa) {\n                    rendered = renderer.getAA(parseInt(object.aa), track).addBoxOverlay(track, parseInt(object.width), 1, object.options);\n                } else if (object.peptide) {\n                    rendered = renderer.getAminoAcidsByPeptide(object.peptide, track).addToLayer(track, 1, object.options);\n                }\n            }\n            if (object.type == \"shape\") {\n                if (object.aa) {\n                    rendered = renderer.getAA(parseInt(object.aa), track).addShapeOverlay(track, parseInt(object.width), object.options);\n                } else if (object.peptide) {\n                    rendered = renderer.getAminoAcidsByPeptide(object.peptide, track)[0].addShapeOverlay(track, object.peptide.length, object.options);\n                }\n            }\n            if (object.type == 'line') {\n                rendered = renderer.addValuesToLayer(track, object.values, object.options);\n            }\n            if (object.type == \"marker\") {\n                var content = (object.options || {}).content;\n                var wanted_height = object.options.height;\n\n                if (Array.isArray && Array.isArray(content)) {\n                    var cloned_options_array = {};\n                    for (var key in object.options) {\n                        if (object.options.hasOwnProperty(key)) {\n                            cloned_options_array[key] = object.options[key];\n                        }\n                    }\n                    if (object.options.content && Array.isArray(content_data)) {\n                        cloned_options_array.content = object.options.content.map(renderer.fix_icons.bind(renderer));\n                    }\n\n                    click_reveal = renderer.getAA(parseInt(object.aa), track).addToLayer(track, cloned_options_array);\n                    click_reveal = click_reveal[1];\n                    click_reveal.style.display = 'none';\n                    object.options.content = object.options.alt_content;\n                    content = object.options.content;\n                }\n                if (typeof content == 'object') {\n                    var content_el;\n                    if (content.type == \"circle\") {\n                        content_el = renderer._canvas.circle(-0.5, -0.5, 1, 1);\n                    }\n                    if (content.type == 'text_circle') {\n                        content_el = renderer._canvas.text_circle(0.5, 0.5, 1, content.text, content.options || {});\n                        object.options.break_viewbox = true;\n                    }\n                    if (content.type == \"left_triangle\") {\n                        content_el = renderer._canvas.poly('-100,0 0,-100 0,100');\n                    }\n                    if (content.type == \"right_triangle\") {\n                        content_el = renderer._canvas.poly('0,100 100,0 0,-100');\n                    }\n\n                    [\"fill\", \"stroke\", \"stroke-width\", \"fill-opacity\", \"stroke-opacity\", \"opacity\"].forEach(function (prop) {\n                        if (content[prop]) {\n                            content_el.setAttribute(prop, content[prop]);\n                        }\n                    });\n                    object.options.content = content_el;\n                }\n                var cloned_options = {};\n                for (var key in object.options) {\n                    if (object.options.hasOwnProperty(key)) {\n                        cloned_options[key] = object.options[key];\n                    }\n                }\n                var content_data = (object.options || {}).content;\n                if (content_data && typeof content_data === 'string') {\n                    cloned_options.content = renderer.fix_icons(content_data);\n                }\n                if (content_data && Array.isArray(content_data)) {\n                    cloned_options.content = content_data.map(renderer.fix_icons.bind(renderer));\n                }\n                var added = renderer.getAA(parseInt(object.aa), track).addToLayer(track, cloned_options);\n                if (click_reveal) {\n\n                    click_reveal.toggleReveal = function (ev) {\n                        ev.stopPropagation();\n                        if (this.style.display === 'none') {\n                            this.parentNode.appendChild(this);\n                            this.style.display = 'block';\n                        } else {\n                            this.style.display = 'none';\n                        }\n                        renderer.refresh();\n                    };\n                    added[1].addEventListener('touchstart', click_reveal.toggleReveal.bind(click_reveal), true);\n                    added[1].addEventListener('click', click_reveal.toggleReveal.bind(click_reveal), false);\n                }\n                rendered = added[1];\n            }\n            if ((object.options || {}).zoom_level) {\n                rendered.zoom_level = object.options.zoom_level;\n            }\n            if (object.identifier) {\n                rendered.setAttribute('identifier', object.identifier);\n            }\n            if ((object.options || {}).events && rendered) {\n                object.options.events.forEach(function (ev) {\n                    (ev.type || \"\").split(\",\").forEach(function (evtype) {\n                        if (evtype == 'click' && rendered.style) {\n                            rendered.style.cursor = 'pointer';\n                        }\n                        rendered.addEventListener(evtype, function (e) {\n                            e.event_data = ev.data;\n                            e.layer = track;\n                            e.aa = object.aa;\n                        });\n                    });\n                });\n            }\n            results.push(rendered);\n        });\n        return results;\n    };\n\n    CondensedSequenceRenderer.prototype.addTextTrack = function (seq, container) {\n        var RS = this._RS;\n        var renderer = this;\n        var max_length = 300;\n        var canvas = renderer._canvas;\n        var seq_chars = seq.split('');\n\n        var amino_acids = canvas.set();\n        var amino_acids_shown = false;\n        var x = 0;\n\n        var has_textLength = true;\n        var no_op = function no_op() {};\n        try {\n            var test_el = document.createElementNS(svgns, 'text');\n            test_el.setAttribute('textLength', 10);\n            no_op(test_el.textLength);\n        } catch (e) {\n            has_textLength = false;\n        }\n\n        /* We used to test to see if there was a touch event\n           when doing the textLength method of amino acid\n           layout, but iOS seems to support this now.\n           \n           Test case for textLength can be found here\n           \n           http://jsfiddle.net/nkmLu/11/embedded/result/\n        */\n\n        /* We also need to test for support for adjusting textLength\n           while also adjusting the dx value. Internet Explorer 10\n           squeezes text when setting a dx value as well as a textLength.\n           I.e. the right-most position of the character is calculated to\n           be x + textLength, rather than x + dx + textLength.\n         */\n\n        var supports_dx = false;\n        if (typeof _MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"].supports_dx !== 'undefined') {\n            supports_dx = _MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"].supports_dx;\n        } else {\n            (function (supports_textLength) {\n                if (!supports_textLength) {\n                    supports_dx = false;\n                    return;\n                }\n                var test_el = document.createElementNS(svgns, 'text');\n                test_el.setAttribute('textLength', 30);\n\n                if (!test_el.getExtentOfChar) {\n                    return;\n                }\n                test_el.setAttribute('x', '0');\n                test_el.setAttribute('y', '0');\n                test_el.textContent = 'ABC';\n                canvas.appendChild(test_el);\n                var extent = test_el.getExtentOfChar(2).x;\n                test_el.setAttribute('dx', '10');\n                if (Math.abs(test_el.getExtentOfChar(2).x - extent) < 9.5) {\n                    supports_dx = false;\n                } else {\n                    supports_dx = true;\n                }\n                _MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"].supports_dx = supports_dx;\n                test_el.parentNode.removeChild(test_el);\n            })(has_textLength);\n        }\n\n        var a_text;\n\n        if (has_textLength && 'lengthAdjust' in document.createElementNS(svgns, 'text') && 'textLength' in document.createElementNS(svgns, 'text')) {\n            if (seq.length <= max_length) {\n                a_text = canvas.text(0, 12, document.createTextNode(seq));\n                a_text.setAttribute('textLength', RS * seq.length);\n            } else {\n                a_text = canvas.text(0, 12, document.createTextNode(seq.substr(0, max_length)));\n                a_text.setAttribute('textLength', RS * max_length);\n            }\n            canvas.insertBefore(a_text, canvas.firstChild.nextSibling);\n\n            a_text.style.fontFamily = \"'Lucida Console', 'Courier New', Monaco, monospace\";\n            a_text.setAttribute('lengthAdjust', 'spacing');\n            a_text.setAttribute('text-anchor', 'start');\n            a_text.setAttribute('dx', 5);\n            a_text.setAttribute('dy', '1.5ex');\n            a_text.setAttribute('font-size', RS);\n            a_text.setAttribute('fill', '#000000');\n            amino_acids.push(a_text);\n            container.push(a_text);\n        } else {\n            for (var i = 0; i < seq_chars.length; i++) {\n                a_text = canvas.text(x, 12, seq_chars[i]);\n                a_text.firstChild.setAttribute('dy', '1.5ex');\n                amino_acids.push(a_text);\n                container.push(a_text);\n                a_text.style.fontFamily = \"'Lucida Console', Monaco, monospace\";\n                x += 1;\n            }\n            amino_acids.attr({ 'width': RS, 'text-anchor': 'start', 'height': RS, 'font-size': RS, 'fill': '#000000' });\n        }\n        var update_sequence = function update_sequence() {\n            if (seq.length <= max_length) {\n                return;\n            }\n            var container_width = renderer._container_canvas.parentNode.cached_width;\n            if (!container_width) {\n                container_width = renderer._container_canvas.parentNode.getBoundingClientRect().width;\n                var docwidth = document.documentElement.clientWidth;\n                if (docwidth > container_width) {\n                    container_width = docwidth;\n                }\n            }\n            let max_size = Math.ceil(10 * container_width * renderer.zoom / RS);\n            if (max_size > seq.length) {\n                max_size = seq.length;\n            }\n\n            a_text.setAttribute('textLength', RS * max_size);\n\n            var start = parseInt(renderer.leftVisibleResidue());\n            start -= 50;\n            if (start < 0) {\n                start = 0;\n            }\n            if (start + max_size >= seq.length) {\n                start = seq.length - max_size;\n                if (start < 0) {\n                    start = 0;\n                }\n            }\n            a_text.replaceChild(document.createTextNode(seq.substr(start, max_size)), a_text.firstChild);\n            a_text.setAttribute(supports_dx ? 'dx' : 'x', 5 + start * RS);\n        };\n        var panstart = function panstart() {\n            if (amino_acids_shown) {\n                amino_acids.attr({ 'display': 'none' });\n            }\n        };\n        var panend = function panend() {\n            if (amino_acids_shown) {\n                amino_acids.attr({ 'display': 'block' });\n                update_sequence();\n            }\n        };\n        var zoomchange = function zoomchange() {\n            if (canvas.zoom > 3.6) {\n                amino_acids.attr({ 'display': 'block' });\n                amino_acids_shown = true;\n                update_sequence();\n            } else if (canvas.zoom > 0.2) {\n                amino_acids.attr({ 'display': 'none' });\n                amino_acids_shown = false;\n            } else {\n                amino_acids.attr({ 'display': 'none' });\n                amino_acids_shown = false;\n            }\n        };\n        if (!container.panevents) {\n            canvas.addEventListener('panstart', panstart, false);\n            _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].add(canvas, 'panend', panend);\n            container.panevents = true;\n        }\n\n        _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].add(canvas, 'zoomChange', zoomchange, false);\n        _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].add(amino_acids[0], 'removed', function () {\n            canvas.removeEventListener('panstart', panstart);\n            _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].remove(canvas, 'panend', panend);\n            _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].remove(canvas, 'zoomChange', zoomchange);\n            delete container.panevents;\n        });\n        return amino_acids;\n    };\n\n    CondensedSequenceRenderer.prototype.renderTextTrack = function (lay, in_text) {\n        var layerName = lay;\n        if (typeof layerName !== 'string') {\n            layerName = lay.name;\n        }\n        var canvas = this._canvas;\n        if (!canvas || typeof layerName == 'undefined') {\n            return;\n        }\n        var renderer = this;\n        var container = this._layer_containers[layerName];\n        var result = this.addTextTrack(in_text, container);\n        return result;\n    };\n})();\n\nCondensedSequenceRenderer.prototype.EnableHighlights = function () {\n    var renderer = this;\n    var highlights = [];\n    var createNewHighlight = function createNewHighlight() {\n        var highlight = renderer._canvas.rect(0, 0, 0, '100%');\n        highlight.setAttribute('fill', '#ffdddd');\n        highlight.removeAttribute('stroke');\n        var pnode = highlight.parentNode;\n        pnode.insertBefore(highlight, pnode.firstChild.nextSibling);\n        highlights.push(highlight);\n    };\n    createNewHighlight();\n\n    renderer.moveHighlight = function () {\n        var vals = Array.prototype.slice.call(arguments);\n        var RS = this._RS;\n        var i = 0,\n            idx = 0;\n        for (i = 0; i < vals.length; i += 2) {\n            var from = vals[i];\n            var to = vals[i + 1];\n            var highlight = highlights[idx];\n            if (!highlight) {\n                createNewHighlight();\n                highlight = highlights[idx];\n            }\n            if (highlight.previousSibling.previousSibling && highlights.indexOf(highlight.previousSibling.previousSibling) < 0) {\n                highlight.parentNode.insertBefore(highlight, highlight.parentNode.firstChild.nextSibling);\n            }\n            highlight.setAttribute('x', (from - 1) * RS);\n            highlight.setAttribute('width', (to - (from - 1)) * RS);\n            highlight.setAttribute('visibility', 'visible');\n            idx += 1;\n        }\n        for (i = idx; i < highlights.length; i++) {\n            highlights[i].setAttribute('visibility', 'hidden');\n        }\n    };\n};\n\n(function () {\n\n    var bindClick = function bindClick(element, handler) {\n        if (\"ontouchstart\" in window) {\n            element.addEventListener('touchstart', function (ev) {\n                var startX = ev.touches[0].clientX;\n                var startY = ev.touches[0].clientY;\n                var reset = function reset() {\n                    document.body.removeEventListener('touchmove', move);\n                    element.removeEventListener('touchend', end);\n                };\n                var end = function end(ev) {\n                    reset();\n                    ev.stopPropagation();\n                    ev.preventDefault();\n                    if (handler) {\n                        handler.call(null, ev);\n                    }\n                };\n                var move = function move(ev) {\n                    if (Math.abs(ev.touches[0].clientX - startX) > 10 || Math.abs(ev.touches[0].clientY - startY) > 10) {\n                        reset();\n                    }\n                };\n                //FIXME - PASSIVE\n                document.body.addEventListener('touchmove', move, { passive: true });\n                element.addEventListener('touchend', end, false);\n            }, { passive: true });\n            //FIXME - PASSIVE\n        } else {\n            element.addEventListener('click', handler, false);\n        }\n    };\n\n    var mousePosition = function mousePosition(evt) {\n        var posx = 0;\n        var posy = 0;\n        if (!evt) {\n            evt = window.event;\n        }\n\n        if (evt.pageX || evt.pageY) {\n            posx = evt.pageX - (document.body.scrollLeft + document.documentElement.scrollLeft);\n            posy = evt.pageY - (document.body.scrollTop + document.documentElement.scrollTop);\n        } else if (evt.clientX || evt.clientY) {\n            posx = evt.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;\n            posy = evt.clientY + document.body.scrollTop + document.documentElement.scrollTop;\n        }\n        if (self.targetElement) {\n            posx = evt.screenX;\n            posy = evt.screenY;\n        }\n        return [posx, posy];\n    };\n\n    var svgPosition = function svgPosition(ev, svgel) {\n        var positions = mousePosition(ev.changedTouches ? ev.changedTouches[0] : ev);\n        var p = {};\n        if (svgel.nodeName == 'svg') {\n            p = svgel.createSVGPoint();\n            var rootCTM = svgel.getScreenCTM();\n            p.x = positions[0];\n            p.y = positions[1];\n\n            self.matrix = rootCTM.inverse();\n            p = p.matrixTransform(self.matrix);\n        } else {\n            p.x = positions[0];\n            p.y = positions[1];\n        }\n        return p;\n    };\n\n    var notifySelectionToLayers = function notifySelectionToLayers(start, end, renderer) {\n        for (var layname in _MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"].layers) {\n            var lay = _MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getLayer(layname);\n            if (start && end) {\n                _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].fire(lay, 'selection', [renderer.scalePosition(start, layname, true), renderer.scalePosition(end, layname, true)]);\n            } else {\n                _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].fire(lay, 'selection', [null, null]);\n            }\n        }\n    };\n\n    CondensedSequenceRenderer.prototype.enableSelection = function (callback) {\n        var self = this;\n\n        if (!self._canvas) {\n            _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].add(self, 'sequenceChange', function () {\n                self.enableSelection();\n            });\n            return;\n        }\n\n        var canvas = self._canvas;\n        var start;\n        var end;\n        var end_func;\n        var local_start;\n        var local_end;\n\n        var moving_func = function moving_func(evt) {\n            evt.preventDefault();\n\n            var p = svgPosition(evt, canvas);\n            end = p.x;\n\n            if (start > end) {\n                local_end = parseInt(start / 50);\n                local_start = parseInt(end / 50);\n            } else {\n                local_end = parseInt(end / 50);\n                local_start = parseInt(start / 50);\n            }\n            self.select(local_start + 1, local_end);\n        };\n\n        // Do not send the click event to the canvas\n        // this screws up with doing things on the selection\n        // Need alternative method to clear selection\n        //\n        bindClick(canvas, function (evt) {\n            if (!self.selecting) {\n                self.select();\n                notifySelectionToLayers(null, null, self);\n                local_start = null;\n                local_end = null;\n            }\n        });\n\n        canvas.addEventListener('mousedown', function (evt) {\n            if (!self.selecting) {\n                return;\n            }\n            var positions = mousePosition(evt);\n            var p = {};\n            if (canvas.nodeName == 'svg') {\n                p = canvas.createSVGPoint();\n                var rootCTM = this.getScreenCTM();\n                p.x = positions[0];\n                p.y = positions[1];\n\n                self.matrix = rootCTM.inverse();\n                p = p.matrixTransform(self.matrix);\n            } else {\n                p.x = positions[0];\n                p.y = positions[1];\n            }\n            start = p.x;\n            end = p.x;\n            canvas.addEventListener('mousemove', moving_func, false);\n            evt.preventDefault();\n        }, false);\n\n        canvas.addEventListener('mouseup', function (evt) {\n            if (self.selecting) {\n                notifySelectionToLayers(local_start + 1, local_end, self);\n                local_start = null;\n                local_end = null;\n            }\n            canvas.removeEventListener('mousemove', moving_func);\n            evt.preventDefault();\n        });\n\n        canvas.addEventListener('touchend', function () {\n            if (self.selecting) {\n                setTimeout(function () {\n                    notifySelectionToLayers(local_start + 1, local_end, self);\n                    local_start = null;\n                    local_end = null;\n                }, 500);\n            }\n            canvas.removeEventListener('touchmove', moving_func);\n        });\n\n        canvas.addEventListener('touchstart', function (evt) {\n            if (!self.selecting) {\n                return;\n            }\n            if (evt.changedTouches.length == 1) {\n                evt.preventDefault();\n                var positions = mousePosition(evt.changedTouches[0]);\n                var p = {};\n                if (canvas.nodeName == 'svg') {\n                    p = canvas.createSVGPoint();\n                    var rootCTM = this.getScreenCTM();\n                    p.x = positions[0];\n                    p.y = positions[1];\n\n                    self.matrix = rootCTM.inverse();\n                    p = p.matrixTransform(self.matrix);\n                } else {\n                    p.x = positions[0];\n                    p.y = positions[1];\n                }\n                start = p.x;\n                end = p.x;\n                canvas.addEventListener('touchmove', moving_func, { passive: true });\n            }\n        }, { passive: true });\n        //FIXME - PASSIVE\n    };\n})();\n\n/*\n * Get a canvas set of the visible tracers on this renderer\n */\nCondensedSequenceRenderer.prototype._visibleTracers = function () {\n    var tracers = null;\n    for (var i in _MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"].layers) {\n        if (this.isLayerActive(i) && this._layer_containers[i] && this._layer_containers[i].tracers) {\n            if (!tracers) {\n                tracers = this._layer_containers[i].tracers;\n            } else {\n                tracers.concat(this._layer_containers[i].tracers);\n            }\n        }\n    }\n    return tracers;\n};\n\nCondensedSequenceRenderer.prototype._resizeContainer = function () {\n    var RS = this._RS;\n    if (this._container && this._canvas) {\n\n        var width = (this.zoom || 1) * 2 * this.sequence.length;\n        var height = (this.zoom || 1) * 2 * (this._canvas._canvas_height / this._RS);\n        if (this._canvas_callout_padding) {\n            height += this._canvas_callout_padding;\n        }\n        this._canvas.setAttribute('width', width);\n        this._canvas.setAttribute('height', height);\n        this.navigation.setDimensions(width, height);\n\n        if (this.grow_container) {\n            this._container_canvas.setAttribute('height', height);\n            // this._container.style.height = height+'px';        \n        } else {\n            this._container_canvas.setAttribute('height', '100%');\n            this._container_canvas.setAttribute('width', '100%');\n\n            // this._container.style.height = 'auto';\n            this.navigation.setZoom(this.zoom);\n        }\n    }\n};\n\n(function (clazz) {\n\n    var vis_change_event = function vis_change_event(renderer, visibility) {\n        var self = this;\n        if (!renderer._layer_containers[self.name] || renderer._layer_containers[self.name].length <= 0) {\n            return;\n        }\n\n        if (!visibility) {\n            if (renderer._layer_containers[self.name].tracers) {\n                renderer._layer_containers[self.name].tracers.hide();\n            }\n        }\n    };\n\n    /**\n     * Add a layer to this renderer.\n     * @param {Object} layer    Layer object to add. The layer data is used to create a track that can be independently shown/hidden.\n     *                          The track itself is by default hidden.\n     */\n    clazz.prototype.addTrack = function (layer) {\n        var RS = this._RS;\n        var renderer = this;\n\n        if (!this._canvas) {\n            _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].add(this, 'sequencechange', function () {\n                this.addTrack(layer);\n                _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].remove(this, 'sequencechange', arguments.callee);\n            });\n            console.log(\"No canvas, cannot add track, waiting for sequencechange event\");\n            return;\n        }\n\n        var layer_containers = this._layer_containers || [];\n\n        if (!layer_containers[layer.name] || layer_containers[layer.name] === null) {\n            layer_containers[layer.name] = this._canvas.set();\n            if (!layer_containers[layer.name].track_height) {\n                layer_containers[layer.name].track_height = renderer.trackHeight || 4;\n            }\n            _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].remove(layer, 'visibilityChange', vis_change_event);\n            _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].add(layer, 'visibilityChange', vis_change_event);\n            var event_names = ['click', 'mouseover', 'mousedown', 'mousemove', 'mouseout', 'mouseup', 'mouseenter', 'mouseleave'];\n            var ev_function = function ev_function(ev, original_event, element) {\n                _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].fire(layer, ev.type, [original_event, element.position_start, element.position_end]);\n            };\n            // for (var i = 0 ; i < event_names.length; i++) {\n            //     bean.add(layer_containers[layer.name]._event_proxy,event_names[i],ev_function);\n            // }\n            _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].remove(layer, 'removed');\n            _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].add(layer, 'removed', function (rend) {\n                if (rend) {\n                    rend.removeTrack(this);\n                } else {\n                    renderer.removeTrack(this);\n                }\n            });\n        }\n\n        this._layer_containers = layer_containers;\n    };\n\n    clazz.prototype.removeTrack = function (layer) {\n        if (!this._layer_containers) {\n            return;\n        }\n        var layer_containers = this._layer_containers || [];\n        if (layer_containers[layer.name]) {\n            delete this._layer_containers[layer.name];\n            layer.disabled = true;\n        }\n    };\n\n    var refresh_id = 0;\n    clazz.prototype.disablePrintResizing = function () {\n        delete this._media_func;\n    };\n\n    clazz.prototype.enablePrintResizing = function () {\n        if (!(this.win() || window).matchMedia) {\n            return;\n        }\n        if (this._media_func) {\n            return this._media_func;\n        }\n        this._media_func = function (matcher) {\n            var self = this;\n            if (!self._canvas) {\n                return;\n            }\n            if (self.grow_container) {\n                if (matcher.matches) {\n                    delete self._container_canvas.parentNode.cached_width;\n                    _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].fire(self._canvas, 'panend');\n                }\n                return;\n            }\n            var match = matcher;\n            if (!match.matches) {\n                if (self.old_zoom) {\n                    var a_zoom = self.old_zoom;\n                    self.old_zoom = null;\n                    self.zoomCenter = null;\n                    self.withoutRefresh(function () {\n                        self.zoom = a_zoom;\n                    });\n                    self._canvas.setCurrentTranslateXY(self.old_translate, 0);\n                    self._container_canvas.setAttribute('viewBox', self.old_viewbox);\n                    // self._container.style.height = 'auto';\n                    self.old_zoom = null;\n                    self.old_translate = null;\n                    self.refresh();\n                    _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].fire(self._canvas, 'zoomChange');\n                }\n                return;\n            }\n            try {\n                var container = self._container;\n                self.old_translate = self._canvas.currentTranslateCache.x;\n                self._canvas.setCurrentTranslateXY(0, 0);\n                var zoomFactor = 0.95 * container.clientWidth / self.sequence.length;\n                if (!self.old_zoom) {\n                    self.old_zoom = self.zoom;\n                    self.old_viewbox = self._container_canvas.getAttribute('viewBox');\n                }\n                self.zoomCenter = null;\n                self._container_canvas.removeAttribute('viewBox');\n                self.withoutRefresh(function () {\n                    self.zoom = zoomFactor;\n                });\n                self.refresh();\n            } catch (err) {\n                console.log(err);\n                console.log(err.stack);\n            }\n        };\n        var rend = this;\n        if (!rend._bound_media) {\n            (this.win() || window).matchMedia('print').addListener(function (matcher) {\n                if (rend._media_func) {\n                    rend._media_func(matcher);\n                }\n            });\n        }\n        rend._bound_media = true;\n    };\n\n    /**\n     * Cause a refresh of the renderer, re-arranging the tracks on the canvas, and resizing the canvas if necessary.\n     * @param {Boolean} animateds Cause this refresh to be an animated refresh\n     */\n    clazz.prototype.refresh = function (animated) {\n        if (!this._canvas) {\n            return;\n        }\n\n        var layer_containers = this._layer_containers || [];\n\n        var RS = this._RS;\n        var track_heights = 0;\n        var order = this.trackOrder || [];\n        var fixed_font_scale = this.fixedFontScale;\n\n        if (this.navigation) {\n            this.navigation.reset();\n        }\n        for (var i = 0; i < order.length; i++) {\n\n            var name = order[i];\n            var container = layer_containers[name];\n            if (!container) {\n                continue;\n            }\n            var y_val;\n            if (!this.isLayerActive(name)) {\n                var attrs = { 'y': -1 * this._axis_height * RS, 'height': RS * container.track_height / this.zoom, 'visibility': 'hidden' };\n                //            var attrs = { 'y' : (this._axis_height  + (track_heights - container.track_height )/ this.zoom)*RS, 'height' :  RS * container.track_height / this.zoom ,'visibility' : 'hidden' };\n                if (_MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getLayer(name).group) {\n                    var controller_track = this.navigation.getController(_MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getLayer(name).group);\n                    if (controller_track && this.isLayerActive(controller_track)) {\n                        attrs.y = layer_containers[controller_track.name].currenty();\n                    }\n                }\n\n                if (container.fixed_track_height) {\n                    delete attrs.height;\n                }\n\n                if (animated) {\n                    container.animate(attrs);\n                } else {\n                    container.attr(attrs);\n                }\n                if (container.tracers) {}\n                continue;\n            } else {\n                // container.attr({ 'opacity' : '1' });\n            }\n\n            var tracer_top = track_heights;\n\n            if (container.fixed_track_height) {\n\n                var track_height = container.fixed_track_height;\n\n                y_val = this._axis_height + track_heights / this.zoom;\n\n                if (animated) {\n                    container.animate({ 'visibility': 'visible', 'y': y_val * RS, 'height': RS * container.track_height / this.zoom });\n                } else {\n                    container.attr({ 'visibility': 'visible', 'y': y_val * RS, 'height': RS * container.track_height / this.zoom });\n                }\n                if (this.navigation) {\n                    y_val -= 1 * container.track_height / this.zoom;\n                    this.navigation.renderTrack(_MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getLayer(name), y_val * RS, RS * container.fixed_track_height / this.zoom, { 'font-scale': (fixed_font_scale || 1) * 3 * container.track_height / container.fixed_track_height });\n                }\n                track_heights += container.fixed_track_height + this.trackGap - container.track_height;\n            } else {\n                y_val = this._axis_height + track_heights / this.zoom;\n                if (animated) {\n                    container.animate({ 'visibility': 'visible', 'y': y_val * RS, 'height': RS * container.track_height / this.zoom });\n                } else {\n                    container.attr({ 'visibility': 'visible', 'y': y_val * RS, 'height': RS * container.track_height / this.zoom });\n                }\n                if (this.navigation) {\n                    y_val -= 1 * container.track_height / this.zoom;\n                    this.navigation.renderTrack(_MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getLayer(name), y_val * RS, RS * 3 * container.track_height / this.zoom, fixed_font_scale ? { 'font-scale': fixed_font_scale } : null);\n                    track_heights += container.track_height;\n                }\n                track_heights += container.track_height + this.trackGap;\n            }\n            container.refresh_zoom();\n\n            if (container.tracers) {\n                var disp_style = this.isLayerActive(name) && this.zoom > 3.6 ? 'visible' : 'hidden';\n                var height = (1.5 + tracer_top / this.zoom) * RS;\n\n                if (animated) {\n                    container.tracers.animate({ 'visibility': disp_style, 'y': 0.65 * this._axis_height * RS, 'height': height });\n                } else {\n                    container.tracers.attr({ 'visibility': disp_style, 'y': 0.65 * this._axis_height * RS, 'height': height });\n                }\n            }\n        }\n\n        var viewBox = [-1, 0, 0, 0];\n        viewBox[0] = -2 * RS;\n        viewBox[2] = (this.sequence.split('').length + this.padding + 2) * RS;\n        viewBox[3] = (this._axis_height + track_heights / this.zoom + this.padding / this.zoom) * RS;\n        this._canvas.setAttribute('viewBox', viewBox.join(' '));\n        this._canvas._canvas_height = viewBox[3];\n\n        var outer_viewbox = [].concat(viewBox);\n\n        outer_viewbox[0] = 0;\n        outer_viewbox[2] = this.zoom * (2 * this.sequence.length) + this.padding;\n        outer_viewbox[3] = this.zoom * 2 * (this._axis_height + track_heights / this.zoom + this.padding / this.zoom);\n        if (!this.grow_container) {\n            this._container_canvas.setAttribute('viewBox', outer_viewbox.join(' '));\n        } else {\n            this._container_canvas.removeAttribute('viewBox');\n        }\n\n        this._resizeContainer();\n\n        viewBox[0] = 0;\n        if (this.navigation) {\n            if (this.grow_container) {\n                this.navigation.nav_width_base = outer_viewbox[3] < 200 ? outer_viewbox[3] : 200;\n            }\n            this.navigation.move_closer();\n            if (this.navigation.visible()) {\n                this._canvas.style.GomapScrollLeftMargin = 100 * RS / this.zoom;\n            } else {\n                this._canvas.style.GomapScrollLeftMargin = 1000;\n            }\n            this.navigation.setViewBox(viewBox.join(' '));\n        }\n\n        if (this.navigation) {\n            this.navigation.refresh();\n        }\n    };\n\n    /*\n    \n    Modified from:\n    \n    http://stackoverflow.com/questions/5433806/convert-embedded-svg-to-png-in-place\n    \n    None of the Safari browsers work with this, giving DOM Exception 18\n    \n    http://stackoverflow.com/questions/8158312/rasterizing-an-in-document-svg-to-canvas\n    \n    I think this is the relevant bug.\n    \n    https://bugs.webkit.org/show_bug.cgi?id=119492\n    \n    */\n\n    var svgDataURL = function svgDataURL(svg) {\n        svg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');\n        svg.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink');\n\n        var svgAsXML = new XMLSerializer().serializeToString(svg);\n        return \"data:image/svg+xml,\" + encodeURIComponent(svgAsXML);\n    };\n\n    clazz.prototype.pngURL = function (pngReady, out_width) {\n        //var svg = document.getElementById('foobar');//this._canvas;\n        var svg_data = this._canvas.cloneNode(true);\n        var sequences = svg_data.querySelectorAll('text[data-spaces]');\n        for (var i = 0; i < sequences.length; i++) {\n            sequences[i].parentNode.removeChild(sequences[i]);\n        }\n\n        // Set up the aspect ratio of the output element\n        var svg = document.createElementNS(svgns, 'svg');\n        svg.setAttribute('width', this._container_canvas.getBoundingClientRect().width);\n        svg.setAttribute('height', this._container_canvas.getBoundingClientRect().height);\n        svg.setAttribute('preserveAspectRatio', 'xMinYMin meet');\n\n        var transform_group = document.createElementNS(svgns, 'g');\n        transform_group.setAttribute('transform', this._canvas.parentNode.getAttribute('transform'));\n        svg.appendChild(transform_group);\n        transform_group.appendChild(svg_data);\n\n        // We are missing the defs elements from the containing node\n\n        var all_defs = this._container_canvas.querySelectorAll('defs');\n        for (var i = 0; i < all_defs.length; i++) {\n            svg.appendChild(all_defs[i].cloneNode(true));\n        }\n        var can = document.createElement('canvas');\n        var total_width = 2 * parseInt(svg.getAttribute('width'));\n        var total_height = 2 * parseInt(svg.getAttribute('height'));\n        if (out_width) {\n            if (total_width > out_width) {\n                var ratio = total_width / out_width;\n                total_width = out_width;\n                total_height = parseInt(total_height / ratio);\n            }\n        }\n        can.width = total_width;\n        can.height = total_height;\n        var svgImg = new Image();\n        svgImg.width = 1;\n        svgImg.height = 1;\n        var ctx = can.getContext('2d');\n        svgImg.onload = function () {\n            ctx.drawImage(svgImg, 0, 0, can.width, can.height);\n            pngReady(can.toDataURL());\n        };\n        svgImg.onerror = function () {\n            console.log(\"Got an error\");\n        };\n        var dataurl = svgDataURL(svg);\n        svgImg.src = dataurl;\n    };\n})(CondensedSequenceRenderer);\n\n/**\n * Zoom level has changed for this renderer\n * @name    CondensedSequenceRenderer#zoomChange\n * @event\n * @param   {Object}    e\n */\n\nCondensedSequenceRenderer.Zoom = function (renderer) {\n\n    /**\n     *  @lends CondensedSequenceRenderer.prototype\n     *  @property   {Number}    zoom        The zoom level for a renderer. Minimum zoom level is zero, and defaults to the default zoom value\n     *  @property   {Array}     trackOrder  The order of tracks on the renderer, an array of layer/group names.\n     *  @property   {Number}    padding     Padding to apply to the right and top of plots (default 10).\n     *  @property   {Number}    trackGap    Vertical gap between tracks (default 10)\n     */\n    var timeout = null;\n    var start_zoom = null;\n    var zoom_level = null;\n    var center_residue = null;\n    var start_x = null;\n    var transformer;\n    var shifter;\n    var accessors = {\n        setZoom: function setZoom(zoomLevel) {\n            var container_width = renderer._container.cached_width;\n            if (!container_width) {\n                container_width = renderer._container.clientWidth;\n            }\n            if (!renderer.sequence) {\n                zoom_level = zoomLevel;\n                return;\n            }\n            var min_zoom_level = container_width / (2 * renderer.sequence.length);\n            // if  (! renderer.grow_container ) {\n            //     min_zoom_level = 0.3 / 2 * min_zoom_level;\n            // }\n\n            // var min_zoom_level = renderer.sequence ? (0.3 / 2) * container_width / renderer.sequence.length : 0.5;\n            if (zoomLevel < min_zoom_level) {\n                zoomLevel = min_zoom_level;\n            }\n            if (zoomLevel > 10) {\n                zoomLevel = 10;\n            }\n\n            var self = this;\n\n            if (zoomLevel == zoom_level) {\n                if (this.refresh.suspended && self._canvas && self._canvas.zoom !== parseFloat(zoom_level)) {\n                    self._canvas.zoom = parseFloat(zoom_level);\n                    self._canvas.setScale(1);\n\n                    _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].fire(self._canvas, 'zoomChange');\n                }\n                return;\n            }\n\n            if (!self._canvas) {\n                zoom_level = zoomLevel;\n                return;\n            }\n\n            var no_touch_center = false;\n\n            if (self.zoomCenter == 'center') {\n                no_touch_center = true;\n                self.zoomCenter = { 'x': self._RS * 0.5 * (self.leftVisibleResidue() + self.rightVisibleResidue()) };\n            }\n\n            if (self.zoomCenter && !center_residue) {\n                start_x = self._canvas.currentTranslateCache.x || 0;\n                center_residue = self.zoomCenter ? self.zoomCenter.x : 0;\n            } else if (center_residue && !self.zoomCenter) {\n                // We should not be zooming if there is a center residue and no zoomCenter;\n                return;\n            }\n\n            if (timeout) {\n                clearTimeout(timeout);\n            } else {\n                start_zoom = parseFloat(zoom_level || 1);\n            }\n\n            zoom_level = parseFloat(zoomLevel);\n\n            var scale_value = Math.abs(parseFloat(zoomLevel) / start_zoom);\n\n            window.cancelAnimationFrame(transformer);\n            transformer = window.requestAnimationFrame(function () {\n                // Rendering bottleneck\n                self._canvas.setScale(scale_value);\n            });\n\n            _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].fire(self._canvas, '_anim_begin');\n            if (document.createEvent) {\n                var evObj = document.createEvent('Events');\n                evObj.initEvent('panstart', false, true);\n                self._canvas.dispatchEvent(evObj);\n            }\n            var old_x = self._canvas.currentTranslateCache.x;\n            if (center_residue) {\n                var delta = (start_zoom - zoom_level) / (scale_value * 25) * center_residue;\n                delta += start_x / scale_value;\n                cancelAnimationFrame(shifter);\n                shifter = window.requestAnimationFrame(function () {\n\n                    // Rendering bottleneck\n                    self._canvas.setCurrentTranslateXY(delta, (start_zoom - zoom_level) / scale_value * self._axis_height * 2);\n                });\n            }\n\n            var end_function = function end_function() {\n                timeout = null;\n                var scale_value = Math.abs(parseFloat(zoom_level) / start_zoom);\n\n                self._canvas.setScale(null);\n\n                _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].fire(self._canvas, 'panend');\n                _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].fire(self._canvas, '_anim_end');\n                let zoomchange = function zoomchange() {\n                    _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].remove(self._canvas, 'zoomChange', zoomchange);\n                    self.refresh();\n                    if (typeof center_residue != 'undefined') {\n                        var delta = (start_zoom - zoom_level) / 25 * center_residue;\n                        delta += start_x;\n\n                        self._resizeContainer();\n\n                        if (self._canvas.shiftPosition) {\n                            self._canvas.shiftPosition(delta, 0);\n                        } else {\n                            self._canvas.setCurrentTranslateXY(delta, 0);\n                        }\n                    }\n                    center_residue = null;\n                    start_x = null;\n                };\n                _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].add(self._canvas, 'zoomChange', zoomchange);\n\n                if (self._canvas) {\n                    self._canvas.zoom = parseFloat(zoom_level);\n                    _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].fire(self._canvas, 'zoomChange');\n                }\n                _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].fire(self, 'zoomChange');\n            };\n\n            if (\"ontouchend\" in document && self.zoomCenter && !no_touch_center) {\n                _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].remove(self, 'gestureend');\n                let ender = function ender() {\n                    _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].remove(self, 'gestureend', ender);\n                    end_function();\n                };\n                _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].add(self, 'gestureend', ender);\n                timeout = 1;\n            } else {\n                if (!this.refresh.suspended) {\n                    timeout = setTimeout(end_function, 100);\n                } else {\n                    end_function();\n                }\n            }\n        },\n        fitZoom: function fitZoom() {\n            var container_width = renderer._container.cached_width;\n            if (!container_width) {\n                container_width = renderer._container.clientWidth;\n            }\n            var min_zoom_level = 0.5;\n            if (renderer.sequence) {\n                min_zoom_level = container_width / (2 * renderer.sequence.length);\n            }\n            renderer.zoom = min_zoom_level;\n        },\n        getZoom: function getZoom() {\n            return zoom_level || 1;\n        }\n    };\n\n    if (Object.defineProperty && !_MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"].IE8) {\n        Object.defineProperty(renderer, \"zoom\", {\n            get: accessors.getZoom,\n            set: accessors.setZoom\n        });\n    }\n\n    renderer.fitZoom = accessors.fitZoom;\n};\n\n/* Add some properties that will trigger a refresh on the renderer when they are changed.\n   These are all stateless\n */\n\n(function (clazz) {\n\n    var accessors = {\n        getPadding: function getPadding() {\n            return this._padding || 10;\n        },\n\n        setPadding: function setPadding(padding) {\n            this._padding = padding;\n            this.refresh();\n        },\n\n        getTrackGap: function getTrackGap() {\n            if (!this._track_gap) {\n                var default_value = \"ontouchend\" in document ? 20 : 10;\n                this._track_gap = this._track_gap || default_value;\n            }\n\n            return this._track_gap;\n        },\n\n        setTrackGap: function setTrackGap(trackGap) {\n            this._track_gap = trackGap;\n            this.refresh();\n        }\n    };\n\n    if (Object.defineProperty && !_MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"].IE8) {\n        Object.defineProperty(clazz.prototype, \"padding\", {\n            get: accessors.getPadding,\n            set: accessors.setPadding\n        });\n        Object.defineProperty(clazz.prototype, \"trackGap\", {\n            get: accessors.getTrackGap,\n            set: accessors.setTrackGap\n        });\n    }\n})(CondensedSequenceRenderer);\n\nCondensedSequenceRenderer.Navigation = _CondensedSequenceRendererNavigation__WEBPACK_IMPORTED_MODULE_2__[\"default\"];\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (CondensedSequenceRenderer);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9qcy9saWIvQ29uZGVuc2VkU2VxdWVuY2VSZW5kZXJlci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9qcy9saWIvQ29uZGVuc2VkU2VxdWVuY2VSZW5kZXJlci5qcz9hODFkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogIEBmaWxlT3ZlcnZpZXcgICBCYXNpYyBjbGFzc2VzIGFuZCBkZWZpbml0aW9ucyBmb3IgYW4gU1ZHLWJhc2VkIHNlcXVlbmNlIHJlbmRlcmVyXG4gKi9cblxuaW1wb3J0IE1BU0NQIGZyb20gJy4vTUFTQ1AnO1xuaW1wb3J0IFNlcXVlbmNlUmVuZGVyZXIgZnJvbSAnLi9TZXF1ZW5jZVJlbmRlcmVyJztcbmltcG9ydCBOYXZpZ2F0aW9uIGZyb20gJy4vQ29uZGVuc2VkU2VxdWVuY2VSZW5kZXJlck5hdmlnYXRpb24nO1xuaW1wb3J0IGJlYW4gZnJvbSAnLi4vYmVhbic7XG5pbXBvcnQgU1ZHQ2FudmFzIGZyb20gJy4vU1ZHQ2FudmFzJztcblxuY29uc3Qgc3ZnbnMgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnO1xuXG4vKiogRGVmYXVsdCBjbGFzcyBjb25zdHJ1Y3RvclxuICogIEBjbGFzcyAgICAgIFJlbmRlcnMgYSBzZXF1ZW5jZSB1c2luZyBhIGNvbmRlbnNlZCB0cmFjay1iYXNlZCBkaXNwbGF5XG4gKiAgQHBhcmFtICAgICAge0VsZW1lbnR9IHNlcXVlbmNlQ29udGFpbmVyIENvbnRhaW5lciBlbGVtZW50IHRoYXQgdGhlIHNlcXVlbmNlIGN1cnJlbnRseSBpcyBmb3VuZCBpbiwgYW5kIGFsc28gXG4gKiAgICAgICAgICAgICAgdGhlIGNvbnRhaW5lciB0aGF0IGRhdGEgd2lsbCBiZSByZS1pbnNlcnRlZCBpbnRvLlxuICogIEBleHRlbmRzICAgIE1BU0NQLlNlcXVlbmNlUmVuZGVyZXJcbiAqL1xuY29uc3QgQ29uZGVuc2VkU2VxdWVuY2VSZW5kZXJlciA9IGZ1bmN0aW9uKHNlcXVlbmNlQ29udGFpbmVyKSB7XG4gICAgdGhpcy5fUlMgPSA1MDtcbiAgICBTZXF1ZW5jZVJlbmRlcmVyLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAvLyBDcmVhdGUgYSBjb21tb24gbGF5ZXIgZm9yIHRoZSBwcmltYXJ5IHNlcXVlbmNlXG4gICAgTUFTQ1AucmVnaXN0ZXJMYXllcigncHJpbWFyeVNlcXVlbmNlJywgeyAnZnVsbG5hbWUnIDogJ1ByaW1hcnkgU2VxdWVuY2UnIH0pO1xuXG5cbiAgICBDb25kZW5zZWRTZXF1ZW5jZVJlbmRlcmVyLlpvb20oc2VsZik7XG4gICAgdmFyIHJlc2l6ZVRpbWVvdXQ7XG4gICAgdmFyIHJlc2l6ZV9jYWxsYmFjayA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBzZXF1ZW5jZUNvbnRhaW5lci5jYWNoZWRfd2lkdGggPSBzZXF1ZW5jZUNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aDtcbiAgICB9O1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLGZ1bmN0aW9uKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQocmVzaXplVGltZW91dCk7XG4gICAgICAgIGlmICh3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB7XG4gICAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJlc2l6ZV9jYWxsYmFjaylcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc2l6ZVRpbWVvdXQgPSBzZXRUaW1lb3V0KHJlc2l6ZV9jYWxsYmFjaywxMDApO1xuICAgICAgICB9XG4gICAgfSx0cnVlKTtcbiAgICBzZXF1ZW5jZUNvbnRhaW5lci5jYWNoZWRfd2lkdGggPSBzZXF1ZW5jZUNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aDtcblxuICAgIC8vIFdlIHdhbnQgdG8gdW5iaW5kIHRoZSBkZWZhdWx0IGhhbmRsZXIgZm9yIHNlcXVlbmNlIGNoYW5nZSB0aGF0IHdlIGdldCBmcm9tXG4gICAgLy8gaW5oZXJpdGluZyBmcm9tIENvbmRlbnNlZFNlcXVlbmNlUmVuZGVyZXJcbiAgICBiZWFuLnJlbW92ZSh0aGlzLCdzZXF1ZW5jZUNoYW5nZScpO1xuXG4gICAgYmVhbi5hZGQodGhpcywnc2VxdWVuY2VDaGFuZ2UnLGZ1bmN0aW9uKCkge1xuICAgICAgICBmb3IgKHZhciBsYXllcm5hbWUgaW4gTUFTQ1AubGF5ZXJzKSB7XG4gICAgICAgICAgICBpZiAoTUFTQ1AubGF5ZXJzLmhhc093blByb3BlcnR5KGxheWVybmFtZSkpIHtcbiAgICAgICAgICAgICAgICBNQVNDUC5sYXllcnNbbGF5ZXJuYW1lXS5kaXNhYmxlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2VsZi56b29tID0gc2VsZi56b29tO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5Db25kZW5zZWRTZXF1ZW5jZVJlbmRlcmVyLnByb3RvdHlwZSA9IG5ldyBTZXF1ZW5jZVJlbmRlcmVyKCk7XG5cbihmdW5jdGlvbihjbGF6eikge1xuICAgIHZhciBjcmVhdGVDYW52YXNPYmplY3QgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJlbmRlcmVyID0gdGhpcztcblxuICAgICAgICBpZiAodGhpcy5fb2JqZWN0KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHN2Z3dlYiAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHN2Z3dlYi5yZW1vdmVDaGlsZCh0aGlzLl9vYmplY3QsIHRoaXMuX29iamVjdC5wYXJlbnROb2RlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb2JqZWN0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5fb2JqZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2NhbnZhcyA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9vYmplY3QgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjYW52YXM7XG4gICAgICAgIGlmICggZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uaGFzRmVhdHVyZShcImh0dHA6Ly93d3cudzMub3JnL1RSL1NWRzExL2ZlYXR1cmUjQmFzaWNTdHJ1Y3R1cmVcIiwgXCIxLjFcIikgKSB7XG4gICAgICAgICAgICB2YXIgbmF0aXZlX2NhbnZhcyA9IHRoaXMud2luKCkuZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHN2Z25zLCdzdmcnKTtcbiAgICAgICAgICAgIG5hdGl2ZV9jYW52YXMuc2V0QXR0cmlidXRlKCd3aWR0aCcsJzEwMCUnKTtcbiAgICAgICAgICAgIG5hdGl2ZV9jYW52YXMuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCcxMDAlJyk7XG4gICAgICAgICAgICB0aGlzLl9jb250YWluZXIuYXBwZW5kQ2hpbGQobmF0aXZlX2NhbnZhcyk7XG4gICAgICAgICAgICB0aGlzLl9jYW52YXMgPSBuYXRpdmVfY2FudmFzO1xuICAgICAgICAgICAgY2FudmFzID0ge1xuICAgICAgICAgICAgICAgICdhZGRFdmVudExpc3RlbmVyJyA6IGZ1bmN0aW9uKG5hbWUsbG9hZF9mdW5jKSB7XG4gICAgICAgICAgICAgICAgICAgIG5hdGl2ZV9jYW52YXMuY29udGVudERvY3VtZW50ID0geyAncm9vdEVsZW1lbnQnIDogbmF0aXZlX2NhbnZhcyB9O1xuICAgICAgICAgICAgICAgICAgICBsb2FkX2Z1bmMuY2FsbChuYXRpdmVfY2FudmFzKTtcbiAgICAgICAgICAgICAgICB9ICAgICAgICAgICAgXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGNvbnRhaW5lcl9jYW52ID0gdGhpcztcbiAgICAgICAgICAgIFNWR0NhbnZhcyhjb250YWluZXJfY2Fudik7XG4gICAgICAgICAgICBpZiAocmVuZGVyZXIuZm9udF9vcmRlcikge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lcl9jYW52LmZvbnRfb3JkZXIgPSByZW5kZXJlci5mb250X29yZGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGdyb3VwID0gY29udGFpbmVyX2NhbnYubWFrZUVsKCdnJyk7XG4gICAgICAgIFxuICAgICAgICAgICAgdmFyIGNhbnYgPSBjb250YWluZXJfY2Fudi5tYWtlRWwoJ3N2ZycpO1xuICAgICAgICAgICAgY2Fudi5SUyA9IHJlbmRlcmVyLl9SUztcbiAgICAgICAgICAgIFNWR0NhbnZhcyhjYW52KTtcbiAgICAgICAgICAgIGlmIChyZW5kZXJlci5mb250X29yZGVyKSB7XG4gICAgICAgICAgICAgICAgY2Fudi5mb250X29yZGVyID0gcmVuZGVyZXIuZm9udF9vcmRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdyb3VwLmFwcGVuZENoaWxkKGNhbnYpO1xuICAgICAgICAgICAgY29udGFpbmVyX2NhbnYuYXBwZW5kQ2hpbGQoZ3JvdXApO1xuXG4gICAgICAgICAgICB2YXIgc3VwcG9ydHNfZXZlbnRzID0gdHJ1ZTtcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgbm9vcCA9IGNhbnYuYWRkRXZlbnRMaXN0ZW5lcjtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIHN1cHBvcnRzX2V2ZW50cyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY2FudmFzX3JlY3QgPSBjYW52Lm1ha2VFbCgncmVjdCcsIHsgICd4JzonLTEwJScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3knOictMTAlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnd2lkdGgnOicxMjAlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnaGVpZ2h0JzonMTIwJScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3N0eWxlJzonZmlsbDogI2ZmZmZmZjsnfSk7XG4gICAgICAgIFxuICAgICAgICBcbiAgICAgICAgXG4gICAgICAgICAgICB2YXIgbGVmdF9mYWRlID0gY29udGFpbmVyX2NhbnYubWFrZUVsKCdyZWN0Jyx7ICAgICAgJ3gnOicwJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAneSc6JzAnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICd3aWR0aCc6JzUwJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnaGVpZ2h0JzonMTAwJScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3N0eWxlJzonZmlsbDogdXJsKCNsZWZ0X2ZhZGUpOyd9KTtcblxuICAgICAgICAgICAgdmFyIHJpZ2h0X2ZhZGUgPSBjb250YWluZXJfY2Fudi5tYWtlRWwoJ3JlY3QnLHsgICAgICd4JzonMTAwJScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3knOicwJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnd2lkdGgnOicyNScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2hlaWdodCc6JzEwMCUnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICd0cmFuc2Zvcm0nOid0cmFuc2xhdGUoLTE1LDApJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnc3R5bGUnOidmaWxsOiB1cmwoI3JpZ2h0X2ZhZGUpOyd9KTtcblxuICAgICAgICAgICAgY29udGFpbmVyX2NhbnYuYXBwZW5kQ2hpbGQobGVmdF9mYWRlKTtcbiAgICAgICAgICAgIGNvbnRhaW5lcl9jYW52LmFwcGVuZENoaWxkKHJpZ2h0X2ZhZGUpO1xuXG4gICAgICAgICAgICBiZWFuLmFkZChjYW52LCdwYW4nLGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmIChjYW52LmN1cnJlbnRUcmFuc2xhdGVDYWNoZS54ID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdF9mYWRlLnNldEF0dHJpYnV0ZSgndmlzaWJpbGl0eScsJ2hpZGRlbicpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnRfZmFkZS5zZXRBdHRyaWJ1dGUoJ3Zpc2liaWxpdHknLCd2aXNpYmxlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZW5kZXJlci5yaWdodFZpc2libGVSZXNpZHVlKCkgPCByZW5kZXJlci5zZXF1ZW5jZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmlnaHRfZmFkZS5zZXRBdHRyaWJ1dGUoJ3Zpc2liaWxpdHknLCd2aXNpYmxlJyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmlnaHRfZmFkZS5zZXRBdHRyaWJ1dGUoJ3Zpc2liaWxpdHknLCdoaWRkZW4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgICAgICBiZWFuLmFkZChjYW52LCdfYW5pbV9iZWdpbicsZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgbGVmdF9mYWRlLnNldEF0dHJpYnV0ZSgndmlzaWJpbGl0eScsJ2hpZGRlbicpO1xuICAgICAgICAgICAgICAgIHJpZ2h0X2ZhZGUuc2V0QXR0cmlidXRlKCd2aXNpYmlsaXR5JywnaGlkZGVuJyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgICAgICBiZWFuLmFkZChjYW52LCdfYW5pbV9lbmQnLGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGJlYW4uZmlyZShjYW52LCdwYW4nKTtcbiAgICAgICAgICAgIH0pO1xuXG5cbiAgICAgICAgICAgIGNhbnYuY3VycmVudFRyYW5zbGF0ZUNhY2hlID0geyB4OiAwLCB5OiAwIH07XG5cbiAgICAgICAgICAgIGlmIChjYW52LmN1cnJlbnRUcmFuc2xhdGVDYWNoZS54ID49IDApIHtcbiAgICAgICAgICAgICAgICBsZWZ0X2ZhZGUuc2V0QXR0cmlidXRlKCd2aXNpYmlsaXR5JywnaGlkZGVuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByaWdodF9mYWRlLnNldEF0dHJpYnV0ZSgndmlzaWJpbGl0eScsJ2hpZGRlbicpO1xuXG4gICAgICAgICAgICB2YXIgbmF2X2dyb3VwID0gY29udGFpbmVyX2NhbnYubWFrZUVsKCdnJyk7XG4gICAgICAgICAgICBjb250YWluZXJfY2Fudi5hcHBlbmRDaGlsZChuYXZfZ3JvdXApO1xuICAgICAgICAgICAgdmFyIG5hdl9jYW52YXMgPSBjb250YWluZXJfY2Fudi5tYWtlRWwoJ3N2ZycpO1xuICAgICAgICAgICAgbmF2X2dyb3VwLmFwcGVuZENoaWxkKG5hdl9jYW52YXMpO1xuXG4gICAgICAgICAgICBncm91cC5zdHlsZS53aWxsQ2hhbmdlID0gJ3RyYW5zZm9ybSc7XG5cbiAgICAgICAgICAgY2Fudi5zZXRTY2FsZSA9IGZ1bmN0aW9uKHNjYWxlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGN1cnJfdHJhbnNmb3JtID0gKGdyb3VwLl9jYWNoZWRfdHJhbnNmb3JtIHx8ICcnICkucmVwbGFjZSgvc2NhbGVcXChbXlxcKV0rXFwpLywnJyk7XG4gICAgICAgICAgICAgICAgaWYgKHNjYWxlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJfdHJhbnNmb3JtID0gKCcgc2NhbGUoJytzY2FsZSsnKSAnICsgY3Vycl90cmFuc2Zvcm0gKS5yZXBsYWNlKC9cXHMrL2csJyAnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZ3JvdXAuX2NhY2hlZF90cmFuc2Zvcm0gPSBjdXJyX3RyYW5zZm9ybTtcbiAgICAgICAgICAgICAgICBncm91cC5zdHlsZS50cmFuc2Zvcm0gPSBjdXJyX3RyYW5zZm9ybTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgbmF2X2NhbnZhcy5zZXRTY2FsZSA9IGZ1bmN0aW9uKHNjYWxlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGN1cnJfdHJhbnNmb3JtID0gKG5hdl9ncm91cC5fY2FjaGVkX3RyYW5zZm9ybSB8fCAnJyApLnJlcGxhY2UoL3NjYWxlXFwoW15cXCldK1xcKS8sJycpO1xuICAgICAgICAgICAgICAgIGlmIChzY2FsZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyX3RyYW5zZm9ybSA9IChjdXJyX3RyYW5zZm9ybSArICcgc2NhbGUoJytzY2FsZSsnKSAnKS5yZXBsYWNlKC9cXHMrL2csJyAnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmF2X2dyb3VwLl9jYWNoZWRfdHJhbnNmb3JtID0gY3Vycl90cmFuc2Zvcm07XG4gICAgICAgICAgICAgICAgbmF2X2dyb3VwLnN0eWxlLnRyYW5zZm9ybSA9IGN1cnJfdHJhbnNmb3JtO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGJlYW4uYWRkKGNhbnYsJ3pvb21DaGFuZ2UnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCAhIHJlbmRlcmVyLmZpeGVkX3NpemUgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2Fudi5zZXRTY2FsZSgxKTtcbiAgICAgICAgICAgICAgICBuYXZfY2FudmFzLnNldFNjYWxlKDEpO1xuICAgICAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjb250YWluZXJfaGVpZ2h0ID0gY29udGFpbmVyX2NhbnYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICBsZXQgY2Fudl9oZWlnaHQgPSBjYW52LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGN1cnJlbnRfc2NhbGUgPSAoZ3JvdXAuX2NhY2hlZF90cmFuc2Zvcm0gfHwgJ3NjYWxlKDEpJykubWF0Y2goL3NjYWxlXFwoKFtcXGRcXC5dKylcXCkvKSB8fCAnMSc7XG4gICAgICAgICAgICAgICAgICAgIGNhbnYuc2V0U2NhbGUoKDEqY29udGFpbmVyX2hlaWdodCAvIGNhbnZfaGVpZ2h0KS50b0ZpeGVkKDIpKTtcbiAgICAgICAgICAgICAgICAgICAgbmF2X2NhbnZhcy5zZXRTY2FsZSgoMSpjb250YWluZXJfaGVpZ2h0IC8gY2Fudl9oZWlnaHQpLnRvRml4ZWQoMikpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG5cblxuICAgICAgICAgICAgdmFyIHVhID0gd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQ7XG4gICAgICAgICAgICB2YXIgaXNfZXhwbG9yZXIgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmICh1YS5pbmRleE9mKCdFZGdlLycpID49IDApIHtcbiAgICAgICAgICAgICAgICBpc19leHBsb3JlciA9IHRydWU7XG4gICAgICAgICAgICB9XG5cblxuICAgICAgICAgICBjYW52LnNldEN1cnJlbnRUcmFuc2xhdGVYWSA9IGZ1bmN0aW9uKHgseSkge1xuICAgICAgICAgICAgICAgIHZhciBjdXJyX3RyYW5zZm9ybSA9IGdyb3VwLl9jYWNoZWRfdHJhbnNmb3JtIHx8ICcnO1xuICAgICAgICAgICAgICAgIGN1cnJfdHJhbnNmb3JtID0gKGN1cnJfdHJhbnNmb3JtLnJlcGxhY2UoL3RyYW5zbGF0ZVxcKFteXFwpXStcXCkvLCcnKSArICcgdHJhbnNsYXRlKCcreCsncHgsICcreSsncHgpICcpLnJlcGxhY2UoL1xccysvZywnICcpO1xuICAgICAgICAgICAgICAgIGdyb3VwLl9jYWNoZWRfdHJhbnNmb3JtID0gY3Vycl90cmFuc2Zvcm07XG4gICAgICAgICAgICAgICAgaWYgKCAhIGlzX2V4cGxvcmVyICkge1xuICAgICAgICAgICAgICAgICAgICBncm91cC5zdHlsZS50cmFuc2Zvcm0gPSBjdXJyX3RyYW5zZm9ybTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBncm91cC5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsY3Vycl90cmFuc2Zvcm0ucmVwbGFjZSgvcHgvZywnJykpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFRyYW5zbGF0ZUNhY2hlLnggPSB4O1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFRyYW5zbGF0ZUNhY2hlLnkgPSB5O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNhbnYuc2V0Q3VycmVudFRyYW5zbGF0ZVhZKDAsMCk7XG4gICAgICAgIFxuICAgICAgICAgICAgbmF2X2NhbnZhcy5zZXRDdXJyZW50VHJhbnNsYXRlWFkgPSBmdW5jdGlvbih4LHkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJfdHJhbnNmb3JtID0gKG5hdl9ncm91cC5nZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScpIHx8ICcnKS5yZXBsYWNlKC90cmFuc2xhdGVcXChbXlxcKV0rXFwpLywnJyk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJfdHJhbnNmb3JtID0gY3Vycl90cmFuc2Zvcm0gKyAnIHRyYW5zbGF0ZSgnK3grJywgJyt5KycpICc7XG4gICAgICAgICAgICAgICAgICAgIG5hdl9ncm91cC5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsY3Vycl90cmFuc2Zvcm0pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRUcmFuc2xhdGUueCA9IHg7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFRyYW5zbGF0ZS55ID0geTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBuYXZfY2FudmFzLnNldEN1cnJlbnRUcmFuc2xhdGVYWSgwLDApO1xuICAgICAgICBcblxuICAgICAgICBcbiAgICAgICAgICAgIGFkZE5hdi5jYWxsKHJlbmRlcmVyLG5hdl9jYW52YXMpO1xuXG4gICAgICAgICAgICB2YXIgbmF2ID0gcmVuZGVyZXIubmF2aWdhdGlvbjtcbiAgICAgICAgICAgIHZhciBvbGRfc2hvdyA9IG5hdi5zaG93LCBvbGRfaGlkZSA9IG5hdi5oaWRlO1xuICAgICAgICAgICAgbmF2LnNob3cgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBvbGRfc2hvdy5hcHBseShuYXYsYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICBjYW52LnN0eWxlLkdvbWFwU2Nyb2xsTGVmdE1hcmdpbiA9IDEwMCAqIHJlbmRlcmVyLl9SUyAvIHJlbmRlcmVyLnpvb207XG4gICAgICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgICAgIG5hdi5oaWRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgb2xkX2hpZGUuYXBwbHkobmF2LGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgY2Fudi5zdHlsZS5Hb21hcFNjcm9sbExlZnRNYXJnaW4gPSAxMDAwO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgICAgICByZW5kZXJlci5fY29udGFpbmVyX2NhbnZhcyA9IGNvbnRhaW5lcl9jYW52O1xuICAgICAgICAgICAgY29udGFpbmVyX2NhbnYuc2V0QXR0cmlidXRlKCdwcmVzZXJ2ZUFzcGVjdFJhdGlvJywneE1pbllNaW4gbWVldCcpO1xuICAgICAgICAgICAgY29udGFpbmVyX2NhbnYuc2V0QXR0cmlidXRlKCd3aWR0aCcsJzEwMCUnKTtcbiAgICAgICAgICAgIGNvbnRhaW5lcl9jYW52LnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywnMTAwJScpO1xuICAgICAgICAgICAgY2Fudi5hcHBlbmRDaGlsZChjYW52Lm1ha2VFbCgncmVjdCcsIHsneCc6MCwneSc6MCwnb3BhY2l0eSc6IDAsJ3dpZHRoJzonMTAwJScsJ2hlaWdodCc6JzEwMCUnLCdzdHJva2Utd2lkdGgnOicwJywnZmlsbCc6JyNmZmZmZmYnfSkpO1xuICAgICAgICAgICAgcmVuZGVyZXIuX29iamVjdCA9IHRoaXM7XG4gICAgICAgICAgICByZW5kZXJlci5fY2FudmFzID0gY2FudjtcbiAgICAgICAgICAgIHJlbmRlcmVyLl9jYW52YXMuX2NhbnZhc19oZWlnaHQgPSAwO1xuICAgICAgICAgICAgYmVhbi5maXJlKHJlbmRlcmVyLCdzdmdyZWFkeScpO1xuICAgICAgICB9LGZhbHNlKTtcbiAgICBcbiAgICAgICAgcmV0dXJuIGNhbnZhcztcbiAgICB9O1xuXG4gICAgdmFyIHdoZWVsX2ZuID0gZnVuY3Rpb24oZSkge1xuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgdmFyIGFkZE5hdiA9IGZ1bmN0aW9uKG5hdl9jYW52YXMpIHtcbiAgICAgICAgdGhpcy5uYXZpZ2F0aW9uID0gbmV3IENvbmRlbnNlZFNlcXVlbmNlUmVuZGVyZXIuTmF2aWdhdGlvbihuYXZfY2FudmFzLHRoaXMpO1xuICAgICAgICB2YXIgbmF2ID0gdGhpcy5uYXZpZ2F0aW9uO1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgXG4gICAgICAgIHZhciBoaWRlX2Nocm9tZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgbmF2LmRlbW90ZSgpOyBcbiAgICAgICAgfTtcbiAgICBcbiAgICAgICAgdmFyIHNob3dfY2hyb21lID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBuYXYucHJvbW90ZSgpO1xuICAgICAgICAgICAgbmF2LnJlZnJlc2goKTtcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoICEgTUFTQ1AuSUUgKSB7XG4gICAgICAgIGJlYW4uYWRkKHRoaXMuX2NhbnZhcywncGFuc3RhcnQnLGhpZGVfY2hyb21lKTtcbiAgICAgICAgYmVhbi5hZGQodGhpcy5fY2FudmFzLCdwYW5lbmQnLHNob3dfY2hyb21lKTtcbiAgICAgICAgYmVhbi5hZGQodGhpcy5fY2FudmFzLCdfYW5pbV9iZWdpbicsaGlkZV9jaHJvbWUpO1xuICAgICAgICBiZWFuLmFkZCh0aGlzLl9jYW52YXMsJ19hbmltX2VuZCcsc2hvd19jaHJvbWUpO1xuICAgICAgICBuYXZfY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ0RPTU1vdXNlU2Nyb2xsJyx3aGVlbF9mbixmYWxzZSk7XG4gICAgICAgIG5hdl9jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignd2hlZWwnLHdoZWVsX2ZuLGZhbHNlKTtcbiAgICAgICAgbmF2X2NhbnZhcy5vbm1vdXNld2hlZWwgPSB3aGVlbF9mbjtcblxuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgZHJhd0FtaW5vQWNpZHMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJlbmRlcmVyID0gdGhpcztcbiAgICAgICAgdmFyIGFhcyA9IHJlbmRlcmVyLmFkZFRleHRUcmFjayh0aGlzLnNlcXVlbmNlLHRoaXMuX2NhbnZhcy5zZXQoKSk7XG4gICAgICAgIGFhcy5hdHRyKHsneScgOiAwLjUqcmVuZGVyZXIuX2F4aXNfaGVpZ2h0KnJlbmRlcmVyLl9SU30pO1xuICAgICAgICByZW5kZXJlci5zZWxlY3QgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciB2YWxzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgICAgIHZhciBmcm9tID0gdmFsc1swXTtcbiAgICAgICAgICAgIHZhciB0byA9IHZhbHNbMV07XG4gICAgICAgICAgICB0aGlzLm1vdmVIaWdobGlnaHQuYXBwbHkodGhpcyx2YWxzKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHpvb21jaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGFhcy5hdHRyKHsneScgOiAwLjUqcmVuZGVyZXIuX2F4aXNfaGVpZ2h0KnJlbmRlcmVyLl9SU30pO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgY2FudmFzID0gcmVuZGVyZXIuX2NhbnZhcztcbiAgICAgICAgYmVhbi5hZGQoY2FudmFzLCd6b29tQ2hhbmdlJywgem9vbWNoYW5nZSk7XG4gICAgICAgIGJlYW4uYWRkKGFhcywncmVtb3ZlZCcsZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBiZWFuLnJlbW92ZShjYW52YXMsJ3pvb21DaGFuZ2UnLHpvb21jaGFuZ2UpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGFhcztcbiAgICB9O1xuICAgIHZhciBtYWluRHJhd0F4aXM7XG4gICAgdmFyIGRyYXdBeGlzID0gbWFpbkRyYXdBeGlzID0gZnVuY3Rpb24oY2FudmFzLGxpbmVMZW5ndGgpIHtcbiAgICAgICAgdmFyIFJTID0gdGhpcy5fUlM7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIHggPSAwLCBpID0gMDtcbiAgICBcbiAgICBcbiAgICAgICAgdmFyIGF4aXMgPSBjYW52YXMuc2V0KCk7XG5cbiAgICAgICAgdmFyIGF4aXNfYmFjayA9IGNhbnZhcy5yZWN0KDAsMCxsaW5lTGVuZ3RoLDEuNSk7XG4gICAgICAgIGF4aXNfYmFjay5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLFwidXJsKCcjXCIrc2VsZi5heGlzX3BhdHRlcm5faWQrXCInKVwiKTtcbiAgICAgICAgYXhpc19iYWNrLnJlbW92ZUF0dHJpYnV0ZSgnc3Ryb2tlJyk7XG4gICAgICAgIGF4aXNfYmFjay5yZW1vdmVBdHRyaWJ1dGUoJ3N0cm9rZS13aWR0aCcpO1xuICAgICAgICBheGlzX2JhY2suc2V0QXR0cmlidXRlKCdpZCcsJ2F4aXNfYmFjaycpO1xuXG4gICAgICAgIHZhciBiYXNlX2F4aXNfaGVpZ2h0ID0gMzA7XG5cbiAgICAgICAgdmFyIGFsbF9sYWJlbHMgPSBjYW52YXMuc2V0KCk7XG4gICAgICAgIHZhciBtYWpvcl9tYXJrX2xhYmVscyA9IGNhbnZhcy5zZXQoKTtcbiAgICAgICAgdmFyIG1pbm9yX21hcmtfbGFiZWxzID0gY2FudmFzLnNldCgpO1xuICAgICAgICB2YXIgdGhvdXNhbmRfbWFya19sYWJlbHMgPSBjYW52YXMuc2V0KCk7XG4gICAgICAgIHZhciBtaW5vcl9tYXJrID0gMTA7XG4gICAgICAgIHZhciBtYWpvcl9tYXJrID0gMjA7XG4gICAgICAgIFxuICAgICAgICBpZiAodGhpcy5zZXF1ZW5jZS5sZW5ndGggPiA1MDAwKSB7XG4gICAgICAgICAgICBtaW5vcl9tYXJrID0gMTAwO1xuICAgICAgICAgICAgbWFqb3JfbWFyayA9IDIwMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zZXF1ZW5jZS5sZW5ndGggPiAxMDAwKSB7XG4gICAgICAgICAgICBtaW5vcl9tYXJrID0gMjA7XG4gICAgICAgICAgICBtYWpvcl9tYXJrID0gNDA7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICggaSA9IDA7IGkgPCAobGluZUxlbmd0aC81KTsgaSsrICkge1xuXG4gICAgICAgICAgICB2YXIgYV90ZXh0ID0gY2FudmFzLnRleHQoeC0wLjUsMCxcIlwiKyh4KSk7XG4gICAgICAgICAgICBhbGxfbGFiZWxzLnB1c2goYV90ZXh0KTtcblxuICAgICAgICAgICAgaWYgKCAoeCAlIG1ham9yX21hcmspID09PSAwICYmIHggIT09IDApIHtcbiAgICAgICAgICAgICAgICBtYWpvcl9tYXJrX2xhYmVscy5wdXNoKGFfdGV4dCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCggeCAlIG1pbm9yX21hcmsgKSA9PT0gMCAmJiB4ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgbWlub3JfbWFya19sYWJlbHMucHVzaChhX3RleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCAoeCAlICgyNTAqcGFyc2VJbnQodGhpcy5zZXF1ZW5jZS5sZW5ndGggLyA1MDApKSkgPT09IDAgJiYgeCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHRob3VzYW5kX21hcmtfbGFiZWxzLnB1c2goYV90ZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHggKz0gNTtcbiAgICAgICAgfVxuICAgIFxuICAgICAgICBmb3IgKCBpID0gMDsgaSA8IGFsbF9sYWJlbHMubGVuZ3RoOyBpKysgKSB7XG4gICAgICAgICAgICBhbGxfbGFiZWxzW2ldLnN0eWxlLnRleHRBbmNob3IgPSAnbWlkZGxlJztcbiAgICAgICAgICAgIGFsbF9sYWJlbHNbaV0uZmlyc3RDaGlsZC5zZXRBdHRyaWJ1dGUoJ2R5JywnMS41ZXgnKTtcbiAgICAgICAgfVxuICAgIFxuICAgICAgICBhbGxfbGFiZWxzLmF0dHIoeydwb2ludGVyLWV2ZW50cycgOiAnbm9uZScsICd0ZXh0LWFuY2hvcicgOiAnbWlkZGxlJywgJ2ZvbnQtc2l6ZScgOiA3KlJTKydwdCd9KTtcbiAgICAgICAgYWxsX2xhYmVscy5oaWRlKCk7XG5cbiAgICAgICBzZWxmLl9heGlzX2hlaWdodCA9IHBhcnNlSW50KCBiYXNlX2F4aXNfaGVpZ2h0IC8gc2VsZi56b29tKTtcblxuICAgIFxuICAgICAgICB2YXIgem9vbV9zdGF0dXMgPSBudWxsO1xuICAgICAgICB2YXIgem9vbWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHJlbmRlcmVyID0gc2VsZjtcbiAgICAgICAgICAgICAgIHJlbmRlcmVyLl9heGlzX2hlaWdodCA9IHBhcnNlSW50KCBiYXNlX2F4aXNfaGVpZ2h0IC8gcmVuZGVyZXIuem9vbSk7XG4gICAgICAgICAgICAgICB2YXIgcGF0dGVybiA9IHJlbmRlcmVyLl9jYW52YXMub3duZXJTVkdFbGVtZW50LmdldEVsZW1lbnRCeUlkKHJlbmRlcmVyLmF4aXNfcGF0dGVybl9pZCk7XG5cbiAgICAgICAgICAgICAgIHRob3VzYW5kX21hcmtfbGFiZWxzLmZvckVhY2goZnVuY3Rpb24obGFiZWwpIHtcbiAgICAgICAgICAgICAgICBsYWJlbC5zZXRBdHRyaWJ1dGUoJ3Zpc2liaWxpdHknLCdoaWRkZW4nKTtcbiAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICBpZiAodGhpcy56b29tID4gMy42KSB7XG4gICAgICAgICAgICAgICAgICAgYXhpc19iYWNrLnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJywndHJhbnNsYXRlKC01LCcrKDAuMypyZW5kZXJlci5fYXhpc19oZWlnaHQqUlMpKycpJyk7XG4gICAgICAgICAgICAgICAgICAgYXhpc19iYWNrLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywwLjI1KnJlbmRlcmVyLl9heGlzX2hlaWdodCpSUyk7XG4gICAgICAgICAgICAgICAgICAgcGF0dGVybi5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywxMCpSUyk7XG4gICAgICAgICAgICAgICAgICAgcGF0dGVybi5maXJzdENoaWxkLnNldEF0dHJpYnV0ZSgneCcsOS41KlJTKTtcbiAgICAgICAgICAgICAgICAgICBwYXR0ZXJuLmZpcnN0Q2hpbGQuc2V0QXR0cmlidXRlKCd3aWR0aCcsUlMgLyByZW5kZXJlci56b29tKTtcblxuICAgICAgICAgICAgICAgICAgIG1pbm9yX21hcmtfbGFiZWxzLnNob3coKTtcbiAgICAgICAgICAgICAgICAgICBtYWpvcl9tYXJrX2xhYmVscy5zaG93KCk7XG4gICAgICAgICAgICAgICAgICAgdmFyIHRleHRfc2NhbGUgPSAwLjE1KnNlbGYuX2F4aXNfaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgIGlmICh0ZXh0X3NjYWxlIDwgMSkge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0X3NjYWxlID0gMTtcbiAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgbWlub3JfbWFya19sYWJlbHMuYXR0cih7ICdmb250LXNpemUnIDogKHRleHRfc2NhbGUqUlMpKydwdCcsICd0ZXh0LWFuY2hvcicgOiAnZW5kJyB9KTtcbiAgICAgICAgICAgICAgICAgICBtYWpvcl9tYXJrX2xhYmVscy5hdHRyKHsgJ2ZvbnQtc2l6ZScgOiAodGV4dF9zY2FsZSpSUykrJ3B0JywgJ3RleHQtYW5jaG9yJyA6ICdlbmQnIH0pO1xuICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl92aXNpYmxlVHJhY2VycyAmJiB0aGlzLl92aXNpYmxlVHJhY2VycygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Zpc2libGVUcmFjZXJzKCkuc2hvdygpO1xuICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy56b29tID4gMS44KSB7XG5cbiAgICAgICAgICAgICAgICAgICBtaW5vcl9tYXJrX2xhYmVscy5oaWRlKCk7XG4gICAgICAgICAgICAgICAgICAgbWFqb3JfbWFya19sYWJlbHMuc2hvdygpO1xuICAgICAgICAgICAgICAgICAgIG1ham9yX21hcmtfbGFiZWxzLmF0dHIoeyAnZm9udC1zaXplJyA6ICgwLjUqUlMqc2VsZi5fYXhpc19oZWlnaHQpKydwdCcsICd0ZXh0LWFuY2hvcicgOiAnbWlkZGxlJyB9KTtcbiAgICAgICAgICAgICAgICAgICBheGlzX2JhY2suc2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nLCd0cmFuc2xhdGUoLTI1LCcrKDAuNSpyZW5kZXJlci5fYXhpc19oZWlnaHQqUlMpKycpJyk7XG4gICAgICAgICAgICAgICAgICAgYXhpc19iYWNrLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywwLjMqcmVuZGVyZXIuX2F4aXNfaGVpZ2h0KlJTKTtcbiAgICAgICAgICAgICAgICAgICBwYXR0ZXJuLnNldEF0dHJpYnV0ZSgnd2lkdGgnLDIwKlJTKTtcbiAgICAgICAgICAgICAgICAgICBwYXR0ZXJuLmZpcnN0Q2hpbGQuc2V0QXR0cmlidXRlKCd3aWR0aCcsUlMgLyByZW5kZXJlci56b29tICk7XG4gICAgICAgICAgICAgICAgICAgcGF0dGVybi5maXJzdENoaWxkLnNldEF0dHJpYnV0ZSgneCcsJzAnKTtcbiAgICAgICAgICAgICAgICAgICBpZiAodGhpcy50cmFjZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgIHRoaXMudHJhY2Vycy5oaWRlKCk7XG4gICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnpvb20gPiAwLjIpIHtcblxuICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnRyYWNlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50cmFjZXJzLmhpZGUoKTtcbiAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgbWlub3JfbWFya19sYWJlbHMuaGlkZSgpO1xuICAgICAgICAgICAgICAgICAgIG1ham9yX21hcmtfbGFiZWxzLnNob3coKTtcbiAgICAgICAgICAgICAgICAgICBtYWpvcl9tYXJrX2xhYmVscy5hdHRyKHsgJ2ZvbnQtc2l6ZScgOiAoMC41KlJTKnNlbGYuX2F4aXNfaGVpZ2h0KSsncHQnLCAndGV4dC1hbmNob3InIDogJ21pZGRsZScgfSk7XG4gICAgICAgICAgICAgICAgICAgYXhpc19iYWNrLnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJywndHJhbnNsYXRlKC0yNSwnKygwLjUqcmVuZGVyZXIuX2F4aXNfaGVpZ2h0KlJTKSsnKScpO1xuICAgICAgICAgICAgICAgICAgIGF4aXNfYmFjay5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsMC4zKnJlbmRlcmVyLl9heGlzX2hlaWdodCpSUyk7XG4gICAgICAgICAgICAgICAgICAgcGF0dGVybi5zZXRBdHRyaWJ1dGUoJ3dpZHRoJyw1MCpSUyk7XG4gICAgICAgICAgICAgICAgICAgcGF0dGVybi5maXJzdENoaWxkLnNldEF0dHJpYnV0ZSgnd2lkdGgnLFJTIC8gcmVuZGVyZXIuem9vbSk7XG5cblxuXG4gICAgICAgICAgICAgICAgICAgdmFyIGxhc3RfcmlnaHQgPSAtMTAwMDA7XG4gICAgICAgICAgICAgICAgICAgdmFyIGNoYW5nZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICBtYWpvcl9tYXJrX2xhYmVscy5mb3JFYWNoKGZ1bmN0aW9uKGxhYmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICggISBsYWJlbC5jYWNoZWRfYmJveCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWwuY2FjaGVkX2Jib3ggPSBsYWJlbC5nZXRCQm94KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhYmVsLmNhY2hlZF9iYm94LnggPD0gKGxhc3RfcmlnaHQrKFJTKjEwKSkgfHwgKHBhcnNlSW50KGxhYmVsLnRleHRDb250ZW50KSAlIDUwKSAhPSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbC5zZXRBdHRyaWJ1dGUoJ3Zpc2liaWxpdHknLCdoaWRkZW4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWwuc2V0QXR0cmlidXRlKCd2aXNpYmlsaXR5JywndmlzaWJsZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdF9yaWdodCA9IGxhYmVsLmNhY2hlZF9iYm94LnggKyBsYWJlbC5jYWNoZWRfYmJveC53aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIG1ham9yX21hcmtfbGFiZWxzWzBdLnNldEF0dHJpYnV0ZSgndmlzaWJpbGl0eScsJ2hpZGRlbicpO1xuICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgaWYgKHRoaXMudHJhY2Vycykge1xuICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRyYWNlcnMuaGlkZSgpO1xuICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICBtaW5vcl9tYXJrX2xhYmVscy5oaWRlKCk7XG4gICAgICAgICAgICAgICAgICAgbWFqb3JfbWFya19sYWJlbHMuaGlkZSgpO1xuICAgICAgICAgICAgICAgICAgIHRob3VzYW5kX21hcmtfbGFiZWxzLnNob3coKTtcbiAgICAgICAgICAgICAgICAgICB0aG91c2FuZF9tYXJrX2xhYmVscy5hdHRyKHsgJ2ZvbnQtc2l6ZScgOiAoMC41KlJTKnNlbGYuX2F4aXNfaGVpZ2h0KSsncHQnLCAndGV4dC1hbmNob3InIDogJ21pZGRsZScgfSk7XG5cbiAgICAgICAgICAgICAgICAgICBheGlzX2JhY2suc2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nLCd0cmFuc2xhdGUoLTUwLCcrKDAuODUqcmVuZGVyZXIuX2F4aXNfaGVpZ2h0KlJTKSsnKScpO1xuICAgICAgICAgICAgICAgICAgIGF4aXNfYmFjay5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsMC4xKnJlbmRlcmVyLl9heGlzX2hlaWdodCpSUyk7XG4gICAgICAgICAgICAgICAgICAgcGF0dGVybi5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywyNTAqUlMpO1xuICAgICAgICAgICAgICAgICAgIHBhdHRlcm4uZmlyc3RDaGlsZC5zZXRBdHRyaWJ1dGUoJ3dpZHRoJyxSUyAvIHJlbmRlcmVyLnpvb20pO1xuXG5cbiAgICAgICAgICAgICAgICAgICB2YXIgbGFzdF9yaWdodCA9IC0xMDAwMDtcbiAgICAgICAgICAgICAgICAgICB2YXIgY2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgIHRob3VzYW5kX21hcmtfbGFiZWxzLmZvckVhY2goZnVuY3Rpb24obGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCAhIGxhYmVsLmNhY2hlZF9iYm94KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbC5jYWNoZWRfYmJveCA9IGxhYmVsLmdldEJCb3goKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAobGFiZWwuY2FjaGVkX2Jib3gueCA8PSAobGFzdF9yaWdodCsoUlMqMTApKSB8fCAocGFyc2VJbnQobGFiZWwudGV4dENvbnRlbnQpICUgMjUwKSAhPSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbC5zZXRBdHRyaWJ1dGUoJ3Zpc2liaWxpdHknLCdoaWRkZW4nKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsLnNldEF0dHJpYnV0ZSgndmlzaWJpbGl0eScsJ3Zpc2libGUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RfcmlnaHQgPSBsYWJlbC5jYWNoZWRfYmJveC54ICsgbGFiZWwuY2FjaGVkX2Jib3gud2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICBpZiAoY2hhbmdlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aG91c2FuZF9tYXJrX2xhYmVsc1swXS5zZXRBdHRyaWJ1dGUoJ3Zpc2liaWxpdHknLCdoaWRkZW4nKTtcbiAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGJlYW4uYWRkKGNhbnZhcywnem9vbUNoYW5nZScsIHpvb21jaGFuZ2UpO1xuICAgICAgICBiZWFuLmFkZChheGlzLCdyZW1vdmVkJyxmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGJlYW4ucmVtb3ZlKGNhbnZhcywnem9vbUNoYW5nZScsem9vbWNoYW5nZSk7XG4gICAgICAgICAgICB2YXIgcmVtb3ZlciA9IGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVsLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGF4aXNfYmFjay5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGF4aXNfYmFjayk7XG4gICAgICAgICAgICBhbGxfbGFiZWxzLmZvckVhY2gocmVtb3Zlcik7XG5cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBheGlzO1xuICAgIH07XG5cbiAgICBjbGF6ei5wcm90b3R5cGUucGFuVG8gPSBmdW5jdGlvbihlbmQsY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHJlbmRlcmVyID0gdGhpcztcbiAgICAgICAgdmFyIHBvcyA9IHJlbmRlcmVyLmxlZnRWaXNpYmxlUmVzaWR1ZSgpO1xuICAgICAgICB2YXIgZGVsdGEgPSAxO1xuICAgICAgICBpZiAocG9zID09IGVuZCkge1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2suY2FsbChudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9zID4gZW5kKSB7XG4gICAgICAgICAgICBkZWx0YSA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJlbmRlcmVyLnNldExlZnRWaXNpYmxlUmVzaWR1ZShwb3MpO1xuICAgICAgICAgICAgcG9zICs9IGRlbHRhO1xuICAgICAgICAgICAgYmVhbi5maXJlKHJlbmRlcmVyLl9jYW52YXMsJ3BhbmVuZCcpO1xuICAgICAgICAgICAgaWYgKHBvcyAhPT0gZW5kKSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFyZ3VtZW50cy5jYWxsZWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suY2FsbChudWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBjbGF6ei5wcm90b3R5cGUuem9vbVRvID0gZnVuY3Rpb24oem9vbSxyZXNpZHVlLGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciByZW5kZXJlciA9IHRoaXM7XG4gICAgICAgIHZhciBjdXJyID0gcmVuZGVyZXIuem9vbTtcbiAgICAgICAgdmFyIGRlbHRhID0gKHpvb20gLSBjdXJyKS81MDtcbiAgICAgICAgbGV0IHpvb21jaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGJlYW4ucmVtb3ZlKHJlbmRlcmVyLCd6b29tQ2hhbmdlJyx6b29tY2hhbmdlKTtcbiAgICAgICAgICAgIGRlbGV0ZSByZW5kZXJlci56b29tQ2VudGVyO1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2suY2FsbChudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgYmVhbi5hZGQocmVuZGVyZXIsJ3pvb21DaGFuZ2UnLHpvb21jaGFuZ2UpO1xuICAgICAgICBpZiAocmVzaWR1ZSkge1xuICAgICAgICAgICAgcmVuZGVyZXIuem9vbUNlbnRlciA9IChyZXNpZHVlID09ICdjZW50ZXInKSA/IHJlc2lkdWUgOiB7ICd4JyA6IHJlbmRlcmVyLl9SUypyZXNpZHVlIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZW5kZXJlci56b29tID0gem9vbTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZW5kZXJlci56b29tID0gY3VycjtcbiAgICAgICAgICAgIGN1cnIgKz0gZGVsdGE7XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMoY3VyciAtIHpvb20pID4gMC4wMSkge1xuICAgICAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShhcmd1bWVudHMuY2FsbGVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIGNsYXp6LnByb3RvdHlwZS5zZXRMZWZ0VmlzaWJsZVJlc2lkdWUgPSBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBzZWxmLl9jYW52YXMuc2V0Q3VycmVudFRyYW5zbGF0ZVhZKChzZWxmLl9jYW52YXMud2lkdGguYmFzZVZhbC52YWx1ZSAqICgxIC0gKHZhbCAvIChzZWxmLnNlcXVlbmNlLmxlbmd0aCtzZWxmLnBhZGRpbmcrMikpKSkgLSBzZWxmLl9jYW52YXMud2lkdGguYmFzZVZhbC52YWx1ZSwwKTtcbiAgICB9O1xuXG4gICAgY2xhenoucHJvdG90eXBlLmxlZnRWaXNpYmxlUmVzaWR1ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciB2YWwgPSBNYXRoLmZsb29yKChzZWxmLnNlcXVlbmNlLmxlbmd0aCtzZWxmLnBhZGRpbmcrMikqKDEtKChzZWxmLl9jYW52YXMud2lkdGguYmFzZVZhbC52YWx1ZSArIHNlbGYuX2NhbnZhcy5jdXJyZW50VHJhbnNsYXRlQ2FjaGUueCkgLyBzZWxmLl9jYW52YXMud2lkdGguYmFzZVZhbC52YWx1ZSkpKS0xO1xuICAgICAgICBpZiAodmFsIDwgMCkge1xuICAgICAgICAgICAgdmFsID0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH07XG5cbiAgICBjbGF6ei5wcm90b3R5cGUucmlnaHRWaXNpYmxlUmVzaWR1ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBjb250YWluZXJfd2lkdGggPSBzZWxmLl9jb250YWluZXJfY2FudmFzLnBhcmVudE5vZGUuY2FjaGVkX3dpZHRoO1xuICAgICAgICBpZiAoICEgY29udGFpbmVyX3dpZHRoICkge1xuICAgICAgICAgICAgY29udGFpbmVyX3dpZHRoID0gc2VsZi5fY29udGFpbmVyX2NhbnZhcy5wYXJlbnROb2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoO1xuICAgICAgICB9XG4gICAgICAgIHZhciB2YWwgPSBNYXRoLmZsb29yKHNlbGYubGVmdFZpc2libGVSZXNpZHVlKCkgKyAoc2VsZi5zZXF1ZW5jZS5sZW5ndGgrc2VsZi5wYWRkaW5nKzIpKihjb250YWluZXJfd2lkdGgvIHNlbGYuX2NhbnZhcy53aWR0aC5iYXNlVmFsLnZhbHVlKSk7XG4gICAgICAgIGlmICh2YWwgPiBzZWxmLnNlcXVlbmNlLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFsID0gc2VsZi5zZXF1ZW5jZS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbDtcbiAgICB9O1xuXG4gICAgY2xhenoucHJvdG90eXBlLmFkZEF4aXNTY2FsZSA9IGZ1bmN0aW9uKGlkZW50aWZpZXIsc2NhbGVyKSB7XG4gICAgICAgIGlmICggISB0aGlzLl9zY2FsZXJzICkge1xuICAgICAgICAgICAgdGhpcy5fc2NhbGVycyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzY2FsZXJzID0gdGhpcy5fc2NhbGVycy5maWx0ZXIoIHNjYWxlID0+IHNjYWxlLmlkZW50aWZpZXIgIT09IGlkZW50aWZpZXIgKTtcbiAgICAgICAgc2NhbGVycy5wdXNoKHNjYWxlcik7XG4gICAgICAgIHRoaXMuX3NjYWxlcnMgPSBzY2FsZXJzO1xuICAgICAgICBzY2FsZXIuaWRlbnRpZmllciA9IGlkZW50aWZpZXI7XG4gICAgICAgIHJldHVybiBzY2FsZXI7XG4gICAgfTtcblxuICAgIGNsYXp6LnByb3RvdHlwZS5yZWZyZXNoU2NhbGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgbGF5cyA9IE9iamVjdC5rZXlzKHRoaXMuX2xheWVyX2NvbnRhaW5lcnMpO1xuICAgICAgICBsYXlzLmZvckVhY2goZnVuY3Rpb24obGF5KSB7XG4gICAgICAgICAgICBzZWxmLl9sYXllcl9jb250YWluZXJzW2xheV0uZm9yRWFjaChmdW5jdGlvbihlbCkge1xuICAgICAgICAgICAgICAgIGlmIChlbC5tb3ZlICYmIGVsLmFhKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBhYSA9IHNlbGYuc2NhbGVQb3NpdGlvbihlbC5hYSxsYXkpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYWFfd2lkdGggPSBzZWxmLnNjYWxlUG9zaXRpb24oZWwuYWErZWwuYWFfd2lkdGgsbGF5KSA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhYSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFhICo9IC0xO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChhYV93aWR0aCA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFhX3dpZHRoICo9IC0xO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsLm1vdmUoYWEtMSxhYV93aWR0aC1hYSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBjbGF6ei5wcm90b3R5cGUuc2NhbGVQb3NpdGlvbiA9IGZ1bmN0aW9uKGFhLGxheWVyLGludmVyc2UpIHtcbiAgICAgICAgdmFyIGxheWVyX29iaiA9IE1BU0NQLmdldExheWVyKGxheWVyKTtcbiAgICAgICAgaWYgKCAhIGxheWVyX29iaiApIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdNaXNzaW5nIGxheWVyIG9iamVjdCBmb3IgbGF5ZXIgaWRlbnRpZmllcicsbGF5ZXIsJ21ha2luZyBkdW1teSBsYXllciBzY2FsZWQgd2l0aCBpZGVudGlmaWVyJyxsYXllcik7XG4gICAgICAgICAgICBsYXllcl9vYmogPSB7ICduYW1lJyA6IGxheWVyLCAnc2NhbGVzJyA6IG5ldyBTZXQoKSB9O1xuICAgICAgICAgICAgbGF5ZXJfb2JqLnNjYWxlcy5hZGQobGF5ZXIpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzY2FsZXJfZnVuY3MgPSAodGhpcy5fc2NhbGVycyB8fCBbXSkuY29uY2F0KFtdKTtcbiAgICAgICAgdmFyIG5ld19hYSA9IChpbnZlcnNlID8gc2NhbGVyX2Z1bmNzLnJldmVyc2UoKSA6IHNjYWxlcl9mdW5jcykucmVkdWNlKCh2YWwsZm4pID0+IHsgIHJldHVybiBmbih2YWwsbGF5ZXJfb2JqLGludmVyc2UpOyB9LGFhKTtcbiAgICAgICAgcmV0dXJuIG5ld19hYTtcbiAgICB9O1xuXG4gICAgY2xhenoucHJvdG90eXBlLmdldEFBID0gZnVuY3Rpb24oYWEsbGF5ZXIsc2NhbGVfbmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRBbWlub0FjaWRzQnlQb3NpdGlvbihbYWFdLGxheWVyLHNjYWxlX25hbWUpLnNoaWZ0KCk7XG4gICAgfTtcblxuICAgIGNsYXp6LnByb3RvdHlwZS5nZXRBbWlub0FjaWRzQnlQb3NpdGlvbiA9IGZ1bmN0aW9uKGFhcyxsYXllcikge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBuZXdfYWFzID0gYWFzLm1hcChmdW5jdGlvbihhYSkgeyByZXR1cm4gTWF0aC5hYnMoc2VsZi5zY2FsZVBvc2l0aW9uKGFhLGxheWVyKSk7IH0pO1xuICAgICAgICB2YXIgcmVzdWx0cyA9IFNlcXVlbmNlUmVuZGVyZXIucHJvdG90eXBlLmdldEFtaW5vQWNpZHNCeVBvc2l0aW9uLmNhbGwodGhpcyxuZXdfYWFzKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5ld19hYXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHRzW2ldKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0c1tpXS5vcmlnaW5hbF9pbmRleCA9IGFhc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9O1xuXG4gICAgY2xhenoucHJvdG90eXBlLmdldEFtaW5vQWNpZHNCeVBlcHRpZGUgPSBmdW5jdGlvbihwZXB0aWRlLGxheWVyKSB7XG4gICAgICAgIGxheWVyID0gTUFTQ1AuZ2V0TGF5ZXIobGF5ZXIpO1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBwb3NpdGlvbnMgPSBbXTtcbiAgICAgICAgdmFyIHNlbGZfc2VxO1xuICAgICAgICB2YXIgaWRlbnRpZmllciA9IGxheWVyLmFjY2Vzc2lvbjtcbiAgICAgICAgaWYgKHNlbGYuc2VxdWVuY2VzKSB7XG4gICAgICAgICAgICBzZWxmX3NlcSA9IHNlbGYuc2VxdWVuY2VzIFsgKCBzZWxmLnNlcXVlbmNlcy5tYXAoZnVuY3Rpb24oc2VxKSB7ICByZXR1cm4gKHNlcS5hZ2kgfHwgc2VxLmFjYyB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpOyAgfSkgKS5pbmRleE9mKGlkZW50aWZpZXIudG9Mb3dlckNhc2UoKSkgXS50b1N0cmluZygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2VsZl9zZXEgPSBzZWxmLnNlcXVlbmNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdGFydCA9IHNlbGZfc2VxLmluZGV4T2YocGVwdGlkZSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGVwdGlkZS5sZW5ndGg7IGkrKyApIHtcbiAgICAgICAgICAgIHBvc2l0aW9ucy5wdXNoKHN0YXJ0K2kpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHRzID0gc2VsZi5nZXRBbWlub0FjaWRzQnlQb3NpdGlvbihwb3NpdGlvbnMsbGF5ZXIpO1xuICAgICAgICBpZiAocmVzdWx0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJlc3VsdHMuYWRkVG9MYXllciA9IGZ1bmN0aW9uKGxheWVybmFtZSwgZnJhY3Rpb24sIG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0c1swXS5hZGRCb3hPdmVybGF5KGxheWVybmFtZSxyZXN1bHRzLmxlbmd0aCxmcmFjdGlvbixvcHRpb25zKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHRzLmFkZFRvTGF5ZXIgPSBmdW5jdGlvbigpIHt9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH07XG5cbiAgICBjbGF6ei5wcm90b3R5cGUud2luID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9jb250YWluZXIgJiYgdGhpcy5fY29udGFpbmVyLm93bmVyRG9jdW1lbnQgJiYgdGhpcy5fY29udGFpbmVyLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcpIHtcbiAgICAgICAgICAgIHZhciByZXR1cm5fdmFsID0gdGhpcy5fY29udGFpbmVyLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHJldHVybl92YWwgPT09ICdvYmplY3QnICYmIHJldHVybl92YWwuY29uc3RydWN0b3IgIT09IFdpbmRvdyApIHtcbiAgICAgICAgICAgICAgICByZXR1cm5fdmFsID0gcmV0dXJuX3ZhbFtPYmplY3Qua2V5cyhyZXR1cm5fdmFsKVswXV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmV0dXJuX3ZhbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG5cbiAgICBjbGF6ei5wcm90b3R5cGUuc2V0U2VxdWVuY2UgPSBmdW5jdGlvbihzZXF1ZW5jZSkge1xuICAgICAgICB2YXIgbmV3X3NlcXVlbmNlID0gdGhpcy5fY2xlYW5TZXF1ZW5jZShzZXF1ZW5jZSk7XG4gICAgICAgIGlmIChuZXdfc2VxdWVuY2UgPT0gdGhpcy5zZXF1ZW5jZSAmJiBuZXdfc2VxdWVuY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGJlYW4uZmlyZSh0aGlzLCdzZXF1ZW5jZUNoYW5nZScpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgXG4gICAgICAgIGlmICghIG5ld19zZXF1ZW5jZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgXG4gICAgICAgIHRoaXMuc2VxdWVuY2UgPSBuZXdfc2VxdWVuY2U7XG5cbiAgICAgICAgZGVsZXRlIHRoaXMuc2VxdWVuY2VzO1xuXG4gICAgICAgIHZhciBzZXFfY2hhcnMgPSB0aGlzLnNlcXVlbmNlLnNwbGl0KCcnKTtcbiAgICAgICAgdmFyIGxpbmVfbGVuZ3RoID0gc2VxX2NoYXJzLmxlbmd0aDtcblxuICAgICAgICBpZiAobGluZV9sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZW5kZXJlciA9IHRoaXM7XG5cblxuICAgICAgICB2YXIgYnVpbGRfc2VxdWVuY2VfZWxzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgc2VxX2VscyA9IFtdO1xuICAgICAgICAgICAgcmVuZGVyZXIuc2VxdWVuY2Uuc3BsaXQoJycpLmZvckVhY2goIGZ1bmN0aW9uKGFhLGkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZWwgPSB7fTtcbiAgICAgICAgICAgICAgICBlbC5faW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIGVsLl9yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICAgICAgICAgIHJlbmRlcmVyLl9leHRlbmRFbGVtZW50KGVsKTtcbiAgICAgICAgICAgICAgICBlbC5hbWlub19hY2lkID0gYWE7XG4gICAgICAgICAgICAgICAgc2VxX2Vscy5wdXNoKGVsKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmVuZGVyZXIuX3NlcXVlbmNlX2VscyA9IHNlcV9lbHM7XG4gICAgICAgIH07XG5cbiAgICAgICAgYnVpbGRfc2VxdWVuY2VfZWxzKCk7XG5cbiAgICAgICAgdmFyIFJTID0gdGhpcy5fUlM7XG5cbiAgICAgICAgYmVhbi5yZW1vdmUodGhpcywnc3ZncmVhZHknKTtcbiAgICAgICAgYmVhbi5hZGQodGhpcywnc3ZncmVhZHknLGZ1bmN0aW9uKGNudikge1xuICAgICAgICAgICAgdmFyIGNhbnYgPSByZW5kZXJlci5fY2FudmFzO1xuICAgICAgICAgICAgY2Fudi5SUyA9IFJTO1xuICAgICAgICAgICAgY2Fudi5zZXRBdHRyaWJ1dGUoJ2JhY2tncm91bmQnLCAnIzAwMDAwMCcpO1xuICAgICAgICAgICAgY2Fudi5zZXRBdHRyaWJ1dGUoJ3ByZXNlcnZlQXNwZWN0UmF0aW8nLCd4TWluWU1pbiBtZWV0Jyk7XG4gICAgICAgIFxuICAgICAgICAgICAgdmFyIGRlZnMgPSBjYW52Lm1ha2VFbCgnZGVmcycpO1xuICAgICAgICAgICAgcmVuZGVyZXIuX2NvbnRhaW5lcl9jYW52YXMuYXBwZW5kQ2hpbGQoZGVmcyk7XG5cblxuICAgICAgICAgICAgZGVmcy5hcHBlbmRDaGlsZChjYW52Lm1ha2VfZ3JhZGllbnQoJ3RyYWNrX3NoaW5lJywnMCUnLCcxMDAlJyxbJyMxMTExMTEnLCcjYWFhYWFhJywnIzExMTExMSddLCBbMC41LDAuNSwwLjVdKSk7XG4gICAgICAgICAgICBkZWZzLmFwcGVuZENoaWxkKGNhbnYubWFrZV9ncmFkaWVudCgnc2ltcGxlX2dyYWRpZW50JywnMCUnLCcxMDAlJyxbJyNhYWFhYWEnLCcjODg4ODg4J10sIFsxLDFdKSk7XG4gICAgICAgICAgICBkZWZzLmFwcGVuZENoaWxkKGNhbnYubWFrZV9ncmFkaWVudCgnbGVmdF9mYWRlJywnMTAwJScsJzAlJyxbJyNmZmZmZmYnLCcjZmZmZmZmJ10sIFsxLDBdKSk7XG4gICAgICAgICAgICBkZWZzLmFwcGVuZENoaWxkKGNhbnYubWFrZV9ncmFkaWVudCgncmlnaHRfZmFkZScsJzEwMCUnLCcwJScsWycjZmZmZmZmJywnI2ZmZmZmZiddLCBbMCwxXSkpO1xuICAgICAgICAgICAgZGVmcy5hcHBlbmRDaGlsZChjYW52Lm1ha2VfZ3JhZGllbnQoJ3JlZF8zZCcsJzAlJywnMTAwJScsWycjQ0YwMDAwJywnIzU0MDAwMCddLCBbMSwxXSkpO1xuICAgICAgICBcbiAgICAgICAgICAgIHJlbmRlcmVyLmdyYWRpZW50cyA9IFtdO1xuICAgICAgICAgICAgcmVuZGVyZXIuYWRkM2RHcmFkaWVudCA9IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgICAgICAgICAgICAgZGVmcy5hcHBlbmRDaGlsZChjYW52Lm1ha2VfZ3JhZGllbnQoJ2dyYWRfJytjb2xvciwnMCUnLCcxMDAlJyxbY29sb3IsJyNmZmZmZmYnLGNvbG9yXSxbMSwxLDFdICkpO1xuICAgICAgICAgICAgICAgIHJlbmRlcmVyLmdyYWRpZW50cy5wdXNoKGNvbG9yKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciBzaGFkb3cgPSBjYW52Lm1ha2VFbCgnZmlsdGVyJyx7XG4gICAgICAgICAgICAgICAgJ2lkJzonZHJvcF9zaGFkb3cnLFxuICAgICAgICAgICAgICAgICdmaWx0ZXJVbml0cyc6J29iamVjdEJvdW5kaW5nQm94JyxcbiAgICAgICAgICAgICAgICAneCc6ICctNTAlJyxcbiAgICAgICAgICAgICAgICAneSc6ICctNTAlJyxcbiAgICAgICAgICAgICAgICAnd2lkdGgnOicyMDAlJyxcbiAgICAgICAgICAgICAgICAnaGVpZ2h0JzonMjAwJSdcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBzaGFkb3cuYXBwZW5kQ2hpbGQoY2Fudi5tYWtlRWwoJ2ZlR2F1c3NpYW5CbHVyJyx7J2luJzonU291cmNlR3JhcGhpYycsICdzdGREZXZpYXRpb24nOic0JywgJ3Jlc3VsdCcgOiAnYmx1cl9vdXQnfSkpO1xuICAgICAgICAgICAgc2hhZG93LmFwcGVuZENoaWxkKGNhbnYubWFrZUVsKCdmZU9mZnNldCcseydpbic6J2JsdXJfb3V0JywgJ3Jlc3VsdCc6J3RoZV9zaGFkb3cnLCAnZHgnOiczJywnZHknOicxJ30pKTtcbiAgICAgICAgICAgIHNoYWRvdy5hcHBlbmRDaGlsZChjYW52Lm1ha2VFbCgnZmVCbGVuZCcseydpbic6J1NvdXJjZUdyYXBoaWMnLCAnaW4yJzondGhlX3NoYWRvdycsICdtb2RlJzonbm9ybWFsJ30pKTtcbiAgICAgICAgXG4gICAgICAgICAgICBkZWZzLmFwcGVuZENoaWxkKHNoYWRvdyk7XG4gICAgICAgICAgICB2YXIgbGlua19pY29uID0gY2Fudi5tYWtlRWwoJ3N2Zycse1xuICAgICAgICAgICAgICAgICd3aWR0aCcgOiAnMTAwJScsXG4gICAgICAgICAgICAgICAgJ2hlaWdodCc6ICcxMDAlJyxcbiAgICAgICAgICAgICAgICAnaWQnICAgIDogJ25ld19saW5rX2ljb24nLFxuICAgICAgICAgICAgICAgICd2aWV3Qm94JzogJzAgMCAxMDAgMTAwJyxcbiAgICAgICAgICAgICAgICAncHJlc2VydmVBc3BlY3RSYXRpbycgOiAneE1pbllNaW4gbWVldCdcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBkZWZzLmFwcGVuZENoaWxkKGxpbmtfaWNvbik7XG5cbiAgICAgICAgICAgIGxpbmtfaWNvbi5hcHBlbmRDaGlsZChjYW52Lm1ha2VFbCgncmVjdCcsIHtcbiAgICAgICAgICAgICAgICAneCcgOiAnMTIuNScsXG4gICAgICAgICAgICAgICAgJ3knIDogJzM3LjUnLFxuICAgICAgICAgICAgICAgICdzdHJva2Utd2lkdGgnIDogJzMnLFxuICAgICAgICAgICAgICAgICd3aWR0aCcgOiAnNTAnLFxuICAgICAgICAgICAgICAgICdoZWlnaHQnOiAnNTAnLFxuICAgICAgICAgICAgICAgICdzdHJva2UnOiAnI2ZmZmZmZicsXG4gICAgICAgICAgICAgICAgJ2ZpbGwnICA6ICdub25lJyAgICAgICAgICAgIFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgbGlua19pY29uLmFwcGVuZENoaWxkKGNhbnYubWFrZUVsKCdwYXRoJywge1xuICAgICAgICAgICAgICAgICdkJyA6ICdNIDUwLjAsMTYuNyBMIDgzLjMsMTYuNyBMIDgzLjMsNTAuMCBMIDc5LjIsNTYuMiBMIDY4LjgsMzkuNiBMIDQzLjgsNjYuNyBMIDMzLjMsNTYuMiBMIDYwLjQsMzEuMiBMIDQzLjgsMjAuOCBMIDUwLjAsMTYuNyB6JyxcbiAgICAgICAgICAgICAgICAnc3Ryb2tlLXdpZHRoJyA6ICczJyxcbiAgICAgICAgICAgICAgICAnc3Ryb2tlJzogJyM5OTk5OTknLFxuICAgICAgICAgICAgICAgICdmaWxsJyAgOiAnI2ZmZmZmZicgICAgICAgICAgICBcbiAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgdmFyIHBsdXNfaWNvbiA9IGNhbnYubWFrZUVsKCdzdmcnLHtcbiAgICAgICAgICAgICAgICAnd2lkdGgnIDogJzEwMCUnLFxuICAgICAgICAgICAgICAgICdoZWlnaHQnOiAnMTAwJScsXG4gICAgICAgICAgICAgICAgJ2lkJyAgICA6ICdwbHVzX2ljb24nLFxuICAgICAgICAgICAgICAgICd2aWV3Qm94JzogJzAgMCAxMDAgMTAwJyxcbiAgICAgICAgICAgICAgICAncHJlc2VydmVBc3BlY3RSYXRpbycgOiAneE1pbllNaW4gbWVldCdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcGx1c19pY29uLmFwcGVuZENoaWxkKGNhbnYucGx1cygwLDAsMTAwL2NhbnYuUlMpKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZGVmcy5hcHBlbmRDaGlsZChwbHVzX2ljb24pO1xuXG4gICAgICAgICAgICB2YXIgbWludXNfaWNvbiA9IGNhbnYubWFrZUVsKCdzdmcnLHtcbiAgICAgICAgICAgICAgICAnd2lkdGgnIDogJzEwMCUnLFxuICAgICAgICAgICAgICAgICdoZWlnaHQnOiAnMTAwJScsXG4gICAgICAgICAgICAgICAgJ2lkJyAgICA6ICdtaW51c19pY29uJyxcbiAgICAgICAgICAgICAgICAndmlld0JveCc6ICcwIDAgMTAwIDEwMCcsXG4gICAgICAgICAgICAgICAgJ3ByZXNlcnZlQXNwZWN0UmF0aW8nIDogJ3hNaW5ZTWluIG1lZXQnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG1pbnVzX2ljb24uYXBwZW5kQ2hpbGQoY2Fudi5taW51cygwLDAsMTAwL2NhbnYuUlMpKTtcblxuICAgICAgICAgICAgZGVmcy5hcHBlbmRDaGlsZChtaW51c19pY29uKTtcbiAgICAgICAgICAgIHZhciBheGlzX3BhdHRlcm5faWQgPSAnYXhpc19wYXR0ZXJuXycrKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcbiAgICAgICAgICAgIHZhciBwYXR0ZXJuID0gY2Fudi5tYWtlRWwoJ3BhdHRlcm4nLCB7XG4gICAgICAgICAgICAgICAgJ3BhdHRlcm5Vbml0cycgOiAndXNlclNwYWNlT25Vc2UnLFxuICAgICAgICAgICAgICAgICd4JyAgICAgICAgICAgIDogJzAnLFxuICAgICAgICAgICAgICAgICd5JyAgICAgICAgICAgIDogJzAnLFxuICAgICAgICAgICAgICAgICd3aWR0aCcgICAgICAgIDogMTAqY2Fudi5SUyxcbiAgICAgICAgICAgICAgICAnaGVpZ2h0JyAgICAgICA6IDIqY2Fudi5SUyxcbiAgICAgICAgICAgICAgICAnaWQnICAgICAgICAgICA6IGF4aXNfcGF0dGVybl9pZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZW5kZXJlci5heGlzX3BhdHRlcm5faWQgPSBheGlzX3BhdHRlcm5faWQ7XG5cbiAgICAgICAgICAgIHZhciBsaW5lID0gY2Fudi5tYWtlRWwoJ3JlY3QnLHtcbiAgICAgICAgICAgICAgICAneCcgICAgIDogJzAnLFxuICAgICAgICAgICAgICAgICd5JyAgICAgOiAnMCcsXG4gICAgICAgICAgICAgICAgJ3dpZHRoJyA6ICcxMCUnLFxuICAgICAgICAgICAgICAgICdoZWlnaHQnOiAnMTAwMCUnLFxuICAgICAgICAgICAgICAgICdmaWxsJyAgOiAnIzAwMCcsXG4gICAgICAgICAgICAgICAgJ3N0cm9rZSc6ICcwJyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcGF0dGVybi5hcHBlbmRDaGlsZChsaW5lKTtcblxuICAgICAgICAgICAgZGVmcy5hcHBlbmRDaGlsZChwYXR0ZXJuKTtcblxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgcmVuZGVyZXIuX2F4aXNfaGVpZ2h0ID0gMTA7XG4gICAgICAgICAgICB2YXIgYWFzID0gZHJhd0FtaW5vQWNpZHMuY2FsbChzZWxmLGNhbnYpO1xuICAgICAgICAgICAgcmVuZGVyZXIuaGlkZUF4aXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBkcmF3QXhpcyA9IGZ1bmN0aW9uKGNhbnYpIHtcbiAgICAgICAgICAgICAgICAgICAgYmVhbi5hZGQoY2FudiwgJ3pvb21DaGFuZ2UnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX2F4aXNfaGVpZ2h0ID0gMTAgLyBzZWxmLnpvb207XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBzZWxmLl9heGlzX2hlaWdodCA9IDEwIC8gc2VsZi56b29tO1xuICAgICAgICAgICAgICAgIHRoaXMucmVkcmF3QXhpcygpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlbmRlcmVyLnNob3dBeGlzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgZHJhd0F4aXMgPSBtYWluRHJhd0F4aXM7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWRyYXdBeGlzKCk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgYXhpcyA9IGRyYXdBeGlzLmNhbGwoc2VsZixjYW52LGxpbmVfbGVuZ3RoKTtcbiAgICAgICAgICAgIHJlbmRlcmVyLnJlZHJhd0F4aXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBiZWFuLmZpcmUoYXhpcywncmVtb3ZlZCcpO1xuICAgICAgICAgICAgICAgIGFhcy5mb3JFYWNoKGZ1bmN0aW9uKGFhKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhYS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhYS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGFhKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJlYW4uZmlyZShhYXMsJ3JlbW92ZWQnKTtcbiAgICAgICAgICAgICAgICBheGlzID0gZHJhd0F4aXMuY2FsbChzZWxmLGNhbnYscmVuZGVyZXIuc2VxdWVuY2UubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBhYXMgPSBkcmF3QW1pbm9BY2lkcy5jYWxsKHNlbGYsY2Fudik7XG5cbiAgICAgICAgICAgICAgICBidWlsZF9zZXF1ZW5jZV9lbHMoKTtcbiAgICAgICAgICAgICAgICByZW5kZXJlci5yZWZyZXNoKCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKCAhIHJlbmRlcmVyLmhpZGVfYXhpcyApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNob3dBeGlzKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuaGlkZUF4aXMoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVuZGVyZXIuX2xheWVyX2NvbnRhaW5lcnMgPSB7fTtcbiAgICAgICAgICAgIHJlbmRlcmVyLmVuYWJsZVByaW50UmVzaXppbmcoKTtcbiAgICAgICAgICAgIHJlbmRlcmVyLmVuYWJsZVNjYWxpbmcoKTtcbiAgICAgICAgICAgIHJlbmRlcmVyLmVuYWJsZVNlbGVjdGlvbigpO1xuXG4gICAgICAgICAgICAvLyBXaGVuIHdlIGhhdmUgYSBsYXllciByZWdpc3RlcmVkIHdpdGggdGhlIGdsb2JhbCBNQVNDUCBvYmplY3RcbiAgICAgICAgICAgIC8vIGFkZCBhIHRyYWNrIHdpdGhpbiB0aGlzIHJlbmRlcmVyLlxuICAgICAgICAgICAgYmVhbi5hZGQoTUFTQ1AsJ2xheWVyUmVnaXN0ZXJlZCcsIGZ1bmN0aW9uKGxheWVyLHJlbmQpIHtcbiAgICAgICAgICAgICAgICBpZiAoISByZW5kIHx8IHJlbmQgPT09IHJlbmRlcmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcmVyLmFkZFRyYWNrKGxheWVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgYmVhbi5maXJlKHJlbmRlcmVyLCdzZXF1ZW5jZUNoYW5nZScpO1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIGNhbnZhcyA9IGNyZWF0ZUNhbnZhc09iamVjdC5jYWxsKHRoaXMpO1xuICAgICAgICBpZiAoISB0aGlzLl9jYW52YXMpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3Znd2ViICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgc3Znd2ViLmFwcGVuZENoaWxkKGNhbnZhcyx0aGlzLl9jb250YWluZXIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb250YWluZXIuYXBwZW5kQ2hpbGQoY2FudmFzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIFxuICAgICAgICB2YXIgcmVuZCA9IHRoaXM7XG4gICAgICAgIHRoaXMuRW5hYmxlSGlnaGxpZ2h0cygpO1xuICAgIFxuICAgICAgICB2YXIgc2VxX2NoYW5nZV9mdW5jID0gZnVuY3Rpb24ob3RoZXJfZnVuYykge1xuICAgICAgICAgICAgaWYgKCAhIHJlbmQuX2NhbnZhcyApIHtcbiAgICAgICAgICAgICAgICBiZWFuLmFkZChyZW5kLCdzZXF1ZW5jZUNoYW5nZScsZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGJlYW4ucmVtb3ZlKHJlbmQsJ3NlcXVlbmNlQ2hhbmdlJyxhcmd1bWVudHMuY2FsbGVlKTtcbiAgICAgICAgICAgICAgICAgICAgb3RoZXJfZnVuYy5hcHBseSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdGhlcl9mdW5jLmFwcGx5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgXG4gICAgICAgIHNlcV9jaGFuZ2VfZnVuYy5yZWFkeSA9IGZ1bmN0aW9uKG90aGVyX2Z1bmMpIHtcbiAgICAgICAgICAgIHRoaXMuY2FsbCh0aGlzLG90aGVyX2Z1bmMpO1xuICAgICAgICB9O1xuICAgIFxuICAgICAgICByZXR1cm4gc2VxX2NoYW5nZV9mdW5jO1xuICAgIFxuICAgIH07XG5cbn0pKENvbmRlbnNlZFNlcXVlbmNlUmVuZGVyZXIpO1xuXG5cbihmdW5jdGlvbigpIHtcbiAgICB2YXIgc3ZnbnMgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnO1xuICAgIHZhciBhZGRfaW1wb3J0ID0gZnVuY3Rpb24ob3duZXJkb2MpIHtcbiAgICAgICAgaWYgKCFvd25lcmRvYy5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgICBvd25lcmRvYy5FTEVNRU5UX05PREUgPSAxO1xuICAgICAgICAgIG93bmVyZG9jLkFUVFJJQlVURV9OT0RFID0gMjtcbiAgICAgICAgICBvd25lcmRvYy5URVhUX05PREUgPSAzO1xuICAgICAgICAgIG93bmVyZG9jLkNEQVRBX1NFQ1RJT05fTk9ERSA9IDQ7XG4gICAgICAgICAgb3duZXJkb2MuRU5USVRZX1JFRkVSRU5DRV9OT0RFID0gNTtcbiAgICAgICAgICBvd25lcmRvYy5FTlRJVFlfTk9ERSA9IDY7XG4gICAgICAgICAgb3duZXJkb2MuUFJPQ0VTU0lOR19JTlNUUlVDVElPTl9OT0RFID0gNztcbiAgICAgICAgICBvd25lcmRvYy5DT01NRU5UX05PREUgPSA4O1xuICAgICAgICAgIG93bmVyZG9jLkRPQ1VNRU5UX05PREUgPSA5O1xuICAgICAgICAgIG93bmVyZG9jLkRPQ1VNRU5UX1RZUEVfTk9ERSA9IDEwO1xuICAgICAgICAgIG93bmVyZG9jLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREUgPSAxMTtcbiAgICAgICAgICBvd25lcmRvYy5OT1RBVElPTl9OT0RFID0gMTI7XG4gICAgICAgIH1cblxuICAgICAgICBvd25lcmRvYy5faW1wb3J0Tm9kZSA9IGZ1bmN0aW9uKG5vZGUsIGFsbENoaWxkcmVuKSB7XG4gICAgICAgICAgc3dpdGNoIChub2RlLm5vZGVUeXBlKSB7XG4gICAgICAgICAgICBjYXNlIG93bmVyZG9jLkVMRU1FTlRfTk9ERTpcbiAgICAgICAgICAgICAgdmFyIG5ld05vZGUgPSBvd25lcmRvYy5jcmVhdGVFbGVtZW50TlMoc3ZnbnMsbm9kZS5ub2RlTmFtZSk7XG4gICAgICAgICAgICAgIC8qIGRvZXMgdGhlIG5vZGUgaGF2ZSBhbnkgYXR0cmlidXRlcyB0byBhZGQ/ICovXG4gICAgICAgICAgICAgIGlmIChub2RlLmF0dHJpYnV0ZXMgJiYgbm9kZS5hdHRyaWJ1dGVzLmxlbmd0aCA+IDApXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlsID0gbm9kZS5hdHRyaWJ1dGVzLmxlbmd0aDsgaSA8IGlsOykge1xuICAgICAgICAgICAgICAgICAgaWYgKCEgL15vbi8udGVzdChub2RlLmF0dHJpYnV0ZXNbaV0ubm9kZU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgbmV3Tm9kZS5zZXRBdHRyaWJ1dGUobm9kZS5hdHRyaWJ1dGVzW2ldLm5vZGVOYW1lLCBub2RlLmdldEF0dHJpYnV0ZShub2RlLmF0dHJpYnV0ZXNbaSsrXS5ub2RlTmFtZSkpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLyogYXJlIHdlIGdvaW5nIGFmdGVyIGNoaWxkcmVuIHRvbywgYW5kIGRvZXMgdGhlIG5vZGUgaGF2ZSBhbnk/ICovXG4gICAgICAgICAgICAgIGlmIChhbGxDaGlsZHJlbiAmJiBub2RlLmNoaWxkTm9kZXMgJiYgbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCA+IDApXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlsID0gbm9kZS5jaGlsZE5vZGVzLmxlbmd0aDsgaSA8IGlsOykge1xuICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuY2hpbGROb2Rlc1tpXS5ub2RlTmFtZSAhPT0gJ1VTRScgJiYgbm9kZS5jaGlsZE5vZGVzW2ldLm5vZGVOYW1lLnRvVXBwZXJDYXNlKCkgIT09ICdTQ1JJUFQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgbmV3Tm9kZS5hcHBlbmRDaGlsZChvd25lcmRvYy5faW1wb3J0Tm9kZShub2RlLmNoaWxkTm9kZXNbaSsrXSwgYWxsQ2hpbGRyZW4pKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBuZXdOb2RlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2Ugb3duZXJkb2MuVEVYVF9OT0RFOlxuICAgICAgICAgICAgY2FzZSBvd25lcmRvYy5DREFUQV9TRUNUSU9OX05PREU6XG4gICAgICAgICAgICBjYXNlIG93bmVyZG9jLkNPTU1FTlRfTk9ERTpcbiAgICAgICAgICAgICAgcmV0dXJuIG93bmVyZG9jLmNyZWF0ZVRleHROb2RlKG5vZGUubm9kZVZhbHVlKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICB2YXIgZml4X2NoaWxkX2xpbmtzID0gZnVuY3Rpb24obm9kZSxwcmVmaXgpIHtcbiAgICAgIGlmIChub2RlLmNoaWxkTm9kZXMgJiYgbm9kZS5jaGlsZE5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGlsID0gbm9kZS5jaGlsZE5vZGVzLmxlbmd0aDsgaSA8IGlsOykge1xuICAgICAgICAgIGlmIChub2RlLmNoaWxkTm9kZXNbaV0ubm9kZU5hbWUudG9VcHBlckNhc2UoKSA9PT0gJ1VTRScpIHtcbiAgICAgICAgICAgIHZhciBsaW5rdmFsID0gbm9kZS5jaGlsZE5vZGVzW2ldLmdldEF0dHJpYnV0ZSgneGxpbms6aHJlZicpO1xuICAgICAgICAgICAgbm9kZS5jaGlsZE5vZGVzW2ldLnNldEF0dHJpYnV0ZSgneGxpbms6aHJlZicsbGlua3ZhbC5yZXBsYWNlKC9eIy8sJyMnK3ByZWZpeCsnXycpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIENvbmRlbnNlZFNlcXVlbmNlUmVuZGVyZXIucHJvdG90eXBlLmltcG9ydEljb25zID0gZnVuY3Rpb24obmFtZXNwYWNlLGRvYyxhbHRfdXJsKSB7XG4gICAgICAgIHZhciBuZXdfb3duZXIgPSB0aGlzLl9jb250YWluZXJfY2FudmFzLm93bmVyRG9jdW1lbnQ7XG4gICAgICAgIGlmICh0aGlzLl9jb250YWluZXJfY2FudmFzLmdldEVsZW1lbnRCeUlkKCdkZWZzXycrbmFtZXNwYWNlKSl7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY29udGFpbmVyX2NhbnZhcy5hcHBlbmRDaGlsZChuZXdfb3duZXIuY3JlYXRlRWxlbWVudCgnZGVmcycpKTtcbiAgICAgICAgdGhpcy5fY29udGFpbmVyX2NhbnZhcy5sYXN0Q2hpbGQuc2V0QXR0cmlidXRlKCdpZCcsJ2RlZnNfJytuYW1lc3BhY2UpO1xuICAgICAgICB2YXIgZGVmc19ibG9jayA9IHRoaXMuX2NvbnRhaW5lcl9jYW52YXMubGFzdENoaWxkO1xuXG4gICAgICAgIGlmICggISBuZXdfb3duZXIuX2ltcG9ydE5vZGUgKSB7XG4gICAgICAgICAgICBhZGRfaW1wb3J0KG5ld19vd25lcik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHVhID0gd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQ7XG4gICAgICAgIGlmICh1YS5pbmRleE9mKCdFZGdlLycpID49IDApIHtcbiAgICAgICAgICAgIHRoaXMuaWNvbnNfZmFpbGVkID0gdGhpcy5pY29uc19mYWlsZWQgfHwge307XG4gICAgICAgICAgICB0aGlzLmljb25zX2ZhaWxlZFtuYW1lc3BhY2VdID0gYWx0X3VybDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmV3X25vZGVzID0gbmV3X293bmVyLl9pbXBvcnROb2RlKGRvYyx0cnVlKTtcbiAgICAgICAgaWYgKHR5cGVvZiBYUGF0aFJlc3VsdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHZhciBpdGVyYXRvciA9IG5ld19vd25lci5ldmFsdWF0ZSgnLy9zdmc6ZGVmcy8qJyxuZXdfbm9kZXMsZnVuY3Rpb24obnMpIHsgcmV0dXJuIHN2Z25zOyB9ICxYUGF0aFJlc3VsdC5BTllfVFlQRSxudWxsKTtcbiAgICAgICAgICAgIHZhciBlbCA9IGl0ZXJhdG9yLml0ZXJhdGVOZXh0KCk7XG4gICAgICAgICAgICB2YXIgdG9fYXBwZW5kID0gW107XG4gICAgICAgICAgICB3aGlsZSAoZWwpIHtcbiAgICAgICAgICAgICAgICB0b19hcHBlbmQucHVzaChlbCk7XG4gICAgICAgICAgICAgICAgZWwgPSBpdGVyYXRvci5pdGVyYXRlTmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRvX2FwcGVuZC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmljb25zX2ZhaWxlZCA9IHRoaXMuaWNvbnNfZmFpbGVkIHx8IHt9O1xuICAgICAgICAgICAgICAgIHRoaXMuaWNvbnNfZmFpbGVkW25hbWVzcGFjZV0gPSBhbHRfdXJsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG9fYXBwZW5kLmZvckVhY2goZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2lkJyxuYW1lc3BhY2UrJ18nK2VsLmdldEF0dHJpYnV0ZSgnaWQnKSk7XG4gICAgICAgICAgICAgICAgZml4X2NoaWxkX2xpbmtzKGVsLG5hbWVzcGFjZSk7XG4gICAgICAgICAgICAgICAgZGVmc19ibG9jay5hcHBlbmRDaGlsZChlbCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBlbHMgPSBuZXdfbm9kZXMucXVlcnlTZWxlY3RvckFsbCgnZGVmcyA+IConKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwIDsgaSA8IGVscy5sZW5ndGg7IGkrKyApIHtcbiAgICAgICAgICAgICAgICBlbHNbaV0uc2V0QXR0cmlidXRlKCdpZCcsbmFtZXNwYWNlKydfJytlbHNbaV0uZ2V0QXR0cmlidXRlKCdpZCcpKTtcbiAgICAgICAgICAgICAgICBmaXhfY2hpbGRfbGlua3MoZWwsbmFtZXNwYWNlKTtcbiAgICAgICAgICAgICAgICBkZWZzX2Jsb2NrLmFwcGVuZENoaWxkKGVsc1tpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG59KSgpO1xuXG5cbkNvbmRlbnNlZFNlcXVlbmNlUmVuZGVyZXIucHJvdG90eXBlLmFkZFZhbHVlc1RvTGF5ZXIgPSBmdW5jdGlvbihsYXllck5hbWUsdmFsdWVzLG9wdGlvbnMpIHtcbiAgICB2YXIgUlMgPSB0aGlzLl9SUztcbiAgICBcbiAgICB2YXIgY2FudmFzID0gdGhpcy5fY2FudmFzO1xuICAgIFxuICAgIGlmICggISBjYW52YXMgKSB7ICAgICAgICBcbiAgICAgICAgdmFyIG9yaWdfZnVuYyA9IGFyZ3VtZW50cy5jYWxsZWU7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgYmVhbi5hZGQodGhpcy5fcmVuZGVyZXIsJ3NlcXVlbmNlY2hhbmdlJyxmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGJlYW4ucmVtb3ZlKHRoaXMuX3JlbmRlcmVyLCdzZXF1ZW5jZWNoYW5nZScsYXJndW1lbnRzLmNhbGxlZSk7XG4gICAgICAgICAgICBvcmlnX2Z1bmMuY2FsbChzZWxmLGxheWVyTmFtZSx2YWx1ZXMpO1xuICAgICAgICB9KTtcbiAgICAgICAgbG9nKFwiRGVsYXlpbmcgcmVuZGVyaW5nLCB3YWl0aW5nIGZvciBzZXF1ZW5jZSBjaGFuZ2VcIik7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbWF4X3ZhbHVlO1xuICAgIHZhciBtaW5fdmFsdWU7XG4gICAgdmFyIGhlaWdodF9zY2FsZSA9IDE7XG4gICAgXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICBpZiAob3B0aW9ucy5oZWlnaHQpIHtcbiAgICAgICAgaGVpZ2h0X3NjYWxlID0gb3B0aW9ucy5oZWlnaHQgLyB0aGlzLl9sYXllcl9jb250YWluZXJzW2xheWVyTmFtZV0udHJhY2tfaGVpZ2h0O1xuICAgIH1cblxuICAgIHZhciBvZmZzZXRfc2NhbGUgPSAwO1xuICAgIGlmIChvcHRpb25zLm9mZnNldCkge1xuICAgICAgICBvZmZzZXRfc2NhbGUgPSBvcHRpb25zLm9mZnNldCAvIHRoaXMuX2xheWVyX2NvbnRhaW5lcnNbbGF5ZXJOYW1lXS50cmFja19oZWlnaHQ7XG4gICAgfVxuICAgIHZhciByZWNhbGN1bGF0ZV9wbG90ICA9IGZ1bmN0aW9uKHNjYWxlKSB7XG4gICAgICAgIHZhciBwbG90X3BhdGggPSAnIG0nKygtMC41KlJTKSsnIDAnO1xuICAgICAgICB2YXIgbGFzdF92YWx1ZSA9IG51bGw7XG4gICAgICAgIHZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoIHR5cGVvZihsYXN0X3ZhbHVlKSA9PSAndW5kZWZpbmVkJyApIHtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGxvdF9wYXRoICs9ICcgbCcrUlMrJyAnKygtMSAqUlMqc2NhbGUqaGVpZ2h0X3NjYWxlKih2YWx1ZSAtIGxhc3RfdmFsdWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxhc3RfdmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIGlmIChpc05hTihtYXhfdmFsdWUpIHx8ICh2YWx1ZSA+IG1heF92YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBtYXhfdmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc05hTihtaW5fdmFsdWUpIHx8ICh2YWx1ZSA8IG1pbl92YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBtaW5fdmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwbG90X3BhdGg7XG4gICAgfTtcbiAgICB2YXIgcGxvdCA9IHRoaXMuX2NhbnZhcy5wYXRoKCdNMCAwIE0wIDAgbTAgJysoKG1heF92YWx1ZSB8fCAwKSkqUlMrJyAnK3JlY2FsY3VsYXRlX3Bsb3QoMSkpO1xuICAgIHZhciBhYnNfbWluX3ZhbCA9IG1pbl92YWx1ZTtcbiAgICB2YXIgYWJzX21heF92YWwgPSBtYXhfdmFsdWU7XG4gICAgcGxvdC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZScsb3B0aW9ucy5jb2xvciB8fCAnI2ZmMDAwMCcpO1xuICAgIHBsb3Quc2V0QXR0cmlidXRlKCdzdHJva2Utd2lkdGgnLCAob3B0aW9ucy50aGlja25lc3MgfHwgMC4zNSkqUlMpO1xuICAgIHBsb3Quc2V0QXR0cmlidXRlKCdmaWxsJywgJ25vbmUnKTtcbiAgICBwbG90LnNldEF0dHJpYnV0ZSgndmlzaWJpbGl0eScsJ2hpZGRlbicpO1xuICAgIHBsb3Quc2V0QXR0cmlidXRlKCdwb2ludGVyLWV2ZW50cycsJ25vbmUnKTtcbiAgICB0aGlzLl9sYXllcl9jb250YWluZXJzW2xheWVyTmFtZV0ucHVzaChwbG90KTtcbiAgICBwbG90LnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJywndHJhbnNsYXRlKDEsMTApIHNjYWxlKDEsMSknKTtcbiAgICBpZiAoISBvcHRpb25zLmhpZGVfYXhpcykge1xuICAgICAgICB2YXIgYXhpcyA9IHRoaXMuX2NhbnZhcy5wYXRoKCdNMCAwIG0wICcrKFJTKigobWF4X3ZhbHVlIHx8IDApIC0gKG1pbl92YWx1ZSB8fCAwKSkpKycgbCcrdGhpcy5fc2VxdWVuY2VfZWxzLmxlbmd0aCpSUysnIDAnKTtcbiAgICAgICAgYXhpcy5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS13aWR0aCcsMC4yKlJTKTtcbiAgICAgICAgYXhpcy5zZXRBdHRyaWJ1dGUoJ3Zpc2liaWxpdHknLCdoaWRkZW4nKTtcbiAgICAgICAgYXhpcy5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsJ3RyYW5zbGF0ZSgxLDApJyk7XG4gICAgICAgIGF4aXMuc2V0QXR0cmlidXRlKCdwb2ludGVyLWV2ZW50cycsJ25vbmUnKTtcbiAgICAgICAgYXhpcy5zZXRIZWlnaHQgPSBmdW5jdGlvbihoZWlnaHQpIHtcbiAgICAgICAgICAgIGlmIChhYnNfbWluX3ZhbCA8IDAgJiYgYWJzX21heF92YWwgPiAwKSB7XG4gICAgICAgICAgICAgICAgYXhpcy5zZXRBdHRyaWJ1dGUoJ2QnLCdNMCAwIE0wIDAgbTAgJysoaGVpZ2h0Km9mZnNldF9zY2FsZSkrJyBtMCAnKygwLjUqaGVpZ2h0KmhlaWdodF9zY2FsZSkrJyBsJytyZW5kZXJlci5fc2VxdWVuY2VfZWxzLmxlbmd0aCpSUysnIDAnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYXhpcy5zZXRBdHRyaWJ1dGUoJ2QnLCdNMCAwIE0wIDAgbTAgJysoaGVpZ2h0Km9mZnNldF9zY2FsZSkrJyBtMCAnKygwLjUqKDEtYWJzX21pbl92YWwpKmhlaWdodCpoZWlnaHRfc2NhbGUpKycgbCcrcmVuZGVyZXIuX3NlcXVlbmNlX2Vscy5sZW5ndGgqUlMrJyAwJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBheGlzLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLXdpZHRoJywwLjIqUlMvcmVuZGVyZXIuem9vbSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2xheWVyX2NvbnRhaW5lcnNbbGF5ZXJOYW1lXS5wdXNoKGF4aXMpO1xuICAgIH1cbiAgICB2YXIgcmVuZGVyZXIgPSB0aGlzO1xuXG4gICAgaWYgKG9wdGlvbnMubGFiZWwpIHtcbiAgICAgICAgdmFyIHRleHQgPSB0aGlzLl9jYW52YXMudGV4dCgwLDAsIG9wdGlvbnMubGFiZWwubWF4IHx8IG9wdGlvbnMubGFiZWwubWluICk7XG4gICAgICAgIHRleHQuc2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nLCd0cmFuc2xhdGUoMCwwKScpO1xuICAgICAgICB0ZXh0LnNldEF0dHJpYnV0ZSgnZm9udC1zaXplJywgKDQqUlMpKydwdCcpO1xuICAgICAgICB0ZXh0LnNldEhlaWdodCA9IGZ1bmN0aW9uKGhlaWdodCkge1xuICAgICAgICAgICAgdGV4dC5zZXRBdHRyaWJ1dGUoJ3knLGhlaWdodCpvZmZzZXRfc2NhbGUpO1xuICAgICAgICAgICAgdGV4dC5zZXRBdHRyaWJ1dGUoJ2ZvbnQtc2l6ZScsKDQqUlMvcmVuZGVyZXIuem9vbSkrJ3B0Jyk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2xheWVyX2NvbnRhaW5lcnNbbGF5ZXJOYW1lXS5wdXNoKHRleHQpO1xuICAgIH1cblxuICAgIHBsb3Quc2V0SGVpZ2h0ID0gZnVuY3Rpb24oaGVpZ2h0KSB7XG4gICAgICAgIHZhciBwYXRoX3ZhbHMgPSByZWNhbGN1bGF0ZV9wbG90KDAuNSpoZWlnaHQvUlMpO1xuICAgICAgICBwbG90LnNldEF0dHJpYnV0ZSgnZCcsJ00wIDAgTTAgMCBtMCAnKyhoZWlnaHQqb2Zmc2V0X3NjYWxlKSsnIG0wICcrKDAuNSpoZWlnaHQqaGVpZ2h0X3NjYWxlKSsnICcrcGF0aF92YWxzKTtcbiAgICAgICAgcGxvdC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS13aWR0aCcsKChvcHRpb25zLnRoaWNrbmVzcyB8fCAwLjM1KSpSUykvcmVuZGVyZXIuem9vbSk7XG4gICAgfTtcbiAgICByZXR1cm4gcGxvdDtcbn07XG5cbihmdW5jdGlvbigpIHtcbnZhciBhZGRFbGVtZW50VG9MYXllciA9IGZ1bmN0aW9uKGxheWVyTmFtZSxvcHRzKSB7XG4gICAgdmFyIGNhbnZhcyA9IHRoaXMuX3JlbmRlcmVyLl9jYW52YXM7XG5cbiAgICBpZiAoICEgY2FudmFzICkgeyAgICAgICAgXG4gICAgICAgIHZhciBvcmlnX2Z1bmMgPSBhcmd1bWVudHMuY2FsbGVlO1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIGJlYW4uYWRkKHRoaXMuX3JlbmRlcmVyLCdzZXF1ZW5jZWNoYW5nZScsZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBiZWFuLnJlbW92ZSh0aGlzLl9yZW5kZXJlciwnc2VxdWVuY2VjaGFuZ2UnLGFyZ3VtZW50cy5jYWxsZWUpOyAgICAgICAgICAgIFxuICAgICAgICAgICAgb3JpZ19mdW5jLmNhbGwoc2VsZixsYXllck5hbWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgbG9nKFwiRGVsYXlpbmcgcmVuZGVyaW5nLCB3YWl0aW5nIGZvciBzZXF1ZW5jZSBjaGFuZ2VcIik7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgdHJhY2VyID0gbnVsbDtcbiAgICB2YXIgdHJhY2VyX21hcmtlciA9IG51bGw7XG4gICAgdmFyIHJlbmRlcmVyID0gdGhpcy5fcmVuZGVyZXI7XG5cbiAgICBpZiAoICEgb3B0cyApIHtcbiAgICAgICAgb3B0cyA9IHt9O1xuICAgIH1cblxuICAgIHZhciBzY2FsZSA9IDE7XG4gICAgaWYgKG9wdHMuaGVpZ2h0KSB7XG4gICAgICAgIG9wdHMuaGVpZ2h0ID0gcGFyc2VGbG9hdChvcHRzLmhlaWdodCk7XG4gICAgICAgIGlmICh0eXBlb2Yob3B0cy5oZWlnaHQpICE9PSAndW5kZWZpbmVkJyAmJiBvcHRzLmJhcmVfZWxlbWVudCApIHtcbiAgICAgICAgICAgIG9wdHMuaGVpZ2h0ICo9IDI7XG4gICAgICAgIH1cbiAgICAgICAgc2NhbGUgPSBvcHRzLmhlaWdodCAvIHRoaXMuX3JlbmRlcmVyLl9sYXllcl9jb250YWluZXJzW2xheWVyTmFtZV0udHJhY2tfaGVpZ2h0O1xuICAgICAgICBpZiAodHlwZW9mKG9wdHMub2Zmc2V0KSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIG9wdHMub2Zmc2V0ICA9IC0xLjI1IC0xLjI1ICsgKG9wdHMub2Zmc2V0IC8gb3B0cy5oZWlnaHQpICogNTsvLyAoIC0yNTAvNCArICh4IC8gaGVpZ2h0KSAqIDI1MCApIHdoZXJlIDI1MCBpcyBncm93aW5nIG1hcmtlciBoZWlnaHRcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciB0cmFjZXJfbWFya2VyID0gY2FudmFzLmdyb3dpbmdNYXJrZXIoMCwwLG9wdHMuY29udGVudCB8fCBsYXllck5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCksb3B0cyk7XG4gICAgdHJhY2VyX21hcmtlci5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsJ3RyYW5zbGF0ZSgnKygodGhpcy5faW5kZXggKyAwLjUpICogdGhpcy5fcmVuZGVyZXIuX1JTKSArJywwLjAxKSBzY2FsZSgnK3NjYWxlKycpJyk7XG4gICAgdHJhY2VyX21hcmtlci5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsJzI1MCcpO1xuICAgIHRyYWNlcl9tYXJrZXIuZmlyc3RDaGlsZC5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoLTEwMCwwKSByb3RhdGUoMCwxMDAsMC4wMDEpJyk7XG4gICAgaWYgKCBvcHRzLmJyZWFrX3ZpZXdib3ggKSB7XG4gICAgICAgIHRyYWNlcl9tYXJrZXIuY29udGFpbmVyLnJlbW92ZUF0dHJpYnV0ZSgndmlld0JveCcpO1xuICAgICAgICB0cmFjZXJfbWFya2VyLmNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgJzEwMCUnKTtcbiAgICAgICAgdHJhY2VyX21hcmtlci5jb250YWluZXIuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCcxMDAlJyk7XG4gICAgfVxuICAgIGlmICghIG9wdHMubm9fdHJhY2VyICkge1xuXG4gICAgICAgIHZhciBib2JibGUgPSBjYW52YXMuY2lyY2xlKHRoaXMuX2luZGV4KzAuNSwxMCwwLjI1KTtcbiAgICAgICAgYm9iYmxlLnNldEF0dHJpYnV0ZSgndmlzaWJpbGl0eScsJ2hpZGRlbicpO1xuICAgICAgICBib2JibGUuc3R5bGUub3BhY2l0eSA9ICcwLjQnO1xuICAgICAgICB0cmFjZXIgPSBjYW52YXMucmVjdCh0aGlzLl9pbmRleCswLjUsMTAsMC4wNSwwKTtcbiAgICAgICAgdHJhY2VyLl9pbmRleCA9IHRoaXMuX2luZGV4O1xuICAgICAgICB0cmFjZXIuc3R5bGUuc3Ryb2tlV2lkdGggPSAnMCc7XG4gICAgICAgIHRyYWNlci5zdHlsZS5maWxsID0gTUFTQ1AubGF5ZXJzW2xheWVyTmFtZV0uY29sb3I7XG4gICAgICAgIHRyYWNlci5zZXRBdHRyaWJ1dGUoJ3Zpc2liaWxpdHknLCdoaWRkZW4nKTtcbiAgICAgICAgY2FudmFzLmluc2VydEJlZm9yZSh0cmFjZXIsY2FudmFzLmZpcnN0Q2hpbGQubmV4dFNpYmxpbmcpO1xuICAgICAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLl9yZW5kZXJlcjtcblxuICAgICAgICBpZiAoICEgdGhpcy5fcmVuZGVyZXIuX2xheWVyX2NvbnRhaW5lcnNbbGF5ZXJOYW1lXS50cmFjZXJzKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJlci5fbGF5ZXJfY29udGFpbmVyc1tsYXllck5hbWVdLnRyYWNlcnMgPSBjYW52YXMuc2V0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCAhIGNhbnZhcy50cmFjZXJzICkge1xuICAgICAgICAgICAgY2FudmFzLnRyYWNlcnMgPSBjYW52YXMuc2V0KCk7XG4gICAgICAgICAgICBjYW52YXMuX3Zpc2libGVUcmFjZXJzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlbmRlcmVyLl92aXNpYmxlVHJhY2VycygpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB0cmFjZXIuc2V0SGVpZ2h0ID0gZnVuY3Rpb24oaGVpZ2h0KSB7XG4gICAgICAgICAgICBpZiAodHJhY2VyLmdldEF0dHJpYnV0ZSgndmlzaWJpbGl0eScpID09ICdoaWRkZW4nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdHJhbnNmb3JtX2F0dHIgPSB0cmFjZXJfbWFya2VyLmdldEF0dHJpYnV0ZSgndHJhbnNmb3JtJyk7XG4gICAgICAgICAgICB2YXIgbWF0Y2hlcyA9IC90cmFuc2xhdGVcXCguKlssXFxzXSguKilcXCkgc2NhbGVcXCgoLiopXFwpLy5leGVjKHRyYW5zZm9ybV9hdHRyKTtcbiAgICAgICAgICAgIGlmIChtYXRjaGVzWzFdICYmIG1hdGNoZXNbMl0pIHtcbiAgICAgICAgICAgICAgICB2YXIgc2NhbGUgPSBwYXJzZUZsb2F0KG1hdGNoZXNbMl0pO1xuICAgICAgICAgICAgICAgIHZhciB5ID0gcGFyc2VGbG9hdChtYXRjaGVzWzFdKTtcbiAgICAgICAgICAgICAgICB2YXIgbmV3X2hlaWdodCA9IHkgKyBzY2FsZSooKCh0cmFjZXJfbWFya2VyLm9mZnNldCB8fCAwKSAqIDUwKSArIDEyNSkgLSBwYXJzZUludCh0aGlzLmdldEF0dHJpYnV0ZSgneScpKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JyxuZXdfaGVpZ2h0IDwgMCA/IDAgOiBuZXdfaGVpZ2h0ICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdoZWlnaHQnLGhlaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLl9sYXllcl9jb250YWluZXJzW2xheWVyTmFtZV0udHJhY2Vycy5wdXNoKHRyYWNlcik7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLl9sYXllcl9jb250YWluZXJzW2xheWVyTmFtZV0udHJhY2Vycy5wdXNoKGJvYmJsZSk7XG4gICAgICAgIHRyYWNlci5zZXRBdHRyaWJ1dGUoJ3BvaW50ZXItZXZlbnRzJywnbm9uZScpO1xuICAgICAgICBib2JibGUuc2V0QXR0cmlidXRlKCdwb2ludGVyLWV2ZW50cycsJ25vbmUnKTtcbiAgICAgICAgY2FudmFzLnRyYWNlcnMucHVzaCh0cmFjZXIpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdHMub2Zmc2V0ID09ICd1bmRlZmluZWQnIHx8IG9wdHMub2Zmc2V0ID09PSBudWxsKSB7XG4gICAgICAgIC8vIHRyYWNlcl9tYXJrZXIub2Zmc2V0ID0gMi41KnRoaXMuX3JlbmRlcmVyLl9sYXllcl9jb250YWluZXJzW2xheWVyTmFtZV0udHJhY2tfaGVpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRyYWNlcl9tYXJrZXIub2Zmc2V0ID0gb3B0cy5vZmZzZXQ7XG4gICAgfVxuXG5cbiAgICAvLyB0cmFjZXJfbWFya2VyLnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJywnc2NhbGUoMC41KScpO1xuICAgIC8vIHRyYWNlcl9tYXJrZXIuem9vbV9sZXZlbCA9ICd0ZXh0JztcbiAgICB0cmFjZXJfbWFya2VyLnNldEF0dHJpYnV0ZSgndmlzaWJpbGl0eScsJ2hpZGRlbicpO1xuXG4gICAgdGhpcy5fcmVuZGVyZXIuX2xheWVyX2NvbnRhaW5lcnNbbGF5ZXJOYW1lXS5wdXNoKHRyYWNlcl9tYXJrZXIpO1xuICAgIHZhciByZXN1bHQgPSBbdHJhY2VyLHRyYWNlcl9tYXJrZXIsYm9iYmxlXTtcbiAgICB0cmFjZXJfbWFya2VyLnNldEF0dHJpYnV0ZSgnY2xhc3MnLGxheWVyTmFtZSk7XG4gICAgcmVzdWx0Lm1vdmUgPSBmdW5jdGlvbih4LHdpZHRoKSB7XG4gICAgICAgIHZhciB0cmFuc2Zvcm1fYXR0ciA9IHRyYWNlcl9tYXJrZXIuZ2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nKTtcbiAgICAgICAgdmFyIG1hdGNoZXMgPSAvdHJhbnNsYXRlXFwoLipbLFxcc10oLiopXFwpIHNjYWxlXFwoKC4qKVxcKS8uZXhlYyh0cmFuc2Zvcm1fYXR0cik7XG4gICAgICAgIGlmIChtYXRjaGVzWzFdICYmIG1hdGNoZXNbMl0pIHtcbiAgICAgICAgICAgIHRyYWNlcl9tYXJrZXIuc2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nLCd0cmFuc2xhdGUoJysoKHgrMC41KSpyZW5kZXJlci5fUlMpKycsJyttYXRjaGVzWzFdKycpIHNjYWxlKCcrbWF0Y2hlc1syXSsnKScpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0cmFjZXIpIHtcbiAgICAgICAgICAgIHRyYWNlci5tb3ZlKHgrMC41LDAuMDUpO1xuICAgICAgICAgICAgYm9iYmxlLm1vdmUoeCswLjUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBpZiAodHJhY2VyKSB7XG4gICAgICAgIHRyYWNlcl9tYXJrZXIudHJhY2VyID0gdHJhY2VyO1xuICAgICAgICB0cmFjZXJfbWFya2VyLmJvYmJsZSA9IGJvYmJsZTtcbiAgICB9XG4gICAgdGhpcy5fcmVuZGVyZXIuX2xheWVyX2NvbnRhaW5lcnNbbGF5ZXJOYW1lXS5wdXNoKHJlc3VsdCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbnZhciBhZGRCb3hPdmVybGF5VG9FbGVtZW50ID0gZnVuY3Rpb24obGF5ZXJOYW1lLHdpZHRoLGZyYWN0aW9uLG9wdHMpIHtcbiAgICBcbiAgICB2YXIgY2FudmFzID0gdGhpcy5fcmVuZGVyZXIuX2NhbnZhcztcbiAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLl9yZW5kZXJlcjtcbiAgICBpZiAoICEgb3B0cyApIHtcbiAgICAgICAgb3B0cyA9IHsgfTtcbiAgICB9XG4gICAgaWYgKCAhIGNhbnZhcyApIHtcbiAgICAgICAgdmFyIG9yaWdfZnVuYyA9IGFyZ3VtZW50cy5jYWxsZWU7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgYmVhbi5hZGQodGhpcy5fcmVuZGVyZXIsJ3NlcXVlbmNlY2hhbmdlJyxmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGJlYW4ucmVtb3ZlKHRoaXMuX3JlbmRlcmVyLCdzZXF1ZW5jZWNoYW5nZScsYXJndW1lbnRzLmNhbGxlZSk7XG4gICAgICAgICAgICBvcmlnX2Z1bmMuY2FsbChzZWxmLGxheWVyTmFtZSx3aWR0aCxvcHRzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGxvZyhcIkRlbGF5aW5nIHJlbmRlcmluZywgd2FpdGluZyBmb3Igc2VxdWVuY2UgY2hhbmdlXCIpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG5cbiAgICB2YXIgcmVjdCA9ICBjYW52YXMucmVjdCgtMC4yNSt0aGlzLl9pbmRleCw2MCx3aWR0aCB8fCAxLCBvcHRzLmhlaWdodCB8fCA0ICxvcHRzKTtcbiAgICB2YXIgcmVjdF94ID0gcGFyc2VGbG9hdChyZWN0LmdldEF0dHJpYnV0ZSgneCcpKTtcbiAgICB2YXIgcmVjdF9tYXhfeCA9IHJlY3RfeCArIHBhcnNlRmxvYXQocmVjdC5nZXRBdHRyaWJ1dGUoJ3dpZHRoJykpO1xuICAgIHZhciBjb250YWluZXIgPSB0aGlzLl9yZW5kZXJlci5fbGF5ZXJfY29udGFpbmVyc1tsYXllck5hbWVdO1xuICAgIGlmICggdHlwZW9mKG9wdHMubWVyZ2UpICE9PSAndW5kZWZpbmVkJyAmJiBvcHRzLm1lcmdlICkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbnRhaW5lci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGNvbnRhaW5lcltpXS52YWx1ZSAhPSBmcmFjdGlvbiApIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBlbF94ID0gcGFyc2VGbG9hdChjb250YWluZXJbaV0uZ2V0QXR0cmlidXRlKCd4JykpO1xuICAgICAgICAgICAgdmFyIGVsX21heF94ID0gZWxfeCArIHBhcnNlRmxvYXQoY29udGFpbmVyW2ldLmdldEF0dHJpYnV0ZSgnd2lkdGgnKSk7XG4gICAgICAgICAgICBpZiAoKGVsX3ggPD0gcmVjdF94ICYmIHJlY3RfeCA8PSBlbF9tYXhfeCkgfHxcbiAgICAgICAgICAgICAgICAocmVjdF94IDw9IGVsX3ggJiYgZWxfeCA8PSByZWN0X21heF94KSkge1xuICAgICAgICAgICAgICAgICAgICBjb250YWluZXJbaV0uc2V0QXR0cmlidXRlKCd4JywgXCJcIitNYXRoLm1pbihlbF94LHJlY3RfeCkpO1xuICAgICAgICAgICAgICAgICAgICBjb250YWluZXJbaV0uc2V0QXR0cmlidXRlKCd3aWR0aCcsIFwiXCIrKE1hdGgubWF4KGVsX21heF94LHJlY3RfbWF4X3gpLU1hdGgubWluKGVsX3gscmVjdF94KSkgKTtcbiAgICAgICAgICAgICAgICAgICAgcmVjdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHJlY3QpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29udGFpbmVyW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9yZW5kZXJlci5fbGF5ZXJfY29udGFpbmVyc1tsYXllck5hbWVdLnB1c2gocmVjdCk7XG4gICAgcmVjdC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJyxsYXllck5hbWUpO1xuICAgIHJlY3Quc2V0QXR0cmlidXRlKCd2aXNpYmlsaXR5JywgJ2hpZGRlbicpO1xuICAgIHJlY3Quc2V0QXR0cmlidXRlKCdzdHJva2Utd2lkdGgnLCcwcHgnKTtcbiAgICBpZiAodHlwZW9mKGZyYWN0aW9uKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmVjdC5zZXRBdHRyaWJ1dGUoJ29wYWNpdHknLGZyYWN0aW9uKTtcbiAgICAgICAgcmVjdC52YWx1ZSA9IGZyYWN0aW9uO1xuICAgIH1cbiAgICByZWN0LnNldEF0dHJpYnV0ZSgnZmlsbCcsb3B0cy5maWxsIHx8IE1BU0NQLmxheWVyc1tsYXllck5hbWVdLmNvbG9yKTtcbiAgICByZWN0LnBvc2l0aW9uX3N0YXJ0ID0gdGhpcy5faW5kZXg7XG4gICAgcmVjdC5wb3NpdGlvbl9lbmQgPSB0aGlzLl9pbmRleCArIHdpZHRoO1xuICAgIGlmICgodHlwZW9mKG9wdHMub2Zmc2V0KSAhPT0gXCJ1bmRlZmluZWRcIikgfHwgb3B0cy5oZWlnaHRfc2NhbGUpIHtcbiAgICAgICAgdmFyIG9mZnNldF92YWwgPSBvcHRzLm9mZnNldDtcbiAgICAgICAgcmVjdC5zZXRIZWlnaHQgPSBmdW5jdGlvbihoZ2h0KSB7XG4gICAgICAgICAgICB2YXIgaGVpZ2h0X3ZhbCA9IG9wdHMuaGVpZ2h0ID8gKG9wdHMuaGVpZ2h0KnJlbmRlcmVyLl9SUy9yZW5kZXJlci56b29tKSA6IGhnaHQqKG9wdHMuaGVpZ2h0X3NjYWxlIHx8IDEpO1xuICAgICAgICAgICAgaWYgKG9wdHMuYWxpZ24gPT0gJ2JvdHRvbScpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgneScsKG9mZnNldF92YWwqcmVuZGVyZXIuX1JTL3JlbmRlcmVyLnpvb20pLShoZ2h0KihvcHRzLmhlaWdodF9zY2FsZSB8fCAxKSkgKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JyxoZWlnaHRfdmFsKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3knLG9mZnNldF92YWwqcmVuZGVyZXIuX1JTL3JlbmRlcmVyLnpvb20pO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdoZWlnaHQnLGhlaWdodF92YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gcmVjdDtcbn07XG5cbnZhciBhZGRUZXh0VG9FbGVtZW50ID0gZnVuY3Rpb24obGF5ZXJOYW1lLHdpZHRoLG9wdHMpIHtcbiAgICB2YXIgY2FudmFzID0gdGhpcy5fcmVuZGVyZXIuX2NhbnZhcztcbiAgICB2YXIgcmVuZGVyZXIgPSB0aGlzLl9yZW5kZXJlcjtcbiAgICBpZiAoICEgY2FudmFzICkge1xuICAgICAgICB2YXIgb3JpZ19mdW5jID0gYXJndW1lbnRzLmNhbGxlZTtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBiZWFuLmFkZCh0aGlzLl9yZW5kZXJlciwnc2VxdWVuY2VjaGFuZ2UnLGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgYmVhbi5yZW1vdmUodGhpcy5fcmVuZGVyZXIsJ3NlcXVlbmNlY2hhbmdlJyxhcmd1bWVudHMuY2FsbGVlKTtcbiAgICAgICAgICAgIG9yaWdfZnVuYy5jYWxsKHNlbGYsbGF5ZXJOYW1lLHdpZHRoLG9wdHMpO1xuICAgICAgICB9KTtcbiAgICAgICAgbG9nKFwiRGVsYXlpbmcgcmVuZGVyaW5nLCB3YWl0aW5nIGZvciBzZXF1ZW5jZSBjaGFuZ2VcIik7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCAhIG9wdHMgKSB7XG4gICAgICAgIG9wdHMgPSB7fTtcbiAgICB9XG4gICAgaWYgKG9wdHMuaGVpZ2h0KSB7XG4gICAgICAgIG9wdHMuaGVpZ2h0ID0gb3B0cy5oZWlnaHQgKiB0aGlzLl9yZW5kZXJlci5fUlM7XG4gICAgfVxuICAgIHZhciBoZWlnaHQgPSBvcHRzLmhlaWdodCB8fCB0aGlzLl9yZW5kZXJlci5fbGF5ZXJfY29udGFpbmVyc1tsYXllck5hbWVdLnRyYWNrSGVpZ2h0IHx8IDQ7XG4gICAgdmFyIHBvc2l0aW9uID0gdGhpcy5faW5kZXg7XG4gICAgaWYgKHdpZHRoID4gMSkge1xuICAgICAgICBwb3NpdGlvbiA9IHBvc2l0aW9uICsgTWF0aC5mbG9vcigwLjUqd2lkdGgpO1xuICAgIH1cbiAgICB2YXIgdGV4dF9zY2FsZSA9ICg0LzMpO1xuICAgIHZhciB0ZXh0ID0gY2FudmFzLnRleHQocG9zaXRpb24sMCxvcHRzLnR4dCB8fCBvcHRzLmNvbnRlbnQgfHwgXCJUZXh0XCIpO1xuICAgIHRleHQuc2V0QXR0cmlidXRlKCdmb250LXNpemUnLHRleHRfc2NhbGUqaGVpZ2h0KTtcbiAgICB0ZXh0LmNhY2hlZF93aWR0aCA9IHRleHQuZ2V0Q29tcHV0ZWRUZXh0TGVuZ3RoKCkgLyBoZWlnaHQ7XG4gICAgdGV4dC5zZXRBdHRyaWJ1dGUoJ2ZvbnQtd2VpZ2h0JywnYm9sZGVyJyk7XG4gICAgdGV4dC5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLCBvcHRzLmZpbGwgfHwgJyNmZmZmZmYnKTtcbiAgICB0ZXh0LnNldEF0dHJpYnV0ZSgnc3Ryb2tlJywnIzAwMDAwMCcpO1xuICAgIGlmICghIChcInN0cm9rZV93aWR0aFwiIGluIG9wdHMpKSB7XG4gICAgICAgIG9wdHMuc3Ryb2tlX3dpZHRoID0gNTtcbiAgICB9XG4gICAgdGV4dC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS13aWR0aCcsb3B0cy5zdHJva2Vfd2lkdGgrJycpO1xuICAgIHRleHQuc2V0QXR0cmlidXRlKCdzdHlsZScsJ2ZvbnQtZmFtaWx5OiAnK2NhbnZhcy5mb250X29yZGVyKTtcbiAgICB0ZXh0LmZpcnN0Q2hpbGQuc2V0QXR0cmlidXRlKCdkeScsJzEuM2V4Jyk7XG4gICAgdGV4dC5zZXRBdHRyaWJ1dGUoJ3RleHQtYW5jaG9yJywnbWlkZGxlJyk7XG4gICAgaWYgKG9wdHMuYWxpZ24pIHtcbiAgICAgICAgaWYgKG9wdHMuYWxpZ24gPT0gXCJsZWZ0XCIpIHtcbiAgICAgICAgICAgIHRleHQuc2V0QXR0cmlidXRlKCd0ZXh0LWFuY2hvcicsICdzdGFydCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRzLmFsaWduID09ICdyaWdodCcpIHtcbiAgICAgICAgICAgIHRleHQuc2V0QXR0cmlidXRlKCd0ZXh0LWFuY2hvcicsICdlbmQnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAod2lkdGggPiAxKSB7XG4gICAgICAgIHZhciBjbGlwID0gY2FudmFzLmNsaXBQYXRoKCk7XG4gICAgICAgIHZhciBtYXNrID0gY2FudmFzLnJlY3QoLTAuNSp3aWR0aCxvcHRzLm9mZnNldCB8fCAwLHdpZHRoLGhlaWdodCk7XG4gICAgICAgIGNsaXAucHVzaChtYXNrKTtcbiAgICAgICAgbWFzay5yZW1vdmVBdHRyaWJ1dGUoJ3knKTtcbiAgICAgICAgdmFyIG1hc2tfaWQgPSAnaWQnICsgKG5ldyBEYXRlKCkpLmdldFRpbWUoKStcIl9cIitjbGlwLnBhcmVudE5vZGUuY2hpbGROb2Rlcy5sZW5ndGg7XG4gICAgICAgIGNsaXAuc2V0QXR0cmlidXRlKCdpZCcsbWFza19pZCk7XG4gICAgICAgIHRleHQuc2V0QXR0cmlidXRlKCdjbGlwLXBhdGgnLCd1cmwoIycrbWFza19pZCsnKScpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdHMub2Zmc2V0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0ZXh0LnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJywndHJhbnNsYXRlKCcrdGV4dC5nZXRBdHRyaWJ1dGUoJ3gnKSsnLCcrdGV4dC5nZXRBdHRyaWJ1dGUoJ3knKSsnKScpO1xuICAgICAgICB0ZXh0Lm9mZnNldCA9IG9wdHMub2Zmc2V0O1xuICAgICAgICB0ZXh0LnNldEhlaWdodCA9IGZ1bmN0aW9uKGhlaWdodCkge1xuICAgICAgICAgICAgdmFyIHRvcF9vZmZzZXQgPSB0aGlzLm9mZnNldDtcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCd4JywwKTtcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCd5Jyx0b3Bfb2Zmc2V0KnJlbmRlcmVyLl9SUyAvIHJlbmRlcmVyLnpvb20pO1xuICAgICAgICAgICAgaWYgKG1hc2spIG1hc2suc2V0QXR0cmlidXRlKCd5Jyx0aGlzLmdldEF0dHJpYnV0ZSgneScpKTtcbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdzdHJva2Utd2lkdGgnLCA1L3JlbmRlcmVyLnpvb20pO1xuICAgICAgICAgICAgaWYgKG9wdHMuaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2ZvbnQtc2l6ZScsIHRleHRfc2NhbGUqb3B0cy5oZWlnaHQvcmVuZGVyZXIuem9vbSk7XG4gICAgICAgICAgICAgICAgaWYgKG1hc2spIG1hc2suc2V0QXR0cmlidXRlKCdoZWlnaHQnLG9wdHMuaGVpZ2h0L3JlbmRlcmVyLnpvb20pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnZm9udC1zaXplJywgdGV4dF9zY2FsZSpoZWlnaHQpO1xuICAgICAgICAgICAgICAgIGlmIChtYXNrKSBtYXNrLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JyxoZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSBhIG1hc2ssIHdlIHdhbnQgdG8gbW92ZSB0aGUgdGV4dCB0byB0aGUgbGVmdC5cbiAgICAgICAgICAgIGlmICggbWFzayApIHtcbiAgICAgICAgICAgICAgICBpZiAoKHRoaXMuY2FjaGVkX3dpZHRoKmhlaWdodCkgPiAod2lkdGggKjUwKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgneCcsKC0wLjUqd2lkdGgqNTApKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3RleHQtYW5jaG9yJywnc3RhcnQnKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgneCcsJzAnKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3RleHQtYW5jaG9yJywnbWlkZGxlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgneCcsJzAnKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgndGV4dC1hbmNob3InLCdtaWRkbGUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0ZXh0LnNldEhlaWdodCA9IGZ1bmN0aW9uKGhlaWdodCkge1xuICAgICAgICAgICAgdGV4dC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS13aWR0aCcsIDUvcmVuZGVyZXIuem9vbSk7XG4gICAgICAgICAgICBpZiAob3B0cy5oZWlnaHQpIHtcbiAgICAgICAgICAgICAgICB0ZXh0LnNldEF0dHJpYnV0ZSgnZm9udC1zaXplJywgdGV4dF9zY2FsZSpvcHRzLmhlaWdodC9yZW5kZXJlci56b29tKTtcbiAgICAgICAgICAgICAgICBpZiAobWFzaykgbWFzay5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsb3B0cy5oZWlnaHQvcmVuZGVyZXIuem9vbSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRleHQuc2V0QXR0cmlidXRlKCdmb250LXNpemUnLCB0ZXh0X3NjYWxlKmhlaWdodCk7XG4gICAgICAgICAgICAgICAgaWYgKG1hc2spIG1hc2suc2V0QXR0cmlidXRlKCdoZWlnaHQnLGhlaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmICh3aWR0aCA+IDEpIHtcbiAgICAgICAgdGV4dC5tb3ZlID0gZnVuY3Rpb24obmV3X3gsbmV3X3dpZHRoKSB7XG4gICAgICAgICAgICBpZiAobWFzaykgbWFzay5zZXRBdHRyaWJ1dGUoJ3gnLCgtMSpuZXdfd2lkdGgqcmVuZGVyZXIuX1JTKjAuNSkpO1xuICAgICAgICAgICAgaWYgKG1hc2spIG1hc2suc2V0QXR0cmlidXRlKCd3aWR0aCcsbmV3X3dpZHRoKnJlbmRlcmVyLl9SUyk7XG4gICAgICAgICAgICB0ZXh0LnNldEF0dHJpYnV0ZSgneCcsKG5ld194ICsgcGFyc2VJbnQoMC41Km5ld193aWR0aCkpKnJlbmRlcmVyLl9SUyApO1xuICAgICAgICB9O1xuICAgIH1cbiAgICB0aGlzLl9yZW5kZXJlci5fbGF5ZXJfY29udGFpbmVyc1tsYXllck5hbWVdLnB1c2godGV4dCk7XG4gICAgcmV0dXJuIHRleHQ7XG59XG5cbnZhciBhZGRTaGFwZVRvRWxlbWVudCA9IGZ1bmN0aW9uKGxheWVyTmFtZSx3aWR0aCxvcHRzKSB7XG4gICAgdmFyIGNhbnZhcyA9IHRoaXMuX3JlbmRlcmVyLl9jYW52YXM7XG4gICAgdmFyIHJlbmRlcmVyID0gdGhpcy5fcmVuZGVyZXI7XG5cbiAgICBpZiAoICEgY2FudmFzICkge1xuICAgICAgICB2YXIgb3JpZ19mdW5jID0gYXJndW1lbnRzLmNhbGxlZTtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBiZWFuLmFkZCh0aGlzLl9yZW5kZXJlciwnc2VxdWVuY2VjaGFuZ2UnLGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgYmVhbi5yZW1vdmUodGhpcy5fcmVuZGVyZXIsJ3NlcXVlbmNlY2hhbmdlJyxhcmd1bWVudHMuY2FsbGVlKTtcbiAgICAgICAgICAgIG9yaWdfZnVuYy5jYWxsKHNlbGYsbGF5ZXJOYW1lLHdpZHRoLG9wdHMpO1xuICAgICAgICB9KTtcbiAgICAgICAgbG9nKFwiRGVsYXlpbmcgcmVuZGVyaW5nLCB3YWl0aW5nIGZvciBzZXF1ZW5jZSBjaGFuZ2VcIik7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbWV0aG9kcyA9IHtcbiAgICAgICAgXCJwZW50YWdvblwiIDogY2FudmFzLnBlbnRhZ29uLFxuICAgICAgICBcImhleGFnb25cIiAgOiBjYW52YXMuaGV4YWdvbixcbiAgICAgICAgXCJyZWN0YW5nbGVcIjogY2FudmFzLnJlY3QsXG4gICAgICAgIFwiZWxsaXBzZVwiICA6IGNhbnZhcy5lbGxpcHRpY2FsUmVjdCxcbiAgICAgICAgXCJyb3VuZHJlY3RcIjogZnVuY3Rpb24oeCx5LHdpZHRoLGhlaWdodCkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbnZhcy5yb3VuZFJlY3QoeCx5LHdpZHRoLGhlaWdodCwwLjI1KmhlaWdodCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCAhIG9wdHMucm90YXRlICkge1xuICAgICAgICBvcHRzLnJvdGF0ZSA9IDA7XG4gICAgfVxuICAgIHZhciBzaGFwZSA9IG51bGw7XG4gICAgdmFyIHNoYXBlX25hbWUgPSAob3B0cy5zaGFwZS5zcGxpdCgnLScpIHx8ICcnKVswXTtcbiAgICBpZiAoc2hhcGVfbmFtZSBpbiBtZXRob2RzKSB7XG4gICAgICAgIHZhciBpc19yb3RhdGVkID0gb3B0cy5zaGFwZS5zcGxpdCgnLScpWzFdO1xuICAgICAgICBpZiAoaXNfcm90YXRlZCA9PSAnbGVmdCcgJiYgISBvcHRzLnJvdGF0ZSkge1xuICAgICAgICAgICAgb3B0cy5yb3RhdGUgPSA5MDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNfcm90YXRlZCA9PSAncmlnaHQnICYmICEgb3B0cy5yb3RhdGUpIHtcbiAgICAgICAgICAgIG9wdHMucm90YXRlID0gMjcwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc19yb3RhdGVkID09ICdmbGlwJyAmJiAhIG9wdHMucm90YXRlKSB7XG4gICAgICAgICAgICBvcHRzLnJvdGF0ZSA9IDE4MDtcbiAgICAgICAgfVxuICAgICAgICBzaGFwZSA9IG1ldGhvZHNbc2hhcGVfbmFtZV0uY2FsbChjYW52YXMsdGhpcy5faW5kZXgsNjAsd2lkdGggfHwgMSxvcHRzLmhlaWdodCB8fCA0LG9wdHMucm90YXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICgodHlwZW9mIG9wdHMub2Zmc2V0KSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgdmFyIHhfcG9zID0gc2hhcGUuZ2V0QXR0cmlidXRlKCd4Jyk7XG4gICAgICAgIHZhciB5X3BvcyA9IHNoYXBlLmdldEF0dHJpYnV0ZSgneScpO1xuICAgICAgICBzaGFwZS5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsJ3RyYW5zbGF0ZSgnK3hfcG9zKycsJyt5X3BvcysnKScpO1xuICAgICAgICBzaGFwZS5zZXRBdHRyaWJ1dGUoJ3gnLCcwJyk7XG4gICAgICAgIHZhciBvZmZzZXRfdmFsID0gb3B0cy5vZmZzZXQgfHwgMDtcbiAgICAgICAgdmFyIG9yaWdfaGVpZ2h0ID0gb3B0cy5oZWlnaHQgfHwgNDtcbiAgICAgICAgc2hhcGUuc2V0QXR0cmlidXRlKCd5JyxvZmZzZXRfdmFsKnRoaXMuX3JlbmRlcmVyLl9SUyk7XG4gICAgICAgIHNoYXBlLnNldEhlaWdodCA9IGZ1bmN0aW9uKGhlaWdodCkge1xuICAgICAgICAgICAgaWYgKCAhIHRoaXMuX29yaWdfc3Ryb2tlX3dpZHRoICkge1xuICAgICAgICAgICAgICAgIHRoaXMuX29yaWdfc3Ryb2tlX3dpZHRoID0gcGFyc2VJbnQodGhpcy5nZXRBdHRyaWJ1dGUoJ3N0cm9rZS13aWR0aCcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNoYXBlLnNldEF0dHJpYnV0ZSgneScsIChvZmZzZXRfdmFsKnJlbmRlcmVyLl9SUy9yZW5kZXJlci56b29tKSk7XG4gICAgICAgICAgICBzaGFwZS5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsKG9yaWdfaGVpZ2h0KnJlbmRlcmVyLl9SUykvcmVuZGVyZXIuem9vbSk7XG4gICAgICAgICAgICBzaGFwZS5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS13aWR0aCcsdGhpcy5fb3JpZ19zdHJva2Vfd2lkdGgvcmVuZGVyZXIuem9vbSk7XG4gICAgICAgICAgICBpZiAoIG9wdHMuc2hhcGUgPT0gJ2VsbGlwc2UnICkge1xuICAgICAgICAgICAgICAgIHNoYXBlLnNldEF0dHJpYnV0ZSgncnknLCAwLjUqKG9yaWdfaGVpZ2h0KnJlbmRlcmVyLl9SUykvcmVuZGVyZXIuem9vbSApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdHMuc2hhcGUgPT0gJ3JvdW5kcmVjdCcpIHtcbiAgICAgICAgICAgICAgICBzaGFwZS5zZXRBdHRyaWJ1dGUoJ3J4JywgMC4yNSoob3JpZ19oZWlnaHQqcmVuZGVyZXIuX1JTKS9yZW5kZXJlci56b29tICk7XG4gICAgICAgICAgICAgICAgc2hhcGUuc2V0QXR0cmlidXRlKCdyeScsIDAuMjUqKG9yaWdfaGVpZ2h0KnJlbmRlcmVyLl9SUykvcmVuZGVyZXIuem9vbSApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBzaGFwZS5tb3ZlID0gZnVuY3Rpb24obmV3X3gsbmV3X3dpZHRoKSB7XG4gICAgICAgICAgICB2YXIgdHJhbnNmb3JtX2F0dHIgPSB0aGlzLmdldEF0dHJpYnV0ZSgndHJhbnNmb3JtJyk7XG4gICAgICAgICAgICB2YXIgbWF0Y2hlcyA9IC90cmFuc2xhdGVcXCguKlssXFxzXSguKilcXCkvLmV4ZWModHJhbnNmb3JtX2F0dHIpO1xuICAgICAgICAgICAgaWYgKG1hdGNoZXNbMV0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJywndHJhbnNsYXRlKCcrKG5ld194KnJlbmRlcmVyLl9SUykrJywnK21hdGNoZXNbMV0rJyknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCd3aWR0aCcsbmV3X3dpZHRoKnJlbmRlcmVyLl9SUyk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKCgodHlwZW9mIG9wdHMub2Zmc2V0KSAhPT0gJ3VuZGVmaW5lZCcpICYmIChvcHRzLnNoYXBlID09IFwiaGV4YWdvblwiIHx8IG9wdHMuc2hhcGUgPT0gXCJwZW50YWdvblwiICkpIHtcbiAgICAgICAgdmFyIG9mZnNldF92YWwgPSBvcHRzLm9mZnNldCB8fCAwO1xuICAgICAgICB2YXIgb3JpZ19oZWlnaHQgPSBvcHRzLmhlaWdodCB8fCA0O1xuICAgICAgICB2YXIgYWRqdXN0bWVudF9nID0gY2FudmFzLmdyb3VwKCk7XG4gICAgICAgIGFkanVzdG1lbnRfZy5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsc2hhcGUuZ2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nKSk7XG4gICAgICAgIGFkanVzdG1lbnRfZy5wdXNoKHNoYXBlKTtcbiAgICAgICAgc2hhcGUuc2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nLCd0cmFuc2xhdGUoMCwwKScpO1xuICAgICAgICBhZGp1c3RtZW50X2cuc2V0SGVpZ2h0ID0gZnVuY3Rpb24oaGVpZ2h0KSB7XG4gICAgICAgICAgICBpZiAoICEgc2hhcGUuX29yaWdfc3Ryb2tlX3dpZHRoICkge1xuICAgICAgICAgICAgICAgIHNoYXBlLl9vcmlnX3N0cm9rZV93aWR0aCA9IHBhcnNlSW50KHNoYXBlLmdldEF0dHJpYnV0ZSgnc3Ryb2tlLXdpZHRoJykpIHx8IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzaGFwZS5zZXRIZWlnaHQob3JpZ19oZWlnaHQqcmVuZGVyZXIuX1JTL3JlbmRlcmVyLnpvb20pO1xuICAgICAgICAgICAgc2hhcGUuc2V0QXR0cmlidXRlKCdzdHJva2Utd2lkdGgnLHRoaXMuX29yaWdfc3Ryb2tlX3dpZHRoL3JlbmRlcmVyLnpvb20pO1xuICAgICAgICAgICAgc2hhcGUuc2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nLCd0cmFuc2xhdGUoMCwwKScpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9yZW5kZXJlci5fbGF5ZXJfY29udGFpbmVyc1tsYXllck5hbWVdLnB1c2goYWRqdXN0bWVudF9nKTtcbiAgICAgICAgYWRqdXN0bWVudF9nLnNldEF0dHJpYnV0ZSgndmlzaWJpbGl0eScsICdoaWRkZW4nKTtcbiAgICAgICAgYWRqdXN0bWVudF9nLnNldEF0dHJpYnV0ZSgnY2xhc3MnLGxheWVyTmFtZSk7XG4gICAgICAgIGFkanVzdG1lbnRfZy5wb3NpdGlvbl9zdGFydCA9IHRoaXMuX2luZGV4O1xuICAgICAgICBhZGp1c3RtZW50X2cucG9zaXRpb25fZW5kID0gdGhpcy5faW5kZXggKyB3aWR0aDtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLl9sYXllcl9jb250YWluZXJzW2xheWVyTmFtZV0ucHVzaChzaGFwZSk7XG4gICAgICAgIHNoYXBlLnNldEF0dHJpYnV0ZSgndmlzaWJpbGl0eScsICdoaWRkZW4nKTtcbiAgICAgICAgc2hhcGUuc2V0QXR0cmlidXRlKCdjbGFzcycsbGF5ZXJOYW1lKTtcbiAgICAgICAgc2hhcGUucG9zaXRpb25fc3RhcnQgPSB0aGlzLl9pbmRleDtcbiAgICAgICAgc2hhcGUucG9zaXRpb25fZW5kID0gdGhpcy5faW5kZXggKyB3aWR0aDtcblxuICAgIH1cbiAgICBzaGFwZS5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLG9wdHMuZmlsbCB8fCBNQVNDUC5sYXllcnNbbGF5ZXJOYW1lXS5jb2xvcik7XG4gICAgaWYgKG9wdHMuc3Ryb2tlKSB7XG4gICAgICAgIHNoYXBlLnNldEF0dHJpYnV0ZSgnc3Ryb2tlJyxvcHRzLnN0cm9rZSk7XG4gICAgfVxuICAgIGlmIChvcHRzLnN0cm9rZV93aWR0aCkge1xuICAgICAgICBzaGFwZS5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS13aWR0aCcscmVuZGVyZXIuX1JTKm9wdHMuc3Ryb2tlX3dpZHRoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBzaGFwZS5zdHlsZS5zdHJva2VXaWR0aCA9ICcwJztcbiAgICB9XG4gICAgcmV0dXJuIHNoYXBlO1xufTtcblxudmFyIGFkZEVsZW1lbnRUb0xheWVyV2l0aExpbmsgPSBmdW5jdGlvbihsYXllck5hbWUsdXJsLHdpZHRoKSB7XG4gICAgdmFyIGNhbnZhcyA9IHRoaXMuX3JlbmRlcmVyLl9jYW52YXM7XG5cbiAgICBpZiAoICEgY2FudmFzICkge1xuICAgICAgICB2YXIgb3JpZ19mdW5jID0gYXJndW1lbnRzLmNhbGxlZTtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBiZWFuLmFkZCh0aGlzLl9yZW5kZXJlciwnc2VxdWVuY2VjaGFuZ2UnLGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgYmVhbi5yZW1vdmUodGhpcy5fcmVuZGVyZXIsJ3NlcXVlbmNlY2hhbmdlJyxhcmd1bWVudHMuY2FsbGVlKTsgICAgICAgICAgICBcbiAgICAgICAgICAgIG9yaWdfZnVuYy5jYWxsKHNlbGYsbGF5ZXJOYW1lLHVybCx3aWR0aCk7XG4gICAgICAgIH0pO1xuICAgICAgICBsb2coXCJEZWxheWluZyByZW5kZXJpbmcsIHdhaXRpbmcgZm9yIHNlcXVlbmNlIGNoYW5nZVwiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuXG4gICAgdmFyIHJlY3QgPSAgY2FudmFzLnJlY3QoLTAuMjUrdGhpcy5faW5kZXgsNjAsd2lkdGggfHwgMSw0KTtcbiAgICB0aGlzLl9yZW5kZXJlci5fbGF5ZXJfY29udGFpbmVyc1tsYXllck5hbWVdLnB1c2gocmVjdCk7XG4gICAgcmVjdC5zdHlsZS5zdHJva2VXaWR0aCA9ICcwcHgnOyAgICBcbiAgICByZWN0LnNldEF0dHJpYnV0ZSgnZmlsbCcsTUFTQ1AubGF5ZXJzW2xheWVyTmFtZV0uY29sb3IpO1xuICAgIHJlY3Quc2V0QXR0cmlidXRlKCd2aXNpYmlsaXR5JywgJ2hpZGRlbicpO1xuICAgIHJlY3Quc2V0QXR0cmlidXRlKCdjbGFzcycsbGF5ZXJOYW1lKTtcbiAgICByZXR1cm4gcmVjdDtcbn07XG5cbnZhciBhZGRDYWxsb3V0VG9MYXllciA9IGZ1bmN0aW9uKGxheWVyTmFtZSxlbGVtZW50LG9wdHMpIHtcbiAgICB2YXIgY2FudmFzID0gdGhpcy5fcmVuZGVyZXIuX2NhbnZhcztcblxuICAgIHZhciByZW5kZXJlciA9IHRoaXMuX3JlbmRlcmVyO1xuICAgIFxuICAgIGlmICh0eXBlb2YgZWxlbWVudCA9PSAnc3RyaW5nJykge1xuICAgICAgICB2YXIgYV9lbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICByZW5kZXJlci5maWxsVGVtcGxhdGUoZWxlbWVudCxvcHRzLGZ1bmN0aW9uKGVycixlbCkge1xuICAgICAgICAgICAgYV9lbC5pbm5lckhUTUwgPSBlbDtcbiAgICAgICAgfSk7XG4gICAgICAgIGVsZW1lbnQgPSBhX2VsO1xuICAgIH1cbiAgICBcbiAgICBpZiAoICEgY2FudmFzICkge1xuICAgICAgICB2YXIgb3JpZ19mdW5jID0gYXJndW1lbnRzLmNhbGxlZTtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBiZWFuLmFkZCh0aGlzLl9yZW5kZXJlciwnc2VxdWVuY2VjaGFuZ2UnLGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgYmVhbi5yZW1vdmUodGhpcy5fcmVuZGVyZXIsJ3NlcXVlbmNlY2hhbmdlJyxhcmd1bWVudHMuY2FsbGVlKTsgICAgICAgICAgICBcbiAgICAgICAgICAgIG9yaWdfZnVuYy5jYWxsKHNlbGYsbGF5ZXJOYW1lLHdpZHRoLG9wdHMpO1xuICAgICAgICB9KTtcbiAgICAgICAgbG9nKFwiRGVsYXlpbmcgcmVuZGVyaW5nLCB3YWl0aW5nIGZvciBzZXF1ZW5jZSBjaGFuZ2VcIik7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGNhbGxvdXQgPSBjYW52YXMuY2FsbG91dCh0aGlzLl9pbmRleCswLjUsMC4wMSxlbGVtZW50LHsnd2lkdGgnIDogKDEwKm9wdHMud2lkdGgpIHx8IDEwMCAsJ2hlaWdodCc6IChvcHRzLmhlaWdodCAqIDEwKSB8fCAxMDAsICdhbGlnbicgOiBvcHRzLmFsaWduLCAnZm9udC1zaXplJyA6IG9wdHNbJ2ZvbnQtc2l6ZSddIH0pO1xuICAgIGNhbGxvdXQuc2V0SGVpZ2h0KG9wdHMuaGVpZ2h0KnRoaXMuX3JlbmRlcmVyLl9SUyk7XG4gICAgdGhpcy5fcmVuZGVyZXIuX2NhbnZhc19jYWxsb3V0X3BhZGRpbmcgPSBNYXRoLm1heCgoKDEwKm9wdHMuaGVpZ2h0KSB8fCAxMDApLHRoaXMuX3JlbmRlcmVyLl9jYW52YXNfY2FsbG91dF9wYWRkaW5nfHwwKTtcbiAgICB0aGlzLl9yZW5kZXJlci5fbGF5ZXJfY29udGFpbmVyc1tsYXllck5hbWVdLnB1c2goY2FsbG91dCk7XG4gICAgY2FsbG91dC5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY29udCA9IHJlbmRlcmVyLl9sYXllcl9jb250YWluZXJzW2xheWVyTmFtZV07XG4gICAgICAgIGlmIChjb250LmluZGV4T2YoY2FsbG91dCkgPiAwKSB7XG4gICAgICAgICAgICBjb250LnNwbGljZShjb250LmluZGV4T2YoY2FsbG91dCksMSk7XG4gICAgICAgIH1cbiAgICAgICAgY2FsbG91dC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGNhbGxvdXQpO1xuICAgIH07XG4gICAgcmV0dXJuIGNhbGxvdXQ7XG59O1xuXG52YXIgc2NhbGVkQWRkU2hhcGVPdmVybGF5ID0gZnVuY3Rpb24obGF5ZXJuYW1lLHdpZHRoLG9wdHMpIHtcbiAgICB2YXIgc3RhcnQgPSB0aGlzLl9pbmRleDtcbiAgICB2YXIgZW5kID0gTWF0aC5hYnModGhpcy5fcmVuZGVyZXIuc2NhbGVQb3NpdGlvbih0aGlzLm9yaWdpbmFsX2luZGV4K3dpZHRoLGxheWVybmFtZSkpIC0gMTtcbiAgICB2YXIgcmVzID0gYWRkU2hhcGVUb0VsZW1lbnQuY2FsbChzdGFydCA8IGVuZCA/IHRoaXMgOiB0aGlzLl9yZW5kZXJlci5fc2VxdWVuY2VfZWxzW2VuZF0sbGF5ZXJuYW1lLCBNYXRoLmFicyhlbmQgLSBzdGFydCksb3B0cyk7XG4gICAgcmVzLmFhID0gdGhpcy5vcmlnaW5hbF9pbmRleDtcbiAgICByZXMuYWFfd2lkdGggPSB3aWR0aDtcbiAgICByZXR1cm4gcmVzO1xufTtcblxudmFyIHNjYWxlZEFkZEJveE92ZXJsYXkgPSBmdW5jdGlvbihsYXllcm5hbWUsd2lkdGgsZnJhY3Rpb24sb3B0cykge1xuICAgIHZhciBzdGFydCA9IHRoaXMuX2luZGV4O1xuICAgIHZhciBlbmQgPSBNYXRoLmFicyh0aGlzLl9yZW5kZXJlci5zY2FsZVBvc2l0aW9uKHRoaXMub3JpZ2luYWxfaW5kZXgrd2lkdGgsbGF5ZXJuYW1lKSkgLSAxO1xuXG4gICAgdmFyIHJlcyA9IGFkZEJveE92ZXJsYXlUb0VsZW1lbnQuY2FsbChzdGFydCA8IGVuZCA/IHRoaXMgOiB0aGlzLl9yZW5kZXJlci5fc2VxdWVuY2VfZWxzW2VuZF0sbGF5ZXJuYW1lLE1hdGguYWJzKGVuZCAtIHN0YXJ0KSxmcmFjdGlvbixvcHRzKTtcblxuICAgIGlmICghIChvcHRzIHx8IHt9KS5tZXJnZSApIHtcbiAgICAgICAgcmVzLmFhX3dpZHRoID0gd2lkdGg7XG4gICAgICAgIHJlcy5hYSA9IHRoaXMub3JpZ2luYWxfaW5kZXg7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmVzLmFhX3dpZHRoID0gcGFyc2VJbnQocmVzLmdldEF0dHJpYnV0ZSgnd2lkdGgnKSkgLyB0aGlzLl9yZW5kZXJlci5fUlM7XG4gICAgICAgIGlmIChyZXMuYWFfd2lkdGggPT0gd2lkdGgpIHtcbiAgICAgICAgICAgIHJlcy5hYSA9IHRoaXMub3JpZ2luYWxfaW5kZXg7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn07XG5cbnZhciBzY2FsZWRBZGRUZXh0T3ZlcmxheSA9IGZ1bmN0aW9uKGxheWVybmFtZSx3aWR0aCxvcHRzKSB7XG4gICAgdmFyIHN0YXJ0ID0gdGhpcy5faW5kZXg7XG4gICAgdmFyIGVuZCA9IE1hdGguYWJzKHRoaXMuX3JlbmRlcmVyLnNjYWxlUG9zaXRpb24odGhpcy5vcmlnaW5hbF9pbmRleCt3aWR0aCxsYXllcm5hbWUpKSAtIDE7XG4gICAgdmFyIHJlcyA9IGFkZFRleHRUb0VsZW1lbnQuY2FsbChzdGFydCA8IGVuZCA/IHRoaXMgOiB0aGlzLl9yZW5kZXJlci5fc2VxdWVuY2VfZWxzW2VuZF0sbGF5ZXJuYW1lLE1hdGguYWJzKGVuZCAtIHN0YXJ0KSxvcHRzKTtcbiAgICByZXMuYWEgPSB0aGlzLm9yaWdpbmFsX2luZGV4O1xuICAgIHJlcy5hYV93aWR0aCA9IHdpZHRoO1xuICAgIHJldHVybiByZXM7XG59O1xuXG52YXIgc2NhbGVkQWRkVG9MYXllcldpdGhMaW5rID0gZnVuY3Rpb24obGF5ZXJuYW1lLHVybCx3aWR0aCkge1xuICAgIHZhciBzdGFydCA9IHRoaXMuX2luZGV4O1xuICAgIHZhciBlbmQgPSBNYXRoLmFicyh0aGlzLl9yZW5kZXJlci5zY2FsZVBvc2l0aW9uKHRoaXMub3JpZ2luYWxfaW5kZXgrd2lkdGgsbGF5ZXJuYW1lKSkgLSAxO1xuICAgIHZhciByZXMgPSBhZGRFbGVtZW50VG9MYXllcldpdGhMaW5rLmNhbGwoc3RhcnQgPCBlbmQgPyB0aGlzIDogdGhpcy5fcmVuZGVyZXIuX3NlcXVlbmNlX2Vsc1tlbmRdLGxheWVybmFtZSx1cmwsTWF0aC5hYnMoZW5kIC0gc3RhcnQpKTtcbiAgICByZXMuYWEgPSB0aGlzLm9yaWdpbmFsX2luZGV4O1xuICAgIHJldHVybiByZXM7XG59O1xuXG52YXIgc2NhbGVkQWRkVG9MYXllciA9IGZ1bmN0aW9uKGxheWVybmFtZSxvcHRzKSB7XG4gICAgdmFyIHJlcyA9IGFkZEVsZW1lbnRUb0xheWVyLmNhbGwodGhpcyxsYXllcm5hbWUsb3B0cyk7XG4gICAgcmVzLmFhID0gdGhpcy5vcmlnaW5hbF9pbmRleDtcbiAgICByZXMuYWFfd2lkdGggPSAxO1xuICAgIHJldHVybiByZXM7XG59O1xuXG5Db25kZW5zZWRTZXF1ZW5jZVJlbmRlcmVyLnByb3RvdHlwZS5lbmFibGVTY2FsaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgYmVhbi5hZGQodGhpcywncmVhZGVyUmVnaXN0ZXJlZCcsZnVuY3Rpb24ocmVhZGVyKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdFbmFibGluZyBzY2FsaW5nIGZvciBsZWdhY3kgcmVhZGVycycpO1xuICAgICAgICB2YXIgb2xkX3Jlc3VsdCA9IHJlYWRlci5nb3RSZXN1bHQ7XG4gICAgICAgIHZhciByZW5kZXJlciA9IHRoaXM7XG4gICAgICAgIHJlYWRlci5nb3RSZXN1bHQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciB3YW50ZWRfaWQgPSByZWFkZXIuYWNjIHx8IHJlYWRlci5hZ2kgfHwgXCJcIjtcblxuICAgICAgICAgICAgdmFyIG9sZF9nZXRfYWFzID0gQ29uZGVuc2VkU2VxdWVuY2VSZW5kZXJlci5wcm90b3R5cGUuZ2V0QW1pbm9BY2lkc0J5UG9zaXRpb247XG4gICAgICAgICAgICB2YXIgb2xkX2dldF9wZXAgPSBDb25kZW5zZWRTZXF1ZW5jZVJlbmRlcmVyLnByb3RvdHlwZS5nZXRBbWlub0FjaWRzQnlQZXB0aWRlO1xuICAgICAgICAgICAgdmFyIG9sZF9zZXF1ZW5jZSA9IHJlbmRlcmVyLnNlcXVlbmNlO1xuICAgICAgICAgICAgaWYgKHJlbmRlcmVyLnNlcXVlbmNlcykge1xuICAgICAgICAgICAgICAgIHJlbmRlcmVyLnNlcXVlbmNlID0gKHJlbmRlcmVyLnNlcXVlbmNlcyBbICggcmVuZGVyZXIuc2VxdWVuY2VzLm1hcChmdW5jdGlvbihzZXEpIHsgIHJldHVybiAoc2VxLmFnaSB8fCBzZXEuYWNjIHx8IFwiXCIpLnRvTG93ZXJDYXNlKCk7ICB9KSApLmluZGV4T2Yod2FudGVkX2lkLnRvTG93ZXJDYXNlKCkpIF0gfHwgXCJcIikudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgb2xkX3NlcXVlbmNlID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlbmRlcmVyLmdldEFtaW5vQWNpZHNCeVBvc2l0aW9uID0gZnVuY3Rpb24oYWFzLGxheSxhY2Nlc3Npb24pIHtcbiAgICAgICAgICAgICAgICBpZiAoICEgbGF5ICYmICEgYWNjZXNzaW9uICkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnR3Vlc3Npbmcgc2NhbGluZyBpZGVudGlmaWVyIGFzJyx3YW50ZWRfaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gb2xkX2dldF9hYXMuY2FsbCh0aGlzLGFhcyxsYXkgfHwgd2FudGVkX2lkLGFjY2Vzc2lvbiB8fCB3YW50ZWRfaWQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlbmRlcmVyLmdldEFtaW5vQWNpZHNCeVBlcHRpZGUgPSBmdW5jdGlvbihwZXB0aWRlLGxheSxhY2Nlc3Npb24pIHtcbiAgICAgICAgICAgICAgICBpZiAoICEgbGF5ICYmICEgYWNjZXNzaW9uICkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnR3Vlc3Npbmcgc2NhbGluZyBpZGVudGlmaWVyIGFzJyx3YW50ZWRfaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gb2xkX2dldF9wZXAuY2FsbCh0aGlzLHBlcHRpZGUsbGF5IHx8IHdhbnRlZF9pZCxhY2Nlc3Npb24gfHwgd2FudGVkX2lkKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBvbGRfcmVzdWx0LmNhbGwocmVhZGVyKTtcblxuICAgICAgICAgICAgaWYgKG9sZF9zZXF1ZW5jZSkge1xuICAgICAgICAgICAgICAgIHJlbmRlcmVyLnNlcXVlbmNlID0gb2xkX3NlcXVlbmNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZW5kZXJlci5nZXRBbWlub0FjaWRzQnlQb3NpdGlvbiA9IG9sZF9nZXRfYWFzO1xuICAgICAgICAgICAgcmVuZGVyZXIuZ2V0QW1pbm9BY2lkc0J5UGVwdGlkZSA9IG9sZF9nZXRfcGVwO1xuICAgICAgICB9O1xuICAgIH0pO1xufTtcblxuXG5Db25kZW5zZWRTZXF1ZW5jZVJlbmRlcmVyLnByb3RvdHlwZS5fZXh0ZW5kRWxlbWVudCA9IGZ1bmN0aW9uKGVsKSB7XG4gICAgZWwuYWRkVG9MYXllciA9IHNjYWxlZEFkZFRvTGF5ZXI7XG4gICAgZWwuYWRkQm94T3ZlcmxheSA9IHNjYWxlZEFkZEJveE92ZXJsYXk7XG4gICAgZWwuYWRkU2hhcGVPdmVybGF5ID0gc2NhbGVkQWRkU2hhcGVPdmVybGF5O1xuICAgIGVsLmFkZFRleHRPdmVybGF5ID0gc2NhbGVkQWRkVGV4dE92ZXJsYXk7XG4gICAgZWwuYWRkVG9MYXllcldpdGhMaW5rID0gc2NhbGVkQWRkVG9MYXllcldpdGhMaW5rO1xuICAgIGVsLmNhbGxvdXQgPSBhZGRDYWxsb3V0VG9MYXllcjtcbiAgICBlbFsnX3JlbmRlcmVyJ10gPSB0aGlzO1xufTtcblxuQ29uZGVuc2VkU2VxdWVuY2VSZW5kZXJlci5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24obGF5LGVsKSB7XG4gICAgaWYgKCAhIGVsICkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0aGlzLl9sYXllcl9jb250YWluZXJzW2xheV0gJiYgdGhpcy5fbGF5ZXJfY29udGFpbmVyc1tsYXldLmluZGV4T2YoZWwpID49IDApIHtcbiAgICAgICAgdGhpcy5fbGF5ZXJfY29udGFpbmVyc1tsYXldLnNwbGljZSh0aGlzLl9sYXllcl9jb250YWluZXJzW2xheV0uaW5kZXhPZihlbCksMSk7XG4gICAgICAgIGJlYW4uZmlyZShlbCwncmVtb3ZlZCcpO1xuICAgICAgICBpZiAoZWwucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVsLnRyYWNlciAmJiBlbC50cmFjZXIucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgZWwudHJhY2VyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWwudHJhY2VyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZWwuYm9iYmxlICYmIGVsLmJvYmJsZS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICBlbC5ib2JibGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbC5ib2JibGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG52YXIgbWFya19ncm91cHMgPSBmdW5jdGlvbihyZW5kZXJlcixvYmplY3RzKSB7XG4gICAgdmFyIGdyb3VwID0gW107XG4gICAgdmFyIG5ld19vYmplY3RzID0gW107XG4gICAgZm9yIChpID0gMDsgaSA8IG9iamVjdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjdXJyZW50ID0gb2JqZWN0c1tpXSwgbmV4dCA9IG51bGw7XG4gICAgICBpZiAoICEgY3VycmVudCApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAob2JqZWN0c1tpKzFdKSB7XG4gICAgICAgIG5leHQgPSBvYmplY3RzW2krMV07XG4gICAgICB9XG4gICAgICBpZiAoICghIG5leHQgfHwgKHBhcnNlSW50KG5leHQuYWEpIC0gcGFyc2VJbnQoY3VycmVudC5hYSkgPiAxMCkgfHwgcmVuZGVyZXIuc2VxdWVuY2Uuc3Vic3RyaW5nKGN1cnJlbnQsbmV4dC0xKS5tYXRjaCgvW1NUXS8pKSApIHtcbiAgICAgICAgaWYgKGdyb3VwLmxlbmd0aCA8IDMpIHtcbiAgICAgICAgICBncm91cC5wdXNoKGN1cnJlbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGdyb3VwLnB1c2goY3VycmVudCk7XG4gICAgICAgICAgZ3JvdXAuZm9yRWFjaChmdW5jdGlvbihzaXRlKXtcbiAgICAgICAgICAgIHNpdGUub3B0aW9ucy56b29tX2xldmVsID0gJ3RleHQnO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHZhciBjb2FsZXNjZV9vcHRpb25zID0gZ3JvdXBbMF0uY29hbGVzY2UgfHwgb2JqZWN0c1swXS5jb2FsZXNjZTtcbiAgICAgICAgICBuZXdfb2JqZWN0cy5wdXNoKHtcbiAgICAgICAgICAgICdhYScgOiBncm91cFswXS5hYSxcbiAgICAgICAgICAgICd0eXBlJyA6ICdzaGFwZScsXG4gICAgICAgICAgICAnd2lkdGgnIDogcGFyc2VJbnQoY3VycmVudC5hYSktcGFyc2VJbnQoZ3JvdXBbMF0uYWEpKzEsXG4gICAgICAgICAgICAnb3B0aW9ucycgOiB7ICAgJ3pvb21fbGV2ZWwnIDogJ3N1bW1hcnknLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdzaGFwZScgOiAncm91bmRyZWN0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZmlsbCcgOiBjb2FsZXNjZV9vcHRpb25zLmZpbGwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ3N0cm9rZScgOiBjb2FsZXNjZV9vcHRpb25zLnN0cm9rZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnc3Ryb2tlX3dpZHRoJyA6IGNvYWxlc2NlX29wdGlvbnMuc3Ryb2tlX3dpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdoZWlnaHQnIDogZ3JvdXBbMF0ub3B0aW9ucy5oZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ29mZnNldCcgOiBncm91cFswXS5vcHRpb25zLm9mZnNldFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZ3JvdXAgPSBbXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdyb3VwLnB1c2goY3VycmVudCk7XG4gICAgICB9XG4gICAgfVxuICAgIG5ld19vYmplY3RzLmZvckVhY2goZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgIG9iamVjdHMucHVzaChvYmopO1xuICAgIH0pO1xufTtcblxuQ29uZGVuc2VkU2VxdWVuY2VSZW5kZXJlci5wcm90b3R5cGUuZml4X2ljb25zID0gZnVuY3Rpb24oaWNvbl9yZWYpIHtcbiAgICBpZiAoICEgdGhpcy5pY29uc19mYWlsZWQgKSB7XG4gICAgICAgIHJldHVybiBpY29uX3JlZjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZihpY29uX3JlZikgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHZhciB2YWxzID0gaWNvbl9yZWYuc3BsaXQoJ18nKTtcbiAgICAgICAgaWYgKHZhbHNbMF0gJiYgdGhpcy5pY29uc19mYWlsZWRbdmFsc1swXS5yZXBsYWNlKCcjJywnJyldKSB7XG4gICAgICAgICAgICB2YWxzWzBdID0gdGhpcy5pY29uc19mYWlsZWRbdmFsc1swXS5yZXBsYWNlKCcjJywnJyldKycjJztcbiAgICAgICAgICAgIHZhciBzdGFydCA9IHZhbHMuc2hpZnQoKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGljb25fcmVmLHN0YXJ0K3ZhbHMuam9pbignXycpKTtcbiAgICAgICAgICAgIHJldHVybiBzdGFydCt2YWxzLmpvaW4oJ18nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaWNvbl9yZWY7XG59XG5cbkNvbmRlbnNlZFNlcXVlbmNlUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlck9iamVjdHMgPSBmdW5jdGlvbih0cmFjayxvYmplY3RzKSB7XG4gICAgdmFyIHJlbmRlcmVyID0gdGhpcztcbiAgICBpZiAob2JqZWN0cy5sZW5ndGggPiAwICYmIG9iamVjdHNbMF0uY29hbGVzY2UgKSB7XG4gICAgICAgIG1hcmtfZ3JvdXBzKHJlbmRlcmVyLG9iamVjdHMpO1xuICAgIH1cbiAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgIG9iamVjdHMuZm9yRWFjaChmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgdmFyIHBvdGVudGlhbF9oZWlnaHQgPSBvYmplY3Qub3B0aW9ucyA/IChvYmplY3Qub3B0aW9ucy5oZWlnaHQgfHwgcmVuZGVyZXIuX2xheWVyX2NvbnRhaW5lcnNbdHJhY2tdLnRyYWNrX2hlaWdodCkgKyAob2JqZWN0Lm9wdGlvbnMub2Zmc2V0ICsgb2JqZWN0Lm9wdGlvbnMuaGVpZ2h0IHx8IDApIDogMDtcbiAgICAgICAgaWYgKG9iamVjdC5vcHRpb25zICYmIChwb3RlbnRpYWxfaGVpZ2h0ID4gcmVuZGVyZXIuX2xheWVyX2NvbnRhaW5lcnNbdHJhY2tdLnRyYWNrX2hlaWdodCkgKSB7XG4gICAgICAgICAgICB2YXIgbmV3X2hlaWdodCA9IHJlbmRlcmVyLl9sYXllcl9jb250YWluZXJzW3RyYWNrXS50cmFja19oZWlnaHQgKyBvYmplY3Qub3B0aW9ucy5vZmZzZXQgKyAob2JqZWN0Lm9wdGlvbnMuaGVpZ2h0IHx8IHJlbmRlcmVyLl9sYXllcl9jb250YWluZXJzW3RyYWNrXS50cmFja19oZWlnaHQpO1xuICAgICAgICAgICAgaWYgKChyZW5kZXJlci5fbGF5ZXJfY29udGFpbmVyc1t0cmFja10uZml4ZWRfdHJhY2tfaGVpZ2h0IHx8IDApIDwgbmV3X2hlaWdodCkge1xuICAgICAgICAgICAgICAgIHJlbmRlcmVyLl9sYXllcl9jb250YWluZXJzW3RyYWNrXS5maXhlZF90cmFja19oZWlnaHQgPSBuZXdfaGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNsaWNrX3JldmVhbDtcbiAgICAgICAgdmFyIHJlbmRlcmVkO1xuICAgICAgICBpZiAob2JqZWN0LmFhICYmICggISByZW5kZXJlci5nZXRBQShwYXJzZUludChvYmplY3QuYWEpLHRyYWNrKSkgKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCh0eXBlb2Ygb2JqZWN0LmFhICE9PSAndW5kZWZpbmVkJykgJiYgaXNOYU4ob2JqZWN0LmFhKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmplY3QudHlwZSA9PSBcInRleHRcIikge1xuICAgICAgICAgICAgaWYgKG9iamVjdC5hYSkge1xuICAgICAgICAgICAgICAgIGlmIChvYmplY3Qud2lkdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyZWQgPSByZW5kZXJlci5nZXRBQShwYXJzZUludChvYmplY3QuYWEpLHRyYWNrKS5hZGRUZXh0T3ZlcmxheSh0cmFjayxvYmplY3Qud2lkdGgsb2JqZWN0Lm9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbmRlcmVkID0gcmVuZGVyZXIuZ2V0QUEocGFyc2VJbnQob2JqZWN0LmFhKSx0cmFjaykuYWRkVGV4dE92ZXJsYXkodHJhY2ssMSxvYmplY3Qub3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChvYmplY3QucGVwdGlkZSkge1xuICAgICAgICAgICAgICAgIHJlbmRlcmVkID0gcmVuZGVyZXIuZ2V0QW1pbm9BY2lkc0J5UGVwdGlkZShvYmplY3QucGVwdGlkZSx0cmFjaykuYWRkVGV4dE92ZXJsYXkodHJhY2ssMSxvYmplY3Qub3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iamVjdC50eXBlID09PSBcImJveFwiKSB7XG4gICAgICAgICAgICBpZiAob2JqZWN0LmFhKSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyZWQgPSByZW5kZXJlci5nZXRBQShwYXJzZUludChvYmplY3QuYWEpLHRyYWNrKS5hZGRCb3hPdmVybGF5KHRyYWNrLHBhcnNlSW50KG9iamVjdC53aWR0aCksMSxvYmplY3Qub3B0aW9ucyk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG9iamVjdC5wZXB0aWRlKSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyZWQgPSByZW5kZXJlci5nZXRBbWlub0FjaWRzQnlQZXB0aWRlKG9iamVjdC5wZXB0aWRlLHRyYWNrKS5hZGRUb0xheWVyKHRyYWNrLDEsb2JqZWN0Lm9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChvYmplY3QudHlwZSA9PSBcInNoYXBlXCIpIHtcbiAgICAgICAgICAgIGlmIChvYmplY3QuYWEpIHtcbiAgICAgICAgICAgICAgICByZW5kZXJlZCA9IHJlbmRlcmVyLmdldEFBKHBhcnNlSW50KG9iamVjdC5hYSksdHJhY2spLmFkZFNoYXBlT3ZlcmxheSh0cmFjayxwYXJzZUludChvYmplY3Qud2lkdGgpLG9iamVjdC5vcHRpb25zKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAob2JqZWN0LnBlcHRpZGUpIHtcbiAgICAgICAgICAgICAgICByZW5kZXJlZCA9IHJlbmRlcmVyLmdldEFtaW5vQWNpZHNCeVBlcHRpZGUob2JqZWN0LnBlcHRpZGUsdHJhY2spWzBdLmFkZFNoYXBlT3ZlcmxheSh0cmFjaywgb2JqZWN0LnBlcHRpZGUubGVuZ3RoLCBvYmplY3Qub3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iamVjdC50eXBlID09ICdsaW5lJykge1xuICAgICAgICAgICAgcmVuZGVyZWQgPSByZW5kZXJlci5hZGRWYWx1ZXNUb0xheWVyKHRyYWNrLG9iamVjdC52YWx1ZXMsb2JqZWN0Lm9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvYmplY3QudHlwZSA9PSBcIm1hcmtlclwiKSB7XG4gICAgICAgICAgICB2YXIgY29udGVudCA9IChvYmplY3Qub3B0aW9ucyB8fCB7fSkuY29udGVudDtcbiAgICAgICAgICAgIHZhciB3YW50ZWRfaGVpZ2h0ID0gb2JqZWN0Lm9wdGlvbnMuaGVpZ2h0O1xuXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSAmJiBBcnJheS5pc0FycmF5KGNvbnRlbnQpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNsb25lZF9vcHRpb25zX2FycmF5ID0ge307XG4gICAgICAgICAgICAgICAgZm9yKCB2YXIga2V5IGluIG9iamVjdC5vcHRpb25zICkge1xuICAgICAgICAgICAgICAgICAgICBpZiAob2JqZWN0Lm9wdGlvbnMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xvbmVkX29wdGlvbnNfYXJyYXlba2V5XSA9IG9iamVjdC5vcHRpb25zW2tleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG9iamVjdC5vcHRpb25zLmNvbnRlbnQgJiYgQXJyYXkuaXNBcnJheShjb250ZW50X2RhdGEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsb25lZF9vcHRpb25zX2FycmF5LmNvbnRlbnQgPSBvYmplY3Qub3B0aW9ucy5jb250ZW50Lm1hcChyZW5kZXJlci5maXhfaWNvbnMuYmluZChyZW5kZXJlcikpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNsaWNrX3JldmVhbCA9IHJlbmRlcmVyLmdldEFBKHBhcnNlSW50KG9iamVjdC5hYSksdHJhY2spLmFkZFRvTGF5ZXIodHJhY2ssY2xvbmVkX29wdGlvbnNfYXJyYXkpO1xuICAgICAgICAgICAgICAgIGNsaWNrX3JldmVhbCA9IGNsaWNrX3JldmVhbFsxXTtcbiAgICAgICAgICAgICAgICBjbGlja19yZXZlYWwuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgICAgICBvYmplY3Qub3B0aW9ucy5jb250ZW50ID0gb2JqZWN0Lm9wdGlvbnMuYWx0X2NvbnRlbnQ7XG4gICAgICAgICAgICAgICAgY29udGVudCA9IG9iamVjdC5vcHRpb25zLmNvbnRlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mKGNvbnRlbnQpID09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRlbnRfZWw7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRlbnQudHlwZSA9PSBcImNpcmNsZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRfZWwgPSByZW5kZXJlci5fY2FudmFzLmNpcmNsZSgtMC41LC0wLjUsMSwxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRlbnQudHlwZSA9PSAndGV4dF9jaXJjbGUnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRfZWwgPSByZW5kZXJlci5fY2FudmFzLnRleHRfY2lyY2xlKDAuNSwwLjUsMSxjb250ZW50LnRleHQsY29udGVudC5vcHRpb25zIHx8IHt9KTtcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0Lm9wdGlvbnMuYnJlYWtfdmlld2JveCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjb250ZW50LnR5cGUgPT0gXCJsZWZ0X3RyaWFuZ2xlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudF9lbCA9IHJlbmRlcmVyLl9jYW52YXMucG9seSgnLTEwMCwwIDAsLTEwMCAwLDEwMCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY29udGVudC50eXBlID09IFwicmlnaHRfdHJpYW5nbGVcIikge1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50X2VsID0gcmVuZGVyZXIuX2NhbnZhcy5wb2x5KCcwLDEwMCAxMDAsMCAwLC0xMDAnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBbXCJmaWxsXCIsXCJzdHJva2VcIixcInN0cm9rZS13aWR0aFwiLFwiZmlsbC1vcGFjaXR5XCIsXCJzdHJva2Utb3BhY2l0eVwiLFwib3BhY2l0eVwiXS5mb3JFYWNoKGZ1bmN0aW9uKHByb3ApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRbcHJvcF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRfZWwuc2V0QXR0cmlidXRlKHByb3AsY29udGVudFtwcm9wXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBvYmplY3Qub3B0aW9ucy5jb250ZW50ID0gY29udGVudF9lbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjbG9uZWRfb3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgZm9yKCB2YXIga2V5IGluIG9iamVjdC5vcHRpb25zICkge1xuICAgICAgICAgICAgICAgIGlmIChvYmplY3Qub3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsb25lZF9vcHRpb25zW2tleV0gPSBvYmplY3Qub3B0aW9uc1trZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBjb250ZW50X2RhdGEgPSAob2JqZWN0Lm9wdGlvbnMgfHwge30pLmNvbnRlbnQ7XG4gICAgICAgICAgICBpZiAoY29udGVudF9kYXRhICYmIHR5cGVvZiBjb250ZW50X2RhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgY2xvbmVkX29wdGlvbnMuY29udGVudCA9IHJlbmRlcmVyLmZpeF9pY29ucyhjb250ZW50X2RhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbnRlbnRfZGF0YSAmJiBBcnJheS5pc0FycmF5KGNvbnRlbnRfZGF0YSkpIHtcbiAgICAgICAgICAgICAgICBjbG9uZWRfb3B0aW9ucy5jb250ZW50ID0gY29udGVudF9kYXRhLm1hcChyZW5kZXJlci5maXhfaWNvbnMuYmluZChyZW5kZXJlcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGFkZGVkID0gcmVuZGVyZXIuZ2V0QUEocGFyc2VJbnQob2JqZWN0LmFhKSx0cmFjaykuYWRkVG9MYXllcih0cmFjayxjbG9uZWRfb3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAoY2xpY2tfcmV2ZWFsKSB7XG5cbiAgICAgICAgICAgICAgICBjbGlja19yZXZlYWwudG9nZ2xlUmV2ZWFsID0gZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgICAgICAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0eWxlLmRpc3BsYXkgPT09ICdub25lJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnROb2RlLmFwcGVuZENoaWxkKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZW5kZXJlci5yZWZyZXNoKCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBhZGRlZFsxXS5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgY2xpY2tfcmV2ZWFsLnRvZ2dsZVJldmVhbC5iaW5kKGNsaWNrX3JldmVhbCksdHJ1ZSk7XG4gICAgICAgICAgICAgICAgYWRkZWRbMV0uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLGNsaWNrX3JldmVhbC50b2dnbGVSZXZlYWwuYmluZChjbGlja19yZXZlYWwpLGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlbmRlcmVkID0gYWRkZWRbMV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChvYmplY3Qub3B0aW9ucyB8fCB7fSkuem9vbV9sZXZlbCkge1xuICAgICAgICAgICAgcmVuZGVyZWQuem9vbV9sZXZlbCA9IG9iamVjdC5vcHRpb25zLnpvb21fbGV2ZWw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9iamVjdC5pZGVudGlmaWVyKSB7XG4gICAgICAgICAgICByZW5kZXJlZC5zZXRBdHRyaWJ1dGUoJ2lkZW50aWZpZXInLG9iamVjdC5pZGVudGlmaWVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKG9iamVjdC5vcHRpb25zIHx8IHt9KS5ldmVudHMgJiYgcmVuZGVyZWQgKSB7XG4gICAgICAgICAgICBvYmplY3Qub3B0aW9ucy5ldmVudHMuZm9yRWFjaChmdW5jdGlvbihldikge1xuICAgICAgICAgICAgICAgIChldi50eXBlIHx8IFwiXCIpLnNwbGl0KFwiLFwiKS5mb3JFYWNoKGZ1bmN0aW9uKGV2dHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXZ0eXBlID09ICdjbGljaycgJiYgcmVuZGVyZWQuc3R5bGUgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJlZC5zdHlsZS5jdXJzb3IgPSAncG9pbnRlcic7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyZWQuYWRkRXZlbnRMaXN0ZW5lcihldnR5cGUsZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5ldmVudF9kYXRhID0gZXYuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUubGF5ZXIgPSB0cmFjaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuYWEgPSBvYmplY3QuYWE7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0cy5wdXNoKHJlbmRlcmVkKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0cztcbn07XG5cbkNvbmRlbnNlZFNlcXVlbmNlUmVuZGVyZXIucHJvdG90eXBlLmFkZFRleHRUcmFjayA9IGZ1bmN0aW9uKHNlcSxjb250YWluZXIpIHtcbiAgICB2YXIgUlMgPSB0aGlzLl9SUztcbiAgICB2YXIgcmVuZGVyZXIgPSB0aGlzO1xuICAgIHZhciBtYXhfbGVuZ3RoID0gMzAwO1xuICAgIHZhciBjYW52YXMgPSByZW5kZXJlci5fY2FudmFzO1xuICAgIHZhciBzZXFfY2hhcnMgPSBzZXEuc3BsaXQoJycpO1xuXG4gICAgdmFyIGFtaW5vX2FjaWRzID0gY2FudmFzLnNldCgpO1xuICAgIHZhciBhbWlub19hY2lkc19zaG93biA9IGZhbHNlO1xuICAgIHZhciB4ID0gMDtcblxuICAgIHZhciBoYXNfdGV4dExlbmd0aCA9IHRydWU7XG4gICAgdmFyIG5vX29wID0gZnVuY3Rpb24oKSB7fTtcbiAgICB0cnkge1xuICAgICAgICB2YXIgdGVzdF9lbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhzdmducywndGV4dCcpO1xuICAgICAgICB0ZXN0X2VsLnNldEF0dHJpYnV0ZSgndGV4dExlbmd0aCcsMTApO1xuICAgICAgICBub19vcCh0ZXN0X2VsLnRleHRMZW5ndGgpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgaGFzX3RleHRMZW5ndGggPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvKiBXZSB1c2VkIHRvIHRlc3QgdG8gc2VlIGlmIHRoZXJlIHdhcyBhIHRvdWNoIGV2ZW50XG4gICAgICAgd2hlbiBkb2luZyB0aGUgdGV4dExlbmd0aCBtZXRob2Qgb2YgYW1pbm8gYWNpZFxuICAgICAgIGxheW91dCwgYnV0IGlPUyBzZWVtcyB0byBzdXBwb3J0IHRoaXMgbm93LlxuICAgICAgIFxuICAgICAgIFRlc3QgY2FzZSBmb3IgdGV4dExlbmd0aCBjYW4gYmUgZm91bmQgaGVyZVxuICAgICAgIFxuICAgICAgIGh0dHA6Ly9qc2ZpZGRsZS5uZXQvbmttTHUvMTEvZW1iZWRkZWQvcmVzdWx0L1xuICAgICovXG5cbiAgICAvKiBXZSBhbHNvIG5lZWQgdG8gdGVzdCBmb3Igc3VwcG9ydCBmb3IgYWRqdXN0aW5nIHRleHRMZW5ndGhcbiAgICAgICB3aGlsZSBhbHNvIGFkanVzdGluZyB0aGUgZHggdmFsdWUuIEludGVybmV0IEV4cGxvcmVyIDEwXG4gICAgICAgc3F1ZWV6ZXMgdGV4dCB3aGVuIHNldHRpbmcgYSBkeCB2YWx1ZSBhcyB3ZWxsIGFzIGEgdGV4dExlbmd0aC5cbiAgICAgICBJLmUuIHRoZSByaWdodC1tb3N0IHBvc2l0aW9uIG9mIHRoZSBjaGFyYWN0ZXIgaXMgY2FsY3VsYXRlZCB0b1xuICAgICAgIGJlIHggKyB0ZXh0TGVuZ3RoLCByYXRoZXIgdGhhbiB4ICsgZHggKyB0ZXh0TGVuZ3RoLlxuICAgICAqL1xuXG4gICAgdmFyIHN1cHBvcnRzX2R4ID0gZmFsc2U7XG4gICAgaWYgKHR5cGVvZiBNQVNDUC5zdXBwb3J0c19keCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgc3VwcG9ydHNfZHggPSBNQVNDUC5zdXBwb3J0c19keDtcbiAgICB9IGVsc2Uge1xuICAgICAgICAoZnVuY3Rpb24oc3VwcG9ydHNfdGV4dExlbmd0aCkge1xuICAgICAgICAgICAgaWYgKCEgc3VwcG9ydHNfdGV4dExlbmd0aCkge1xuICAgICAgICAgICAgICAgIHN1cHBvcnRzX2R4ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHRlc3RfZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoc3ZnbnMsJ3RleHQnKTtcbiAgICAgICAgICAgIHRlc3RfZWwuc2V0QXR0cmlidXRlKCd0ZXh0TGVuZ3RoJywzMCk7XG5cbiAgICAgICAgICAgIGlmICggISB0ZXN0X2VsLmdldEV4dGVudE9mQ2hhciApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ZXN0X2VsLnNldEF0dHJpYnV0ZSgneCcsJzAnKTtcbiAgICAgICAgICAgIHRlc3RfZWwuc2V0QXR0cmlidXRlKCd5JywnMCcpO1xuICAgICAgICAgICAgdGVzdF9lbC50ZXh0Q29udGVudCA9ICdBQkMnO1xuICAgICAgICAgICAgY2FudmFzLmFwcGVuZENoaWxkKHRlc3RfZWwpO1xuICAgICAgICAgICAgdmFyIGV4dGVudCA9IHRlc3RfZWwuZ2V0RXh0ZW50T2ZDaGFyKDIpLng7XG4gICAgICAgICAgICB0ZXN0X2VsLnNldEF0dHJpYnV0ZSgnZHgnLCcxMCcpO1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKHRlc3RfZWwuZ2V0RXh0ZW50T2ZDaGFyKDIpLnggLSBleHRlbnQpIDwgOS41KSB7XG4gICAgICAgICAgICAgICAgc3VwcG9ydHNfZHggPSBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3VwcG9ydHNfZHggPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgTUFTQ1Auc3VwcG9ydHNfZHggPSBzdXBwb3J0c19keDtcbiAgICAgICAgICAgIHRlc3RfZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0ZXN0X2VsKTtcbiAgICAgICAgfSkoaGFzX3RleHRMZW5ndGgpO1xuICAgIH1cblxuICAgIHZhciBhX3RleHQ7XG5cbiAgICBpZiAoaGFzX3RleHRMZW5ndGggJiYgKCdsZW5ndGhBZGp1c3QnIGluIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhzdmducywndGV4dCcpKSAmJiAoJ3RleHRMZW5ndGgnIGluIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhzdmducywndGV4dCcpKSkge1xuICAgICAgICBpZiAoc2VxLmxlbmd0aCA8PSBtYXhfbGVuZ3RoKSB7XG4gICAgICAgICAgICBhX3RleHQgPSBjYW52YXMudGV4dCgwLDEyLGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHNlcSkpO1xuICAgICAgICAgICAgYV90ZXh0LnNldEF0dHJpYnV0ZSgndGV4dExlbmd0aCcsUlMqc2VxLmxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhX3RleHQgPSBjYW52YXMudGV4dCgwLDEyLGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHNlcS5zdWJzdHIoMCxtYXhfbGVuZ3RoKSkpO1xuICAgICAgICAgICAgYV90ZXh0LnNldEF0dHJpYnV0ZSgndGV4dExlbmd0aCcsUlMqbWF4X2xlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgY2FudmFzLmluc2VydEJlZm9yZShhX3RleHQsY2FudmFzLmZpcnN0Q2hpbGQubmV4dFNpYmxpbmcpO1xuXG4gICAgICAgIGFfdGV4dC5zdHlsZS5mb250RmFtaWx5ID0gXCInTHVjaWRhIENvbnNvbGUnLCAnQ291cmllciBOZXcnLCBNb25hY28sIG1vbm9zcGFjZVwiO1xuICAgICAgICBhX3RleHQuc2V0QXR0cmlidXRlKCdsZW5ndGhBZGp1c3QnLCdzcGFjaW5nJyk7XG4gICAgICAgIGFfdGV4dC5zZXRBdHRyaWJ1dGUoJ3RleHQtYW5jaG9yJywgJ3N0YXJ0Jyk7XG4gICAgICAgIGFfdGV4dC5zZXRBdHRyaWJ1dGUoJ2R4Jyw1KTtcbiAgICAgICAgYV90ZXh0LnNldEF0dHJpYnV0ZSgnZHknLCcxLjVleCcpO1xuICAgICAgICBhX3RleHQuc2V0QXR0cmlidXRlKCdmb250LXNpemUnLCBSUyk7XG4gICAgICAgIGFfdGV4dC5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLCAnIzAwMDAwMCcpO1xuICAgICAgICBhbWlub19hY2lkcy5wdXNoKGFfdGV4dCk7XG4gICAgICAgIGNvbnRhaW5lci5wdXNoKGFfdGV4dCk7XG4gICAgfSBlbHNlIHsgICAgXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VxX2NoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhX3RleHQgPSBjYW52YXMudGV4dCh4LDEyLHNlcV9jaGFyc1tpXSk7XG4gICAgICAgICAgICBhX3RleHQuZmlyc3RDaGlsZC5zZXRBdHRyaWJ1dGUoJ2R5JywnMS41ZXgnKTtcbiAgICAgICAgICAgIGFtaW5vX2FjaWRzLnB1c2goYV90ZXh0KTtcbiAgICAgICAgICAgIGNvbnRhaW5lci5wdXNoKGFfdGV4dCk7XG4gICAgICAgICAgICBhX3RleHQuc3R5bGUuZm9udEZhbWlseSA9IFwiJ0x1Y2lkYSBDb25zb2xlJywgTW9uYWNvLCBtb25vc3BhY2VcIjtcbiAgICAgICAgICAgIHggKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBhbWlub19hY2lkcy5hdHRyKCB7ICd3aWR0aCc6IFJTLCd0ZXh0LWFuY2hvcic6J3N0YXJ0JywnaGVpZ2h0JzogUlMsJ2ZvbnQtc2l6ZSc6UlMsJ2ZpbGwnOicjMDAwMDAwJ30pO1xuICAgIH1cbiAgICB2YXIgdXBkYXRlX3NlcXVlbmNlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChzZXEubGVuZ3RoIDw9IG1heF9sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29udGFpbmVyX3dpZHRoID0gcmVuZGVyZXIuX2NvbnRhaW5lcl9jYW52YXMucGFyZW50Tm9kZS5jYWNoZWRfd2lkdGg7XG4gICAgICAgIGlmICggISBjb250YWluZXJfd2lkdGggKSB7XG4gICAgICAgICAgICBjb250YWluZXJfd2lkdGggPSByZW5kZXJlci5fY29udGFpbmVyX2NhbnZhcy5wYXJlbnROb2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoO1xuICAgICAgICAgICAgdmFyIGRvY3dpZHRoID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoO1xuICAgICAgICAgICAgaWYgKGRvY3dpZHRoID4gY29udGFpbmVyX3dpZHRoKSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyX3dpZHRoID0gZG9jd2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG1heF9zaXplID0gTWF0aC5jZWlsKDEwKmNvbnRhaW5lcl93aWR0aCAqIHJlbmRlcmVyLnpvb20gLyBSUyk7XG4gICAgICAgIGlmIChtYXhfc2l6ZSA+IHNlcS5sZW5ndGgpIHtcbiAgICAgICAgICAgIG1heF9zaXplID0gc2VxLmxlbmd0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGFfdGV4dC5zZXRBdHRyaWJ1dGUoJ3RleHRMZW5ndGgnLFJTKm1heF9zaXplKTtcblxuICAgICAgICB2YXIgc3RhcnQgPSBwYXJzZUludChyZW5kZXJlci5sZWZ0VmlzaWJsZVJlc2lkdWUoKSk7XG4gICAgICAgIHN0YXJ0IC09IDUwO1xuICAgICAgICBpZiAoc3RhcnQgPCAwKSB7IFxuICAgICAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoc3RhcnQgKyBtYXhfc2l6ZSkgPj0gc2VxLmxlbmd0aCkge1xuICAgICAgICAgICAgc3RhcnQgPSBzZXEubGVuZ3RoIC0gbWF4X3NpemU7XG4gICAgICAgICAgICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFfdGV4dC5yZXBsYWNlQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoc2VxLnN1YnN0cihzdGFydCxtYXhfc2l6ZSkpLGFfdGV4dC5maXJzdENoaWxkKTtcbiAgICAgICAgYV90ZXh0LnNldEF0dHJpYnV0ZShzdXBwb3J0c19keCA/ICdkeCcgOiAneCcsNSsoKHN0YXJ0KSpSUykpO1xuICAgIH07XG4gICAgdmFyIHBhbnN0YXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYW1pbm9fYWNpZHNfc2hvd24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbWlub19hY2lkcy5hdHRyKCB7ICdkaXNwbGF5JyA6ICdub25lJ30pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgIHZhciBwYW5lbmQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhbWlub19hY2lkc19zaG93bikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFtaW5vX2FjaWRzLmF0dHIoIHsnZGlzcGxheScgOiAnYmxvY2snfSApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZV9zZXF1ZW5jZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgIHZhciB6b29tY2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgIGlmIChjYW52YXMuem9vbSA+IDMuNikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgYW1pbm9fYWNpZHMuYXR0cih7J2Rpc3BsYXknIDogJ2Jsb2NrJ30pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgYW1pbm9fYWNpZHNfc2hvd24gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlX3NlcXVlbmNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2FudmFzLnpvb20gPiAwLjIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGFtaW5vX2FjaWRzLmF0dHIoeydkaXNwbGF5JyA6ICdub25lJ30pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgYW1pbm9fYWNpZHNfc2hvd24gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGFtaW5vX2FjaWRzLmF0dHIoeydkaXNwbGF5JyA6ICdub25lJ30pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgYW1pbm9fYWNpZHNfc2hvd24gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgIH07XG4gICAgaWYgKCAhIGNvbnRhaW5lci5wYW5ldmVudHMgKSB7XG4gICAgICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdwYW5zdGFydCcsIHBhbnN0YXJ0LGZhbHNlKTtcbiAgICAgICAgYmVhbi5hZGQoY2FudmFzLCdwYW5lbmQnLCBwYW5lbmQpO1xuICAgICAgICBjb250YWluZXIucGFuZXZlbnRzID0gdHJ1ZTtcbiAgICB9XG4gICAgICAgXG4gICAgYmVhbi5hZGQoY2FudmFzLCd6b29tQ2hhbmdlJywgem9vbWNoYW5nZSxmYWxzZSk7XG4gICAgYmVhbi5hZGQoYW1pbm9fYWNpZHNbMF0sJ3JlbW92ZWQnLGZ1bmN0aW9uKCkge1xuICAgICAgICBjYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcigncGFuc3RhcnQnLHBhbnN0YXJ0KTtcbiAgICAgICAgYmVhbi5yZW1vdmUoY2FudmFzLCdwYW5lbmQnLHBhbmVuZCk7XG4gICAgICAgIGJlYW4ucmVtb3ZlKGNhbnZhcywnem9vbUNoYW5nZScsem9vbWNoYW5nZSk7XG4gICAgICAgIGRlbGV0ZSBjb250YWluZXIucGFuZXZlbnRzO1xuICAgIH0pO1xuICAgIHJldHVybiBhbWlub19hY2lkcztcbn07XG5cbkNvbmRlbnNlZFNlcXVlbmNlUmVuZGVyZXIucHJvdG90eXBlLnJlbmRlclRleHRUcmFjayA9IGZ1bmN0aW9uKGxheSxpbl90ZXh0KSB7XG4gICAgdmFyIGxheWVyTmFtZSA9IGxheTtcbiAgICBpZiAodHlwZW9mIGxheWVyTmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgbGF5ZXJOYW1lID0gbGF5Lm5hbWU7XG4gICAgfVxuICAgIHZhciBjYW52YXMgPSB0aGlzLl9jYW52YXM7XG4gICAgaWYgKCAhIGNhbnZhcyB8fCB0eXBlb2YgbGF5ZXJOYW1lID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHJlbmRlcmVyID0gdGhpcztcbiAgICB2YXIgY29udGFpbmVyID0gdGhpcy5fbGF5ZXJfY29udGFpbmVyc1tsYXllck5hbWVdO1xuICAgIHZhciByZXN1bHQgPSB0aGlzLmFkZFRleHRUcmFjayhpbl90ZXh0LGNvbnRhaW5lcik7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbn0pKCk7XG5cbkNvbmRlbnNlZFNlcXVlbmNlUmVuZGVyZXIucHJvdG90eXBlLkVuYWJsZUhpZ2hsaWdodHMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcmVuZGVyZXIgPSB0aGlzO1xuICAgIHZhciBoaWdobGlnaHRzID0gW107XG4gICAgdmFyIGNyZWF0ZU5ld0hpZ2hsaWdodCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaGlnaGxpZ2h0ID0gcmVuZGVyZXIuX2NhbnZhcy5yZWN0KDAsMCwwLCcxMDAlJyk7XG4gICAgICAgIGhpZ2hsaWdodC5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLCcjZmZkZGRkJyk7XG4gICAgICAgIGhpZ2hsaWdodC5yZW1vdmVBdHRyaWJ1dGUoJ3N0cm9rZScpO1xuICAgICAgICB2YXIgcG5vZGUgPSBoaWdobGlnaHQucGFyZW50Tm9kZTtcbiAgICAgICAgcG5vZGUuaW5zZXJ0QmVmb3JlKGhpZ2hsaWdodCxwbm9kZS5maXJzdENoaWxkLm5leHRTaWJsaW5nKTtcbiAgICAgICAgaGlnaGxpZ2h0cy5wdXNoKGhpZ2hsaWdodCk7XG4gICAgfTtcbiAgICBjcmVhdGVOZXdIaWdobGlnaHQoKTtcblxuICAgIHJlbmRlcmVyLm1vdmVIaWdobGlnaHQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHZhbHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICB2YXIgUlMgPSB0aGlzLl9SUztcbiAgICAgICAgdmFyIGkgPSAwLCBpZHggPSAwO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdmFscy5sZW5ndGg7IGkrPSAyKSB7XG4gICAgICAgICAgICB2YXIgZnJvbSA9IHZhbHNbaV07XG4gICAgICAgICAgICB2YXIgdG8gPSB2YWxzW2krMV07XG4gICAgICAgICAgICB2YXIgaGlnaGxpZ2h0ID0gaGlnaGxpZ2h0c1tpZHhdO1xuICAgICAgICAgICAgaWYgKCAhIGhpZ2hsaWdodCApIHtcbiAgICAgICAgICAgICAgICBjcmVhdGVOZXdIaWdobGlnaHQoKTtcbiAgICAgICAgICAgICAgICBoaWdobGlnaHQgPSBoaWdobGlnaHRzW2lkeF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIGhpZ2hsaWdodC5wcmV2aW91c1NpYmxpbmcucHJldmlvdXNTaWJsaW5nICYmIGhpZ2hsaWdodHMuaW5kZXhPZihoaWdobGlnaHQucHJldmlvdXNTaWJsaW5nLnByZXZpb3VzU2libGluZykgPCAwICkge1xuICAgICAgICAgICAgICAgIGhpZ2hsaWdodC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShoaWdobGlnaHQsaGlnaGxpZ2h0LnBhcmVudE5vZGUuZmlyc3RDaGlsZC5uZXh0U2libGluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoaWdobGlnaHQuc2V0QXR0cmlidXRlKCd4JywoZnJvbSAtIDEpICogUlMgKTtcbiAgICAgICAgICAgIGhpZ2hsaWdodC5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywodG8gLSAoZnJvbSAtIDEpKSAqIFJTICk7XG4gICAgICAgICAgICBoaWdobGlnaHQuc2V0QXR0cmlidXRlKCd2aXNpYmlsaXR5JywndmlzaWJsZScpO1xuICAgICAgICAgICAgaWR4ICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChpID0gaWR4OyBpIDwgaGlnaGxpZ2h0cy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICBoaWdobGlnaHRzW2ldLnNldEF0dHJpYnV0ZSgndmlzaWJpbGl0eScsJ2hpZGRlbicpO1xuICAgICAgICB9XG4gICAgfTtcbn07XG5cbihmdW5jdGlvbigpIHtcblxuICAgIHZhciBiaW5kQ2xpY2sgPSBmdW5jdGlvbihlbGVtZW50LGhhbmRsZXIpIHtcbiAgICAgICAgaWYgKFwib250b3VjaHN0YXJ0XCIgaW4gd2luZG93KSB7XG4gICAgICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0YXJ0WCA9IGV2LnRvdWNoZXNbMF0uY2xpZW50WDtcbiAgICAgICAgICAgICAgICB2YXIgc3RhcnRZID0gZXYudG91Y2hlc1swXS5jbGllbnRZO1xuICAgICAgICAgICAgICAgIHZhciByZXNldCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsbW92ZSk7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLGVuZCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB2YXIgZW5kID0gZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVyLmNhbGwobnVsbCxldik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHZhciBtb3ZlID0gZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKE1hdGguYWJzKGV2LnRvdWNoZXNbMF0uY2xpZW50WCAtIHN0YXJ0WCkgPiAxMCB8fCBNYXRoLmFicyhldi50b3VjaGVzWzBdLmNsaWVudFkgLSBzdGFydFkpID4gMTApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc2V0KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8vRklYTUUgLSBQQVNTSVZFXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBtb3ZlICwge3Bhc3NpdmU6dHJ1ZX0pO1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLGVuZCxmYWxzZSk7XG4gICAgICAgICAgICB9LHtwYXNzaXZlIDogdHJ1ZX0pO1xuICAgICAgICAgICAgLy9GSVhNRSAtIFBBU1NJVkVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLGhhbmRsZXIsZmFsc2UpO1xuICAgICAgICB9XG4gICAgfTtcblxuXG4gIHZhciBtb3VzZVBvc2l0aW9uID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgICB2YXIgcG9zeCA9IDA7XG4gICAgICB2YXIgcG9zeSA9IDA7XG4gICAgICBpZiAoIWV2dCkge1xuICAgICAgICAgIGV2dCA9IHdpbmRvdy5ldmVudDtcbiAgICAgIH1cblxuICAgICAgaWYgKGV2dC5wYWdlWCB8fCBldnQucGFnZVkpICAgICB7XG4gICAgICAgICAgcG9zeCA9IGV2dC5wYWdlWCAtIChkb2N1bWVudC5ib2R5LnNjcm9sbExlZnQgKyBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCk7XG4gICAgICAgICAgcG9zeSA9IGV2dC5wYWdlWSAtIChkb2N1bWVudC5ib2R5LnNjcm9sbFRvcCArIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3ApO1xuICAgICAgfSBlbHNlIGlmIChldnQuY2xpZW50WCB8fCBldnQuY2xpZW50WSkgIHtcbiAgICAgICAgICBwb3N4ID0gZXZ0LmNsaWVudFggKyBkb2N1bWVudC5ib2R5LnNjcm9sbExlZnQgKyBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdDtcbiAgICAgICAgICBwb3N5ID0gZXZ0LmNsaWVudFkgKyBkb2N1bWVudC5ib2R5LnNjcm9sbFRvcCArIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3A7XG4gICAgICB9XG4gICAgICBpZiAoc2VsZi50YXJnZXRFbGVtZW50KSB7XG4gICAgICAgICAgcG9zeCA9IGV2dC5zY3JlZW5YO1xuICAgICAgICAgIHBvc3kgPSBldnQuc2NyZWVuWTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbIHBvc3gsIHBvc3kgXTtcbiAgfTtcblxuICB2YXIgc3ZnUG9zaXRpb24gPSBmdW5jdGlvbihldixzdmdlbCkge1xuICAgICAgdmFyIHBvc2l0aW9ucyA9IG1vdXNlUG9zaXRpb24oZXYuY2hhbmdlZFRvdWNoZXMgPyBldi5jaGFuZ2VkVG91Y2hlc1swXSA6IGV2KTtcbiAgICAgIHZhciBwID0ge307XG4gICAgICBpZiAoc3ZnZWwubm9kZU5hbWUgPT0gJ3N2ZycpIHtcbiAgICAgICAgICBwID0gc3ZnZWwuY3JlYXRlU1ZHUG9pbnQoKTtcbiAgICAgICAgICB2YXIgcm9vdENUTSA9IHN2Z2VsLmdldFNjcmVlbkNUTSgpO1xuICAgICAgICAgIHAueCA9IHBvc2l0aW9uc1swXTtcbiAgICAgICAgICBwLnkgPSBwb3NpdGlvbnNbMV07XG5cbiAgICAgICAgICBzZWxmLm1hdHJpeCA9IHJvb3RDVE0uaW52ZXJzZSgpO1xuICAgICAgICAgIHAgPSBwLm1hdHJpeFRyYW5zZm9ybShzZWxmLm1hdHJpeCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgIHAueCA9IHBvc2l0aW9uc1swXTtcbiAgICAgICAgICBwLnkgPSBwb3NpdGlvbnNbMV07XG4gICAgICB9XG4gICAgICByZXR1cm4gcDtcbiAgfTtcblxuICB2YXIgbm90aWZ5U2VsZWN0aW9uVG9MYXllcnMgPSBmdW5jdGlvbihzdGFydCxlbmQscmVuZGVyZXIpIHtcbiAgICBmb3IgKHZhciBsYXluYW1lIGluIE1BU0NQLmxheWVycykge1xuICAgICAgICB2YXIgbGF5ID0gTUFTQ1AuZ2V0TGF5ZXIobGF5bmFtZSk7XG4gICAgICAgIGlmIChzdGFydCAmJiBlbmQpIHtcbiAgICAgICAgICAgIGJlYW4uZmlyZShsYXksJ3NlbGVjdGlvbicsIFsgcmVuZGVyZXIuc2NhbGVQb3NpdGlvbihzdGFydCxsYXluYW1lLHRydWUpLCByZW5kZXJlci5zY2FsZVBvc2l0aW9uKGVuZCxsYXluYW1lLHRydWUpIF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYmVhbi5maXJlKGxheSwnc2VsZWN0aW9uJywgWyBudWxsLG51bGwgXSk7XG4gICAgICAgIH1cbiAgICB9XG4gIH07XG5cbkNvbmRlbnNlZFNlcXVlbmNlUmVuZGVyZXIucHJvdG90eXBlLmVuYWJsZVNlbGVjdGlvbiA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgaWYgKCAhIHNlbGYuX2NhbnZhcykge1xuICAgICAgYmVhbi5hZGQoc2VsZiwnc2VxdWVuY2VDaGFuZ2UnLGZ1bmN0aW9uKCkge1xuICAgICAgICBzZWxmLmVuYWJsZVNlbGVjdGlvbigpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGNhbnZhcyA9IHNlbGYuX2NhbnZhcztcbiAgICB2YXIgc3RhcnQ7XG4gICAgdmFyIGVuZDtcbiAgICB2YXIgZW5kX2Z1bmM7XG4gICAgdmFyIGxvY2FsX3N0YXJ0O1xuICAgIHZhciBsb2NhbF9lbmQ7XG5cblxuICAgIHZhciBtb3ZpbmdfZnVuYyA9IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICB2YXIgcCA9IHN2Z1Bvc2l0aW9uKGV2dCxjYW52YXMpO1xuICAgICAgICBlbmQgPSBwLng7XG5cbiAgICAgICAgaWYgKHN0YXJ0ID4gZW5kKSB7XG4gICAgICAgICAgICBsb2NhbF9lbmQgPSBwYXJzZUludChzdGFydCAvIDUwKTtcbiAgICAgICAgICAgIGxvY2FsX3N0YXJ0ID0gcGFyc2VJbnQoZW5kIC8gNTApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbG9jYWxfZW5kID0gcGFyc2VJbnQoZW5kLzUwKTtcbiAgICAgICAgICAgIGxvY2FsX3N0YXJ0ID0gcGFyc2VJbnQoc3RhcnQvNTApO1xuICAgICAgICB9XG4gICAgICAgIHNlbGYuc2VsZWN0KGxvY2FsX3N0YXJ0KzEsbG9jYWxfZW5kKTtcbiAgICB9O1xuXG4gICAgLy8gRG8gbm90IHNlbmQgdGhlIGNsaWNrIGV2ZW50IHRvIHRoZSBjYW52YXNcbiAgICAvLyB0aGlzIHNjcmV3cyB1cCB3aXRoIGRvaW5nIHRoaW5ncyBvbiB0aGUgc2VsZWN0aW9uXG4gICAgLy8gTmVlZCBhbHRlcm5hdGl2ZSBtZXRob2QgdG8gY2xlYXIgc2VsZWN0aW9uXG4gICAgLy9cbiAgICBiaW5kQ2xpY2soY2FudmFzLGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICBpZiAoISBzZWxmLnNlbGVjdGluZykge1xuICAgICAgICAgICAgc2VsZi5zZWxlY3QoKTtcbiAgICAgICAgICAgIG5vdGlmeVNlbGVjdGlvblRvTGF5ZXJzKG51bGwsbnVsbCxzZWxmKTtcbiAgICAgICAgICAgIGxvY2FsX3N0YXJ0ID0gbnVsbDtcbiAgICAgICAgICAgIGxvY2FsX2VuZCA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICBpZiAoISBzZWxmLnNlbGVjdGluZyApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcG9zaXRpb25zID0gbW91c2VQb3NpdGlvbihldnQpO1xuICAgICAgICB2YXIgcCA9IHt9O1xuICAgICAgICBpZiAoY2FudmFzLm5vZGVOYW1lID09ICdzdmcnKSB7XG4gICAgICAgICAgICAgICAgcCA9IGNhbnZhcy5jcmVhdGVTVkdQb2ludCgpO1xuICAgICAgICAgICAgICAgIHZhciByb290Q1RNID0gdGhpcy5nZXRTY3JlZW5DVE0oKTtcbiAgICAgICAgICAgICAgICBwLnggPSBwb3NpdGlvbnNbMF07XG4gICAgICAgICAgICAgICAgcC55ID0gcG9zaXRpb25zWzFdO1xuXG4gICAgICAgICAgICAgICAgc2VsZi5tYXRyaXggPSByb290Q1RNLmludmVyc2UoKTtcbiAgICAgICAgICAgICAgICBwID0gcC5tYXRyaXhUcmFuc2Zvcm0oc2VsZi5tYXRyaXgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHAueCA9IHBvc2l0aW9uc1swXTtcbiAgICAgICAgICAgICAgICBwLnkgPSBwb3NpdGlvbnNbMV07XG4gICAgICAgIH1cbiAgICAgICAgc3RhcnQgPSBwLng7XG4gICAgICAgIGVuZCA9IHAueDtcbiAgICAgICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsbW92aW5nX2Z1bmMsZmFsc2UpO1xuICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9LGZhbHNlKTtcblxuICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJyxmdW5jdGlvbihldnQpIHtcbiAgICAgICAgaWYgKHNlbGYuc2VsZWN0aW5nKSB7XG4gICAgICAgICAgICBub3RpZnlTZWxlY3Rpb25Ub0xheWVycyhsb2NhbF9zdGFydCsxLGxvY2FsX2VuZCxzZWxmKTtcbiAgICAgICAgICAgIGxvY2FsX3N0YXJ0ID0gbnVsbDtcbiAgICAgICAgICAgIGxvY2FsX2VuZCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsbW92aW5nX2Z1bmMpO1xuICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9KTtcblxuICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChzZWxmLnNlbGVjdGluZykge1xuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBub3RpZnlTZWxlY3Rpb25Ub0xheWVycyhsb2NhbF9zdGFydCsxLGxvY2FsX2VuZCxzZWxmKTtcbiAgICAgICAgICAgICAgICBsb2NhbF9zdGFydCA9IG51bGw7XG4gICAgICAgICAgICAgICAgbG9jYWxfZW5kID0gbnVsbDtcbiAgICAgICAgICAgIH0sNTAwKTtcbiAgICAgICAgfVxuICAgICAgICBjYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJyxtb3ZpbmdfZnVuYyk7XG4gICAgfSk7XG5cbiAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIGlmICghIHNlbGYuc2VsZWN0aW5nICkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChldnQuY2hhbmdlZFRvdWNoZXMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgdmFyIHBvc2l0aW9ucyA9IG1vdXNlUG9zaXRpb24oZXZ0LmNoYW5nZWRUb3VjaGVzWzBdKTtcbiAgICAgICAgICAgIHZhciBwID0ge307XG4gICAgICAgICAgICBpZiAoY2FudmFzLm5vZGVOYW1lID09ICdzdmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHAgPSBjYW52YXMuY3JlYXRlU1ZHUG9pbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJvb3RDVE0gPSB0aGlzLmdldFNjcmVlbkNUTSgpO1xuICAgICAgICAgICAgICAgICAgICBwLnggPSBwb3NpdGlvbnNbMF07XG4gICAgICAgICAgICAgICAgICAgIHAueSA9IHBvc2l0aW9uc1sxXTtcblxuICAgICAgICAgICAgICAgICAgICBzZWxmLm1hdHJpeCA9IHJvb3RDVE0uaW52ZXJzZSgpO1xuICAgICAgICAgICAgICAgICAgICBwID0gcC5tYXRyaXhUcmFuc2Zvcm0oc2VsZi5tYXRyaXgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcC54ID0gcG9zaXRpb25zWzBdO1xuICAgICAgICAgICAgICAgICAgICBwLnkgPSBwb3NpdGlvbnNbMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGFydCA9IHAueDtcbiAgICAgICAgICAgIGVuZCA9IHAueDtcbiAgICAgICAgICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLG1vdmluZ19mdW5jLHtwYXNzaXZlOnRydWV9KTtcbiAgICAgICAgfVxuICAgIH0se3Bhc3NpdmU6dHJ1ZX0pO1xuICAgIC8vRklYTUUgLSBQQVNTSVZFXG59O1xuXG59KSgpO1xuXG4vKlxuICogR2V0IGEgY2FudmFzIHNldCBvZiB0aGUgdmlzaWJsZSB0cmFjZXJzIG9uIHRoaXMgcmVuZGVyZXJcbiAqL1xuQ29uZGVuc2VkU2VxdWVuY2VSZW5kZXJlci5wcm90b3R5cGUuX3Zpc2libGVUcmFjZXJzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHRyYWNlcnMgPSBudWxsO1xuICAgIGZvciAodmFyIGkgaW4gTUFTQ1AubGF5ZXJzKSB7XG4gICAgICAgIGlmICh0aGlzLmlzTGF5ZXJBY3RpdmUoaSkgJiYgdGhpcy5fbGF5ZXJfY29udGFpbmVyc1tpXSAmJiB0aGlzLl9sYXllcl9jb250YWluZXJzW2ldLnRyYWNlcnMpIHtcbiAgICAgICAgICAgIGlmICggISB0cmFjZXJzICkge1xuICAgICAgICAgICAgICAgIHRyYWNlcnMgPSB0aGlzLl9sYXllcl9jb250YWluZXJzW2ldLnRyYWNlcnM7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyYWNlcnMuY29uY2F0KHRoaXMuX2xheWVyX2NvbnRhaW5lcnNbaV0udHJhY2Vycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRyYWNlcnM7XG59O1xuXG5Db25kZW5zZWRTZXF1ZW5jZVJlbmRlcmVyLnByb3RvdHlwZS5fcmVzaXplQ29udGFpbmVyID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIFJTID0gdGhpcy5fUlM7XG4gICAgaWYgKHRoaXMuX2NvbnRhaW5lciAmJiB0aGlzLl9jYW52YXMpIHtcbiAgICAgICAgXG4gICAgICAgIHZhciB3aWR0aCA9ICh0aGlzLnpvb20gfHwgMSkqMip0aGlzLnNlcXVlbmNlLmxlbmd0aDtcbiAgICAgICAgdmFyIGhlaWdodCA9ICh0aGlzLnpvb20gfHwgMSkqMioodGhpcy5fY2FudmFzLl9jYW52YXNfaGVpZ2h0L3RoaXMuX1JTKTtcbiAgICAgICAgaWYgKHRoaXMuX2NhbnZhc19jYWxsb3V0X3BhZGRpbmcpIHtcbiAgICAgICAgICAgIGhlaWdodCArPSB0aGlzLl9jYW52YXNfY2FsbG91dF9wYWRkaW5nO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2NhbnZhcy5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgd2lkdGgpO1xuICAgICAgICB0aGlzLl9jYW52YXMuc2V0QXR0cmlidXRlKCdoZWlnaHQnLGhlaWdodCk7XG4gICAgICAgIHRoaXMubmF2aWdhdGlvbi5zZXREaW1lbnNpb25zKHdpZHRoLGhlaWdodCk7XG4gICAgICAgIFxuICAgICAgICBpZiAodGhpcy5ncm93X2NvbnRhaW5lcikge1xuICAgICAgICAgICAgdGhpcy5fY29udGFpbmVyX2NhbnZhcy5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsaGVpZ2h0KTtcbiAgICAgICAgICAgIC8vIHRoaXMuX2NvbnRhaW5lci5zdHlsZS5oZWlnaHQgPSBoZWlnaHQrJ3B4JzsgICAgICAgIFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fY29udGFpbmVyX2NhbnZhcy5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsJzEwMCUnKTtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRhaW5lcl9jYW52YXMuc2V0QXR0cmlidXRlKCd3aWR0aCcsJzEwMCUnKTtcblxuICAgICAgICAgICAgLy8gdGhpcy5fY29udGFpbmVyLnN0eWxlLmhlaWdodCA9ICdhdXRvJztcbiAgICAgICAgICAgIHRoaXMubmF2aWdhdGlvbi5zZXRab29tKHRoaXMuem9vbSk7XG4gICAgICAgIH0gICAgICAgIFxuICAgIH1cbn07XG5cbihmdW5jdGlvbihjbGF6eikge1xuXG52YXIgdmlzX2NoYW5nZV9ldmVudCA9IGZ1bmN0aW9uKHJlbmRlcmVyLHZpc2liaWxpdHkpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgaWYgKCAhIHJlbmRlcmVyLl9sYXllcl9jb250YWluZXJzW3NlbGYubmFtZV0gfHwgcmVuZGVyZXIuX2xheWVyX2NvbnRhaW5lcnNbc2VsZi5uYW1lXS5sZW5ndGggPD0gMCApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBcbiAgICBpZiAoISB2aXNpYmlsaXR5KSB7XG4gICAgICAgIGlmIChyZW5kZXJlci5fbGF5ZXJfY29udGFpbmVyc1tzZWxmLm5hbWVdLnRyYWNlcnMpIHtcbiAgICAgICAgICAgIHJlbmRlcmVyLl9sYXllcl9jb250YWluZXJzW3NlbGYubmFtZV0udHJhY2Vycy5oaWRlKCk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIEFkZCBhIGxheWVyIHRvIHRoaXMgcmVuZGVyZXIuXG4gKiBAcGFyYW0ge09iamVjdH0gbGF5ZXIgICAgTGF5ZXIgb2JqZWN0IHRvIGFkZC4gVGhlIGxheWVyIGRhdGEgaXMgdXNlZCB0byBjcmVhdGUgYSB0cmFjayB0aGF0IGNhbiBiZSBpbmRlcGVuZGVudGx5IHNob3duL2hpZGRlbi5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICBUaGUgdHJhY2sgaXRzZWxmIGlzIGJ5IGRlZmF1bHQgaGlkZGVuLlxuICovXG5jbGF6ei5wcm90b3R5cGUuYWRkVHJhY2sgPSBmdW5jdGlvbihsYXllcikge1xuICAgIHZhciBSUyA9IHRoaXMuX1JTO1xuICAgIHZhciByZW5kZXJlciA9IHRoaXM7XG4gICAgXG4gICAgaWYgKCAhIHRoaXMuX2NhbnZhcyApIHtcbiAgICAgICAgYmVhbi5hZGQodGhpcywnc2VxdWVuY2VjaGFuZ2UnLGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5hZGRUcmFjayhsYXllcik7XG4gICAgICAgICAgICBiZWFuLnJlbW92ZSh0aGlzLCdzZXF1ZW5jZWNoYW5nZScsYXJndW1lbnRzLmNhbGxlZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zb2xlLmxvZyhcIk5vIGNhbnZhcywgY2Fubm90IGFkZCB0cmFjaywgd2FpdGluZyBmb3Igc2VxdWVuY2VjaGFuZ2UgZXZlbnRcIik7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbGF5ZXJfY29udGFpbmVycyA9IHRoaXMuX2xheWVyX2NvbnRhaW5lcnMgfHwgW107XG5cbiAgICBpZiAoICEgbGF5ZXJfY29udGFpbmVyc1tsYXllci5uYW1lXSB8fCBsYXllcl9jb250YWluZXJzW2xheWVyLm5hbWVdID09PSBudWxsKSB7XG4gICAgICAgIGxheWVyX2NvbnRhaW5lcnNbbGF5ZXIubmFtZV0gPSB0aGlzLl9jYW52YXMuc2V0KCk7XG4gICAgICAgIGlmICggISBsYXllcl9jb250YWluZXJzW2xheWVyLm5hbWVdLnRyYWNrX2hlaWdodCkge1xuICAgICAgICAgICAgbGF5ZXJfY29udGFpbmVyc1tsYXllci5uYW1lXS50cmFja19oZWlnaHQgPSByZW5kZXJlci50cmFja0hlaWdodCB8fCA0O1xuICAgICAgICB9XG4gICAgICAgIGJlYW4ucmVtb3ZlKGxheWVyLCd2aXNpYmlsaXR5Q2hhbmdlJyx2aXNfY2hhbmdlX2V2ZW50KTtcbiAgICAgICAgYmVhbi5hZGQobGF5ZXIsJ3Zpc2liaWxpdHlDaGFuZ2UnLHZpc19jaGFuZ2VfZXZlbnQpO1xuICAgICAgICB2YXIgZXZlbnRfbmFtZXMgPSBbJ2NsaWNrJywnbW91c2VvdmVyJywnbW91c2Vkb3duJywnbW91c2Vtb3ZlJywnbW91c2VvdXQnLCdtb3VzZXVwJywnbW91c2VlbnRlcicsJ21vdXNlbGVhdmUnXTtcbiAgICAgICAgdmFyIGV2X2Z1bmN0aW9uID0gZnVuY3Rpb24oZXYsb3JpZ2luYWxfZXZlbnQsZWxlbWVudCkge1xuICAgICAgICAgICAgYmVhbi5maXJlKGxheWVyLGV2LnR5cGUsW29yaWdpbmFsX2V2ZW50LGVsZW1lbnQucG9zaXRpb25fc3RhcnQsZWxlbWVudC5wb3NpdGlvbl9lbmRdKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gZm9yICh2YXIgaSA9IDAgOyBpIDwgZXZlbnRfbmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gICAgIGJlYW4uYWRkKGxheWVyX2NvbnRhaW5lcnNbbGF5ZXIubmFtZV0uX2V2ZW50X3Byb3h5LGV2ZW50X25hbWVzW2ldLGV2X2Z1bmN0aW9uKTtcbiAgICAgICAgLy8gfVxuICAgICAgICBiZWFuLnJlbW92ZShsYXllciwncmVtb3ZlZCcpO1xuICAgICAgICBiZWFuLmFkZChsYXllciwncmVtb3ZlZCcsZnVuY3Rpb24ocmVuZCkge1xuICAgICAgICAgICAgaWYgKHJlbmQpIHtcbiAgICAgICAgICAgICAgICByZW5kLnJlbW92ZVRyYWNrKHRoaXMpO1xuICAgICAgICAgICAgfSBlbHNle1xuICAgICAgICAgICAgICAgIHJlbmRlcmVyLnJlbW92ZVRyYWNrKHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgXG4gICAgdGhpcy5fbGF5ZXJfY29udGFpbmVycyA9IGxheWVyX2NvbnRhaW5lcnM7XG4gICAgXG59O1xuXG5jbGF6ei5wcm90b3R5cGUucmVtb3ZlVHJhY2sgPSBmdW5jdGlvbihsYXllcikge1xuICAgIGlmICghIHRoaXMuX2xheWVyX2NvbnRhaW5lcnMgKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGxheWVyX2NvbnRhaW5lcnMgPSB0aGlzLl9sYXllcl9jb250YWluZXJzIHx8IFtdO1xuICAgIGlmICggbGF5ZXJfY29udGFpbmVyc1tsYXllci5uYW1lXSApIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuX2xheWVyX2NvbnRhaW5lcnNbbGF5ZXIubmFtZV07XG4gICAgICAgIGxheWVyLmRpc2FibGVkID0gdHJ1ZTtcbiAgICB9XG5cbn07XG5cbnZhciByZWZyZXNoX2lkID0gMDtcbmNsYXp6LnByb3RvdHlwZS5kaXNhYmxlUHJpbnRSZXNpemluZyA9IGZ1bmN0aW9uKCkge1xuICAgIGRlbGV0ZSB0aGlzLl9tZWRpYV9mdW5jO1xufTtcblxuY2xhenoucHJvdG90eXBlLmVuYWJsZVByaW50UmVzaXppbmcgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoICEgKHRoaXMud2luKCkgfHwgd2luZG93KS5tYXRjaE1lZGlhICkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLl9tZWRpYV9mdW5jKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9tZWRpYV9mdW5jO1xuICAgIH1cbiAgICB0aGlzLl9tZWRpYV9mdW5jID0gZnVuY3Rpb24obWF0Y2hlcikge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIGlmICggISBzZWxmLl9jYW52YXMgKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCBzZWxmLmdyb3dfY29udGFpbmVyICkge1xuICAgICAgICAgICAgaWYgKG1hdGNoZXIubWF0Y2hlcykge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBzZWxmLl9jb250YWluZXJfY2FudmFzLnBhcmVudE5vZGUuY2FjaGVkX3dpZHRoO1xuICAgICAgICAgICAgICAgIGJlYW4uZmlyZShzZWxmLl9jYW52YXMsJ3BhbmVuZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtYXRjaD1tYXRjaGVyO1xuICAgICAgICBpZiAoISBtYXRjaC5tYXRjaGVzICkge1xuICAgICAgICAgICAgaWYgKHNlbGYub2xkX3pvb20pIHtcbiAgICAgICAgICAgICAgICB2YXIgYV96b29tID0gc2VsZi5vbGRfem9vbTtcbiAgICAgICAgICAgICAgICBzZWxmLm9sZF96b29tID0gbnVsbDtcbiAgICAgICAgICAgICAgICBzZWxmLnpvb21DZW50ZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgIHNlbGYud2l0aG91dFJlZnJlc2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICBzZWxmLnpvb20gPSBhX3pvb207XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgc2VsZi5fY2FudmFzLnNldEN1cnJlbnRUcmFuc2xhdGVYWShzZWxmLm9sZF90cmFuc2xhdGUsMCk7XG4gICAgICAgICAgICAgICAgc2VsZi5fY29udGFpbmVyX2NhbnZhcy5zZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnLHNlbGYub2xkX3ZpZXdib3gpO1xuICAgICAgICAgICAgICAgIC8vIHNlbGYuX2NvbnRhaW5lci5zdHlsZS5oZWlnaHQgPSAnYXV0byc7XG4gICAgICAgICAgICAgICAgc2VsZi5vbGRfem9vbSA9IG51bGw7XG4gICAgICAgICAgICAgICAgc2VsZi5vbGRfdHJhbnNsYXRlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBzZWxmLnJlZnJlc2goKTtcbiAgICAgICAgICAgICAgICBiZWFuLmZpcmUoc2VsZi5fY2FudmFzLCd6b29tQ2hhbmdlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBjb250YWluZXIgPSBzZWxmLl9jb250YWluZXI7XG4gICAgICAgICAgICBzZWxmLm9sZF90cmFuc2xhdGUgPSBzZWxmLl9jYW52YXMuY3VycmVudFRyYW5zbGF0ZUNhY2hlLng7XG4gICAgICAgICAgICBzZWxmLl9jYW52YXMuc2V0Q3VycmVudFRyYW5zbGF0ZVhZKDAsMCk7XG4gICAgICAgICAgICB2YXIgem9vbUZhY3RvciA9IDAuOTUgKiAoY29udGFpbmVyLmNsaWVudFdpZHRoKSAvIChzZWxmLnNlcXVlbmNlLmxlbmd0aCk7XG4gICAgICAgICAgICBpZiAoICEgc2VsZi5vbGRfem9vbSApIHtcbiAgICAgICAgICAgICAgc2VsZi5vbGRfem9vbSA9IHNlbGYuem9vbTtcbiAgICAgICAgICAgICAgc2VsZi5vbGRfdmlld2JveCA9IHNlbGYuX2NvbnRhaW5lcl9jYW52YXMuZ2V0QXR0cmlidXRlKCd2aWV3Qm94Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLnpvb21DZW50ZXIgPSBudWxsO1xuICAgICAgICAgICAgc2VsZi5fY29udGFpbmVyX2NhbnZhcy5yZW1vdmVBdHRyaWJ1dGUoJ3ZpZXdCb3gnKTtcbiAgICAgICAgICAgIHNlbGYud2l0aG91dFJlZnJlc2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgc2VsZi56b29tID0gem9vbUZhY3RvcjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2VsZi5yZWZyZXNoKCk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY29uc29sZS5sb2coZXJyKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGVyci5zdGFjayk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciByZW5kID0gdGhpcztcbiAgICBpZiAoICEgcmVuZC5fYm91bmRfbWVkaWEgKSB7XG4gICAgICAgICh0aGlzLndpbigpIHx8IHdpbmRvdykubWF0Y2hNZWRpYSgncHJpbnQnKS5hZGRMaXN0ZW5lcihmdW5jdGlvbihtYXRjaGVyKSB7XG4gICAgICAgICAgICBpZiAocmVuZC5fbWVkaWFfZnVuYykge1xuICAgICAgICAgICAgICAgIHJlbmQuX21lZGlhX2Z1bmMobWF0Y2hlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZW5kLl9ib3VuZF9tZWRpYSA9IHRydWU7XG59O1xuXG4vKipcbiAqIENhdXNlIGEgcmVmcmVzaCBvZiB0aGUgcmVuZGVyZXIsIHJlLWFycmFuZ2luZyB0aGUgdHJhY2tzIG9uIHRoZSBjYW52YXMsIGFuZCByZXNpemluZyB0aGUgY2FudmFzIGlmIG5lY2Vzc2FyeS5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gYW5pbWF0ZWRzIENhdXNlIHRoaXMgcmVmcmVzaCB0byBiZSBhbiBhbmltYXRlZCByZWZyZXNoXG4gKi9cbmNsYXp6LnByb3RvdHlwZS5yZWZyZXNoID0gZnVuY3Rpb24oYW5pbWF0ZWQpIHtcbiAgICBpZiAoICEgdGhpcy5fY2FudmFzICkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGxheWVyX2NvbnRhaW5lcnMgPSB0aGlzLl9sYXllcl9jb250YWluZXJzIHx8IFtdO1xuXG4gICAgdmFyIFJTID0gdGhpcy5fUlM7XG4gICAgdmFyIHRyYWNrX2hlaWdodHMgPSAwO1xuICAgIHZhciBvcmRlciA9IHRoaXMudHJhY2tPcmRlciB8fCBbXTtcbiAgICB2YXIgZml4ZWRfZm9udF9zY2FsZSA9IHRoaXMuZml4ZWRGb250U2NhbGU7XG4gICAgXG4gICAgaWYgKHRoaXMubmF2aWdhdGlvbikge1xuICAgICAgICB0aGlzLm5hdmlnYXRpb24ucmVzZXQoKTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcmRlci5sZW5ndGg7IGkrKyApIHtcbiAgICAgICAgXG4gICAgICAgIHZhciBuYW1lID0gb3JkZXJbaV07XG4gICAgICAgIHZhciBjb250YWluZXIgPSBsYXllcl9jb250YWluZXJzW25hbWVdO1xuICAgICAgICBpZiAoICEgY29udGFpbmVyICkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHlfdmFsO1xuICAgICAgICBpZiAoISB0aGlzLmlzTGF5ZXJBY3RpdmUobmFtZSkpIHtcbiAgICAgICAgICAgIHZhciBhdHRycyA9IHsgJ3knIDogLTEqKHRoaXMuX2F4aXNfaGVpZ2h0KSpSUywgJ2hlaWdodCcgOiAgUlMgKiBjb250YWluZXIudHJhY2tfaGVpZ2h0IC8gdGhpcy56b29tICwndmlzaWJpbGl0eScgOiAnaGlkZGVuJyB9O1xuLy8gICAgICAgICAgICB2YXIgYXR0cnMgPSB7ICd5JyA6ICh0aGlzLl9heGlzX2hlaWdodCAgKyAodHJhY2tfaGVpZ2h0cyAtIGNvbnRhaW5lci50cmFja19oZWlnaHQgKS8gdGhpcy56b29tKSpSUywgJ2hlaWdodCcgOiAgUlMgKiBjb250YWluZXIudHJhY2tfaGVpZ2h0IC8gdGhpcy56b29tICwndmlzaWJpbGl0eScgOiAnaGlkZGVuJyB9O1xuICAgICAgICAgICAgaWYgKE1BU0NQLmdldExheWVyKG5hbWUpLmdyb3VwKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbnRyb2xsZXJfdHJhY2sgPSB0aGlzLm5hdmlnYXRpb24uZ2V0Q29udHJvbGxlcihNQVNDUC5nZXRMYXllcihuYW1lKS5ncm91cCk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRyb2xsZXJfdHJhY2sgJiYgdGhpcy5pc0xheWVyQWN0aXZlKGNvbnRyb2xsZXJfdHJhY2spKSB7XG4gICAgICAgICAgICAgICAgICAgIGF0dHJzLnkgPSBsYXllcl9jb250YWluZXJzW2NvbnRyb2xsZXJfdHJhY2submFtZV0uY3VycmVudHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChjb250YWluZXIuZml4ZWRfdHJhY2tfaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGF0dHJzLmhlaWdodDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGFuaW1hdGVkKSB7ICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5hbmltYXRlKGF0dHJzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLmF0dHIoYXR0cnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbnRhaW5lci50cmFjZXJzKSB7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIGNvbnRhaW5lci5hdHRyKHsgJ29wYWNpdHknIDogJzEnIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRyYWNlcl90b3AgPSB0cmFja19oZWlnaHRzO1xuXG4gICAgICAgIGlmIChjb250YWluZXIuZml4ZWRfdHJhY2tfaGVpZ2h0KSB7XG5cbiAgICAgICAgICAgIHZhciB0cmFja19oZWlnaHQgPSBjb250YWluZXIuZml4ZWRfdHJhY2tfaGVpZ2h0O1xuXG4gICAgICAgICAgICB5X3ZhbCA9IHRoaXMuX2F4aXNfaGVpZ2h0ICsgdHJhY2tfaGVpZ2h0cyAgLyB0aGlzLnpvb207XG5cbiAgICAgICAgICAgIGlmIChhbmltYXRlZCkge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5hbmltYXRlKHsgJ3Zpc2liaWxpdHknOiAndmlzaWJsZScsICd5JyA6IHlfdmFsKlJTLCAnaGVpZ2h0JyA6ICBSUyAqIGNvbnRhaW5lci50cmFja19oZWlnaHQgLyB0aGlzLnpvb20gfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5hdHRyKHsgJ3Zpc2liaWxpdHknOiAndmlzaWJsZScsICd5JyA6IHlfdmFsKlJTLCAnaGVpZ2h0JyA6ICBSUyAqIGNvbnRhaW5lci50cmFja19oZWlnaHQgLyB0aGlzLnpvb20gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5uYXZpZ2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgeV92YWwgLT0gMSpjb250YWluZXIudHJhY2tfaGVpZ2h0L3RoaXMuem9vbTtcbiAgICAgICAgICAgICAgICB0aGlzLm5hdmlnYXRpb24ucmVuZGVyVHJhY2soTUFTQ1AuZ2V0TGF5ZXIobmFtZSksIHlfdmFsKlJTICwgUlMgKiBjb250YWluZXIuZml4ZWRfdHJhY2tfaGVpZ2h0IC8gdGhpcy56b29tLCB7ICdmb250LXNjYWxlJyA6ICgoZml4ZWRfZm9udF9zY2FsZSB8fCAxKSAqIDMgKmNvbnRhaW5lci50cmFja19oZWlnaHQpIC8gY29udGFpbmVyLmZpeGVkX3RyYWNrX2hlaWdodCB9ICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmFja19oZWlnaHRzICs9IGNvbnRhaW5lci5maXhlZF90cmFja19oZWlnaHQgKyB0aGlzLnRyYWNrR2FwIC0gY29udGFpbmVyLnRyYWNrX2hlaWdodDtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeV92YWwgPSB0aGlzLl9heGlzX2hlaWdodCArIHRyYWNrX2hlaWdodHMgLyB0aGlzLnpvb207XG4gICAgICAgICAgICBpZiAoYW5pbWF0ZWQpIHtcbiAgICAgICAgICAgICAgICBjb250YWluZXIuYW5pbWF0ZSh7ICd2aXNpYmlsaXR5JzogJ3Zpc2libGUnLCAneScgOiB5X3ZhbCpSUywgJ2hlaWdodCcgOiAgUlMgKiBjb250YWluZXIudHJhY2tfaGVpZ2h0IC8gdGhpcy56b29tIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb250YWluZXIuYXR0cih7ICd2aXNpYmlsaXR5JzogJ3Zpc2libGUnLCAneScgOiB5X3ZhbCpSUywgJ2hlaWdodCcgOiAgUlMgKiBjb250YWluZXIudHJhY2tfaGVpZ2h0IC8gdGhpcy56b29tIH0pOyAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLm5hdmlnYXRpb24pIHtcbiAgICAgICAgICAgICAgICB5X3ZhbCAtPSAxKmNvbnRhaW5lci50cmFja19oZWlnaHQvdGhpcy56b29tO1xuICAgICAgICAgICAgICAgIHRoaXMubmF2aWdhdGlvbi5yZW5kZXJUcmFjayhNQVNDUC5nZXRMYXllcihuYW1lKSwgeV92YWwqUlMgLCBSUyAqIDMgKiBjb250YWluZXIudHJhY2tfaGVpZ2h0IC8gdGhpcy56b29tLCBmaXhlZF9mb250X3NjYWxlID8geyAnZm9udC1zY2FsZScgOiBmaXhlZF9mb250X3NjYWxlIH0gOiBudWxsICk7XG4gICAgICAgICAgICAgICAgdHJhY2tfaGVpZ2h0cyArPSBjb250YWluZXIudHJhY2tfaGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJhY2tfaGVpZ2h0cyArPSBjb250YWluZXIudHJhY2tfaGVpZ2h0ICsgdGhpcy50cmFja0dhcDtcbiAgICAgICAgfVxuICAgICAgICBjb250YWluZXIucmVmcmVzaF96b29tKCk7XG5cbiAgICAgICAgaWYgKGNvbnRhaW5lci50cmFjZXJzKSB7XG4gICAgICAgICAgICB2YXIgZGlzcF9zdHlsZSA9ICh0aGlzLmlzTGF5ZXJBY3RpdmUobmFtZSkgJiYgKHRoaXMuem9vbSA+IDMuNikpID8gJ3Zpc2libGUnIDogJ2hpZGRlbic7XG4gICAgICAgICAgICB2YXIgaGVpZ2h0ID0gKDEuNSArIHRyYWNlcl90b3AgLyB0aGlzLnpvb20gKSpSUztcblxuICAgICAgICAgICAgaWYoYW5pbWF0ZWQpIHtcbiAgICAgICAgICAgICAgICBjb250YWluZXIudHJhY2Vycy5hbmltYXRlKHsndmlzaWJpbGl0eScgOiBkaXNwX3N0eWxlICwgJ3knIDogMC42NSoodGhpcy5fYXhpc19oZWlnaHQpKlJTLCdoZWlnaHQnIDogaGVpZ2h0IH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb250YWluZXIudHJhY2Vycy5hdHRyKHsndmlzaWJpbGl0eScgOiBkaXNwX3N0eWxlICwgJ3knIDogMC42NSoodGhpcy5fYXhpc19oZWlnaHQpKlJTLCdoZWlnaHQnIDogaGVpZ2h0IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cblxuICAgIH1cbiAgICBcbiAgICB2YXIgdmlld0JveCA9IFstMSwwLDAsMF07XG4gICAgdmlld0JveFswXSA9IC0yKlJTO1xuICAgIHZpZXdCb3hbMl0gPSAodGhpcy5zZXF1ZW5jZS5zcGxpdCgnJykubGVuZ3RoKyh0aGlzLnBhZGRpbmcpKzIpKlJTO1xuICAgIHZpZXdCb3hbM10gPSAodGhpcy5fYXhpc19oZWlnaHQgKyAodHJhY2tfaGVpZ2h0cyAvIHRoaXMuem9vbSkrICh0aGlzLnBhZGRpbmcgLyB0aGlzLnpvb20pKSpSUztcbiAgICB0aGlzLl9jYW52YXMuc2V0QXR0cmlidXRlKCd2aWV3Qm94Jywgdmlld0JveC5qb2luKCcgJykpO1xuICAgIHRoaXMuX2NhbnZhcy5fY2FudmFzX2hlaWdodCA9IHZpZXdCb3hbM107XG5cblxuICAgIHZhciBvdXRlcl92aWV3Ym94ID0gW10uY29uY2F0KHZpZXdCb3gpO1xuXG4gICAgb3V0ZXJfdmlld2JveFswXSA9IDA7XG4gICAgb3V0ZXJfdmlld2JveFsyXSA9ICh0aGlzLnpvb20pKigyKnRoaXMuc2VxdWVuY2UubGVuZ3RoKSsodGhpcy5wYWRkaW5nKTtcbiAgICBvdXRlcl92aWV3Ym94WzNdID0gKHRoaXMuem9vbSkqMioodGhpcy5fYXhpc19oZWlnaHQgKyAodHJhY2tfaGVpZ2h0cyAvIHRoaXMuem9vbSkrICh0aGlzLnBhZGRpbmcgLyB0aGlzLnpvb20pKTtcbiAgICBpZiAoISB0aGlzLmdyb3dfY29udGFpbmVyICkge1xuICAgICAgICB0aGlzLl9jb250YWluZXJfY2FudmFzLnNldEF0dHJpYnV0ZSgndmlld0JveCcsIG91dGVyX3ZpZXdib3guam9pbignICcpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9jb250YWluZXJfY2FudmFzLnJlbW92ZUF0dHJpYnV0ZSgndmlld0JveCcpO1xuICAgIH1cblxuICAgIHRoaXMuX3Jlc2l6ZUNvbnRhaW5lcigpO1xuXG4gICAgdmlld0JveFswXSA9IDA7XG4gICAgaWYgKHRoaXMubmF2aWdhdGlvbikge1xuICAgICAgICBpZiAoIHRoaXMuZ3Jvd19jb250YWluZXIgKSB7XG4gICAgICAgICAgICB0aGlzLm5hdmlnYXRpb24ubmF2X3dpZHRoX2Jhc2UgPSBvdXRlcl92aWV3Ym94WzNdIDwgMjAwID8gb3V0ZXJfdmlld2JveFszXSA6IDIwMDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm5hdmlnYXRpb24ubW92ZV9jbG9zZXIoKTtcbiAgICAgICAgaWYgKHRoaXMubmF2aWdhdGlvbi52aXNpYmxlKCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2NhbnZhcy5zdHlsZS5Hb21hcFNjcm9sbExlZnRNYXJnaW4gPSAxMDAgKiBSUyAvIHRoaXMuem9vbTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2NhbnZhcy5zdHlsZS5Hb21hcFNjcm9sbExlZnRNYXJnaW4gPSAxMDAwOyAgICAgICAgICAgIFxuICAgICAgICB9XG4gICAgICAgIHRoaXMubmF2aWdhdGlvbi5zZXRWaWV3Qm94KHZpZXdCb3guam9pbignICcpKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5uYXZpZ2F0aW9uKSB7XG4gICAgICAgIHRoaXMubmF2aWdhdGlvbi5yZWZyZXNoKCk7XG4gICAgfVxuXG59O1xuXG5cbi8qXG5cbk1vZGlmaWVkIGZyb206XG5cbmh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNTQzMzgwNi9jb252ZXJ0LWVtYmVkZGVkLXN2Zy10by1wbmctaW4tcGxhY2VcblxuTm9uZSBvZiB0aGUgU2FmYXJpIGJyb3dzZXJzIHdvcmsgd2l0aCB0aGlzLCBnaXZpbmcgRE9NIEV4Y2VwdGlvbiAxOFxuXG5odHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzgxNTgzMTIvcmFzdGVyaXppbmctYW4taW4tZG9jdW1lbnQtc3ZnLXRvLWNhbnZhc1xuXG5JIHRoaW5rIHRoaXMgaXMgdGhlIHJlbGV2YW50IGJ1Zy5cblxuaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTExOTQ5MlxuXG4qL1xuXG52YXIgc3ZnRGF0YVVSTCA9IGZ1bmN0aW9uKHN2Zykge1xuICBzdmcuc2V0QXR0cmlidXRlKCd4bWxucycsJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyk7XG4gIHN2Zy5zZXRBdHRyaWJ1dGUoJ3htbG5zOnhsaW5rJywnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycpO1xuXG4gIHZhciBzdmdBc1hNTCA9IChuZXcgWE1MU2VyaWFsaXplcikuc2VyaWFsaXplVG9TdHJpbmcoc3ZnKTtcbiAgcmV0dXJuIFwiZGF0YTppbWFnZS9zdmcreG1sLFwiICsgZW5jb2RlVVJJQ29tcG9uZW50KHN2Z0FzWE1MKTtcbn07XG5cbmNsYXp6LnByb3RvdHlwZS5wbmdVUkwgPSBmdW5jdGlvbihwbmdSZWFkeSxvdXRfd2lkdGgpIHtcbiAgICAvL3ZhciBzdmcgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZm9vYmFyJyk7Ly90aGlzLl9jYW52YXM7XG4gICAgdmFyIHN2Z19kYXRhID0gdGhpcy5fY2FudmFzLmNsb25lTm9kZSh0cnVlKTtcbiAgICB2YXIgc2VxdWVuY2VzID0gc3ZnX2RhdGEucXVlcnlTZWxlY3RvckFsbCgndGV4dFtkYXRhLXNwYWNlc10nKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlcXVlbmNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBzZXF1ZW5jZXNbaV0ucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzZXF1ZW5jZXNbaV0pO1xuICAgIH1cblxuICAgIC8vIFNldCB1cCB0aGUgYXNwZWN0IHJhdGlvIG9mIHRoZSBvdXRwdXQgZWxlbWVudFxuICAgIHZhciBzdmcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoc3ZnbnMsJ3N2ZycpO1xuICAgIHN2Zy5zZXRBdHRyaWJ1dGUoJ3dpZHRoJyx0aGlzLl9jb250YWluZXJfY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoKTtcbiAgICBzdmcuc2V0QXR0cmlidXRlKCdoZWlnaHQnLHRoaXMuX2NvbnRhaW5lcl9jYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0KTtcbiAgICBzdmcuc2V0QXR0cmlidXRlKCdwcmVzZXJ2ZUFzcGVjdFJhdGlvJywneE1pbllNaW4gbWVldCcpO1xuXG4gICAgdmFyIHRyYW5zZm9ybV9ncm91cCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhzdmducywnZycpO1xuICAgIHRyYW5zZm9ybV9ncm91cC5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsdGhpcy5fY2FudmFzLnBhcmVudE5vZGUuZ2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nKSk7XG4gICAgc3ZnLmFwcGVuZENoaWxkKHRyYW5zZm9ybV9ncm91cCk7XG4gICAgdHJhbnNmb3JtX2dyb3VwLmFwcGVuZENoaWxkKHN2Z19kYXRhKTtcblxuICAgIC8vIFdlIGFyZSBtaXNzaW5nIHRoZSBkZWZzIGVsZW1lbnRzIGZyb20gdGhlIGNvbnRhaW5pbmcgbm9kZVxuXG4gICAgdmFyIGFsbF9kZWZzID0gdGhpcy5fY29udGFpbmVyX2NhbnZhcy5xdWVyeVNlbGVjdG9yQWxsKCdkZWZzJyk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGxfZGVmcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBzdmcuYXBwZW5kQ2hpbGQoYWxsX2RlZnNbaV0uY2xvbmVOb2RlKHRydWUpKTtcbiAgICB9XG4gICAgdmFyIGNhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIHZhciB0b3RhbF93aWR0aCA9IDIqcGFyc2VJbnQoc3ZnLmdldEF0dHJpYnV0ZSgnd2lkdGgnKSk7XG4gICAgdmFyIHRvdGFsX2hlaWdodCA9IDIqcGFyc2VJbnQoc3ZnLmdldEF0dHJpYnV0ZSgnaGVpZ2h0JykpO1xuICAgIGlmIChvdXRfd2lkdGgpIHtcbiAgICAgICAgaWYgKHRvdGFsX3dpZHRoID4gb3V0X3dpZHRoKSB7XG4gICAgICAgICAgICB2YXIgcmF0aW8gPSB0b3RhbF93aWR0aCAvIG91dF93aWR0aDtcbiAgICAgICAgICAgIHRvdGFsX3dpZHRoID0gb3V0X3dpZHRoO1xuICAgICAgICAgICAgdG90YWxfaGVpZ2h0ID0gcGFyc2VJbnQodG90YWxfaGVpZ2h0IC8gcmF0aW8pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhbi53aWR0aCA9IHRvdGFsX3dpZHRoO1xuICAgIGNhbi5oZWlnaHQgPSB0b3RhbF9oZWlnaHQ7XG4gICAgdmFyIHN2Z0ltZyA9IG5ldyBJbWFnZTtcbiAgICBzdmdJbWcud2lkdGggID0gMTtcbiAgICBzdmdJbWcuaGVpZ2h0ID0gMTtcbiAgICB2YXIgY3R4ID0gY2FuLmdldENvbnRleHQoJzJkJyk7XG4gICAgc3ZnSW1nLm9ubG9hZCA9IGZ1bmN0aW9uKCl7XG4gICAgICBjdHguZHJhd0ltYWdlKHN2Z0ltZywwLDAsY2FuLndpZHRoLGNhbi5oZWlnaHQpO1xuICAgICAgcG5nUmVhZHkoY2FuLnRvRGF0YVVSTCgpKTtcbiAgICB9O1xuICAgIHN2Z0ltZy5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIkdvdCBhbiBlcnJvclwiKTtcbiAgICB9O1xuICAgIHZhciBkYXRhdXJsID0gc3ZnRGF0YVVSTChzdmcpO1xuICAgIHN2Z0ltZy5zcmMgPSBkYXRhdXJsO1xufTtcblxufSkoQ29uZGVuc2VkU2VxdWVuY2VSZW5kZXJlcik7XG5cbi8qKlxuICogWm9vbSBsZXZlbCBoYXMgY2hhbmdlZCBmb3IgdGhpcyByZW5kZXJlclxuICogQG5hbWUgICAgQ29uZGVuc2VkU2VxdWVuY2VSZW5kZXJlciN6b29tQ2hhbmdlXG4gKiBAZXZlbnRcbiAqIEBwYXJhbSAgIHtPYmplY3R9ICAgIGVcbiAqL1xuXG5Db25kZW5zZWRTZXF1ZW5jZVJlbmRlcmVyLlpvb20gPSBmdW5jdGlvbihyZW5kZXJlcikge1xuXG4vKipcbiAqICBAbGVuZHMgQ29uZGVuc2VkU2VxdWVuY2VSZW5kZXJlci5wcm90b3R5cGVcbiAqICBAcHJvcGVydHkgICB7TnVtYmVyfSAgICB6b29tICAgICAgICBUaGUgem9vbSBsZXZlbCBmb3IgYSByZW5kZXJlci4gTWluaW11bSB6b29tIGxldmVsIGlzIHplcm8sIGFuZCBkZWZhdWx0cyB0byB0aGUgZGVmYXVsdCB6b29tIHZhbHVlXG4gKiAgQHByb3BlcnR5ICAge0FycmF5fSAgICAgdHJhY2tPcmRlciAgVGhlIG9yZGVyIG9mIHRyYWNrcyBvbiB0aGUgcmVuZGVyZXIsIGFuIGFycmF5IG9mIGxheWVyL2dyb3VwIG5hbWVzLlxuICogIEBwcm9wZXJ0eSAgIHtOdW1iZXJ9ICAgIHBhZGRpbmcgICAgIFBhZGRpbmcgdG8gYXBwbHkgdG8gdGhlIHJpZ2h0IGFuZCB0b3Agb2YgcGxvdHMgKGRlZmF1bHQgMTApLlxuICogIEBwcm9wZXJ0eSAgIHtOdW1iZXJ9ICAgIHRyYWNrR2FwICAgIFZlcnRpY2FsIGdhcCBiZXR3ZWVuIHRyYWNrcyAoZGVmYXVsdCAxMClcbiAqL1xuICAgIHZhciB0aW1lb3V0ID0gbnVsbDtcbiAgICB2YXIgc3RhcnRfem9vbSA9IG51bGw7XG4gICAgdmFyIHpvb21fbGV2ZWwgPSBudWxsO1xuICAgIHZhciBjZW50ZXJfcmVzaWR1ZSA9IG51bGw7XG4gICAgdmFyIHN0YXJ0X3ggPSBudWxsO1xuICAgIHZhciB0cmFuc2Zvcm1lcjtcbiAgICB2YXIgc2hpZnRlcjtcbiAgICB2YXIgYWNjZXNzb3JzID0geyBcbiAgICAgICAgc2V0Wm9vbTogZnVuY3Rpb24oem9vbUxldmVsKSB7XG4gICAgICAgICAgICB2YXIgY29udGFpbmVyX3dpZHRoID0gcmVuZGVyZXIuX2NvbnRhaW5lci5jYWNoZWRfd2lkdGg7XG4gICAgICAgICAgICBpZiAoICEgY29udGFpbmVyX3dpZHRoICkge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lcl93aWR0aCA9IHJlbmRlcmVyLl9jb250YWluZXIuY2xpZW50V2lkdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoICEgcmVuZGVyZXIuc2VxdWVuY2UgKSB7XG4gICAgICAgICAgICAgICAgem9vbV9sZXZlbCA9IHpvb21MZXZlbDtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbWluX3pvb21fbGV2ZWwgPSBjb250YWluZXJfd2lkdGggLyAoMiAqIHJlbmRlcmVyLnNlcXVlbmNlLmxlbmd0aCk7XG4gICAgICAgICAgICAvLyBpZiAgKCEgcmVuZGVyZXIuZ3Jvd19jb250YWluZXIgKSB7XG4gICAgICAgICAgICAvLyAgICAgbWluX3pvb21fbGV2ZWwgPSAwLjMgLyAyICogbWluX3pvb21fbGV2ZWw7XG4gICAgICAgICAgICAvLyB9XG5cbiAgICAgICAgICAgIC8vIHZhciBtaW5fem9vbV9sZXZlbCA9IHJlbmRlcmVyLnNlcXVlbmNlID8gKDAuMyAvIDIpICogY29udGFpbmVyX3dpZHRoIC8gcmVuZGVyZXIuc2VxdWVuY2UubGVuZ3RoIDogMC41O1xuICAgICAgICAgICAgaWYgKHpvb21MZXZlbCA8IG1pbl96b29tX2xldmVsKSB7XG4gICAgICAgICAgICAgICAgem9vbUxldmVsID0gbWluX3pvb21fbGV2ZWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoem9vbUxldmVsID4gMTApIHtcbiAgICAgICAgICAgICAgICB6b29tTGV2ZWwgPSAxMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgICAgICBpZiAoem9vbUxldmVsID09IHpvb21fbGV2ZWwpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZWZyZXNoLnN1c3BlbmRlZCAmJiBzZWxmLl9jYW52YXMgJiYgc2VsZi5fY2FudmFzLnpvb20gIT09IHBhcnNlRmxvYXQoem9vbV9sZXZlbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fY2FudmFzLnpvb20gPSBwYXJzZUZsb2F0KHpvb21fbGV2ZWwpO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLl9jYW52YXMuc2V0U2NhbGUoMSk7XG5cbiAgICAgICAgICAgICAgICAgICAgYmVhbi5maXJlKHNlbGYuX2NhbnZhcywnem9vbUNoYW5nZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgaWYgKCEgc2VsZi5fY2FudmFzKSB7XG4gICAgICAgICAgICAgICAgem9vbV9sZXZlbCA9IHpvb21MZXZlbDtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBub190b3VjaF9jZW50ZXIgPSBmYWxzZTtcblxuICAgICAgICAgICAgaWYgKHNlbGYuem9vbUNlbnRlciA9PSAnY2VudGVyJykge1xuICAgICAgICAgICAgICAgIG5vX3RvdWNoX2NlbnRlciA9IHRydWU7XG4gICAgICAgICAgICAgICAgc2VsZi56b29tQ2VudGVyID0geyd4JyA6IHNlbGYuX1JTKjAuNSooc2VsZi5sZWZ0VmlzaWJsZVJlc2lkdWUoKStzZWxmLnJpZ2h0VmlzaWJsZVJlc2lkdWUoKSkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKCBzZWxmLnpvb21DZW50ZXIgJiYgISBjZW50ZXJfcmVzaWR1ZSApIHtcbiAgICAgICAgICAgICAgICBzdGFydF94ID0gc2VsZi5fY2FudmFzLmN1cnJlbnRUcmFuc2xhdGVDYWNoZS54IHx8IDA7XG4gICAgICAgICAgICAgICAgY2VudGVyX3Jlc2lkdWUgPSBzZWxmLnpvb21DZW50ZXIgPyBzZWxmLnpvb21DZW50ZXIueCA6IDA7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNlbnRlcl9yZXNpZHVlICYmICEgc2VsZi56b29tQ2VudGVyICkge1xuICAgICAgICAgICAgICAgIC8vIFdlIHNob3VsZCBub3QgYmUgem9vbWluZyBpZiB0aGVyZSBpcyBhIGNlbnRlciByZXNpZHVlIGFuZCBubyB6b29tQ2VudGVyO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCB0aW1lb3V0ICkge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RhcnRfem9vbSA9IHBhcnNlRmxvYXQoem9vbV9sZXZlbCB8fCAxKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgem9vbV9sZXZlbCA9IHBhcnNlRmxvYXQoem9vbUxldmVsKTsgICAgICAgIFxuXG4gICAgICAgICAgICB2YXIgc2NhbGVfdmFsdWUgPSBNYXRoLmFicyhwYXJzZUZsb2F0KHpvb21MZXZlbCkvc3RhcnRfem9vbSk7XG5cbiAgICAgICAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSh0cmFuc2Zvcm1lcik7XG4gICAgICAgICAgICB0cmFuc2Zvcm1lciA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgLy8gUmVuZGVyaW5nIGJvdHRsZW5lY2tcbiAgICAgICAgICAgICAgICBzZWxmLl9jYW52YXMuc2V0U2NhbGUoc2NhbGVfdmFsdWUpO1xuXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgYmVhbi5maXJlKHNlbGYuX2NhbnZhcywnX2FuaW1fYmVnaW4nKTtcbiAgICAgICAgICAgIGlmIChkb2N1bWVudC5jcmVhdGVFdmVudCkge1xuICAgICAgICAgICAgICAgIHZhciBldk9iaiA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudHMnKTtcbiAgICAgICAgICAgICAgICBldk9iai5pbml0RXZlbnQoJ3BhbnN0YXJ0JyxmYWxzZSx0cnVlKTtcbiAgICAgICAgICAgICAgICBzZWxmLl9jYW52YXMuZGlzcGF0Y2hFdmVudChldk9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgb2xkX3ggPSBzZWxmLl9jYW52YXMuY3VycmVudFRyYW5zbGF0ZUNhY2hlLng7XG4gICAgICAgICAgICBpZiAoY2VudGVyX3Jlc2lkdWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGVsdGEgPSAoKHN0YXJ0X3pvb20gLSB6b29tX2xldmVsKS8oc2NhbGVfdmFsdWUqMjUpKSpjZW50ZXJfcmVzaWR1ZTtcbiAgICAgICAgICAgICAgICBkZWx0YSArPSBzdGFydF94LyhzY2FsZV92YWx1ZSk7XG4gICAgICAgICAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUoc2hpZnRlcik7XG4gICAgICAgICAgICAgICAgc2hpZnRlciA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUmVuZGVyaW5nIGJvdHRsZW5lY2tcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fY2FudmFzLnNldEN1cnJlbnRUcmFuc2xhdGVYWShkZWx0YSwoKHN0YXJ0X3pvb20gLSB6b29tX2xldmVsKS8oc2NhbGVfdmFsdWUpKSpzZWxmLl9heGlzX2hlaWdodCoyKTtcblxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgICAgIHZhciBlbmRfZnVuY3Rpb24gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB2YXIgc2NhbGVfdmFsdWUgPSBNYXRoLmFicyhwYXJzZUZsb2F0KHpvb21fbGV2ZWwpL3N0YXJ0X3pvb20pO1xuXG4gICAgICAgICAgICAgICAgc2VsZi5fY2FudmFzLnNldFNjYWxlKG51bGwpO1xuXG4gICAgICAgICAgICAgICAgYmVhbi5maXJlKHNlbGYuX2NhbnZhcywncGFuZW5kJyk7XG4gICAgICAgICAgICAgICAgYmVhbi5maXJlKHNlbGYuX2NhbnZhcywnX2FuaW1fZW5kJyk7XG4gICAgICAgICAgICAgICAgbGV0IHpvb21jaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgYmVhbi5yZW1vdmUoc2VsZi5fY2FudmFzLCd6b29tQ2hhbmdlJyx6b29tY2hhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5yZWZyZXNoKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY2VudGVyX3Jlc2lkdWUgIT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZWx0YSA9ICgoc3RhcnRfem9vbSAtIHpvb21fbGV2ZWwpLygyNSkpKmNlbnRlcl9yZXNpZHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsdGEgKz0gc3RhcnRfeDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fcmVzaXplQ29udGFpbmVyKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxmLl9jYW52YXMuc2hpZnRQb3NpdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX2NhbnZhcy5zaGlmdFBvc2l0aW9uKGRlbHRhLDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9jYW52YXMuc2V0Q3VycmVudFRyYW5zbGF0ZVhZKGRlbHRhLDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNlbnRlcl9yZXNpZHVlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRfeCA9IG51bGw7ICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYmVhbi5hZGQoc2VsZi5fY2FudmFzLCd6b29tQ2hhbmdlJyx6b29tY2hhbmdlKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmIChzZWxmLl9jYW52YXMpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fY2FudmFzLnpvb20gPSBwYXJzZUZsb2F0KHpvb21fbGV2ZWwpO1xuICAgICAgICAgICAgICAgICAgICBiZWFuLmZpcmUoc2VsZi5fY2FudmFzLCd6b29tQ2hhbmdlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJlYW4uZmlyZShzZWxmLCd6b29tQ2hhbmdlJyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgICAgIGlmICgoXCJvbnRvdWNoZW5kXCIgaW4gZG9jdW1lbnQpICYmIHNlbGYuem9vbUNlbnRlciAmJiAhIG5vX3RvdWNoX2NlbnRlciApIHtcbiAgICAgICAgICAgICAgICBiZWFuLnJlbW92ZShzZWxmLCdnZXN0dXJlZW5kJyk7XG4gICAgICAgICAgICAgICAgbGV0IGVuZGVyID0gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgYmVhbi5yZW1vdmUoc2VsZiwnZ2VzdHVyZWVuZCcsZW5kZXIpO1xuICAgICAgICAgICAgICAgICAgICBlbmRfZnVuY3Rpb24oKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGJlYW4uYWRkKHNlbGYsJ2dlc3R1cmVlbmQnLGVuZGVyKTtcbiAgICAgICAgICAgICAgICB0aW1lb3V0ID0gMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKCEgdGhpcy5yZWZyZXNoLnN1c3BlbmRlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aW1lb3V0ID0gc2V0VGltZW91dChlbmRfZnVuY3Rpb24sMTAwKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlbmRfZnVuY3Rpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGZpdFpvb206IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGNvbnRhaW5lcl93aWR0aCA9IHJlbmRlcmVyLl9jb250YWluZXIuY2FjaGVkX3dpZHRoO1xuICAgICAgICAgICAgaWYgKCAhIGNvbnRhaW5lcl93aWR0aCApIHtcbiAgICAgICAgICAgICAgICBjb250YWluZXJfd2lkdGggPSByZW5kZXJlci5fY29udGFpbmVyLmNsaWVudFdpZHRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG1pbl96b29tX2xldmVsID0gMC41O1xuICAgICAgICAgICAgaWYgKHJlbmRlcmVyLnNlcXVlbmNlKSB7XG4gICAgICAgICAgICAgICAgbWluX3pvb21fbGV2ZWwgPSBjb250YWluZXJfd2lkdGggLyAoMiAqIHJlbmRlcmVyLnNlcXVlbmNlLmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZW5kZXJlci56b29tID0gbWluX3pvb21fbGV2ZWw7XG4gICAgICAgIH0sXG4gICAgICAgIGdldFpvb206IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHpvb21fbGV2ZWwgfHwgMTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5ICYmICEgTUFTQ1AuSUU4KSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZW5kZXJlcixcInpvb21cIiwge1xuICAgICAgICAgICAgZ2V0IDogYWNjZXNzb3JzLmdldFpvb20sXG4gICAgICAgICAgICBzZXQgOiBhY2Nlc3NvcnMuc2V0Wm9vbVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZW5kZXJlci5maXRab29tID0gYWNjZXNzb3JzLmZpdFpvb207XG5cbn07XG5cbi8qIEFkZCBzb21lIHByb3BlcnRpZXMgdGhhdCB3aWxsIHRyaWdnZXIgYSByZWZyZXNoIG9uIHRoZSByZW5kZXJlciB3aGVuIHRoZXkgYXJlIGNoYW5nZWQuXG4gICBUaGVzZSBhcmUgYWxsIHN0YXRlbGVzc1xuICovXG5cbihmdW5jdGlvbihjbGF6eikge1xuXG4gICAgdmFyIGFjY2Vzc29ycyA9IHtcbiAgICAgICAgZ2V0UGFkZGluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcGFkZGluZyB8fCAxMDtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXRQYWRkaW5nOiBmdW5jdGlvbihwYWRkaW5nKSB7XG4gICAgICAgICAgICB0aGlzLl9wYWRkaW5nID0gcGFkZGluZztcbiAgICAgICAgICAgIHRoaXMucmVmcmVzaCgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldFRyYWNrR2FwOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICghIHRoaXMuX3RyYWNrX2dhcCl7XG4gICAgICAgICAgICAgICAgdmFyIGRlZmF1bHRfdmFsdWUgPSAoXCJvbnRvdWNoZW5kXCIgaW4gZG9jdW1lbnQpID8gMjAgOiAxMDtcbiAgICAgICAgICAgICAgICB0aGlzLl90cmFja19nYXAgPSB0aGlzLl90cmFja19nYXAgfHwgZGVmYXVsdF92YWx1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RyYWNrX2dhcDtcbiAgICAgICAgfSxcblxuICAgICAgICBzZXRUcmFja0dhcDogZnVuY3Rpb24odHJhY2tHYXApIHtcbiAgICAgICAgICAgIHRoaXMuX3RyYWNrX2dhcCA9IHRyYWNrR2FwO1xuICAgICAgICAgICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSAmJiAhIE1BU0NQLklFOCApIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNsYXp6LnByb3RvdHlwZSxcInBhZGRpbmdcIiwge1xuICAgICAgICAgICAgZ2V0IDogYWNjZXNzb3JzLmdldFBhZGRpbmcsXG4gICAgICAgICAgICBzZXQgOiBhY2Nlc3NvcnMuc2V0UGFkZGluZ1xuICAgICAgICB9KTtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNsYXp6LnByb3RvdHlwZSxcInRyYWNrR2FwXCIsIHtcbiAgICAgICAgICAgIGdldCA6IGFjY2Vzc29ycy5nZXRUcmFja0dhcCxcbiAgICAgICAgICAgIHNldCA6IGFjY2Vzc29ycy5zZXRUcmFja0dhcFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgXG59KShDb25kZW5zZWRTZXF1ZW5jZVJlbmRlcmVyKTtcblxuQ29uZGVuc2VkU2VxdWVuY2VSZW5kZXJlci5OYXZpZ2F0aW9uID0gTmF2aWdhdGlvbjtcblxuZXhwb3J0IGRlZmF1bHQgQ29uZGVuc2VkU2VxdWVuY2VSZW5kZXJlcjtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFDQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQUNBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFQQTtBQVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQUNBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXZCQTtBQXlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTkE7QUFKQTtBQWFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7OztBQVNBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTs7Ozs7Ozs7Ozs7Ozs7O0FBZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUE1SkE7QUFDQTtBQThKQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUF0QkE7QUFDQTtBQXdCQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./js/lib/CondensedSequenceRenderer.js\n");

/***/ }),

/***/ "./js/lib/CondensedSequenceRendererNavigation.js":
/*!*******************************************************!*\
  !*** ./js/lib/CondensedSequenceRendererNavigation.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _SVGCanvas__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SVGCanvas */ \"./js/lib/SVGCanvas.js\");\n/* harmony import */ var _bean__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../bean */ \"./js/bean.js\");\n/* harmony import */ var _MASCP__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./MASCP */ \"./js/lib/MASCP.js\");\n\nconst svgns = 'http://www.w3.org/2000/svg';\n\n\n\n\n\nvar touch_scale = 1,\n    touch_enabled = false;\nif (\"ontouchend\" in document) {\n    touch_scale = window.devicePixelRatio > 1 ? 2 : 1;\n    touch_enabled = true;\n}\n\nvar Navigation = function Navigation(parent_canvas, renderer) {\n    Object(_SVGCanvas__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(parent_canvas);\n\n    this.win = function () {\n        return renderer.win();\n    };\n\n    buildNavPane.call(this, parent_canvas);\n\n    var track_group = parent_canvas.group();\n\n    parent_canvas.insertBefore(track_group, parent_canvas.lastChild);\n\n    var track_canvas = document.createElementNS(svgns, 'svg');\n    buildTrackPane.call(this, track_canvas, connectRenderer.call(this, renderer));\n\n    track_group.appendChild(track_canvas);\n\n    track_group.setAttribute('clip-path', 'url(#' + this.clipping_id + ')');\n\n    this.disable = function () {\n        parent_canvas.style.display = 'none';\n        track_canvas.style.display = 'none';\n    };\n\n    this.enable = function () {\n        parent_canvas.style.display = 'block';\n        track_canvas.style.display = 'block';\n    };\n\n    this.demote = function () {\n        track_canvas.hide();\n        return;\n    };\n\n    this.promote = function () {\n        if (this.visible()) {\n            track_canvas.show();\n        } else {\n            track_canvas.hide();\n        }\n    };\n\n    this.setDimensions = function (width, height) {\n        parent_canvas.setAttribute('width', width);\n        parent_canvas.setAttribute('height', height);\n    };\n};\n\nvar connectRenderer = function connectRenderer(renderer) {\n\n    /**\n     * Create a layer based controller for a group. Clicking on the nominated layer will animate out the expansion of the\n     * group.\n     * @param {Object} lay Layer to turn into a group controller\n     * @param {Object} grp Group to be controlled by this layer.\n     */\n\n    var controller_map = {};\n    var expanded_map = {};\n\n    var old_remove_track = renderer.removeTrack;\n\n    renderer.removeTrack = function (layer) {\n        old_remove_track.call(this, layer);\n        delete controller_map[layer.name];\n        delete expanded_map[layer.name];\n    };\n\n    this.isController = function (layer) {\n        if (controller_map[layer.name]) {\n            return true;\n        } else {\n            return false;\n        }\n    };\n\n    this.getController = function (group) {\n        for (var lay in controller_map) {\n            if (controller_map.hasOwnProperty(lay) && controller_map[lay] == group) {\n                return _MASCP__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getLayer(lay);\n            }\n        }\n        return null;\n    };\n\n    this.isControllerExpanded = function (layer) {\n        return expanded_map[layer.name];\n    };\n\n    renderer.createGroupController = function (lay, grp) {\n        var layer = _MASCP__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getLayer(lay);\n        var group = _MASCP__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getGroup(grp);\n\n        if (!layer || !group) {\n            return;\n        }\n\n        if (controller_map[layer.name]) {\n            return;\n        }\n\n        controller_map[layer.name] = group;\n\n        expanded_map[layer.name] = false;\n\n        var self = this;\n\n        _bean__WEBPACK_IMPORTED_MODULE_1__[\"default\"].add(layer, 'removed', function (ev, rend) {\n            self.setGroupVisibility(group);\n        });\n\n        _bean__WEBPACK_IMPORTED_MODULE_1__[\"default\"].add(layer, 'visibilityChange', function (rend, visible) {\n            if (group.size() > 0) {\n                if (!expanded_map.hasOwnProperty(layer.name)) {\n                    expanded_map[layer.name] = false;\n                }\n                self.setGroupVisibility(group, expanded_map[layer.name] && visible, true);\n                renderer.refresh();\n            }\n        });\n        _bean__WEBPACK_IMPORTED_MODULE_1__[\"default\"].add(group, 'visibilityChange', function (rend, visible) {\n            if (visible) {\n                self.showLayer(layer, true);\n                expanded_map[layer.name] = true;\n            }\n        });\n        _bean__WEBPACK_IMPORTED_MODULE_1__[\"default\"].remove(layer, '_expandevent');\n        _bean__WEBPACK_IMPORTED_MODULE_1__[\"default\"].add(layer, '_expandevent', function (ev) {\n            expanded_map[layer.name] = !expanded_map[layer.name];\n            self.withoutRefresh(function () {\n                self.setGroupVisibility(group, expanded_map[layer.name]);\n            });\n            self.refresh(true);\n        });\n    };\n\n    return DragAndDrop(function (track, before, after) {\n        var t_order = renderer.trackOrder;\n\n        t_order.trackIndex = function (tr) {\n            if (!tr) {\n                return this.length;\n            }\n            return this.indexOf(tr.name);\n        };\n\n        if (after && !before) {\n            before = _MASCP__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getLayer(t_order[t_order.trackIndex(after) + 1]);\n        }\n\n        t_order.splice(t_order.trackIndex(track), 1);\n        var extra_to_push = [];\n        if (controller_map[track.name]) {\n            let layer_func = function layer_func(lay) {\n                if (_MASCP__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getGroup(lay) === lay) {\n                    _MASCP__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getGroup(lay).eachLayer(layer_func);\n                }\n                if (t_order.trackIndex(lay) >= 0) {\n                    extra_to_push = [t_order.splice(t_order.trackIndex(lay), 1)[0]].concat(extra_to_push);\n                }\n            };\n            _MASCP__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getGroup(controller_map[track.name]).eachLayer(layer_func);\n        }\n        if (before) {\n            t_order.splice(t_order.trackIndex(before), 1, track.name, before ? before.name : undefined);\n            for (var i = 0; i < extra_to_push.length; i++) {\n                if (extra_to_push[i]) {\n                    t_order.splice(t_order.trackIndex(before), 0, extra_to_push[i]);\n                }\n            }\n        } else {\n            renderer.hideLayer(track);\n            _MASCP__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getLayer(track).disabled = true;\n\n            extra_to_push.forEach(function (lay) {\n\n                renderer.hideLayer(lay);\n                _MASCP__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getLayer(lay).disabled = true;\n            });\n            t_order.push(track.name);\n            t_order = t_order.concat(extra_to_push);\n        }\n\n        renderer.trackOrder = t_order;\n    });\n};\n\nvar DragAndDrop = function DragAndDrop(spliceFunction) {\n    var targets = [];\n    var in_drag = false,\n        drag_el;\n\n    var splice_before, splice_after, trackToSplice;\n\n    var last_target;\n\n    var timeouts = {};\n\n    var nav_reset_set = null;\n\n    let spliceBefore;\n    let spliceAfter;\n\n    var drag_func = function drag_func(handle, element, track, canvas) {\n        var nav = this;\n\n        var old_reset = nav.reset;\n        if (nav_reset_set === null) {\n            nav.reset = function () {\n                targets = [];\n                old_reset.call(this);\n            };\n            nav_reset_set = true;\n        }\n        var resetDrag = function resetDrag() {\n            window.clearTimeout(timeouts.anim);\n            window.clearTimeout(timeouts.hover);\n            for (var i = 0; i < targets.length; i++) {\n                if (targets[i] != drag_el) {\n                    targets[i].removeAttribute('dragging');\n                    targets[i].removeAttribute('transform');\n                    targets[i].setAttribute('pointer-events', 'all');\n                }\n            }\n        };\n\n        targets.push(element);\n        element.track = track;\n\n        var single_touch_event = function single_touch_event(fn) {\n            return function (e) {\n                if (e.touches && e.touches.length == 1) {\n                    fn.call(this, e);\n                }\n            };\n        };\n\n        var beginDragging = function beginDragging(ev, tr, lbl_grp) {\n\n            if (drag_disabled()) {\n                return;\n            }\n\n            var target = canvas.nearestViewportElement;\n\n            if (in_drag) {\n                return;\n            }\n            lbl_grp.setAttribute('dragging', 'true');\n\n            spliceBefore = null;\n            spliceAfter = null;\n\n            var p_orig = lbl_grp.nearestViewportElement.createSVGPoint();\n\n            p_orig.x = ev.clientX || window.pageXOffset + ev.touches[0].clientX;\n            p_orig.y = ev.clientY || window.pageYOffset + ev.touches[0].clientY;\n\n            var rootCTM = lbl_grp.nearestViewportElement.getScreenCTM();\n            var matrix = rootCTM.inverse();\n\n            p_orig = p_orig.matrixTransform(matrix);\n\n            var oX = p_orig.x;\n            var oY = p_orig.y;\n\n            var dragfn = function dragfn(e) {\n                var p = lbl_grp.nearestViewportElement.createSVGPoint();\n                p.x = e.clientX || window.pageXOffset + e.touches[0].clientX;\n                p.y = e.clientY || window.pageYOffset + e.touches[0].clientY;\n                p = p.matrixTransform(matrix);\n\n                var dX = p.x - oX;\n                var dY = p.y - oY;\n                var curr_transform = lbl_grp.getAttribute('transform') || '';\n                curr_transform = curr_transform.replace(/\\s?translate\\([^\\)]+\\)/, '');\n                curr_transform += ' translate(' + dX + ',' + dY + ') ';\n                curr_transform = curr_transform.replace(/\\s*$/, '');\n                lbl_grp.setAttribute('transform', curr_transform);\n                targets.forEach(function (targ) {\n                    var bb = targ.getBBox();\n                    if (bb.y < p.y && bb.y > p.y - bb.height && bb.x < p.x && bb.x > p.x - bb.width) {\n                        el_move.call(targ, e, targ.track);\n                    }\n                });\n                e.stopPropagation();\n                e.preventDefault();\n                return false;\n            };\n            if (touch_enabled) {\n                dragfn = single_touch_event(dragfn);\n            }\n\n            var enddrag = function enddrag(e) {\n                if (e.relatedTarget && (e.relatedTarget == lbl_grp || e.relatedTarget.nearestViewportElement == lbl_grp.nearestViewportElement || e.relatedTarget.nearestViewportElement == target)) {\n                    if (in_drag && targets.indexOf(e.relatedTarget) >= 0) {\n                        resetDrag();\n                    }\n                    return;\n                }\n\n                if (in_drag && (e.type == 'mouseup' || e.type == 'touchend')) {\n                    if (spliceBefore || spliceAfter) {\n                        spliceFunction(trackToSplice, spliceBefore, spliceAfter);\n                    }\n                }\n                target.removeEventListener('touchmove', dragfn, false);\n                target.removeEventListener('mousemove', dragfn, false);\n                target.removeEventListener('touchend', enddrag, false);\n                target.removeEventListener('mouseup', enddrag, false);\n                target.removeEventListener('mouseout', enddrag, false);\n                if (in_drag) {\n                    lbl_grp.setAttributeNS(null, 'pointer-events', 'all');\n                    lbl_grp.removeAttribute('transform');\n                    resetDrag();\n                    in_drag = false;\n                    last_target = null;\n                }\n            };\n            lbl_grp.setAttributeNS(null, 'pointer-events', 'none');\n            lbl_grp.addEventListener('touchmove', dragfn, false);\n            lbl_grp.addEventListener('touchend', enddrag, false);\n            target.addEventListener('mousemove', dragfn, false);\n            target.addEventListener('mouseup', enddrag, false);\n            target.addEventListener('mouseout', enddrag, false);\n\n            in_drag = track;\n            drag_el = lbl_grp;\n        };\n\n        var handle_start = function handle_start(e) {\n            beginDragging(e, track, element);\n        };\n\n        var el_move = function el_move(e, trk) {\n            var trck = trk ? trk : track;\n            var elem = this ? this : element;\n\n            if (in_drag && in_drag != trck && trck != last_target) {\n                last_target = trck;\n                if (timeouts.hover) {\n                    window.clearTimeout(timeouts.hover);\n                }\n                timeouts.hover = window.setTimeout(function () {\n                    if ((in_drag.group || trck.group) && (in_drag.group ? trck.group : !trck.group)) {\n                        if (in_drag.group.name != trck.group.name) {\n                            return;\n                        }\n                    } else {\n                        if (in_drag.group || trck.group) {\n                            return;\n                        }\n                    }\n\n                    if (timeouts.anim) {\n                        window.clearInterval(timeouts.anim);\n                        timeouts.anim = null;\n                    }\n\n                    resetDrag();\n\n                    var current_sibling = elem;\n\n                    var elements_to_shift = [];\n\n                    while (current_sibling !== null) {\n                        if (current_sibling != drag_el && targets.indexOf(current_sibling) >= 0) {\n                            elements_to_shift.push(current_sibling);\n                        }\n                        current_sibling = current_sibling.nextSibling;\n                        if (current_sibling == drag_el) {\n                            break;\n                        }\n                    }\n\n                    current_sibling = elem.previousSibling;\n\n                    var elements_to_shift_up = [];\n\n                    while (current_sibling !== null) {\n                        if (current_sibling != drag_el && targets.indexOf(current_sibling) >= 0) {\n                            elements_to_shift_up.push(current_sibling);\n                        }\n                        current_sibling = current_sibling.previousSibling;\n                        if (current_sibling == drag_el) {\n                            break;\n                        }\n                    }\n                    var anim_steps = 1;\n                    var height = drag_el.getBBox().height / 4;\n                    timeouts.anim = window.setInterval(function () {\n                        var curr_transform,\n                            i = 0;\n\n                        if (anim_steps < 5) {\n                            for (i = 0; i < elements_to_shift.length; i++) {\n                                curr_transform = elements_to_shift[i].getAttribute('transform') || '';\n                                curr_transform = curr_transform.replace(/\\s?translate\\([^\\)]+\\)/, '');\n                                curr_transform += ' translate(0,' + anim_steps * height + ')';\n                                elements_to_shift[i].setAttribute('transform', curr_transform);\n                            }\n\n                            for (i = 0; elements_to_shift.length > 0 && i < elements_to_shift_up.length; i++) {\n\n                                curr_transform = elements_to_shift_up[i].getAttribute('transform') || '';\n                                curr_transform = curr_transform.replace(/\\s?translate\\([^\\)]+\\)/, '');\n                                curr_transform += ' translate(0,' + anim_steps * -1 * height + ')';\n                                elements_to_shift_up[i].setAttribute('transform', curr_transform);\n                            }\n\n                            anim_steps += 1;\n                        } else {\n                            spliceBefore = trck;\n                            trackToSplice = in_drag;\n                            window.clearInterval(timeouts.anim);\n                            timeouts.anim = null;\n                        }\n                    }, 30);\n                }, 300);\n            }\n        };\n\n        handle.addEventListener('mousedown', handle_start, false);\n        handle.addEventListener('touchstart', single_touch_event(handle_start), false);\n    };\n\n    var drag_disabled = function drag_disabled() {\n        return drag_func.disabled;\n    };\n\n    drag_func.spliceFunction = spliceFunction;\n\n    return drag_func;\n};\n\nvar setElementTransform = function setElementTransform(el, transform) {\n    var ua = window.navigator.userAgent;\n    if (ua.indexOf('Edge/') >= 0) {\n        transform = transform.replace(/px/g, '');\n        el.setAttribute('transform', transform);\n    } else {\n        el.style.transform = transform;\n    }\n};\n\nvar buildNavPane = function buildNavPane(back_canvas) {\n    var self = this;\n    self.zoom = 1;\n    self.nav_width_base = 200;\n    var nav_width = self.nav_width_base;\n    self.nav_width = self.nav_width_base;\n    var panel_back = back_canvas.group();\n    var button_group = back_canvas.group();\n\n    var rect = back_canvas.rect(-10, 0, nav_width.toString(), '100%');\n    var base_rounded_corner = [12 * touch_scale, 10 * touch_scale];\n    rect.setAttribute('rx', base_rounded_corner[0].toString());\n    rect.setAttribute('ry', base_rounded_corner[1].toString());\n    if (!touch_enabled) {\n        rect.setAttribute('opacity', '0.8');\n    }\n    rect.style.stroke = '#000000';\n    rect.style.strokeWidth = '2px';\n    rect.style.fill = '#000000';\n    rect.id = 'nav_back';\n\n    panel_back.push(rect);\n\n    self.clipping_id = 'nav_clipping' + new Date().getTime();\n    var clipping = document.createElementNS(svgns, 'clipPath');\n    clipping.id = self.clipping_id;\n    var rect2 = rect.cloneNode();\n    rect2.removeAttribute('id');\n    rect2.removeAttribute('opacity');\n    rect2.setAttribute('x', '0');\n    rect2.setAttribute('width', \"\" + (parseInt(rect2.getAttribute('width')) - 10));\n    rect2.removeAttribute('style');\n    rect2.setAttribute('height', '10000');\n\n    back_canvas.insertBefore(clipping, back_canvas.firstChild);\n    clipping.appendChild(rect2);\n\n    var close_group = back_canvas.crossed_circle(nav_width - (10 + touch_scale * 11), 12 * touch_scale, 10 * touch_scale);\n\n    close_group.style.cursor = 'pointer';\n    if (typeof matchMedia !== 'undefined') {\n        (this.win() || window).matchMedia('print').addListener(function (match) {\n            if (match.matches) {\n                close_group.setAttribute('display', 'none');\n                tracks_button.setAttribute('display', 'none');\n            } else {\n                close_group.setAttribute('display', 'block');\n                tracks_button.setAttribute('display', 'none');\n            }\n        });\n    }\n\n    button_group.push(close_group);\n\n    var tracks_button = _MASCP__WEBPACK_IMPORTED_MODULE_2__[\"default\"].IE ? back_canvas.svgbutton(10, 5, 65, 25, 'Edit') : back_canvas.button(10, 5, 65, 25, 'Edit');\n    tracks_button.id = 'controls';\n    tracks_button.parentNode.setAttribute('clip-path', 'url(#' + self.clipping_id + ')');\n\n    panel_back.push(_MASCP__WEBPACK_IMPORTED_MODULE_2__[\"default\"].IE ? tracks_button : tracks_button.parentNode);\n\n    tracks_button.addEventListener('click', function () {\n        _bean__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fire(self, 'toggleEdit');\n        _bean__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fire(self, 'click');\n    }, false);\n\n    panel_back.setAttribute('style', 'transition: all 0.25s;');\n\n    var old_tracks_style = tracks_button.getAttribute('style');\n    var transform_origin = \"\" + (nav_width - (10 + touch_scale * 11)) + \"px \" + 12 * touch_scale + \"px\";\n    var translate = function translate(amount, rotate) {\n        var trans = \" translate3d(\" + amount + \"px,0px,0px)\";\n        if (rotate) {\n            trans = trans + \" rotate(\" + rotate + \")\";\n        }\n        return \"-webkit-transform:\" + trans + \"; -moz-transform:\" + trans + \"; -ms-transform:\" + trans.replace('3d', '').replace(',0px)', ')') + \"; transform: \" + trans + \";\";\n    };\n\n    tracks_button.setAttribute('style', old_tracks_style + \" transition: all 0.25s;\");\n    close_group.style.transition = 'all 0.25s';\n    close_group.style.transformOrigin = transform_origin;\n    var visible = true;\n\n    var toggler = function toggler(vis, interactive) {\n        visible = vis === false || vis === true ? vis : !visible;\n        var close_transform;\n        var needs_transition = interactive ? \"all ease-in-out 0.4s\" : \"\";\n        let parent_transform = back_canvas.parentNode.style.transform;\n        let scaleval;\n        let yscale = touch_scale;\n        if (scaleval = parent_transform.match(/scale\\(([\\d\\.]+)\\)/)) {\n            yscale = 1;\n        }\n        var transform_origin = \"\" + (self.nav_width_base - (10 + touch_scale * 11)) + \"px \" + 12 * yscale + \"px\";\n\n        if (visible) {\n            self.promote();\n            setElementTransform(panel_back, 'translate(0,0)');\n            panel_back.style.transition = needs_transition;\n\n            close_group._button.removeAttribute('filter');\n            if (\"ontouchend\" in window || window.getComputedStyle(close_group).getPropertyValue(\"-ms-transform\")) {\n                setElementTransform(close_group, '');\n            }\n            setElementTransform(close_group, 'translate(0,0)');\n            close_group.style.transition = needs_transition;\n            close_group.style.transformOrigin = close_group.getBoundingClientRect().left + 'px ' + close_group.getBoundingClientRect().top + ' px';\n            self.refresh();\n        } else {\n            self.demote();\n            // Chrome bug Jan 2015 with the drop shadow\n            //close_group._button.setAttribute('filter','url(#drop_shadow)');\n            close_group.style.transition = needs_transition;\n            close_group.style.transition = needs_transition;\n            // close_group.style.transformOrigin = transform_origin;\n            close_group.style.transformOrigin = close_group.getBoundingClientRect().left + 'px ' + close_group.getBoundingClientRect().top + ' px';\n\n            setElementTransform(close_group, 'translate(' + -0.75 * self.nav_width_base + 'px,0) rotate(405deg)');\n            if (\"ontouchend\" in window) {\n                // No longer special casing IE\n                setElementTransform(close_group, 'translate(' + -0.75 * self.nav_width_base + 'px,0) rotate(45,' + (self.nav_width_base - (10 + touch_scale * 11)) + 'px,' + 12 * touch_scale + 'px)');\n                setElementTransform(panel_back, 'translate(' + -1 * self.nav_width * self.zoom + 'px,0)');\n                panel_back.style.transition = needs_transition;\n            } else {\n                setElementTransform(panel_back, 'translate(' + -1 * self.nav_width * self.zoom + 'px,0)');\n                panel_back.style.transition = needs_transition;\n            }\n        }\n        return true;\n    };\n\n    self.move_closer = function () {\n        if (visible) {\n            return;\n        }\n        setElementTransform(close_group, 'translate(' + -0.75 * self.nav_width_base + 'px,0) rotate(405deg)');\n        if (\"ontouchend\" in window) {\n            // No longer special casing IE\n            setElementTransform(close_group, 'translate(' + -0.75 * self.nav_width_base + 'px,0) rotate(45,' + (self.nav_width_base - (10 + touch_scale * 11)) + 'px,' + 12 * touch_scale + 'px)');\n        }\n    };\n\n    self.hide = function (interactive) {\n        toggler.call(this, false, interactive);\n    };\n    self.show = function (interactive) {\n        toggler.call(this, true, interactive);\n    };\n\n    self.visible = function () {\n        return visible;\n    };\n\n    self.setZoom = function (zoom) {\n        self.nav_width = self.nav_width_base / zoom;\n        close_group.setAttribute('transform', 'scale(' + zoom + ',' + zoom + ') ');\n        let parent_transform = back_canvas.parentNode.style.transform;\n        let scaleval;\n        let yscale = touch_scale;\n        if (scaleval = parent_transform.match(/scale\\(([\\d\\.]+)\\)/)) {\n            yscale = 1;\n        }\n        var transform_origin = \"\" + (self.nav_width_base - (10 + touch_scale * 11)).toFixed(2) + \"px \" + 12 * yscale + \"px\";\n\n        close_group.style.transformOrigin = transform_origin;\n\n        close_group.move(self.nav_width_base - (10 + touch_scale * 11), 12 * touch_scale);\n        rect.setAttribute('transform', 'scale(' + zoom + ',1) ');\n        rect.setAttribute('ry', base_rounded_corner[1].toString());\n        rect.setAttribute('rx', (base_rounded_corner[0] / zoom).toString());\n        rect.setAttribute('x', parseInt(-10 / zoom).toString());\n        rect.setAttribute('width', self.nav_width.toString());\n        self.zoom = zoom;\n        toggler.call(this, visible);\n        self.refresh();\n    };\n\n    close_group.addEventListener('click', function () {\n        if (visible) {\n            self.hide(true);\n        } else {\n            self.show(true);\n        }\n    }, false);\n};\n\nvar buildTrackPane = function buildTrackPane(track_canvas, draganddrop) {\n    var self = this;\n\n    var close_buttons, controller_buttons, edit_enabled;\n\n    var nav_width_track_canvas_ctm = 0;\n\n    Object(_SVGCanvas__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(track_canvas);\n    track_canvas.setAttribute('preserveAspectRatio', 'xMinYMin meet');\n\n    var track_rects = [];\n\n    self.reset = function () {\n        while (track_canvas.firstChild) {\n            track_canvas.removeChild(track_canvas.firstChild);\n        }\n        track_rects = [];\n        ctm_refresh = [];\n        //            self.refresh();\n    };\n\n    var ctm_refresh = [];\n\n    self.isEditing = function () {\n        return edit_enabled;\n    };\n\n    self.refresh = function () {\n        (close_buttons || []).forEach(function (button) {\n            button.setAttribute('visibility', edit_enabled ? 'visible' : 'hidden');\n        });\n        (controller_buttons || []).forEach(function (button) {\n            button.setAttribute('visibility', edit_enabled ? 'hidden' : 'visible');\n        });\n        if (edit_enabled) {\n            toggleMouseEvents.call(this, true);\n        } else {\n            toggleMouseEvents.call(this, false);\n        }\n\n        if (track_canvas.getAttribute('display') == 'none' || track_canvas.style.display == 'none') {\n            return;\n        }\n        if (ctm_refresh.length < 1) {\n            return;\n        }\n        var nav_back = track_canvas.ownerSVGElement.getElementById('nav_back');\n\n        var ctm = nav_back.getScreenCTM().inverse().multiply(track_canvas.getScreenCTM()).inverse();\n        var back_width = nav_back.getBBox().width + nav_back.getBBox().x;\n        var point = track_canvas.createSVGPoint();\n        point.x = back_width;\n        point.y = 0;\n        nav_width_track_canvas_ctm = point.matrixTransform(ctm).x;\n        ctm_refresh.forEach(function (el) {\n            var width = 0;\n            try {\n                width = el.getBBox().width;\n            } catch (err) {\n                // This is a bug with Firefox on some elements getting\n                // the bounding box. We silently fail here, as I can't\n                // figure out why the call to getBBox fails.\n            }\n            if (width > 0) {\n                var a_y = /translate\\((-?\\d+\\.?\\d*)\\s*,?\\s*(-?\\d+\\.?\\d*)\\)/.exec(el.getAttribute('transform') || '');\n                if (typeof a_y != 'undefined') {\n                    a_y = a_y[2];\n                } else {\n                    return;\n                }\n\n                var new_x = nav_width_track_canvas_ctm - 1.5 * parseInt(el.getAttribute('width'), 10);\n                el.setAttribute('transform', 'translate(' + new_x + ',' + a_y + ')');\n            }\n        });\n    };\n\n    var toggleMouseEvents = function toggleMouseEvents(on) {\n        if (track_rects) {\n            (track_rects || []).forEach(function (el) {\n                el.setAttribute('opacity', on ? '1' : touch_enabled ? \"0.5\" : \"0.1\");\n                el.setAttribute('pointer-events', on ? 'all' : 'none');\n                on ? el.parentNode.setAttribute('dragenabled', 'true') : el.parentNode.removeAttribute('dragenabled');\n            });\n        }\n    };\n\n    _bean__WEBPACK_IMPORTED_MODULE_1__[\"default\"].add(self, 'toggleEdit', function () {\n        edit_enabled = typeof edit_enabled == 'undefined' ? true : !edit_enabled;\n        draganddrop.disabled = !edit_enabled;\n        toggleMouseEvents.call(self, edit_enabled);\n\n        self.hide();\n        self.show();\n\n        (close_buttons || []).forEach(function (button) {\n            button.setAttribute('visibility', edit_enabled ? 'visible' : 'hidden');\n        });\n        (controller_buttons || []).forEach(function (button) {\n            button.setAttribute('visibility', edit_enabled ? 'hidden' : 'visible');\n        });\n    });\n\n    this.setViewBox = function (viewBox) {\n        track_canvas.setAttribute('viewBox', viewBox);\n    };\n\n    track_canvas.style.height = '100%';\n    track_canvas.style.width = '100%';\n    track_canvas.setAttribute('height', '100%');\n    track_canvas.setAttribute('width', '100%');\n\n    this.renderTrack = function (track, y, height, options) {\n        var label_group = track_canvas.group();\n        var a_rect = track_canvas.rect(0, y, '100%', height);\n        a_rect.setAttribute('stroke', '#000000');\n        a_rect.setAttribute('stroke-width', '2');\n        a_rect.setAttribute('fill', 'url(#simple_gradient)');\n        a_rect.setAttribute('opacity', touch_enabled ? '0.5' : '0.1');\n        a_rect.setAttribute('pointer-events', 'none');\n        track_rects = track_rects || [];\n\n        track_rects.push(a_rect);\n\n        label_group.push(a_rect);\n\n        // Use these for debugging positioning\n\n        // var r = track_canvas.rect(0,y-height,height,height);\n        // r.setAttribute('fill','#ff0000');\n        // label_group.push(r);\n        // \n        // r = track_canvas.rect(0,y+height,height,height);\n        // r.setAttribute('fill','#ff0000');\n        // label_group.push(r);\n\n\n        var text_scale = options && options['font-scale'] ? options['font-scale'] : 1;\n        var text_left = 4 / 3 * touch_scale * height * text_scale;\n        var a_text = track_canvas.text(text_left, y + 0.5 * height, track.fullname || track.name);\n        a_text.setAttribute('height', height);\n        a_text.setAttribute('width', height);\n        a_text.setAttribute('font-size', 0.6 * height * text_scale);\n        a_text.setAttribute('fill', '#ffffff');\n        a_text.setAttribute('stroke', '#ffffff');\n        a_text.setAttribute('stroke-width', '0');\n        a_text.firstChild.setAttribute('dy', '0.5ex');\n\n        // r = track_canvas.rect(3*height*text_scale,y+0.5*height,2*height,2*height);\n        // r.setAttribute('fill','#00ff00');\n        // label_group.push(r);\n\n        label_group.push(a_text);\n\n        a_text.setAttribute('pointer-events', 'none');\n\n        var circ;\n\n        if (track.href) {\n            a_anchor = track_canvas.a(track.href);\n            var icon_name = null;\n            var icon_metrics = [0.5 * height * text_scale, 0, height * text_scale * touch_scale];\n            icon_metrics[1] = -0.5 * (icon_metrics[2] - height);\n\n            circ = track_canvas.circle(icon_metrics[0] + 0.5 * icon_metrics[2], 0.5 * height, 0.5 * icon_metrics[2]);\n            circ.setAttribute('fill', '#ffffff');\n            circ.setAttribute('opacity', '0.1');\n            a_anchor.appendChild(circ);\n\n            var url_type = track.href;\n            if (typeof url_type === 'string' && url_type.match(/^javascript\\:/)) {\n                icon_name = '#plus_icon';\n            } else if (typeof url_type === 'function') {\n                icon_name = '#plus_icon';\n                a_anchor.setAttribute('href', '#');\n                a_anchor.removeAttribute('target');\n                a_anchor.addEventListener('click', function (e) {\n                    url_type.call();\n\n                    if (e.preventDefault) {\n                        e.preventDefault();\n                    } else {\n                        e.returnResult = false;\n                    }\n                    if (e.stopPropagation) {\n                        e.stopPropagation();\n                    } else {\n                        e.cancelBubble = true;\n                    }\n\n                    return false;\n                }, false);\n            } else {\n                icon_name = '#new_link_icon';\n            }\n            if (track.icon) {\n                icon_name = track.icon;\n            }\n            var a_use = track_canvas.use(icon_name, icon_metrics[0], icon_metrics[1], icon_metrics[2], icon_metrics[2]);\n            a_use.style.cursor = 'pointer';\n            a_anchor.appendChild(a_use);\n            a_anchor.setAttribute('transform', 'translate(' + (nav_width_track_canvas_ctm - 1.5 * icon_metrics[2]) + ',' + y + ')');\n            a_anchor.setAttribute('width', icon_metrics[2].toString());\n            ctm_refresh.push(a_anchor);\n        }\n\n        label_group.addEventListener('touchstart', function () {\n            label_group.onmouseover = undefined;\n            label_group.onmouseout = undefined;\n        }, false);\n\n        label_group.addEventListener('touchend', function () {\n            label_group.onmouseover = undefined;\n            label_group.onmouseout = undefined;\n        }, false);\n\n        draganddrop.call(this, a_rect, label_group, track, track_canvas);\n\n        (function () {\n\n            if (track.group) {\n                return;\n            }\n\n            var t_height = 0.5 * height * touch_scale;\n\n            if (!close_buttons) {\n                close_buttons = [];\n            }\n\n            var closer = track_canvas.crossed_circle(1.5 * t_height, 0, t_height);\n            closer.setAttribute('transform', 'translate(0,' + (y + 0.5 * height) + ') scale(' + text_scale + ')');\n            closer.firstChild.setAttribute('fill', 'url(#red_3d)');\n            for (var nodes = closer.childNodes, i = 0, len = nodes.length; i < len; i++) {\n                nodes[i].setAttribute('stroke-width', (t_height / 4).toString());\n            }\n            closer.addEventListener('click', function () {\n                draganddrop.spliceFunction(track);\n            }, false);\n            label_group.push(closer);\n            close_buttons.push(closer);\n            closer.setAttribute('visibility', 'hidden');\n        })();\n        if (this.isController(track)) {\n            if (!controller_buttons) {\n                controller_buttons = [];\n            }\n\n            var t_height = 0.5 * height * touch_scale;\n            var expander = track_canvas.group();\n            circ = track_canvas.circle(1.5 * t_height, 0, t_height);\n            circ.setAttribute('fill', '#ffffff');\n            circ.setAttribute('opacity', '0.1');\n            expander.push(circ);\n\n            var t_metrics = [1.1 * t_height, -1.25 * t_height, 2.25 * t_height, -0.5 * t_height, 1.1 * t_height, 0.25 * t_height];\n\n            t_metrics[1] += 0.5 * (t_height - 0 * height);\n            t_metrics[3] += 0.5 * (t_height - 0 * height);\n            t_metrics[5] += 0.5 * (t_height - 0 * height);\n\n            var group_toggler = track_canvas.poly('' + t_metrics[0] + ',' + t_metrics[1] + ' ' + t_metrics[2] + ',' + t_metrics[3] + ' ' + t_metrics[4] + ',' + t_metrics[5]);\n            if (this.isControllerExpanded(track)) {\n                expander.setAttribute('transform', 'translate(0,' + (y + 0.5 * height) + ') scale(' + text_scale + ') rotate(90,' + 1.5 * t_height + ',' + t_metrics[3] + ')');\n            } else {\n                expander.setAttribute('transform', 'translate(0,' + (y + 0.5 * height) + ') scale(' + text_scale + ')');\n            }\n            group_toggler.setAttribute('height', 1.75 * t_height);\n            group_toggler.setAttribute('font-size', 1.5 * t_height);\n            group_toggler.setAttribute('fill', '#ffffff');\n            group_toggler.setAttribute('pointer-events', 'none');\n\n            expander.push(group_toggler);\n\n            expander.style.cursor = 'pointer';\n            expander.addEventListener('click', function (e) {\n                e.stopPropagation();\n                _bean__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fire(track, '_expandevent');\n                if (self.isControllerExpanded(track)) {\n                    expander.setAttribute('transform', 'translate(0,' + (y + 0.5 * height) + ') scale(' + text_scale + ') rotate(90,' + 1.5 * t_height + ',' + t_metrics[3] + ')');\n                } else {\n                    expander.setAttribute('transform', 'translate(0,' + (y + 0.5 * height) + ') scale(' + text_scale + ')');\n                }\n            }, false);\n            label_group.push(expander);\n\n            controller_buttons.push(expander);\n            expander.setAttribute('visibility', 'hidden');\n        }\n    };\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Navigation);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9qcy9saWIvQ29uZGVuc2VkU2VxdWVuY2VSZW5kZXJlck5hdmlnYXRpb24uanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vanMvbGliL0NvbmRlbnNlZFNlcXVlbmNlUmVuZGVyZXJOYXZpZ2F0aW9uLmpzP2IxZTMiXSwic291cmNlc0NvbnRlbnQiOlsiXG5jb25zdCBzdmducyA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zyc7XG5cbmltcG9ydCBTVkdDYW52YXMgZnJvbSAnLi9TVkdDYW52YXMnO1xuaW1wb3J0IGJlYW4gZnJvbSAnLi4vYmVhbic7XG5pbXBvcnQgTUFTQ1AgZnJvbSAnLi9NQVNDUCc7XG5cbnZhciB0b3VjaF9zY2FsZSA9IDEsIHRvdWNoX2VuYWJsZWQgPSBmYWxzZTtcbmlmIChcIm9udG91Y2hlbmRcIiBpbiBkb2N1bWVudCkge1xuICAgIHRvdWNoX3NjYWxlID0gd2luZG93LmRldmljZVBpeGVsUmF0aW8gPiAxID8gMiA6IDE7XG4gICAgdG91Y2hfZW5hYmxlZCA9IHRydWU7XG59XG5cbnZhciBOYXZpZ2F0aW9uID0gZnVuY3Rpb24ocGFyZW50X2NhbnZhcyxyZW5kZXJlcikge1xuICAgIFNWR0NhbnZhcyhwYXJlbnRfY2FudmFzKTtcblxuICAgIHRoaXMud2luID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiByZW5kZXJlci53aW4oKTtcbiAgICB9O1xuXG4gICAgYnVpbGROYXZQYW5lLmNhbGwodGhpcyxwYXJlbnRfY2FudmFzKTtcblxuICAgIHZhciB0cmFja19ncm91cCA9IHBhcmVudF9jYW52YXMuZ3JvdXAoKTtcblxuICAgIHBhcmVudF9jYW52YXMuaW5zZXJ0QmVmb3JlKHRyYWNrX2dyb3VwLHBhcmVudF9jYW52YXMubGFzdENoaWxkKTtcblxuICAgIHZhciB0cmFja19jYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoc3ZnbnMsJ3N2ZycpOyAgICBcbiAgICBidWlsZFRyYWNrUGFuZS5jYWxsKHRoaXMsdHJhY2tfY2FudmFzLGNvbm5lY3RSZW5kZXJlci5jYWxsKHRoaXMscmVuZGVyZXIpKTtcblxuICAgIHRyYWNrX2dyb3VwLmFwcGVuZENoaWxkKHRyYWNrX2NhbnZhcyk7XG5cbiAgICB0cmFja19ncm91cC5zZXRBdHRyaWJ1dGUoJ2NsaXAtcGF0aCcsJ3VybCgjJyt0aGlzLmNsaXBwaW5nX2lkKycpJyk7XG5cbiAgICB0aGlzLmRpc2FibGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcGFyZW50X2NhbnZhcy5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICB0cmFja19jYW52YXMuc3R5bGUuZGlzcGxheSA9ICdub25lJztcblxuICAgIH07XG5cbiAgICB0aGlzLmVuYWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBwYXJlbnRfY2FudmFzLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICB0cmFja19jYW52YXMuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgfVxuXG4gICAgdGhpcy5kZW1vdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdHJhY2tfY2FudmFzLmhpZGUoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH07XG5cbiAgICB0aGlzLnByb21vdGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMudmlzaWJsZSgpKSB7XG4gICAgICAgICAgICB0cmFja19jYW52YXMuc2hvdygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHJhY2tfY2FudmFzLmhpZGUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgXG4gICAgdGhpcy5zZXREaW1lbnNpb25zID0gZnVuY3Rpb24od2lkdGgsaGVpZ2h0KSB7XG4gICAgICAgIHBhcmVudF9jYW52YXMuc2V0QXR0cmlidXRlKCd3aWR0aCcsd2lkdGgpO1xuICAgICAgICBwYXJlbnRfY2FudmFzLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JyxoZWlnaHQpO1xuICAgIH07XG4gICAgXG59O1xuXG52YXIgY29ubmVjdFJlbmRlcmVyID0gZnVuY3Rpb24ocmVuZGVyZXIpIHtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIGxheWVyIGJhc2VkIGNvbnRyb2xsZXIgZm9yIGEgZ3JvdXAuIENsaWNraW5nIG9uIHRoZSBub21pbmF0ZWQgbGF5ZXIgd2lsbCBhbmltYXRlIG91dCB0aGUgZXhwYW5zaW9uIG9mIHRoZVxuICAgICAqIGdyb3VwLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBsYXkgTGF5ZXIgdG8gdHVybiBpbnRvIGEgZ3JvdXAgY29udHJvbGxlclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBncnAgR3JvdXAgdG8gYmUgY29udHJvbGxlZCBieSB0aGlzIGxheWVyLlxuICAgICAqL1xuICAgIFxuICAgIHZhciBjb250cm9sbGVyX21hcCA9IHt9O1xuICAgIHZhciBleHBhbmRlZF9tYXAgPSB7fTtcbiAgICBcbiAgICB2YXIgb2xkX3JlbW92ZV90cmFjayA9IHJlbmRlcmVyLnJlbW92ZVRyYWNrO1xuXG4gICAgcmVuZGVyZXIucmVtb3ZlVHJhY2sgPSBmdW5jdGlvbihsYXllcikge1xuICAgICAgICBvbGRfcmVtb3ZlX3RyYWNrLmNhbGwodGhpcyxsYXllcik7XG4gICAgICAgIGRlbGV0ZSBjb250cm9sbGVyX21hcFtsYXllci5uYW1lXTtcbiAgICAgICAgZGVsZXRlIGV4cGFuZGVkX21hcFtsYXllci5uYW1lXTtcbiAgICB9O1xuXG5cbiAgICB0aGlzLmlzQ29udHJvbGxlciA9IGZ1bmN0aW9uKGxheWVyKSB7XG4gICAgICAgIGlmIChjb250cm9sbGVyX21hcFtsYXllci5uYW1lXSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFxuICAgIHRoaXMuZ2V0Q29udHJvbGxlciA9IGZ1bmN0aW9uKGdyb3VwKSB7XG4gICAgICAgIGZvciAodmFyIGxheSBpbiBjb250cm9sbGVyX21hcCkge1xuICAgICAgICAgICAgaWYgKGNvbnRyb2xsZXJfbWFwLmhhc093blByb3BlcnR5KGxheSkgJiYgY29udHJvbGxlcl9tYXBbbGF5XSA9PSBncm91cCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBNQVNDUC5nZXRMYXllcihsYXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgXG4gICAgdGhpcy5pc0NvbnRyb2xsZXJFeHBhbmRlZCA9IGZ1bmN0aW9uKGxheWVyKSB7XG4gICAgICAgIHJldHVybiBleHBhbmRlZF9tYXBbbGF5ZXIubmFtZV07XG4gICAgfTtcbiAgICBcbiAgICByZW5kZXJlci5jcmVhdGVHcm91cENvbnRyb2xsZXIgPSBmdW5jdGlvbihsYXksZ3JwKSB7XG4gICAgICAgIHZhciBsYXllciA9IE1BU0NQLmdldExheWVyKGxheSk7XG4gICAgICAgIHZhciBncm91cCA9IE1BU0NQLmdldEdyb3VwKGdycCk7XG5cbiAgICAgICAgaWYgKCAhIGxheWVyIHx8ICEgZ3JvdXApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb250cm9sbGVyX21hcFtsYXllci5uYW1lXSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29udHJvbGxlcl9tYXBbbGF5ZXIubmFtZV0gPSBncm91cDtcbiAgICAgICAgXG4gICAgICAgIGV4cGFuZGVkX21hcFtsYXllci5uYW1lXSA9IGZhbHNlO1xuICAgICAgICBcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIGJlYW4uYWRkKGxheWVyLCdyZW1vdmVkJyxmdW5jdGlvbihldixyZW5kKSB7XG4gICAgICAgICAgICBzZWxmLnNldEdyb3VwVmlzaWJpbGl0eShncm91cCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGJlYW4uYWRkKGxheWVyLCd2aXNpYmlsaXR5Q2hhbmdlJyxmdW5jdGlvbihyZW5kLHZpc2libGUpIHtcbiAgICAgICAgICAgIGlmIChncm91cC5zaXplKCkgPiAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKCEgZXhwYW5kZWRfbWFwLmhhc093blByb3BlcnR5KGxheWVyLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4cGFuZGVkX21hcFtsYXllci5uYW1lXSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzZWxmLnNldEdyb3VwVmlzaWJpbGl0eShncm91cCwgZXhwYW5kZWRfbWFwW2xheWVyLm5hbWVdICYmIHZpc2libGUsdHJ1ZSk7XG4gICAgICAgICAgICAgICAgcmVuZGVyZXIucmVmcmVzaCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgYmVhbi5hZGQoZ3JvdXAsJ3Zpc2liaWxpdHlDaGFuZ2UnLGZ1bmN0aW9uKHJlbmQsdmlzaWJsZSkge1xuICAgICAgICAgICAgaWYgKHZpc2libGUpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnNob3dMYXllcihsYXllcix0cnVlKTtcbiAgICAgICAgICAgICAgICBleHBhbmRlZF9tYXBbbGF5ZXIubmFtZV0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgYmVhbi5yZW1vdmUobGF5ZXIsJ19leHBhbmRldmVudCcpXG4gICAgICAgIGJlYW4uYWRkKGxheWVyLCdfZXhwYW5kZXZlbnQnLGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgICAgICBleHBhbmRlZF9tYXBbbGF5ZXIubmFtZV0gPSAhIGV4cGFuZGVkX21hcFtsYXllci5uYW1lXTtcbiAgICAgICAgICAgIHNlbGYud2l0aG91dFJlZnJlc2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5zZXRHcm91cFZpc2liaWxpdHkoZ3JvdXAsZXhwYW5kZWRfbWFwW2xheWVyLm5hbWVdKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2VsZi5yZWZyZXNoKHRydWUpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIERyYWdBbmREcm9wKGZ1bmN0aW9uKHRyYWNrLGJlZm9yZSxhZnRlcil7XG4gICAgICAgIHZhciB0X29yZGVyID0gcmVuZGVyZXIudHJhY2tPcmRlcjtcblxuICAgICAgICB0X29yZGVyLnRyYWNrSW5kZXggPSBmdW5jdGlvbih0cikge1xuICAgICAgICAgICAgaWYgKCEgdHIgKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXhPZih0ci5uYW1lKTtcbiAgICAgICAgfTtcbiAgICBcbiAgICAgICAgaWYgKGFmdGVyICYmICEgYmVmb3JlKSB7XG4gICAgICAgICAgICBiZWZvcmUgPSBNQVNDUC5nZXRMYXllcih0X29yZGVyW3Rfb3JkZXIudHJhY2tJbmRleChhZnRlcikgKyAxXSk7XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgdF9vcmRlci5zcGxpY2UodF9vcmRlci50cmFja0luZGV4KHRyYWNrKSwxKTtcbiAgICAgICAgdmFyIGV4dHJhX3RvX3B1c2ggPSBbXTtcbiAgICAgICAgaWYgKGNvbnRyb2xsZXJfbWFwW3RyYWNrLm5hbWVdKSB7XG4gICAgICAgICAgICBsZXQgbGF5ZXJfZnVuYyA9IGZ1bmN0aW9uKGxheSkge1xuICAgICAgICAgICAgICAgIGlmIChNQVNDUC5nZXRHcm91cChsYXkpID09PSBsYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgTUFTQ1AuZ2V0R3JvdXAobGF5KS5lYWNoTGF5ZXIobGF5ZXJfZnVuYyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0X29yZGVyLnRyYWNrSW5kZXgobGF5KSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4dHJhX3RvX3B1c2ggPSBbdF9vcmRlci5zcGxpY2UodF9vcmRlci50cmFja0luZGV4KGxheSksMSlbMF1dLmNvbmNhdChleHRyYV90b19wdXNoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBNQVNDUC5nZXRHcm91cChjb250cm9sbGVyX21hcFt0cmFjay5uYW1lXSkuZWFjaExheWVyKGxheWVyX2Z1bmMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiZWZvcmUpIHtcbiAgICAgICAgICAgIHRfb3JkZXIuc3BsaWNlKHRfb3JkZXIudHJhY2tJbmRleChiZWZvcmUpLDEsdHJhY2submFtZSwgYmVmb3JlID8gYmVmb3JlLm5hbWUgOiB1bmRlZmluZWQgKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXh0cmFfdG9fcHVzaC5sZW5ndGg7IGkrKyApIHtcbiAgICAgICAgICAgICAgICBpZiAoZXh0cmFfdG9fcHVzaFtpXSkge1xuICAgICAgICAgICAgICAgICAgICB0X29yZGVyLnNwbGljZSh0X29yZGVyLnRyYWNrSW5kZXgoYmVmb3JlKSwwLGV4dHJhX3RvX3B1c2hbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlbmRlcmVyLmhpZGVMYXllcih0cmFjayk7XG4gICAgICAgICAgICBNQVNDUC5nZXRMYXllcih0cmFjaykuZGlzYWJsZWQgPSB0cnVlOyAgICAgICAgICAgICAgICBcblxuICAgICAgICAgICAgZXh0cmFfdG9fcHVzaC5mb3JFYWNoKGZ1bmN0aW9uKGxheSkge1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHJlbmRlcmVyLmhpZGVMYXllcihsYXkpO1xuICAgICAgICAgICAgICAgIE1BU0NQLmdldExheWVyKGxheSkuZGlzYWJsZWQgPSB0cnVlOyAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRfb3JkZXIucHVzaCh0cmFjay5uYW1lKTtcbiAgICAgICAgICAgIHRfb3JkZXIgPSB0X29yZGVyLmNvbmNhdChleHRyYV90b19wdXNoKTtcbiAgICAgICAgfVxuICAgIFxuICAgICAgICByZW5kZXJlci50cmFja09yZGVyID0gdF9vcmRlcjtcbiAgICB9KTtcbn07XG5cbnZhciBEcmFnQW5kRHJvcCA9IGZ1bmN0aW9uKHNwbGljZUZ1bmN0aW9uKSB7ICAgIFxuICAgIHZhciB0YXJnZXRzID0gW107XG4gICAgdmFyIGluX2RyYWcgPSBmYWxzZSwgZHJhZ19lbDtcbiAgICBcbiAgICB2YXIgc3BsaWNlX2JlZm9yZSwgc3BsaWNlX2FmdGVyLCB0cmFja1RvU3BsaWNlO1xuICAgIFxuICAgIHZhciBsYXN0X3RhcmdldDtcblxuICAgIHZhciB0aW1lb3V0cyA9IHt9O1xuICAgIFxuICAgIHZhciBuYXZfcmVzZXRfc2V0ID0gbnVsbDtcblxuICAgIGxldCBzcGxpY2VCZWZvcmU7XG4gICAgbGV0IHNwbGljZUFmdGVyO1xuXG5cbiAgICB2YXIgZHJhZ19mdW5jID0gZnVuY3Rpb24oaGFuZGxlLGVsZW1lbnQsdHJhY2ssY2FudmFzKSB7XG4gICAgICAgIHZhciBuYXYgPSB0aGlzO1xuXG5cbiAgICAgICAgdmFyIG9sZF9yZXNldCA9IG5hdi5yZXNldDtcbiAgICAgICAgaWYgKG5hdl9yZXNldF9zZXQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIG5hdi5yZXNldCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRhcmdldHMgPSBbXTtcbiAgICAgICAgICAgICAgICBvbGRfcmVzZXQuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBuYXZfcmVzZXRfc2V0ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzZXREcmFnID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRpbWVvdXRzLmFuaW0pO1xuICAgICAgICAgICAgd2luZG93LmNsZWFyVGltZW91dCh0aW1lb3V0cy5ob3Zlcik7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRhcmdldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0c1tpXSAhPSBkcmFnX2VsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldHNbaV0ucmVtb3ZlQXR0cmlidXRlKCdkcmFnZ2luZycpO1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRzW2ldLnJlbW92ZUF0dHJpYnV0ZSgndHJhbnNmb3JtJyk7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldHNbaV0uc2V0QXR0cmlidXRlKCdwb2ludGVyLWV2ZW50cycsJ2FsbCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICBcbiAgICAgICAgdGFyZ2V0cy5wdXNoKGVsZW1lbnQpO1xuICAgICAgICBlbGVtZW50LnRyYWNrID0gdHJhY2s7XG5cbiAgICAgICAgdmFyIHNpbmdsZV90b3VjaF9ldmVudCA9IGZ1bmN0aW9uKGZuKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIGlmIChlLnRvdWNoZXMgJiYgZS50b3VjaGVzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGZuLmNhbGwodGhpcyxlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBiZWdpbkRyYWdnaW5nID0gZnVuY3Rpb24oZXYsdHIsbGJsX2dycCkge1xuICAgICAgICBcbiAgICAgICAgICAgIGlmIChkcmFnX2Rpc2FibGVkKCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSBjYW52YXMubmVhcmVzdFZpZXdwb3J0RWxlbWVudDtcblxuICAgICAgICAgICAgaWYgKGluX2RyYWcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47ICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGJsX2dycC5zZXRBdHRyaWJ1dGUoJ2RyYWdnaW5nJywndHJ1ZScpO1xuXG4gICAgICAgICAgICBzcGxpY2VCZWZvcmUgPSBudWxsO1xuICAgICAgICAgICAgc3BsaWNlQWZ0ZXIgPSBudWxsO1xuXG4gICAgICAgICAgICB2YXIgcF9vcmlnID0gbGJsX2dycC5uZWFyZXN0Vmlld3BvcnRFbGVtZW50LmNyZWF0ZVNWR1BvaW50KCk7XG5cbiAgICAgICAgICAgIHBfb3JpZy54ID0gZXYuY2xpZW50WCB8fCAod2luZG93LnBhZ2VYT2Zmc2V0ICsgZXYudG91Y2hlc1swXS5jbGllbnRYKTtcbiAgICAgICAgICAgIHBfb3JpZy55ID0gZXYuY2xpZW50WSB8fCAod2luZG93LnBhZ2VZT2Zmc2V0ICsgZXYudG91Y2hlc1swXS5jbGllbnRZKTtcblxuICAgICAgICAgICAgdmFyIHJvb3RDVE0gPSBsYmxfZ3JwLm5lYXJlc3RWaWV3cG9ydEVsZW1lbnQuZ2V0U2NyZWVuQ1RNKCk7XG4gICAgICAgICAgICB2YXIgbWF0cml4ID0gcm9vdENUTS5pbnZlcnNlKCk7XG5cbiAgICAgICAgICAgIHBfb3JpZyA9IHBfb3JpZy5tYXRyaXhUcmFuc2Zvcm0obWF0cml4KTtcblxuICAgICAgICAgICAgdmFyIG9YID0gcF9vcmlnLng7XG4gICAgICAgICAgICB2YXIgb1kgPSBwX29yaWcueTtcblxuICAgICAgICAgICAgdmFyIGRyYWdmbiA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgcCA9IGxibF9ncnAubmVhcmVzdFZpZXdwb3J0RWxlbWVudC5jcmVhdGVTVkdQb2ludCgpO1xuICAgICAgICAgICAgICAgIHAueCA9IGUuY2xpZW50WCB8fCAod2luZG93LnBhZ2VYT2Zmc2V0ICsgZS50b3VjaGVzWzBdLmNsaWVudFgpO1xuICAgICAgICAgICAgICAgIHAueSA9IGUuY2xpZW50WSB8fCAod2luZG93LnBhZ2VZT2Zmc2V0ICsgZS50b3VjaGVzWzBdLmNsaWVudFkpO1xuICAgICAgICAgICAgICAgIHAgPSBwLm1hdHJpeFRyYW5zZm9ybShtYXRyaXgpO1xuXG4gICAgICAgICAgICAgICAgdmFyIGRYID0gKHAueCAtIG9YKTtcbiAgICAgICAgICAgICAgICB2YXIgZFkgPSAocC55IC0gb1kpO1xuICAgICAgICAgICAgICAgIHZhciBjdXJyX3RyYW5zZm9ybSA9IGxibF9ncnAuZ2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nKSB8fCAnJztcbiAgICAgICAgICAgICAgICBjdXJyX3RyYW5zZm9ybSA9IGN1cnJfdHJhbnNmb3JtLnJlcGxhY2UoL1xccz90cmFuc2xhdGVcXChbXlxcKV0rXFwpLywnJyk7XG4gICAgICAgICAgICAgICAgY3Vycl90cmFuc2Zvcm0gKz0gJyB0cmFuc2xhdGUoJytkWCsnLCcrZFkrJykgJztcbiAgICAgICAgICAgICAgICBjdXJyX3RyYW5zZm9ybSA9IGN1cnJfdHJhbnNmb3JtLnJlcGxhY2UoL1xccyokLywnJyk7XG4gICAgICAgICAgICAgICAgbGJsX2dycC5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsY3Vycl90cmFuc2Zvcm0pO1xuICAgICAgICAgICAgICAgIHRhcmdldHMuZm9yRWFjaChmdW5jdGlvbih0YXJnKXtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGJiID0gdGFyZy5nZXRCQm94KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChiYi55IDwgcC55ICYmIGJiLnkgPiAocC55IC0gYmIuaGVpZ2h0KSAmJiBiYi54IDwgcC54ICYmIGJiLnggPiAocC54IC0gYmIud2lkdGgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbF9tb3ZlLmNhbGwodGFyZyxlLHRhcmcudHJhY2spO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICh0b3VjaF9lbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgZHJhZ2ZuID0gc2luZ2xlX3RvdWNoX2V2ZW50KGRyYWdmbik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBlbmRkcmFnID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIGlmIChlLnJlbGF0ZWRUYXJnZXQgJiYgKGUucmVsYXRlZFRhcmdldCA9PSBsYmxfZ3JwIHx8IGUucmVsYXRlZFRhcmdldC5uZWFyZXN0Vmlld3BvcnRFbGVtZW50ID09IGxibF9ncnAubmVhcmVzdFZpZXdwb3J0RWxlbWVudCB8fCBlLnJlbGF0ZWRUYXJnZXQubmVhcmVzdFZpZXdwb3J0RWxlbWVudCA9PSB0YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbl9kcmFnICYmIHRhcmdldHMuaW5kZXhPZihlLnJlbGF0ZWRUYXJnZXQpID49IDApIHsgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc2V0RHJhZygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaW5fZHJhZyAmJiAoZS50eXBlID09ICdtb3VzZXVwJyB8fCBlLnR5cGUgPT0gJ3RvdWNoZW5kJykpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNwbGljZUJlZm9yZSB8fCBzcGxpY2VBZnRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3BsaWNlRnVuY3Rpb24odHJhY2tUb1NwbGljZSwgc3BsaWNlQmVmb3JlLCBzcGxpY2VBZnRlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsZHJhZ2ZuLGZhbHNlKTtcbiAgICAgICAgICAgICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJyxkcmFnZm4sZmFsc2UpO1xuICAgICAgICAgICAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsZW5kZHJhZyxmYWxzZSk7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLGVuZGRyYWcsZmFsc2UpO1xuICAgICAgICAgICAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW91dCcsZW5kZHJhZyxmYWxzZSk7XG4gICAgICAgICAgICAgICAgaWYgKGluX2RyYWcpIHtcbiAgICAgICAgICAgICAgICAgICAgbGJsX2dycC5zZXRBdHRyaWJ1dGVOUyhudWxsLCAncG9pbnRlci1ldmVudHMnLCAnYWxsJyk7XG4gICAgICAgICAgICAgICAgICAgIGxibF9ncnAucmVtb3ZlQXR0cmlidXRlKCd0cmFuc2Zvcm0nKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzZXREcmFnKCk7XG4gICAgICAgICAgICAgICAgICAgIGluX2RyYWcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgbGFzdF90YXJnZXQgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBsYmxfZ3JwLnNldEF0dHJpYnV0ZU5TKG51bGwsICdwb2ludGVyLWV2ZW50cycsICdub25lJyk7XG4gICAgICAgICAgICBsYmxfZ3JwLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsZHJhZ2ZuLGZhbHNlKTtcbiAgICAgICAgICAgIGxibF9ncnAuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLGVuZGRyYWcsZmFsc2UpO1xuICAgICAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsZHJhZ2ZuLGZhbHNlKTtcbiAgICAgICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJyxlbmRkcmFnLGZhbHNlKTtcbiAgICAgICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW91dCcsZW5kZHJhZyxmYWxzZSk7XG4gICAgICAgIFxuICAgICAgICAgICAgaW5fZHJhZyA9IHRyYWNrO1xuICAgICAgICAgICAgZHJhZ19lbCA9IGxibF9ncnA7XG4gICAgICAgIH07XG5cbiAgICAgICAgdmFyIGhhbmRsZV9zdGFydCA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGJlZ2luRHJhZ2dpbmcoZSx0cmFjayxlbGVtZW50KTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgZWxfbW92ZSA9IGZ1bmN0aW9uKGUsdHJrKSB7XG4gICAgICAgICAgICB2YXIgdHJjayA9IHRyayA/IHRyayA6IHRyYWNrO1xuICAgICAgICAgICAgdmFyIGVsZW0gPSB0aGlzID8gdGhpcyA6IGVsZW1lbnQ7XG4gICAgICAgIFxuICAgICAgICAgICAgaWYgKCBpbl9kcmFnICYmIGluX2RyYWcgIT0gdHJjayAmJiB0cmNrICE9IGxhc3RfdGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgbGFzdF90YXJnZXQgPSB0cmNrO1xuICAgICAgICAgICAgICAgIGlmICh0aW1lb3V0cy5ob3Zlcikge1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRpbWVvdXRzLmhvdmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGltZW91dHMuaG92ZXIgPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCAoaW5fZHJhZy5ncm91cCB8fCB0cmNrLmdyb3VwKSAmJiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgKGluX2RyYWcuZ3JvdXAgPyB0cmNrLmdyb3VwIDogICEgdHJjay5ncm91cCApICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluX2RyYWcuZ3JvdXAubmFtZSAhPSB0cmNrLmdyb3VwLm5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGluX2RyYWcuZ3JvdXAgfHwgdHJjay5ncm91cCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAodGltZW91dHMuYW5pbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LmNsZWFySW50ZXJ2YWwodGltZW91dHMuYW5pbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lb3V0cy5hbmltID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICByZXNldERyYWcoKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRfc2libGluZyA9IGVsZW07XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbGVtZW50c190b19zaGlmdCA9IFtdO1xuXG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChjdXJyZW50X3NpYmxpbmcgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50X3NpYmxpbmcgIT0gZHJhZ19lbCAmJiB0YXJnZXRzLmluZGV4T2YoY3VycmVudF9zaWJsaW5nKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbWVudHNfdG9fc2hpZnQucHVzaChjdXJyZW50X3NpYmxpbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudF9zaWJsaW5nID0gY3VycmVudF9zaWJsaW5nLm5leHRTaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRfc2libGluZyA9PSBkcmFnX2VsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudF9zaWJsaW5nID0gZWxlbS5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIHZhciBlbGVtZW50c190b19zaGlmdF91cCA9IFtdO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoY3VycmVudF9zaWJsaW5nICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudF9zaWJsaW5nICE9IGRyYWdfZWwgJiYgdGFyZ2V0cy5pbmRleE9mKGN1cnJlbnRfc2libGluZykgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzX3RvX3NoaWZ0X3VwLnB1c2goY3VycmVudF9zaWJsaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRfc2libGluZyA9IGN1cnJlbnRfc2libGluZy5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudF9zaWJsaW5nID09IGRyYWdfZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgYW5pbV9zdGVwcyA9IDE7XG4gICAgICAgICAgICAgICAgICAgIHZhciBoZWlnaHQgPSBkcmFnX2VsLmdldEJCb3goKS5oZWlnaHQgLyA0O1xuICAgICAgICAgICAgICAgICAgICB0aW1lb3V0cy5hbmltID0gd2luZG93LnNldEludGVydmFsKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJfdHJhbnNmb3JtLCBpID0gMDtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYW5pbV9zdGVwcyA8IDUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZWxlbWVudHNfdG9fc2hpZnQubGVuZ3RoOyBpKysgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJfdHJhbnNmb3JtID0gZWxlbWVudHNfdG9fc2hpZnRbaV0uZ2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nKSB8fCAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3Vycl90cmFuc2Zvcm0gPSBjdXJyX3RyYW5zZm9ybS5yZXBsYWNlKC9cXHM/dHJhbnNsYXRlXFwoW15cXCldK1xcKS8sJycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyX3RyYW5zZm9ybSArPSAnIHRyYW5zbGF0ZSgwLCcrYW5pbV9zdGVwcypoZWlnaHQrJyknO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50c190b19zaGlmdFtpXS5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsY3Vycl90cmFuc2Zvcm0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IChlbGVtZW50c190b19zaGlmdC5sZW5ndGggPiAwKSAmJiBpIDwgZWxlbWVudHNfdG9fc2hpZnRfdXAubGVuZ3RoOyBpKysgKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3Vycl90cmFuc2Zvcm0gPSBlbGVtZW50c190b19zaGlmdF91cFtpXS5nZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScpIHx8ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyX3RyYW5zZm9ybSA9IGN1cnJfdHJhbnNmb3JtLnJlcGxhY2UoL1xccz90cmFuc2xhdGVcXChbXlxcKV0rXFwpLywnJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJfdHJhbnNmb3JtICs9ICcgdHJhbnNsYXRlKDAsJythbmltX3N0ZXBzKi0xKmhlaWdodCsnKSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzX3RvX3NoaWZ0X3VwW2ldLnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJyxjdXJyX3RyYW5zZm9ybSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmltX3N0ZXBzICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwbGljZUJlZm9yZSA9IHRyY2s7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhY2tUb1NwbGljZSA9IGluX2RyYWc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LmNsZWFySW50ZXJ2YWwodGltZW91dHMuYW5pbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZW91dHMuYW5pbSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sMzApO1xuXG4gICAgICAgICAgICAgICAgfSwzMDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIFxuICAgICAgICBoYW5kbGUuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgaGFuZGxlX3N0YXJ0LGZhbHNlKTtcbiAgICAgICAgaGFuZGxlLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLHNpbmdsZV90b3VjaF9ldmVudChoYW5kbGVfc3RhcnQpLGZhbHNlKTtcbiAgICB9O1xuXG4gICAgdmFyIGRyYWdfZGlzYWJsZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGRyYWdfZnVuYy5kaXNhYmxlZDtcbiAgICB9O1xuXG4gICAgZHJhZ19mdW5jLnNwbGljZUZ1bmN0aW9uID0gc3BsaWNlRnVuY3Rpb247XG4gICAgXG4gICAgcmV0dXJuIGRyYWdfZnVuYztcbn07XG5cbnZhciBzZXRFbGVtZW50VHJhbnNmb3JtID0gZnVuY3Rpb24oZWwsdHJhbnNmb3JtKSB7XG4gICAgdmFyIHVhID0gd2luZG93Lm5hdmlnYXRvci51c2VyQWdlbnQ7XG4gICAgaWYgKHVhLmluZGV4T2YoJ0VkZ2UvJykgPj0gMCkge1xuICAgICAgICB0cmFuc2Zvcm0gPSB0cmFuc2Zvcm0ucmVwbGFjZSgvcHgvZywnJyk7XG4gICAgICAgIGVsLnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJyx0cmFuc2Zvcm0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGVsLnN0eWxlLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbiAgICB9XG59O1xuXG52YXIgYnVpbGROYXZQYW5lID0gZnVuY3Rpb24oYmFja19jYW52YXMpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgc2VsZi56b29tID0gMTtcbiAgICBzZWxmLm5hdl93aWR0aF9iYXNlID0gMjAwO1xuICAgIHZhciBuYXZfd2lkdGggPSBzZWxmLm5hdl93aWR0aF9iYXNlO1xuICAgIHNlbGYubmF2X3dpZHRoID0gc2VsZi5uYXZfd2lkdGhfYmFzZTtcbiAgICB2YXIgcGFuZWxfYmFjayA9IGJhY2tfY2FudmFzLmdyb3VwKCk7XG4gICAgdmFyIGJ1dHRvbl9ncm91cCA9IGJhY2tfY2FudmFzLmdyb3VwKCk7XG4gICAgXG4gICAgdmFyIHJlY3QgPSBiYWNrX2NhbnZhcy5yZWN0KC0xMCwwLG5hdl93aWR0aC50b1N0cmluZygpLCcxMDAlJyk7XG4gICAgdmFyIGJhc2Vfcm91bmRlZF9jb3JuZXIgPSBbMTIqdG91Y2hfc2NhbGUsMTAqdG91Y2hfc2NhbGVdO1xuICAgIHJlY3Quc2V0QXR0cmlidXRlKCdyeCcsYmFzZV9yb3VuZGVkX2Nvcm5lclswXS50b1N0cmluZygpKTtcbiAgICByZWN0LnNldEF0dHJpYnV0ZSgncnknLGJhc2Vfcm91bmRlZF9jb3JuZXJbMV0udG9TdHJpbmcoKSk7ICAgIFxuICAgIGlmICghIHRvdWNoX2VuYWJsZWQpIHtcbiAgICAgICAgcmVjdC5zZXRBdHRyaWJ1dGUoJ29wYWNpdHknLCcwLjgnKTtcbiAgICB9XG4gICAgcmVjdC5zdHlsZS5zdHJva2UgPSAnIzAwMDAwMCc7XG4gICAgcmVjdC5zdHlsZS5zdHJva2VXaWR0aCA9ICcycHgnO1xuICAgIHJlY3Quc3R5bGUuZmlsbCA9ICcjMDAwMDAwJztcbiAgICByZWN0LmlkID0gJ25hdl9iYWNrJztcblxuICAgIHBhbmVsX2JhY2sucHVzaChyZWN0KTtcblxuICAgIHNlbGYuY2xpcHBpbmdfaWQgPSAnbmF2X2NsaXBwaW5nJysobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuICAgIHZhciBjbGlwcGluZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhzdmducywnY2xpcFBhdGgnKTtcbiAgICBjbGlwcGluZy5pZCA9IHNlbGYuY2xpcHBpbmdfaWQ7XG4gICAgdmFyIHJlY3QyID0gcmVjdC5jbG9uZU5vZGUoKTtcbiAgICByZWN0Mi5yZW1vdmVBdHRyaWJ1dGUoJ2lkJyk7XG4gICAgcmVjdDIucmVtb3ZlQXR0cmlidXRlKCdvcGFjaXR5Jyk7XG4gICAgcmVjdDIuc2V0QXR0cmlidXRlKCd4JywnMCcpO1xuICAgIHJlY3QyLnNldEF0dHJpYnV0ZSgnd2lkdGgnLFwiXCIrKHBhcnNlSW50KHJlY3QyLmdldEF0dHJpYnV0ZSgnd2lkdGgnKSkgLSAxMCkpO1xuICAgIHJlY3QyLnJlbW92ZUF0dHJpYnV0ZSgnc3R5bGUnKTtcbiAgICByZWN0Mi5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsJzEwMDAwJyk7XG5cbiAgICBiYWNrX2NhbnZhcy5pbnNlcnRCZWZvcmUoY2xpcHBpbmcsYmFja19jYW52YXMuZmlyc3RDaGlsZCk7XG4gICAgY2xpcHBpbmcuYXBwZW5kQ2hpbGQocmVjdDIpO1xuXG4gICAgdmFyIGNsb3NlX2dyb3VwID0gYmFja19jYW52YXMuY3Jvc3NlZF9jaXJjbGUobmF2X3dpZHRoLSgxMCArIHRvdWNoX3NjYWxlKjExKSwoMTIqdG91Y2hfc2NhbGUpLCgxMCp0b3VjaF9zY2FsZSkpO1xuXG4gICAgY2xvc2VfZ3JvdXAuc3R5bGUuY3Vyc29yID0gJ3BvaW50ZXInO1xuICAgIGlmICh0eXBlb2YgbWF0Y2hNZWRpYSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgKHRoaXMud2luKCkgfHwgd2luZG93KS5tYXRjaE1lZGlhKCdwcmludCcpLmFkZExpc3RlbmVyKGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgICAgICAgICBpZiAobWF0Y2gubWF0Y2hlcykge1xuICAgICAgICAgICAgICAgIGNsb3NlX2dyb3VwLnNldEF0dHJpYnV0ZSgnZGlzcGxheScsJ25vbmUnKTtcbiAgICAgICAgICAgICAgICB0cmFja3NfYnV0dG9uLnNldEF0dHJpYnV0ZSgnZGlzcGxheScsJ25vbmUnKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2xvc2VfZ3JvdXAuc2V0QXR0cmlidXRlKCdkaXNwbGF5JywnYmxvY2snKTsgXG4gICAgICAgICAgICAgICAgdHJhY2tzX2J1dHRvbi5zZXRBdHRyaWJ1dGUoJ2Rpc3BsYXknLCdub25lJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGJ1dHRvbl9ncm91cC5wdXNoKGNsb3NlX2dyb3VwKTtcblxuICAgIHZhciB0cmFja3NfYnV0dG9uID0gTUFTQ1AuSUUgPyBiYWNrX2NhbnZhcy5zdmdidXR0b24oMTAsNSw2NSwyNSwnRWRpdCcpIDogYmFja19jYW52YXMuYnV0dG9uKDEwLDUsNjUsMjUsJ0VkaXQnKTtcbiAgICB0cmFja3NfYnV0dG9uLmlkID0gJ2NvbnRyb2xzJztcbiAgICB0cmFja3NfYnV0dG9uLnBhcmVudE5vZGUuc2V0QXR0cmlidXRlKCdjbGlwLXBhdGgnLCd1cmwoIycrc2VsZi5jbGlwcGluZ19pZCsnKScpO1xuXG4gICAgcGFuZWxfYmFjay5wdXNoKE1BU0NQLklFID8gdHJhY2tzX2J1dHRvbiA6IHRyYWNrc19idXR0b24ucGFyZW50Tm9kZSk7XG5cbiAgICB0cmFja3NfYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJyxmdW5jdGlvbigpIHtcbiAgICAgICAgYmVhbi5maXJlKHNlbGYsJ3RvZ2dsZUVkaXQnKTtcbiAgICAgICAgYmVhbi5maXJlKHNlbGYsJ2NsaWNrJyk7XG4gICAgfSxmYWxzZSk7XG5cblxuICAgIHBhbmVsX2JhY2suc2V0QXR0cmlidXRlKCdzdHlsZScsJ3RyYW5zaXRpb246IGFsbCAwLjI1czsnKTtcblxuICAgIHZhciBvbGRfdHJhY2tzX3N0eWxlID0gdHJhY2tzX2J1dHRvbi5nZXRBdHRyaWJ1dGUoJ3N0eWxlJyk7XG4gICAgdmFyIHRyYW5zZm9ybV9vcmlnaW4gPSBcIlwiKyhuYXZfd2lkdGgtKDEwICsgdG91Y2hfc2NhbGUqMTEpKStcInB4IFwiKygxMip0b3VjaF9zY2FsZSkrXCJweFwiO1xuICAgIHZhciB0cmFuc2xhdGUgPSBmdW5jdGlvbihhbW91bnQscm90YXRlKSB7XG4gICAgICAgIHZhciB0cmFucyA9IFwiIHRyYW5zbGF0ZTNkKFwiK2Ftb3VudCtcInB4LDBweCwwcHgpXCI7XG4gICAgICAgIGlmIChyb3RhdGUpIHtcbiAgICAgICAgICAgIHRyYW5zID0gdHJhbnMgKyBcIiByb3RhdGUoXCIrcm90YXRlK1wiKVwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIi13ZWJraXQtdHJhbnNmb3JtOlwiK3RyYW5zK1wiOyAtbW96LXRyYW5zZm9ybTpcIit0cmFucytcIjsgLW1zLXRyYW5zZm9ybTpcIit0cmFucy5yZXBsYWNlKCczZCcsJycpLnJlcGxhY2UoJywwcHgpJywnKScpK1wiOyB0cmFuc2Zvcm06IFwiK3RyYW5zK1wiO1wiO1xuICAgIH07XG5cblxuICAgIHRyYWNrc19idXR0b24uc2V0QXR0cmlidXRlKCdzdHlsZScsb2xkX3RyYWNrc19zdHlsZStcIiB0cmFuc2l0aW9uOiBhbGwgMC4yNXM7XCIpO1xuICAgIGNsb3NlX2dyb3VwLnN0eWxlLnRyYW5zaXRpb24gPSAnYWxsIDAuMjVzJztcbiAgICBjbG9zZV9ncm91cC5zdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSB0cmFuc2Zvcm1fb3JpZ2luO1xuICAgIHZhciB2aXNpYmxlID0gdHJ1ZTtcblxuICAgIFxuICAgIHZhciB0b2dnbGVyID0gZnVuY3Rpb24odmlzLGludGVyYWN0aXZlKSB7XG4gICAgICAgIHZpc2libGUgPSAoIHZpcyA9PT0gZmFsc2UgfHwgdmlzID09PSB0cnVlICkgPyB2aXMgOiAhIHZpc2libGU7XG4gICAgICAgIHZhciBjbG9zZV90cmFuc2Zvcm07XG4gICAgICAgIHZhciBuZWVkc190cmFuc2l0aW9uID0gaW50ZXJhY3RpdmUgPyBcImFsbCBlYXNlLWluLW91dCAwLjRzXCIgOiBcIlwiO1xuICAgICAgICBsZXQgcGFyZW50X3RyYW5zZm9ybSA9IGJhY2tfY2FudmFzLnBhcmVudE5vZGUuc3R5bGUudHJhbnNmb3JtO1xuICAgICAgICBsZXQgc2NhbGV2YWw7XG4gICAgICAgIGxldCB5c2NhbGUgPSB0b3VjaF9zY2FsZTtcbiAgICAgICAgaWYgKHNjYWxldmFsID0gcGFyZW50X3RyYW5zZm9ybS5tYXRjaCgvc2NhbGVcXCgoW1xcZFxcLl0rKVxcKS8pKSB7XG4gICAgICAgICAgICB5c2NhbGUgPSAxO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0cmFuc2Zvcm1fb3JpZ2luID0gXCJcIisoc2VsZi5uYXZfd2lkdGhfYmFzZS0oMTAgKyB0b3VjaF9zY2FsZSoxMSkpK1wicHggXCIrKDEyKnlzY2FsZSkrXCJweFwiO1xuXG4gICAgICAgIGlmICh2aXNpYmxlKSB7XG4gICAgICAgICAgICBzZWxmLnByb21vdGUoKTtcbiAgICAgICAgICAgIHNldEVsZW1lbnRUcmFuc2Zvcm0ocGFuZWxfYmFjaywndHJhbnNsYXRlKDAsMCknKTtcbiAgICAgICAgICAgIHBhbmVsX2JhY2suc3R5bGUudHJhbnNpdGlvbiA9IG5lZWRzX3RyYW5zaXRpb247XG5cbiAgICAgICAgICAgIGNsb3NlX2dyb3VwLl9idXR0b24ucmVtb3ZlQXR0cmlidXRlKCdmaWx0ZXInKTtcbiAgICAgICAgICAgIGlmIChcIm9udG91Y2hlbmRcIiBpbiB3aW5kb3cgfHwgd2luZG93LmdldENvbXB1dGVkU3R5bGUoY2xvc2VfZ3JvdXApLmdldFByb3BlcnR5VmFsdWUoXCItbXMtdHJhbnNmb3JtXCIpKSB7XG4gICAgICAgICAgICAgICAgc2V0RWxlbWVudFRyYW5zZm9ybShjbG9zZV9ncm91cCwnJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRFbGVtZW50VHJhbnNmb3JtKGNsb3NlX2dyb3VwLCAndHJhbnNsYXRlKDAsMCknKTtcbiAgICAgICAgICAgIGNsb3NlX2dyb3VwLnN0eWxlLnRyYW5zaXRpb24gPSBuZWVkc190cmFuc2l0aW9uO1xuICAgICAgICAgICAgY2xvc2VfZ3JvdXAuc3R5bGUudHJhbnNmb3JtT3JpZ2luID0gY2xvc2VfZ3JvdXAuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCsncHggJyArY2xvc2VfZ3JvdXAuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wKycgcHgnO1xuICAgICAgICAgICAgc2VsZi5yZWZyZXNoKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWxmLmRlbW90ZSgpO1xuICAgICAgICAgICAgLy8gQ2hyb21lIGJ1ZyBKYW4gMjAxNSB3aXRoIHRoZSBkcm9wIHNoYWRvd1xuICAgICAgICAgICAgLy9jbG9zZV9ncm91cC5fYnV0dG9uLnNldEF0dHJpYnV0ZSgnZmlsdGVyJywndXJsKCNkcm9wX3NoYWRvdyknKTtcbiAgICAgICAgICAgIGNsb3NlX2dyb3VwLnN0eWxlLnRyYW5zaXRpb24gPSBuZWVkc190cmFuc2l0aW9uO1xuICAgICAgICAgICAgY2xvc2VfZ3JvdXAuc3R5bGUudHJhbnNpdGlvbiA9IG5lZWRzX3RyYW5zaXRpb247XG4gICAgICAgICAgICAvLyBjbG9zZV9ncm91cC5zdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSB0cmFuc2Zvcm1fb3JpZ2luO1xuICAgICAgICAgICAgY2xvc2VfZ3JvdXAuc3R5bGUudHJhbnNmb3JtT3JpZ2luID0gY2xvc2VfZ3JvdXAuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCsncHggJyArY2xvc2VfZ3JvdXAuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wKycgcHgnO1xuXG4gICAgICAgICAgICBzZXRFbGVtZW50VHJhbnNmb3JtKGNsb3NlX2dyb3VwLCAndHJhbnNsYXRlKCcrLTAuNzUqc2VsZi5uYXZfd2lkdGhfYmFzZSsncHgsMCkgcm90YXRlKDQwNWRlZyknKTtcbiAgICAgICAgICAgIGlmIChcIm9udG91Y2hlbmRcIiBpbiB3aW5kb3cpIHtcbiAgICAgICAgICAgICAgICAvLyBObyBsb25nZXIgc3BlY2lhbCBjYXNpbmcgSUVcbiAgICAgICAgICAgICAgICBzZXRFbGVtZW50VHJhbnNmb3JtKGNsb3NlX2dyb3VwLCd0cmFuc2xhdGUoJystMC43NSpzZWxmLm5hdl93aWR0aF9iYXNlKydweCwwKSByb3RhdGUoNDUsJysoc2VsZi5uYXZfd2lkdGhfYmFzZS0oMTAgKyB0b3VjaF9zY2FsZSoxMSkpKydweCwnKygxMip0b3VjaF9zY2FsZSkrJ3B4KScpO1xuICAgICAgICAgICAgICAgIHNldEVsZW1lbnRUcmFuc2Zvcm0ocGFuZWxfYmFjaywgJ3RyYW5zbGF0ZSgnKygtMSpzZWxmLm5hdl93aWR0aCpzZWxmLnpvb20pKydweCwwKScpO1xuICAgICAgICAgICAgICAgIHBhbmVsX2JhY2suc3R5bGUudHJhbnNpdGlvbiA9IG5lZWRzX3RyYW5zaXRpb247XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNldEVsZW1lbnRUcmFuc2Zvcm0ocGFuZWxfYmFjaywndHJhbnNsYXRlKCcrKC0xKnNlbGYubmF2X3dpZHRoKnNlbGYuem9vbSkrJ3B4LDApJyk7XG4gICAgICAgICAgICAgICAgcGFuZWxfYmFjay5zdHlsZS50cmFuc2l0aW9uID0gbmVlZHNfdHJhbnNpdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgc2VsZi5tb3ZlX2Nsb3NlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodmlzaWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHNldEVsZW1lbnRUcmFuc2Zvcm0oY2xvc2VfZ3JvdXAsJ3RyYW5zbGF0ZSgnKy0wLjc1KnNlbGYubmF2X3dpZHRoX2Jhc2UrJ3B4LDApIHJvdGF0ZSg0MDVkZWcpJyk7XG4gICAgICAgIGlmIChcIm9udG91Y2hlbmRcIiBpbiB3aW5kb3cpIHtcbiAgICAgICAgICAgIC8vIE5vIGxvbmdlciBzcGVjaWFsIGNhc2luZyBJRVxuICAgICAgICAgICAgc2V0RWxlbWVudFRyYW5zZm9ybShjbG9zZV9ncm91cCwndHJhbnNsYXRlKCcrLTAuNzUqc2VsZi5uYXZfd2lkdGhfYmFzZSsncHgsMCkgcm90YXRlKDQ1LCcrKHNlbGYubmF2X3dpZHRoX2Jhc2UtKDEwICsgdG91Y2hfc2NhbGUqMTEpKSsncHgsJysoMTIqdG91Y2hfc2NhbGUpKydweCknKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBzZWxmLmhpZGUgPSBmdW5jdGlvbihpbnRlcmFjdGl2ZSkge1xuICAgICAgICB0b2dnbGVyLmNhbGwodGhpcyxmYWxzZSxpbnRlcmFjdGl2ZSk7XG4gICAgfTtcbiAgICBzZWxmLnNob3cgPSBmdW5jdGlvbihpbnRlcmFjdGl2ZSkge1xuICAgICAgICB0b2dnbGVyLmNhbGwodGhpcyx0cnVlLGludGVyYWN0aXZlKTtcbiAgICB9O1xuXG4gICAgc2VsZi52aXNpYmxlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB2aXNpYmxlO1xuICAgIH07XG5cbiAgICBzZWxmLnNldFpvb20gPSBmdW5jdGlvbih6b29tKSB7XG4gICAgICAgIHNlbGYubmF2X3dpZHRoID0gc2VsZi5uYXZfd2lkdGhfYmFzZSAvIHpvb207XG4gICAgICAgIGNsb3NlX2dyb3VwLnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJywnc2NhbGUoJyt6b29tKycsJyt6b29tKycpICcpO1xuICAgICAgICBsZXQgcGFyZW50X3RyYW5zZm9ybSA9IGJhY2tfY2FudmFzLnBhcmVudE5vZGUuc3R5bGUudHJhbnNmb3JtO1xuICAgICAgICBsZXQgc2NhbGV2YWw7XG4gICAgICAgIGxldCB5c2NhbGUgPSB0b3VjaF9zY2FsZTtcbiAgICAgICAgaWYgKHNjYWxldmFsID0gcGFyZW50X3RyYW5zZm9ybS5tYXRjaCgvc2NhbGVcXCgoW1xcZFxcLl0rKVxcKS8pKSB7XG4gICAgICAgICAgICB5c2NhbGUgPSAxO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0cmFuc2Zvcm1fb3JpZ2luID0gXCJcIisoc2VsZi5uYXZfd2lkdGhfYmFzZS0oMTAgKyB0b3VjaF9zY2FsZSoxMSkpLnRvRml4ZWQoMikrXCJweCBcIisoMTIqeXNjYWxlKStcInB4XCI7XG5cbiAgICAgICAgY2xvc2VfZ3JvdXAuc3R5bGUudHJhbnNmb3JtT3JpZ2luID0gdHJhbnNmb3JtX29yaWdpbjtcblxuICAgICAgICBjbG9zZV9ncm91cC5tb3ZlKHNlbGYubmF2X3dpZHRoX2Jhc2UtKDEwICsgdG91Y2hfc2NhbGUqMTEpLDEyKnRvdWNoX3NjYWxlKTtcbiAgICAgICAgcmVjdC5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsJ3NjYWxlKCcrem9vbSsnLDEpICcpO1xuICAgICAgICByZWN0LnNldEF0dHJpYnV0ZSgncnknLCAoYmFzZV9yb3VuZGVkX2Nvcm5lclsxXSkudG9TdHJpbmcoKSk7XG4gICAgICAgIHJlY3Quc2V0QXR0cmlidXRlKCdyeCcsIChiYXNlX3JvdW5kZWRfY29ybmVyWzBdL3pvb20pLnRvU3RyaW5nKCkpO1xuICAgICAgICByZWN0LnNldEF0dHJpYnV0ZSgneCcsIHBhcnNlSW50KC0xMCAvIHpvb20pLnRvU3RyaW5nKCkpO1xuICAgICAgICByZWN0LnNldEF0dHJpYnV0ZSgnd2lkdGgnLCAoc2VsZi5uYXZfd2lkdGgpLnRvU3RyaW5nKCkpO1xuICAgICAgICBzZWxmLnpvb20gPSB6b29tO1xuICAgICAgICB0b2dnbGVyLmNhbGwodGhpcyx2aXNpYmxlKTtcbiAgICAgICAgc2VsZi5yZWZyZXNoKCk7XG4gICAgfTtcblxuICAgIGNsb3NlX2dyb3VwLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJyxmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHZpc2libGUpIHtcbiAgICAgICAgICAgIHNlbGYuaGlkZSh0cnVlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbGYuc2hvdyh0cnVlKTtcbiAgICAgICAgfVxuICAgIH0sZmFsc2UpO1xufTtcblxudmFyIGJ1aWxkVHJhY2tQYW5lID0gZnVuY3Rpb24odHJhY2tfY2FudmFzLGRyYWdhbmRkcm9wKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgdmFyIGNsb3NlX2J1dHRvbnMsIGNvbnRyb2xsZXJfYnV0dG9ucywgZWRpdF9lbmFibGVkO1xuXG4gICAgdmFyIG5hdl93aWR0aF90cmFja19jYW52YXNfY3RtID0gMDtcblxuICAgIFNWR0NhbnZhcyh0cmFja19jYW52YXMpO1xuICAgIHRyYWNrX2NhbnZhcy5zZXRBdHRyaWJ1dGUoJ3ByZXNlcnZlQXNwZWN0UmF0aW8nLCd4TWluWU1pbiBtZWV0Jyk7XG5cblxuXG4gICAgdmFyIHRyYWNrX3JlY3RzID0gW107XG5cbiAgICBzZWxmLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHdoaWxlICh0cmFja19jYW52YXMuZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgdHJhY2tfY2FudmFzLnJlbW92ZUNoaWxkKHRyYWNrX2NhbnZhcy5maXJzdENoaWxkKTtcbiAgICAgICAgfVxuICAgICAgICB0cmFja19yZWN0cyA9IFtdO1xuICAgICAgICBjdG1fcmVmcmVzaCA9IFtdO1xuLy8gICAgICAgICAgICBzZWxmLnJlZnJlc2goKTtcbiAgICB9O1xuXG4gICAgdmFyIGN0bV9yZWZyZXNoID0gW107XG5cbiAgICBzZWxmLmlzRWRpdGluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZWRpdF9lbmFibGVkO1xuICAgIH07XG5cbiAgICBzZWxmLnJlZnJlc2ggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgKGNsb3NlX2J1dHRvbnMgfHwgW10pLmZvckVhY2goZnVuY3Rpb24oYnV0dG9uKSB7XG4gICAgICAgICAgICBidXR0b24uc2V0QXR0cmlidXRlKCd2aXNpYmlsaXR5JywgZWRpdF9lbmFibGVkID8gJ3Zpc2libGUnIDogJ2hpZGRlbicpO1xuICAgICAgICB9KTtcbiAgICAgICAgKGNvbnRyb2xsZXJfYnV0dG9ucyB8fCBbXSkuZm9yRWFjaChmdW5jdGlvbihidXR0b24pIHtcbiAgICAgICAgICAgIGJ1dHRvbi5zZXRBdHRyaWJ1dGUoJ3Zpc2liaWxpdHknLCBlZGl0X2VuYWJsZWQgPyAnaGlkZGVuJyA6ICd2aXNpYmxlJyk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZWRpdF9lbmFibGVkKSB7XG4gICAgICAgICAgICB0b2dnbGVNb3VzZUV2ZW50cy5jYWxsKHRoaXMsdHJ1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0b2dnbGVNb3VzZUV2ZW50cy5jYWxsKHRoaXMsZmFsc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRyYWNrX2NhbnZhcy5nZXRBdHRyaWJ1dGUoJ2Rpc3BsYXknKSA9PSAnbm9uZScgfHwgdHJhY2tfY2FudmFzLnN0eWxlLmRpc3BsYXkgPT0gJ25vbmUnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN0bV9yZWZyZXNoLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmF2X2JhY2sgPSB0cmFja19jYW52YXMub3duZXJTVkdFbGVtZW50LmdldEVsZW1lbnRCeUlkKCduYXZfYmFjaycpO1xuXG4gICAgICAgIHZhciBjdG0gPSBuYXZfYmFjay5nZXRTY3JlZW5DVE0oKS5pbnZlcnNlKCkubXVsdGlwbHkodHJhY2tfY2FudmFzLmdldFNjcmVlbkNUTSgpKS5pbnZlcnNlKCk7XG4gICAgICAgIHZhciBiYWNrX3dpZHRoID0gKG5hdl9iYWNrLmdldEJCb3goKS53aWR0aCArIG5hdl9iYWNrLmdldEJCb3goKS54KTtcbiAgICAgICAgdmFyIHBvaW50ID0gdHJhY2tfY2FudmFzLmNyZWF0ZVNWR1BvaW50KCk7XG4gICAgICAgIHBvaW50LnggPSBiYWNrX3dpZHRoO1xuICAgICAgICBwb2ludC55ID0gMDtcbiAgICAgICAgbmF2X3dpZHRoX3RyYWNrX2NhbnZhc19jdG0gPSBwb2ludC5tYXRyaXhUcmFuc2Zvcm0oY3RtKS54O1xuICAgICAgICBjdG1fcmVmcmVzaC5mb3JFYWNoKGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgICAgICB2YXIgd2lkdGggPSAwO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB3aWR0aCA9IGVsLmdldEJCb3goKS53aWR0aDtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBidWcgd2l0aCBGaXJlZm94IG9uIHNvbWUgZWxlbWVudHMgZ2V0dGluZ1xuICAgICAgICAgICAgICAgIC8vIHRoZSBib3VuZGluZyBib3guIFdlIHNpbGVudGx5IGZhaWwgaGVyZSwgYXMgSSBjYW4ndFxuICAgICAgICAgICAgICAgIC8vIGZpZ3VyZSBvdXQgd2h5IHRoZSBjYWxsIHRvIGdldEJCb3ggZmFpbHMuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIHdpZHRoID4gMCkge1xuICAgICAgICAgICAgICAgIHZhciBhX3kgPSAvdHJhbnNsYXRlXFwoKC0/XFxkK1xcLj9cXGQqKVxccyosP1xccyooLT9cXGQrXFwuP1xcZCopXFwpLy5leGVjKGVsLmdldEF0dHJpYnV0ZSgndHJhbnNmb3JtJykgfHwgJycpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYV95ICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGFfeSA9IGFfeVsyXTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHZhciBuZXdfeCA9IG5hdl93aWR0aF90cmFja19jYW52YXNfY3RtLSAxLjUqcGFyc2VJbnQoZWwuZ2V0QXR0cmlidXRlKCd3aWR0aCcpLDEwKTtcbiAgICAgICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsJ3RyYW5zbGF0ZSgnK25ld194KycsJythX3krJyknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHZhciB0b2dnbGVNb3VzZUV2ZW50cyA9IGZ1bmN0aW9uKG9uKSB7XG4gICAgICAgIGlmICh0cmFja19yZWN0cykge1xuICAgICAgICAgICAgKHRyYWNrX3JlY3RzIHx8IFtdKS5mb3JFYWNoKGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgICAgICAgICAgZWwuc2V0QXR0cmlidXRlKCdvcGFjaXR5JyxvbiA/ICcxJzogKHRvdWNoX2VuYWJsZWQgPyBcIjAuNVwiIDogXCIwLjFcIikgKTtcbiAgICAgICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoJ3BvaW50ZXItZXZlbnRzJywgb24gPyAnYWxsJyA6ICdub25lJyk7XG4gICAgICAgICAgICAgICAgb24gPyBlbC5wYXJlbnROb2RlLnNldEF0dHJpYnV0ZSgnZHJhZ2VuYWJsZWQnLCd0cnVlJykgOiBlbC5wYXJlbnROb2RlLnJlbW92ZUF0dHJpYnV0ZSgnZHJhZ2VuYWJsZWQnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGJlYW4uYWRkKHNlbGYsJ3RvZ2dsZUVkaXQnLGZ1bmN0aW9uKCkge1xuICAgICAgICBlZGl0X2VuYWJsZWQgPSB0eXBlb2YgZWRpdF9lbmFibGVkID09ICd1bmRlZmluZWQnID8gdHJ1ZSA6ICEgZWRpdF9lbmFibGVkO1xuICAgICAgICBkcmFnYW5kZHJvcC5kaXNhYmxlZCA9ICEgZWRpdF9lbmFibGVkO1xuICAgICAgICB0b2dnbGVNb3VzZUV2ZW50cy5jYWxsKHNlbGYsZWRpdF9lbmFibGVkKTtcbiAgICBcbiAgICAgICAgc2VsZi5oaWRlKCk7XG4gICAgICAgIHNlbGYuc2hvdygpO1xuICAgICAgICBcbiAgICAgICAgKGNsb3NlX2J1dHRvbnMgfHwgW10pLmZvckVhY2goZnVuY3Rpb24oYnV0dG9uKSB7XG4gICAgICAgICAgICBidXR0b24uc2V0QXR0cmlidXRlKCd2aXNpYmlsaXR5JywgZWRpdF9lbmFibGVkID8gJ3Zpc2libGUnIDogJ2hpZGRlbicpO1xuICAgICAgICB9KTtcbiAgICAgICAgKGNvbnRyb2xsZXJfYnV0dG9ucyB8fCBbXSkuZm9yRWFjaChmdW5jdGlvbihidXR0b24pIHtcbiAgICAgICAgICAgIGJ1dHRvbi5zZXRBdHRyaWJ1dGUoJ3Zpc2liaWxpdHknLCBlZGl0X2VuYWJsZWQgPyAnaGlkZGVuJyA6ICd2aXNpYmxlJyk7XG4gICAgICAgIH0pO1xuXG4gICAgfSk7XG4gICAgXG4gICAgdGhpcy5zZXRWaWV3Qm94ID0gZnVuY3Rpb24odmlld0JveCkge1xuICAgICAgICB0cmFja19jYW52YXMuc2V0QXR0cmlidXRlKCd2aWV3Qm94Jyx2aWV3Qm94KTtcbiAgICB9O1xuXG4gICAgdHJhY2tfY2FudmFzLnN0eWxlLmhlaWdodCA9ICcxMDAlJztcbiAgICB0cmFja19jYW52YXMuc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgdHJhY2tfY2FudmFzLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywnMTAwJScpOyAgICAgICAgXG4gICAgdHJhY2tfY2FudmFzLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCcxMDAlJyk7XG5cblxuICAgIHRoaXMucmVuZGVyVHJhY2sgPSBmdW5jdGlvbih0cmFjayx5LGhlaWdodCxvcHRpb25zKSB7XG4gICAgICAgIHZhciBsYWJlbF9ncm91cCA9IHRyYWNrX2NhbnZhcy5ncm91cCgpO1xuICAgICAgICB2YXIgYV9yZWN0ID0gdHJhY2tfY2FudmFzLnJlY3QoMCx5LCcxMDAlJyxoZWlnaHQpO1xuICAgICAgICBhX3JlY3Quc2V0QXR0cmlidXRlKCdzdHJva2UnLCcjMDAwMDAwJyk7XG4gICAgICAgIGFfcmVjdC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS13aWR0aCcsJzInKTtcbiAgICAgICAgYV9yZWN0LnNldEF0dHJpYnV0ZSgnZmlsbCcsJ3VybCgjc2ltcGxlX2dyYWRpZW50KScpO1xuICAgICAgICBhX3JlY3Quc2V0QXR0cmlidXRlKCdvcGFjaXR5Jyx0b3VjaF9lbmFibGVkID8gJzAuNScgOiAnMC4xJyk7XG4gICAgICAgIGFfcmVjdC5zZXRBdHRyaWJ1dGUoJ3BvaW50ZXItZXZlbnRzJywnbm9uZScpO1xuICAgICAgICB0cmFja19yZWN0cyA9IHRyYWNrX3JlY3RzIHx8IFtdO1xuICAgIFxuICAgICAgICB0cmFja19yZWN0cy5wdXNoKGFfcmVjdCk7XG4gICAgXG4gICAgICAgIGxhYmVsX2dyb3VwLnB1c2goYV9yZWN0KTtcblxuICAgICAgICAvLyBVc2UgdGhlc2UgZm9yIGRlYnVnZ2luZyBwb3NpdGlvbmluZ1xuICAgIFxuICAgICAgICAvLyB2YXIgciA9IHRyYWNrX2NhbnZhcy5yZWN0KDAseS1oZWlnaHQsaGVpZ2h0LGhlaWdodCk7XG4gICAgICAgIC8vIHIuc2V0QXR0cmlidXRlKCdmaWxsJywnI2ZmMDAwMCcpO1xuICAgICAgICAvLyBsYWJlbF9ncm91cC5wdXNoKHIpO1xuICAgICAgICAvLyBcbiAgICAgICAgLy8gciA9IHRyYWNrX2NhbnZhcy5yZWN0KDAseStoZWlnaHQsaGVpZ2h0LGhlaWdodCk7XG4gICAgICAgIC8vIHIuc2V0QXR0cmlidXRlKCdmaWxsJywnI2ZmMDAwMCcpO1xuICAgICAgICAvLyBsYWJlbF9ncm91cC5wdXNoKHIpO1xuICAgIFxuICAgIFxuICAgICAgICB2YXIgdGV4dF9zY2FsZSA9IChvcHRpb25zICYmIG9wdGlvbnNbJ2ZvbnQtc2NhbGUnXSkgPyBvcHRpb25zWydmb250LXNjYWxlJ10gOiAxO1xuICAgICAgICB2YXIgdGV4dF9sZWZ0ID0gNC8zKnRvdWNoX3NjYWxlKmhlaWdodCp0ZXh0X3NjYWxlOyAgICAgICAgICAgIFxuICAgICAgICB2YXIgYV90ZXh0ID0gdHJhY2tfY2FudmFzLnRleHQodGV4dF9sZWZ0LHkrMC41KmhlaWdodCx0cmFjay5mdWxsbmFtZSB8fCB0cmFjay5uYW1lKTtcbiAgICAgICAgYV90ZXh0LnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgaGVpZ2h0KTtcbiAgICAgICAgYV90ZXh0LnNldEF0dHJpYnV0ZSgnd2lkdGgnLCBoZWlnaHQpO1xuICAgICAgICBhX3RleHQuc2V0QXR0cmlidXRlKCdmb250LXNpemUnLDAuNipoZWlnaHQqdGV4dF9zY2FsZSk7XG4gICAgICAgIGFfdGV4dC5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLCcjZmZmZmZmJyk7XG4gICAgICAgIGFfdGV4dC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZScsJyNmZmZmZmYnKTtcbiAgICAgICAgYV90ZXh0LnNldEF0dHJpYnV0ZSgnc3Ryb2tlLXdpZHRoJywnMCcpO1xuICAgICAgICBhX3RleHQuZmlyc3RDaGlsZC5zZXRBdHRyaWJ1dGUoJ2R5JywgJzAuNWV4Jyk7XG5cbiAgICAgICAgLy8gciA9IHRyYWNrX2NhbnZhcy5yZWN0KDMqaGVpZ2h0KnRleHRfc2NhbGUseSswLjUqaGVpZ2h0LDIqaGVpZ2h0LDIqaGVpZ2h0KTtcbiAgICAgICAgLy8gci5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLCcjMDBmZjAwJyk7XG4gICAgICAgIC8vIGxhYmVsX2dyb3VwLnB1c2gocik7XG5cbiAgICAgICAgbGFiZWxfZ3JvdXAucHVzaChhX3RleHQpO1xuICAgIFxuICAgICAgICBhX3RleHQuc2V0QXR0cmlidXRlKCdwb2ludGVyLWV2ZW50cycsJ25vbmUnKTtcbiAgICBcbiAgICAgICAgdmFyIGNpcmM7XG4gICAgXG4gICAgICAgIGlmICh0cmFjay5ocmVmICkge1xuICAgICAgICAgICAgYV9hbmNob3IgPSB0cmFja19jYW52YXMuYSh0cmFjay5ocmVmKTtcbiAgICAgICAgICAgIHZhciBpY29uX25hbWUgPSBudWxsO1xuICAgICAgICAgICAgdmFyIGljb25fbWV0cmljcyA9IFswLjUqaGVpZ2h0KnRleHRfc2NhbGUsMCxoZWlnaHQqdGV4dF9zY2FsZSp0b3VjaF9zY2FsZV07XG4gICAgICAgICAgICBpY29uX21ldHJpY3NbMV0gPSAtMC41KihpY29uX21ldHJpY3NbMl0gLSBoZWlnaHQpO1xuXG4gICAgICAgICAgICBjaXJjID0gdHJhY2tfY2FudmFzLmNpcmNsZShpY29uX21ldHJpY3NbMF0rMC41Kmljb25fbWV0cmljc1syXSwwLjUqaGVpZ2h0LDAuNSppY29uX21ldHJpY3NbMl0pO1xuICAgICAgICAgICAgY2lyYy5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLCcjZmZmZmZmJyk7XG4gICAgICAgICAgICBjaXJjLnNldEF0dHJpYnV0ZSgnb3BhY2l0eScsJzAuMScpO1xuICAgICAgICAgICAgYV9hbmNob3IuYXBwZW5kQ2hpbGQoY2lyYyk7XG4gICAgICAgIFxuICAgICAgICAgICAgdmFyIHVybF90eXBlID0gdHJhY2suaHJlZjtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdXJsX3R5cGUgPT09ICdzdHJpbmcnICYmIHVybF90eXBlLm1hdGNoKC9eamF2YXNjcmlwdFxcOi8pKSB7XG4gICAgICAgICAgICAgICAgaWNvbl9uYW1lID0gJyNwbHVzX2ljb24nO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdXJsX3R5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBpY29uX25hbWUgPSAnI3BsdXNfaWNvbic7XG4gICAgICAgICAgICAgICAgYV9hbmNob3Iuc2V0QXR0cmlidXRlKCdocmVmJywnIycpO1xuICAgICAgICAgICAgICAgIGFfYW5jaG9yLnJlbW92ZUF0dHJpYnV0ZSgndGFyZ2V0Jyk7XG4gICAgICAgICAgICAgICAgYV9hbmNob3IuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdXJsX3R5cGUuY2FsbCgpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChlLnByZXZlbnREZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnJldHVyblJlc3VsdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChlLnN0b3BQcm9wYWdhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuY2FuY2VsQnViYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9LGZhbHNlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWNvbl9uYW1lID0gJyNuZXdfbGlua19pY29uJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0cmFjay5pY29uKSB7XG4gICAgICAgICAgICAgICAgaWNvbl9uYW1lID0gdHJhY2suaWNvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBhX3VzZSA9IHRyYWNrX2NhbnZhcy51c2UoaWNvbl9uYW1lLGljb25fbWV0cmljc1swXSxpY29uX21ldHJpY3NbMV0saWNvbl9tZXRyaWNzWzJdLGljb25fbWV0cmljc1syXSk7XG4gICAgICAgICAgICBhX3VzZS5zdHlsZS5jdXJzb3IgPSAncG9pbnRlcic7XG4gICAgICAgICAgICBhX2FuY2hvci5hcHBlbmRDaGlsZChhX3VzZSk7XG4gICAgICAgICAgICBhX2FuY2hvci5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsJ3RyYW5zbGF0ZSgnKyhuYXZfd2lkdGhfdHJhY2tfY2FudmFzX2N0bSAtIDEuNSppY29uX21ldHJpY3NbMl0pKycsJyt5KycpJyk7XG4gICAgICAgICAgICBhX2FuY2hvci5zZXRBdHRyaWJ1dGUoJ3dpZHRoJyxpY29uX21ldHJpY3NbMl0udG9TdHJpbmcoKSk7XG4gICAgICAgICAgICBjdG1fcmVmcmVzaC5wdXNoKGFfYW5jaG9yKTtcbiAgICAgICAgfVxuICAgIFxuICAgICAgICBsYWJlbF9ncm91cC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JyxmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGxhYmVsX2dyb3VwLm9ubW91c2VvdmVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgbGFiZWxfZ3JvdXAub25tb3VzZW91dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfSxmYWxzZSk7XG5cbiAgICAgICAgbGFiZWxfZ3JvdXAuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgbGFiZWxfZ3JvdXAub25tb3VzZW92ZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBsYWJlbF9ncm91cC5vbm1vdXNlb3V0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9LGZhbHNlKTtcbiAgICBcbiAgICAgICAgZHJhZ2FuZGRyb3AuY2FsbCh0aGlzLGFfcmVjdCxsYWJlbF9ncm91cCx0cmFjayx0cmFja19jYW52YXMpO1xuICAgIFxuICAgICAgICAoZnVuY3Rpb24oKSB7XG4gICAgICAgIFxuICAgICAgICAgICAgaWYgKHRyYWNrLmdyb3VwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgICAgIHZhciB0X2hlaWdodCA9IDAuNSpoZWlnaHQqdG91Y2hfc2NhbGU7ICAgICAgICAgICAgXG5cbiAgICAgICAgICAgIGlmICggISBjbG9zZV9idXR0b25zKSB7XG4gICAgICAgICAgICAgICAgY2xvc2VfYnV0dG9ucyA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgICAgIHZhciBjbG9zZXIgPSB0cmFja19jYW52YXMuY3Jvc3NlZF9jaXJjbGUoMS41KnRfaGVpZ2h0LDAsdF9oZWlnaHQpO1xuICAgICAgICAgICAgY2xvc2VyLnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJywndHJhbnNsYXRlKDAsJysoeSswLjUqaGVpZ2h0KSsnKSBzY2FsZSgnK3RleHRfc2NhbGUrJyknKTtcbiAgICAgICAgICAgIGNsb3Nlci5maXJzdENoaWxkLnNldEF0dHJpYnV0ZSgnZmlsbCcsJ3VybCgjcmVkXzNkKScpO1xuICAgICAgICAgICAgZm9yICh2YXIgbm9kZXMgPSBjbG9zZXIuY2hpbGROb2RlcywgaSA9IDAsIGxlbiA9IG5vZGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbm9kZXNbaV0uc2V0QXR0cmlidXRlKCdzdHJva2Utd2lkdGgnLCh0X2hlaWdodC80KS50b1N0cmluZygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNsb3Nlci5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgZHJhZ2FuZGRyb3Auc3BsaWNlRnVuY3Rpb24odHJhY2spO1xuICAgICAgICAgICAgfSxmYWxzZSk7XG4gICAgICAgICAgICBsYWJlbF9ncm91cC5wdXNoKGNsb3Nlcik7XG4gICAgICAgICAgICBjbG9zZV9idXR0b25zLnB1c2goY2xvc2VyKTtcbiAgICAgICAgICAgIGNsb3Nlci5zZXRBdHRyaWJ1dGUoJ3Zpc2liaWxpdHknLCAnaGlkZGVuJyk7XG4gICAgICAgIFxuICAgICAgICB9KSgpO1xuICAgICAgICBpZiAodGhpcy5pc0NvbnRyb2xsZXIodHJhY2spKSB7XG4gICAgICAgICAgICBpZiAoICEgY29udHJvbGxlcl9idXR0b25zKSB7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlcl9idXR0b25zID0gW107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB0X2hlaWdodCA9IDAuNSpoZWlnaHQqdG91Y2hfc2NhbGU7XG4gICAgICAgICAgICB2YXIgZXhwYW5kZXIgPSB0cmFja19jYW52YXMuZ3JvdXAoKTtcbiAgICAgICAgICAgIGNpcmMgPSB0cmFja19jYW52YXMuY2lyY2xlKDEuNSp0X2hlaWdodCwwLHRfaGVpZ2h0KTtcbiAgICAgICAgICAgIGNpcmMuc2V0QXR0cmlidXRlKCdmaWxsJywnI2ZmZmZmZicpO1xuICAgICAgICAgICAgY2lyYy5zZXRBdHRyaWJ1dGUoJ29wYWNpdHknLCcwLjEnKTtcbiAgICAgICAgICAgIGV4cGFuZGVyLnB1c2goY2lyYyk7XG5cbiAgICAgICAgICAgIHZhciB0X21ldHJpY3MgPSBbMS4xKnRfaGVpZ2h0LC0xLjI1KnRfaGVpZ2h0LDIuMjUqdF9oZWlnaHQsKC0wLjUqdF9oZWlnaHQpLDEuMSp0X2hlaWdodCwwLjI1KnRfaGVpZ2h0XTtcbiAgICAgICAgXG4gICAgICAgICAgICB0X21ldHJpY3NbMV0gKz0gMC41Kih0X2hlaWdodCAtIDAqaGVpZ2h0KTtcbiAgICAgICAgICAgIHRfbWV0cmljc1szXSArPSAwLjUqKHRfaGVpZ2h0IC0gMCpoZWlnaHQpO1xuICAgICAgICAgICAgdF9tZXRyaWNzWzVdICs9IDAuNSoodF9oZWlnaHQgLSAwKmhlaWdodCk7XG5cbiAgICAgICAgXG4gICAgICAgICAgICB2YXIgZ3JvdXBfdG9nZ2xlciA9IHRyYWNrX2NhbnZhcy5wb2x5KCcnK3RfbWV0cmljc1swXSsnLCcrdF9tZXRyaWNzWzFdKycgJyt0X21ldHJpY3NbMl0rJywnK3RfbWV0cmljc1szXSsnICcrdF9tZXRyaWNzWzRdKycsJyt0X21ldHJpY3NbNV0pO1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNDb250cm9sbGVyRXhwYW5kZWQodHJhY2spKSB7XG4gICAgICAgICAgICAgICAgZXhwYW5kZXIuc2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nLCd0cmFuc2xhdGUoMCwnKyh5KzAuNSpoZWlnaHQpKycpIHNjYWxlKCcrdGV4dF9zY2FsZSsnKSByb3RhdGUoOTAsJysoMS41KnRfaGVpZ2h0KSsnLCcrdF9tZXRyaWNzWzNdKycpJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGV4cGFuZGVyLnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJywndHJhbnNsYXRlKDAsJysoeSswLjUqaGVpZ2h0KSsnKSBzY2FsZSgnK3RleHRfc2NhbGUrJyknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGdyb3VwX3RvZ2dsZXIuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCAxLjc1KnRfaGVpZ2h0KTtcbiAgICAgICAgICAgIGdyb3VwX3RvZ2dsZXIuc2V0QXR0cmlidXRlKCdmb250LXNpemUnLDEuNSp0X2hlaWdodCk7XG4gICAgICAgICAgICBncm91cF90b2dnbGVyLnNldEF0dHJpYnV0ZSgnZmlsbCcsJyNmZmZmZmYnKTtcbiAgICAgICAgICAgIGdyb3VwX3RvZ2dsZXIuc2V0QXR0cmlidXRlKCdwb2ludGVyLWV2ZW50cycsJ25vbmUnKTtcbiAgICAgICAgXG4gICAgICAgICAgICBleHBhbmRlci5wdXNoKGdyb3VwX3RvZ2dsZXIpO1xuXG4gICAgICAgICAgICBleHBhbmRlci5zdHlsZS5jdXJzb3IgPSAncG9pbnRlcic7XG4gICAgICAgICAgICBleHBhbmRlci5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgYmVhbi5maXJlKHRyYWNrLCdfZXhwYW5kZXZlbnQnKTtcbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5pc0NvbnRyb2xsZXJFeHBhbmRlZCh0cmFjaykpIHtcbiAgICAgICAgICAgICAgICAgICAgZXhwYW5kZXIuc2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nLCd0cmFuc2xhdGUoMCwnKyh5KzAuNSpoZWlnaHQpKycpIHNjYWxlKCcrdGV4dF9zY2FsZSsnKSByb3RhdGUoOTAsJysoMS41KnRfaGVpZ2h0KSsnLCcrdF9tZXRyaWNzWzNdKycpJyk7ICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGV4cGFuZGVyLnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJywndHJhbnNsYXRlKDAsJysoeSswLjUqaGVpZ2h0KSsnKSBzY2FsZSgnK3RleHRfc2NhbGUrJyknKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LGZhbHNlKTtcbiAgICAgICAgICAgIGxhYmVsX2dyb3VwLnB1c2goZXhwYW5kZXIpO1xuXG4gICAgICAgICAgICBjb250cm9sbGVyX2J1dHRvbnMucHVzaChleHBhbmRlcik7XG4gICAgICAgICAgICBleHBhbmRlci5zZXRBdHRyaWJ1dGUoJ3Zpc2liaWxpdHknLCAnaGlkZGVuJyk7XG4gICAgICAgIH1cbiAgICB9O1xufTtcblxuZXhwb3J0IGRlZmF1bHQgTmF2aWdhdGlvbjtcbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./js/lib/CondensedSequenceRendererNavigation.js\n");

/***/ }),

/***/ "./js/lib/Dragger.js":
/*!***************************!*\
  !*** ./js/lib/Dragger.js ***!
  \***************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _hammer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../hammer.js */ \"./js/hammer.js\");\n/* harmony import */ var _bean__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../bean */ \"./js/bean.js\");\n/**\n *  @fileOverview   Basic classes and defitions for a Gene Ontology ID based map\n */\n\n\n\n\n/**\n * @class       State class for adding panning functionality to an element. Each element that is to be panned needs a new instance\n *              of the Dragger to store state.\n * @author      hjjoshi\n * @requires    svgweb\n */\nconst Dragger = function Dragger() {\n    this.oX = 0;\n    this.oY = 0;\n    this.dX = 0;\n    this.dY = 0;\n    this.dragging = false;\n    this.targetElement = null;\n};\n\n/**\n * Connect this dragger to a particular element. If an SVG element is given, panning occurs within the bounding box of the SVG, and\n * the image is shifted by using the currentTranslate property. If a regular HTML element is given, the scrollLeft and scrollTop attributes\n * are used to move the viewport around. \n * @param {Element} targetElement Element to enable panning upon.\n */\nDragger.prototype.applyToElement = function (targetElement, enabled) {\n    var self = this;\n    if (typeof enabled !== 'undefined') {\n        self.enabled = enabled;\n    }\n\n    var momentum = [];\n\n    if (targetElement.nodeName == 'svg') {\n        targetElement.getPosition = function () {\n            var translate = targetElement.currentTranslateCache || targetElement.currentTranslate;\n            var dX = translate.x;\n            var dY = translate.y;\n\n            return [dX, dY];\n        };\n\n        targetElement.shiftPosition = function (x, y) {\n            var p = { 'x': x, 'y': y };\n            var viewBoxScale = 1;\n            var vbox = this.getAttribute('viewBox');\n\n            var min_x, min_y, width, height;\n\n            if (vbox) {\n                var viewBox = this.getAttribute('viewBox').split(' ');\n                viewBoxScale = parseFloat(this.width.baseVal.value) / parseFloat(viewBox[2]);\n                min_x = 0;\n                min_y = parseInt(viewBox[1], 10);\n                width = parseInt(viewBox[2], 10);\n                height = parseInt(viewBox[3], 10);\n            } else {\n                min_x = 0;\n                min_y = 0;\n                width = targetElement.width;\n                height = targetElement.height;\n            }\n\n            if (targetElement.style.GomapScrollLeftMargin) {\n                min_x += targetElement.style.GomapScrollLeftMargin;\n            }\n\n            if (self.dragging) {\n                p.x = viewBoxScale * (p.x - self.oX);\n                p.y = viewBoxScale * (p.y - self.oY);\n\n                p.x += self.dX;\n                p.y += self.dY;\n                p.y = 0;\n            }\n\n            if (targetElement._snapback) {\n                clearTimeout(targetElement._snapback);\n                targetElement._snapback = null;\n            }\n\n            if (p.x > viewBoxScale * min_x) {\n                /* Element has shifted too far to the right\n                   Induce some gravity towards the left side\n                   of the screen\n                */\n\n                let do_snapback = function do_snapback() {\n                    var evObj;\n                    var translate = targetElement.currentTranslateCache || targetElement.currentTranslate;\n                    if (Math.abs(translate.x - viewBoxScale * min_x) > 35) {\n                        var new_pos = 0.95 * (translate.x - viewBoxScale * min_x);\n                        if (new_pos < viewBoxScale * min_x) {\n                            new_pos = viewBoxScale * min_x;\n                        }\n\n                        targetElement.setCurrentTranslateXY(new_pos, 0);\n                        window.requestAnimationFrame(do_snapback, targetElement);\n                        //                        targetElement._snapback = setTimeout(arguments.callee,10);\n                        if (document.createEvent) {\n                            var evObj = document.createEvent('Events');\n                            evObj.initEvent('panstart', false, true);\n                            targetElement.dispatchEvent(evObj);\n                        }\n                    } else {\n                        targetElement.setCurrentTranslateXY(viewBoxScale * min_x, 0);\n                        if (document.createEvent) {\n                            var evObj = document.createEvent('Events');\n                            evObj.initEvent('pan', false, true);\n                            targetElement.dispatchEvent(evObj);\n                        }\n                        if (!self.dragging) {\n                            _bean__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fire(targetElement, 'panend');\n                        }\n                        targetElement._snapback = null;\n                    }\n                };\n                targetElement._snapback = setTimeout(do_snapback, 300);\n            }\n\n            var min_val = viewBoxScale * (width - 2 * min_x);\n\n            if (min_x === 0) {\n                min_val *= 0.90;\n            }\n            if (p.x < 0 && Math.abs(p.x) > min_val) {\n                /* Element has shifted too far to the left\n                   Induce some gravity to the right side of the screen\n                */\n                let do_snapback = function do_snapback() {\n                    var evObj;\n                    var translate = targetElement.currentTranslateCache || targetElement.currentTranslate;\n                    if (Math.abs(translate.x - -1 * min_val) > 35) {\n                        var new_pos = 0.95 * translate.x;\n                        if (new_pos > -1 * min_val) {\n                            new_pos = -1 * min_val;\n                        }\n                        targetElement.setCurrentTranslateXY(new_pos, 0);\n                        window.requestAnimationFrame(do_snapback, targetElement);\n                        //                        targetElement._snapback = setTimeout(arguments.callee,10);\n                        if (document.createEvent) {\n                            evObj = document.createEvent('Events');\n                            evObj.initEvent('panstart', false, true);\n                            targetElement.dispatchEvent(evObj);\n                        }\n                    } else {\n                        targetElement.setCurrentTranslateXY(-1 * min_val, 0);\n                        if (document.createEvent) {\n                            evObj = document.createEvent('Events');\n                            evObj.initEvent('pan', false, true);\n                            targetElement.dispatchEvent(evObj);\n                        }\n                        if (!self.dragging) {\n                            _bean__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fire(targetElement, 'panend');\n                        }\n                        targetElement._snapback = null;\n                    }\n                };\n                targetElement._snapback = setTimeout(do_snapback, 300);\n            }\n\n            if (p.y > viewBoxScale * min_y) {\n                p.y = viewBoxScale * min_y;\n            }\n            if (Math.abs(p.y) > 0.50 * viewBoxScale * height) {\n                p.y = -0.50 * viewBoxScale * height;\n            }\n            if (this.setCurrentTranslateXY) {\n                this.setCurrentTranslateXY(p.x, p.y);\n            } else if (this.currentTranslate.setXY) {\n                this.currentTranslate.setXY(p.x, p.y);\n            } else {\n                this.currentTranslate.x = p.x;\n                this.currentTranslate.y = p.y;\n            }\n\n            if (document.createEvent) {\n                var evObj = document.createEvent('Events');\n                evObj.initEvent('pan', false, true);\n                this.dispatchEvent(evObj);\n            }\n        };\n    } else {\n        targetElement.getPosition = function () {\n            return [this.scrollLeft, this.scrollTop];\n        };\n        targetElement.shiftPosition = function (x, y) {\n            this.scrollLeft = self.dX + (self.oX - x);\n            this.scrollTop = self.dY + (self.oY - y);\n\n            if (document.createEvent) {\n                var evObj = document.createEvent('Events');\n                evObj.initEvent('pan', false, true);\n                this.dispatchEvent(evObj);\n            }\n        };\n    }\n\n    var stationary;\n\n    var svgMouseDown = function svgMouseDown(evt) {\n        if (!self.enabled) {\n            return true;\n        }\n\n        var targ = self.targetElement ? self.targetElement : targetElement;\n        var positions = mousePosition(evt);\n        self.dragging = true;\n        self.moved = false;\n        targ.setAttribute('dragging', 'true');\n\n        if (self.targetElement) {\n\n            self.oX = positions[0];\n            self.oY = positions[1];\n            self.dX = self.targetElement.scrollLeft;\n            self.dY = self.targetElement.scrollTop;\n            evt.preventDefault(true);\n            return;\n        }\n\n        var p = targetElement.createSVGPoint();\n        positions = mousePosition(evt);\n        p.x = positions[0];\n        p.y = positions[1];\n\n        var rootCTM = this.firstElementChild.getScreenCTM();\n        self.matrix = rootCTM.inverse();\n\n        p = p.matrixTransform(self.matrix);\n\n        self.dX = targetElement.getPosition()[0];\n        self.dY = targetElement.getPosition()[1];\n\n        self.oX = p.x;\n        self.oY = p.y;\n\n        evt.preventDefault(true);\n\n        if (document.createEvent) {\n            self.clicktimeout = setTimeout(function () {\n                var evObj = document.createEvent('Events');\n                self.clicktimeout = null;\n                evObj.initEvent('panstart', false, true);\n                targ.dispatchEvent(evObj);\n            }, 200);\n        }\n    };\n\n    var mousePosition = function mousePosition(evt) {\n        var posx = 0;\n        var posy = 0;\n        if (!evt) {\n            evt = window.event;\n        }\n        if (evt.pageX || evt.pageY) {\n            posx = evt.pageX;\n            posy = evt.pageY;\n        } else if (evt.clientX || evt.clientY) {\n            posx = evt.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;\n            posy = evt.clientY + document.body.scrollTop + document.documentElement.scrollTop;\n        }\n        if (self.targetElement) {\n            posx = evt.screenX;\n            posy = evt.screenY;\n        }\n        return [posx, posy];\n    };\n\n    var mouseMove = function mouseMove(evt) {\n        var positions = mousePosition(evt);\n        if (self.clicktimeout && Math.abs(positions[0] - self.oX) < 10) {\n            mouseUp();\n        }\n        if (!self.dragging) {\n            return;\n        }\n\n        targetElement.shiftPosition(positions[0], positions[1]);\n\n        evt.preventDefault(true);\n    };\n\n    var mouseDown = function mouseDown(evt) {\n        self.dragging = true;\n        self.moved = false;\n        var positions = mousePosition(evt);\n        self.oX = positions[0];\n        self.oY = positions[1];\n        self.dX = targetElement.getPosition()[0];\n        self.dY = targetElement.getPosition()[1];\n        evt.preventDefault(true);\n        var targ = self.targetElement ? self.targetElement : targetElement;\n        targ.setAttribute('dragging', 'true');\n        if (document.createEvent) {\n            var evObj = document.createEvent('Events');\n            evObj.initEvent('panstart', false, true);\n            targ.dispatchEvent(evObj);\n        }\n    };\n\n    var svgMouseMove = function svgMouseMove(evt) {\n        if (!self.enabled) {\n            return true;\n        }\n        // this.style.cursor = 'url(http://maps.gstatic.com/intl/en_us/mapfiles/openhand_8_8.cur), move';\n        if (!self.dragging) {\n            return;\n        }\n\n        // if (stationary) {\n        //     clearTimeout(stationary);\n        //     stationary = null;\n        // }\n        // \n        // stationary = window.setTimeout(function() {\n        //     self.dragging = false;\n        // },200);        \n\n        doMouseMove.call(this, evt);\n    };\n\n    var doMouseMove = function doMouseMove(evt) {\n        var positions = mousePosition(evt);\n        // this.style.cursor = 'url(http://maps.gstatic.com/intl/en_us/mapfiles/closedhand_8_8.cur), -moz-grabbing';\n\n        if (self.targetElement) {\n            self.targetElement.shiftPosition(positions[0], positions[1]);\n            self.moved = true;\n            return;\n        }\n\n        var p = targetElement._cachedpoint || targetElement.createSVGPoint();\n        targetElement._cachedpoint = p;\n\n        positions = mousePosition(evt);\n\n        p.x = positions[0];\n        p.y = positions[1];\n\n        var rootCTM = targetElement._cachedrctm || targetElement.firstElementChild.getScreenCTM();\n        targetElement._cachedrctm = rootCTM;\n\n        p = p.matrixTransform(self.matrix);\n        targetElement.shiftPosition(p.x, p.y);\n        self.moved = true;\n        //        momentum = p.x;        \n    };\n\n    var captureClick = function captureClick(evt) {\n        evt.stopPropagation();\n        this.removeEventListener('click', captureClick, true);\n    };\n\n    var mouseUp = function mouseUp(evt) {\n        if (self.clicktimeout) {\n            clearTimeout(self.clicktimeout);\n            self.clicktimeout = null;\n        }\n        if (!self.enabled) {\n            return true;\n        }\n        self.oX = 0;\n        self.oY = 0;\n        self.dX = null;\n        self.dY = null;\n        self.dragging = false;\n        evt.preventDefault(true);\n\n        var targ = self.targetElement ? self.targetElement : targetElement;\n\n        targ.removeAttribute('dragging');\n\n        if (!targ._snapback) {\n            _bean__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fire(targ, 'panend', true);\n        }\n\n        if (evt.type == 'mouseup' && self.moved) {\n            targ.addEventListener('click', captureClick, true);\n        }\n        self.moved = false;\n    };\n\n    var mouseOut = function mouseOut(e) {\n        if (!self.dragging || !self.enabled) {\n            return true;\n        }\n        if (this == self.targetElement) {\n            mouseUp(e);\n        }\n\n        if (e.target != this && !e.currentTarget) {\n            return;\n        }\n\n        var toTarget = e.relatedTarget ? e.relatedTarget : e.toElement;\n\n        while (toTarget !== null) {\n            if (toTarget == this) {\n                return;\n            }\n            toTarget = toTarget.parentNode;\n        }\n        mouseUp(e);\n    };\n\n    if (!targetElement.addEventListener) {\n        targetElement.addEventListener = function (name, func, bool) {\n            this.attachEvent(name, func);\n        };\n    }\n\n    targetElement.addEventListener('touchstart', function (e) {\n        if (!self.enabled) {\n            return;\n        }\n        var targ = self.targetElement ? self.targetElement : targetElement;\n        if (self.momentum) {\n            window.clearTimeout(self.momentum);\n            self.momentum = null;\n        }\n        if (e.touches.length == 1) {\n            var positions = mousePosition(e.touches[0]);\n            var p;\n            if (targ.nodeName == 'svg') {\n                p = targ.createSVGPoint();\n                p.x = positions[0];\n                p.y = positions[1];\n                var rootCTM = this.getScreenCTM();\n                self.matrix = rootCTM.inverse();\n                p = p.matrixTransform(self.matrix);\n            } else {\n                p.x = positions[0];\n                p.y = positions[1];\n            }\n            self.oX = p.x;\n            self.oY = p.y;\n\n            self.dragging = true;\n            self.dX = targ.getPosition()[0];\n            self.dY = targ.getPosition()[1];\n\n            self._momentum_shrinker = setInterval(function () {\n                momentum.shift();\n            }, 20);\n            if (document.createEvent) {\n                var evObj = document.createEvent('Events');\n                evObj.initEvent('panstart', false, true);\n                targ.dispatchEvent(evObj);\n            }\n            e.preventDefault();\n        }\n    }, false);\n\n    // document.addEventListener('touchmove',function(e) {\n    //     console.log('touchmove for the document');\n    //     console.log(self.dragging);\n    //     if ( ! self.dragging ) {\n    //         return;\n    //     }\n    //     console.log(\"Ending the drag for document move\");\n    //     self.oX = 0;\n    //     self.oY = 0;\n    //     self.dX = null;\n    //     self.dY = null;\n    //     self.dragging = false;\n    // \n    //     var targ = self.targetElement ? self.targetElement : targetElement;      \n    // \n    //     if (document.createEvent) {\n    //         var evObj = document.createEvent('Events');\n    //         evObj.initEvent('panend',false,true);\n    //         targ.dispatchEvent(evObj);\n    //     }      \n    // },false);\n\n    targetElement.addEventListener('touchmove', function (e) {\n        if (self.drag_zoom) {\n            return;\n        }\n        if (self.momentum) {\n            window.clearTimeout(self.momentum);\n            self.momentum = null;\n        }\n\n        if (e.touches.length != 1) {\n            self.dragging = false;\n        }\n\n        var targ = self.targetElement ? self.targetElement : targetElement;\n\n        var positions = mousePosition(e.touches[0]);\n\n        if (!positions || !self.matrix) {\n            return;\n        }\n\n        var p;\n        if (targ.nodeName == 'svg') {\n            p = targ.createSVGPoint();\n            p.x = positions[0];\n            p.y = positions[1];\n            p = p.matrixTransform(self.matrix);\n        } else {\n            p.x = positions[0];\n            p.y = positions[1];\n        }\n\n        if (self.dragging && 6 * Math.abs(self.oX - p.x) > Math.abs(self.oY - p.y)) {\n            // FIXME - PASSIVE\n            // e.preventDefault();\n        }\n\n        if (!self.dragging) {\n            self.oX = 0;\n            self.oY = 0;\n            self.dX = null;\n            self.dY = null;\n            return;\n        }\n        if (momentum.length > 3) {\n            momentum.splice(2);\n        }\n        targ.shiftPosition(p.x, p.y);\n        momentum.push(targ.getPosition()[0] - self.dX);\n    }, { passive: true });\n    // FIXME - PASSIVE\n\n    var momentum_func = function momentum_func(e) {\n        if (!self.enabled) {\n            return true;\n        }\n        if (!self.dragging) {\n            clearInterval(self._momentum_shrinker);\n            mouseUp(e);\n            return;\n        }\n        var targ = self.targetElement ? self.targetElement : targetElement;\n        var delta = 0;\n\n        if (momentum.length > 0) {\n            var last_val = momentum[0];\n            momentum.forEach(function (m) {\n                if (typeof last_val != 'undefined') {\n                    delta += m - last_val;\n                }\n                last_val = m;\n            });\n            delta = delta / momentum.length;\n        }\n        var start = targ.getPosition()[0];\n        var start_delta = delta;\n        self.dragging = false;\n        if (self.momentum) {\n            window.clearTimeout(self.momentum);\n        }\n        self.momentum = 1;\n        let moment = function moment() {\n            start = targ.getPosition()[0];\n            if (self.dragging) {\n                start += self.oX - self.dX;\n            } else {\n                self.oX = 0;\n                self.dX = 0;\n            }\n            targ.shiftPosition(start + delta, 0);\n            start = start + delta;\n            delta = delta * 0.5;\n\n            if (delta > 0 && Math.abs(start_delta / delta) < 10) {\n                window.requestAnimationFrame(moment, targ);\n                //                window.setTimeout(arguments.callee,50);\n            } else {\n                self.momentum = null;\n                clearInterval(self._momentum_shrinker);\n                mouseUp(e);\n            }\n        };\n\n        moment();\n    };\n\n    targetElement.addEventListener('touchend', momentum_func, false);\n\n    if (targetElement.nodeName == 'svg') {\n        targetElement.addEventListener('mousedown', svgMouseDown, false);\n        targetElement.addEventListener('mousemove', svgMouseMove, false);\n        targetElement.addEventListener('mouseup', mouseUp, false);\n        targetElement.addEventListener('mouseout', mouseOut, false);\n        if (self.targetElement) {\n            self.targetElement.addEventListener('mouseout', mouseOut, false);\n        }\n        // targetElement.addEventListener('click',function(ev) { ev.preventDefault(); ev.stopPropagation(); },false);\n    } else {\n        targetElement.addEventListener('mousedown', mouseDown, false);\n        targetElement.addEventListener('mousemove', mouseMove, false);\n        targetElement.addEventListener('mouseup', mouseUp, false);\n        targetElement.addEventListener('mouseout', mouseOut, false);\n    }\n};\n\nDragger.addTouchZoomControls = function (zoomElement, touchElement, controller) {\n    if (!controller) {\n        controller = { \"enabled\": true };\n    }\n    Dragger.prototype.addTouchZoomControls.call(controller, zoomElement, touchElement);\n    return controller;\n};\n\nDragger.prototype.addTouchZoomControls = function (zoomElement, touchElement) {\n    var self = this;\n    var last_touch_start = null;\n    var xform = null;\n    var max_y = null;\n    var mousePosition = function mousePosition(evt) {\n        var posx = 0;\n        var posy = 0;\n        if (!evt) {\n            evt = window.event;\n        }\n        if (evt.pageX || evt.pageY) {\n            posx = evt.pageX;\n            posy = evt.pageY;\n        } else if (evt.clientX || evt.clientY) {\n            posx = evt.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;\n            posy = evt.clientY + document.body.scrollTop + document.documentElement.scrollTop;\n        }\n        if (self.targetElement) {\n            posx = evt.screenX;\n            posy = evt.screenY;\n        }\n        return [posx, posy];\n    };\n\n    var drag_zoom_move = function drag_zoom_move(evt) {\n        if (!self.enabled || !self.drag_zoom) {\n            return;\n        }\n        if (evt.touches.length == 1) {\n            var positions = mousePosition(evt.touches[0]);\n            var p = {};\n            p.x = positions[0];\n            p.y = positions[1];\n\n            if (touchElement.nodeName == 'svg') {\n                p = touchElement.createSVGPoint();\n                p.x = positions[0];\n                p.y = positions[1];\n                p = p.matrixTransform(xform);\n            }\n            zoomElement.zoom = self.zoom_start * Math.pow(10, (p.y - zoomElement.zoomCenter.y) / max_y);\n        }\n    };\n\n    var drag_zoom_end = function drag_zoom_end(evt) {\n        touchElement.removeEventListener('touchmove', drag_zoom_move);\n        touchElement.removeEventListener('touchend', drag_zoom_end);\n        self.drag_zoom = false;\n    };\n\n    touchElement.addEventListener('touchstart', function (e) {\n        if (!self.enabled) {\n            return;\n        }\n        if (e.touches.length == 1) {\n            if (new Date().getTime() - last_touch_start <= 300) {\n                self.drag_zoom = true;\n                self.zoom_start = zoomElement.zoom;\n\n                var positions = mousePosition(e.touches[0]);\n                var positions2 = mousePosition(e.touches[0]);\n                var p;\n                if (touchElement.nodeName == 'svg') {\n                    p = touchElement.createSVGPoint();\n                    p.x = 0.5 * (positions[0] + positions2[0]);\n                    p.y = 0.5 * (positions[1] + positions2[1]);\n                    var rootCTM = this.getScreenCTM();\n                    xform = rootCTM.inverse();\n                    p = p.matrixTransform(xform);\n                    max_y = parseInt(touchElement.getAttribute('viewBox').split(' ')[3]);\n                } else {\n                    p.x = 0.5 * (positions[0] + positions2[0]);\n                    p.y = 0.5 * (positions[1] + positions2[1]);\n                }\n                zoomElement.zoomCenter = p;\n                touchElement.addEventListener('touchmove', drag_zoom_move, { passive: true });\n                touchElement.addEventListener('touchend', drag_zoom_end, false);\n                e.preventDefault();\n                return;\n            }\n\n            last_touch_start = new Date().getTime();\n            return;\n        }\n        if (e.touches.length == 2) {\n            var positions = mousePosition(e.touches[0]);\n            var positions2 = mousePosition(e.touches[1]);\n            var p;\n            if (touchElement.nodeName == 'svg') {\n                p = touchElement.createSVGPoint();\n                p.x = 0.5 * (positions[0] + positions2[0]);\n                p.y = 0.5 * (positions[1] + positions2[1]);\n                var rootCTM = this.getScreenCTM();\n                self.matrix = rootCTM.inverse();\n                p = p.matrixTransform(self.matrix);\n            } else {\n                p.x = 0.5 * (positions[0] + positions2[0]);\n                p.y = 0.5 * (positions[1] + positions2[1]);\n            }\n            zoomElement.zoomCenter = p;\n            e.preventDefault();\n        }\n    }, false);\n\n    // touchElement.addEventListener('gesturestart',function(e) {\n    Hammer(touchElement).on(\"touch\", function (e) {\n        if (!self.enabled) {\n            return;\n        }\n        // zoomElement.zoomLeft = null;\n        var zoomStart = zoomElement.zoom;\n\n        var zoomscale = function zoomscale(ev) {\n            if (zoomElement.zoomCenter) {\n                zoomElement.zoom = zoomStart * ev.gesture.scale;\n            }\n            ev.preventDefault();\n        };\n        Hammer(touchElement).on('pinch', zoomscale, false);\n        let hammer_release = function hammer_release(ev) {\n            Hammer(touchElement).off('pinch', zoomscale);\n            Hammer(touchElement).off('release', hammer_release);\n            zoomElement.zoomCenter = null;\n            zoomElement.zoomLeft = null;\n            _bean__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fire(zoomElement, 'gestureend');\n        };\n        Hammer(touchElement).on('release', hammer_release, false);\n        e.preventDefault();\n    }, false);\n};\n\n/**\n * Given an element that implements a zoom attribute, creates a div that contains controls for controlling the zoom attribute. The\n * zoomElement must have a zoom attribute, and can fire the zoomChange event whenever the zoom value is changed on the object. The\n * scrollwheel is connected to this element so that when the mouse hovers over the controls, it can control the zoom using only\n * the scroll wheel.\n * @param {Object} zoomElement Element to control the zooming for.\n * @param {Number} min Minimum value for the zoom attribute (default 0)\n * @param {Number} max Maximum value for the zoom attribute (default 10)\n * @param {Number} precision Step precision for the zoom control (default 0.5)\n * @param {Number} value Default value for this control\n * @returns DIV element containing the controls\n * @type Element\n * @see GOMap.Diagram#event:zoomChange\n */\nDragger.addZoomControls = function (zoomElement, min, max, precision, value) {\n    min = min || 0;\n    max = max || 10;\n    precision = precision || 0.5;\n    value = value || zoomElement.zoom || min;\n\n    var controls_container = document.createElement('div');\n\n    var zoomIn = document.createElement('input');\n    zoomIn.setAttribute('type', 'button');\n    zoomIn.setAttribute('value', '+');\n    var zoomOut = document.createElement('input');\n    zoomOut.setAttribute('type', 'button');\n    zoomOut.setAttribute('value', '-');\n    var reset = document.createElement('input');\n    reset.setAttribute('type', 'button');\n    reset.setAttribute('value', 'Reset');\n\n    controls_container.appendChild(reset);\n\n    reset.addEventListener('click', function () {\n        zoomElement.zoom = zoomElement.defaultZoom || value;\n    }, false);\n\n    var range = document.createElement('input');\n    range.setAttribute('min', min);\n    range.setAttribute('max', max);\n    range.setAttribute('step', precision);\n    range.setAttribute('value', value);\n    range.setAttribute('type', 'range');\n    range.setAttribute('style', '-webkit-appearance: slider-horizontal; width: 100%; position: absolute; top: 0px; bottom: 0px; margin-top: 0.5em; left: 100%; margin-left: -0.5em;');\n\n    if (range.type == 'range') {\n\n        range.addEventListener('change', function () {\n            zoomElement.zoom = this.value;\n        }, false);\n\n        var evFunction = null;\n        if (zoomElement.addEventListener) {\n            evFunction = zoomElement.addEventListener;\n        } else if (zoomElement.bind) {\n            evFunction = zoomElement.bind;\n        }\n\n        evFunction.apply(zoomElement, ['zoomChange', function () {\n            range.value = zoomElement.zoom;\n        }, false]);\n\n        reset.style.margin = '0px';\n        reset.style.display = 'block';\n        reset.style.position = 'absolute';\n        reset.style.top = '0px';\n\n        controls_container.appendChild(range);\n        controls_container.style.height = '100%';\n    } else {\n        if (!zoomIn.addEventListener) {\n            var addevlis = function addevlis(name, func) {\n                this.attachEvent(name, func);\n            };\n            zoomIn.addEventListener = addevlis;\n            reset.addEventListener = addevlis;\n            zoomOut.addEventListener = addevlis;\n        }\n        zoomIn.addEventListener('click', function () {\n            zoomElement.zoom += precision;\n        }, false);\n        zoomOut.addEventListener('click', function () {\n            zoomElement.zoom -= precision;\n        }, false);\n\n        zoomIn.style.margin = '0px';\n        zoomIn.style.display = 'block';\n        zoomIn.style.position = 'absolute';\n        zoomIn.style.top = '0px';\n        zoomIn.style.left = '29px';\n\n        zoomOut.style.margin = '0px';\n        zoomOut.style.display = 'block';\n        zoomOut.style.position = 'absolute';\n        zoomOut.style.top = '0px';\n\n        reset.style.margin = '0px';\n        reset.style.display = 'block';\n        reset.style.position = 'absolute';\n        reset.style.top = '23px';\n        reset.style.left = '3px';\n\n        controls_container.appendChild(zoomOut);\n        controls_container.appendChild(zoomIn);\n        controls_container.appendChild(reset);\n    }\n\n    this.addScrollZoomControls(zoomElement, controls_container, precision);\n\n    return controls_container;\n};\n\nDragger.addScrollBar = function (target, controlElement, scrollContainer) {\n    return;\n    var scroller = document.createElement('div');\n    while (scrollContainer.childNodes.length > 0) {\n        scrollContainer.removeChild(scrollContainer.firstChild);\n    }\n    scrollContainer.appendChild(scroller);\n    if (!scrollContainer.style.position) {\n        scrollContainer.style.position = 'relative';\n    }\n    scrollContainer.style.overflowX = 'scroll';\n    scrollContainer.style.overflowY = 'hidden';\n\n    scroller.style.position = 'absolute';\n    scroller.style.left = '0px';\n    scroller.style.width = '100%';\n    scroller.style.height = '100%';\n\n    _bean__WEBPACK_IMPORTED_MODULE_1__[\"default\"].remove(scrollContainer, 'scroll');\n    _bean__WEBPACK_IMPORTED_MODULE_1__[\"default\"].remove(scrollContainer, 'mouseenter');\n    _bean__WEBPACK_IMPORTED_MODULE_1__[\"default\"].add(scrollContainer, 'mouseenter', function () {\n        var size = 100 * target.getTotalLength() / target.getVisibleLength();\n        scroller.cached_width = scroller.clientWidth / size;\n        disabled = true;\n        scrollContainer.scrollLeft += 1;\n        scrollContainer.scrollLeft -= 1;\n        setTimeout(function () {\n            disabled = false;\n        }, 0);\n        _bean__WEBPACK_IMPORTED_MODULE_1__[\"default\"].remove(scrollContainer, 'scroll', scroll_func);\n        _bean__WEBPACK_IMPORTED_MODULE_1__[\"default\"].add(scrollContainer, 'scroll', scroll_func);\n    });\n    var disabled = false;\n\n    if (window.matchMedia) {\n        window.matchMedia('print').addListener(function (matcher) {\n            disabled = true;\n            setTimeout(function () {\n                disabled = false;\n            }, 0);\n        });\n    }\n    var scroll_func = function scroll_func() {\n        if (disabled || !console) {\n            return;\n        }\n        if (document.createEvent) {\n            var evObj = document.createEvent('Events');\n            evObj.initEvent('panstart', false, true);\n            controlElement.dispatchEvent(evObj);\n        }\n        var size = 100 * target.getTotalLength() / target.getVisibleLength();\n        var width = scroller.cached_width ? parseInt(scroller.cached_width * size) : scroller.clientWidth;\n        target.setLeftPosition(parseInt(scrollContainer.scrollLeft * target.getTotalLength() / width));\n        _bean__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fire(controlElement, 'panend');\n    };\n\n    _bean__WEBPACK_IMPORTED_MODULE_1__[\"default\"].add(scrollContainer, 'scroll', scroll_func);\n\n    var left_setter;\n\n    _bean__WEBPACK_IMPORTED_MODULE_1__[\"default\"].add(controlElement, 'pan', function () {\n        cancelAnimationFrame(left_setter);\n        var size = 100 * target.getTotalLength() / target.getVisibleLength();\n        scroller.style.width = parseInt(size) + '%';\n        var width = scroller.cached_width ? parseInt(scroller.cached_width * size) : scroller.clientWidth;\n        scroller.cached_width = width / size;\n\n        var left_shift = parseInt(width * (target.getLeftPosition() / target.getTotalLength()));\n        _bean__WEBPACK_IMPORTED_MODULE_1__[\"default\"].remove(scrollContainer, 'scroll', scroll_func);\n        left_setter = requestAnimationFrame(function () {\n            // Rendering bottleneck\n            scrollContainer.scrollLeft = left_shift;\n        });\n    });\n};\n\n/**\n * Connect the scroll wheel to the controls to control zoom\n */\nDragger.addScrollZoomControls = function (target, controlElement, precision) {\n    precision = precision || 0.5;\n    var self;\n\n    if (this.enabled === null) {\n        self = { 'enabled': true };\n    } else {\n        self = this;\n    }\n    var hookEvent = function hookEvent(element, eventName, callback) {\n        if (typeof element == 'string') {\n            element = document.getElementById(element);\n        }\n\n        if (element === null) {\n            return;\n        }\n\n        if (element.addEventListener) {\n            if (eventName == 'mousewheel') {\n                element.addEventListener('DOMMouseScroll', callback, false);\n                element.addEventListener('wheel', callback, false);\n            }\n            element.addEventListener(eventName, callback, false);\n        } else if (element.attachEvent) {\n            element.attachEvent(\"on\" + eventName, callback);\n        }\n    };\n\n    var mousePosition = function mousePosition(evt) {\n        if (!self.enabled) {\n            return;\n        }\n        var posx = 0;\n        var posy = 0;\n        if (!evt) {\n            evt = window.event;\n        }\n        if (evt.pageX || evt.pageY) {\n            posx = evt.pageX;\n            posy = evt.pageY;\n        } else if (evt.clientX || evt.clientY) {\n            posx = evt.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;\n            posy = evt.clientY + document.body.scrollTop + document.documentElement.scrollTop;\n        }\n\n        var p = {};\n\n        if (controlElement.nodeName == 'svg') {\n            p = controlElement.createSVGPoint();\n            p.x = posx;\n            p.y = posy;\n            /* Fix for mouse position in firefox - http://jsfiddle.net/JNKgR/6/ */\n            var rootCTM = controlElement.firstElementChild.getScreenCTM();\n            self.matrix = rootCTM.inverse();\n            p = p.matrixTransform(self.matrix);\n        } else {\n            p.x = posx;\n            p.y = posy;\n        }\n        return p;\n    };\n\n    var mouseWheel = function mouseWheel(e) {\n        if (!self.enabled) {\n            return;\n        }\n        e = e ? e : window.event;\n        var wheelData = e.detail ? e.detail * -1 : e.wheelDelta;\n        if (!wheelData) {\n            wheelData = e.deltaY;\n        }\n        target.zoomCenter = mousePosition(e);\n\n        if (wheelData > 0) {\n            target.zoom = target.zoom += precision;\n        } else {\n            target.zoom = target.zoom -= precision;\n        }\n\n        if (e.preventDefault) {\n            e.preventDefault();\n        }\n\n        e.returnValue = false;\n        e.stopPropagation();\n\n        return false;\n    };\n\n    var isFF = false;\n\n    if (navigator.userAgent.indexOf('Gecko') >= 0) {\n        isFF = parseFloat(navigator.userAgent.split('Firefox/')[1]) || undefined;\n    }\n\n    if (isFF && typeof svgweb != 'undefined' && svgweb.getHandlerType() == 'native') {\n        hookEvent(controlElement, 'mousewheel', mouseWheel);\n    } else {\n        hookEvent(controlElement, 'mousewheel', mouseWheel);\n    }\n\n    hookEvent(controlElement, 'mousemove', function (e) {\n        if (!self.enabled) {\n            return;\n        }\n        if (target.zoomCenter && Math.abs(target.zoomCenter.x - mousePosition(e).x) > 100) {\n            target.zoomCenter = null;\n            target.zoomLeft = null;\n        }\n    });\n\n    return self;\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Dragger);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9qcy9saWIvRHJhZ2dlci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9qcy9saWIvRHJhZ2dlci5qcz9jMTBiIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogIEBmaWxlT3ZlcnZpZXcgICBCYXNpYyBjbGFzc2VzIGFuZCBkZWZpdGlvbnMgZm9yIGEgR2VuZSBPbnRvbG9neSBJRCBiYXNlZCBtYXBcbiAqL1xuXG5pbXBvcnQgJy4uL2hhbW1lci5qcyc7XG5pbXBvcnQgYmVhbiBmcm9tICcuLi9iZWFuJztcblxuLyoqXG4gKiBAY2xhc3MgICAgICAgU3RhdGUgY2xhc3MgZm9yIGFkZGluZyBwYW5uaW5nIGZ1bmN0aW9uYWxpdHkgdG8gYW4gZWxlbWVudC4gRWFjaCBlbGVtZW50IHRoYXQgaXMgdG8gYmUgcGFubmVkIG5lZWRzIGEgbmV3IGluc3RhbmNlXG4gKiAgICAgICAgICAgICAgb2YgdGhlIERyYWdnZXIgdG8gc3RvcmUgc3RhdGUuXG4gKiBAYXV0aG9yICAgICAgaGpqb3NoaVxuICogQHJlcXVpcmVzICAgIHN2Z3dlYlxuICovXG5jb25zdCBEcmFnZ2VyID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMub1ggPSAwO1xuICB0aGlzLm9ZID0gMDtcbiAgdGhpcy5kWCA9IDA7XG4gIHRoaXMuZFkgPSAwO1xuICB0aGlzLmRyYWdnaW5nID0gZmFsc2U7XG4gIHRoaXMudGFyZ2V0RWxlbWVudCA9IG51bGw7XG59O1xuXG4vKipcbiAqIENvbm5lY3QgdGhpcyBkcmFnZ2VyIHRvIGEgcGFydGljdWxhciBlbGVtZW50LiBJZiBhbiBTVkcgZWxlbWVudCBpcyBnaXZlbiwgcGFubmluZyBvY2N1cnMgd2l0aGluIHRoZSBib3VuZGluZyBib3ggb2YgdGhlIFNWRywgYW5kXG4gKiB0aGUgaW1hZ2UgaXMgc2hpZnRlZCBieSB1c2luZyB0aGUgY3VycmVudFRyYW5zbGF0ZSBwcm9wZXJ0eS4gSWYgYSByZWd1bGFyIEhUTUwgZWxlbWVudCBpcyBnaXZlbiwgdGhlIHNjcm9sbExlZnQgYW5kIHNjcm9sbFRvcCBhdHRyaWJ1dGVzXG4gKiBhcmUgdXNlZCB0byBtb3ZlIHRoZSB2aWV3cG9ydCBhcm91bmQuIFxuICogQHBhcmFtIHtFbGVtZW50fSB0YXJnZXRFbGVtZW50IEVsZW1lbnQgdG8gZW5hYmxlIHBhbm5pbmcgdXBvbi5cbiAqL1xuRHJhZ2dlci5wcm90b3R5cGUuYXBwbHlUb0VsZW1lbnQgPSBmdW5jdGlvbih0YXJnZXRFbGVtZW50LGVuYWJsZWQpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgaWYgKHR5cGVvZiBlbmFibGVkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBzZWxmLmVuYWJsZWQgPSBlbmFibGVkOyAgICAgICAgXG4gICAgfVxuICAgIFxuICAgIHZhciBtb21lbnR1bSA9IFtdO1xuXG4gICAgaWYgKHRhcmdldEVsZW1lbnQubm9kZU5hbWUgPT0gJ3N2ZycpIHtcbiAgICAgICAgdGFyZ2V0RWxlbWVudC5nZXRQb3NpdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHRyYW5zbGF0ZSA9IHRhcmdldEVsZW1lbnQuY3VycmVudFRyYW5zbGF0ZUNhY2hlIHx8IHRhcmdldEVsZW1lbnQuY3VycmVudFRyYW5zbGF0ZTtcbiAgICAgICAgICAgIHZhciBkWCA9IHRyYW5zbGF0ZS54O1xuICAgICAgICAgICAgdmFyIGRZID0gdHJhbnNsYXRlLnk7XG5cbiAgICAgICAgICAgIHJldHVybiBbZFgsIGRZXTtcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIHRhcmdldEVsZW1lbnQuc2hpZnRQb3NpdGlvbiA9IGZ1bmN0aW9uKHgseSkge1xuICAgICAgICAgICAgdmFyIHAgPSB7J3gnIDogeCwgJ3knIDogeSB9O1xuICAgICAgICAgICAgdmFyIHZpZXdCb3hTY2FsZSA9IDE7XG4gICAgICAgICAgICB2YXIgdmJveCA9IHRoaXMuZ2V0QXR0cmlidXRlKCd2aWV3Qm94Jyk7XG5cbiAgICAgICAgICAgIHZhciBtaW5feCxtaW5feSx3aWR0aCxoZWlnaHQ7XG5cbiAgICAgICAgICAgIGlmICh2Ym94KSB7XG4gICAgICAgICAgICAgICAgdmFyIHZpZXdCb3ggPSB0aGlzLmdldEF0dHJpYnV0ZSgndmlld0JveCcpLnNwbGl0KCcgJyk7XG4gICAgICAgICAgICAgICAgdmlld0JveFNjYWxlID0gcGFyc2VGbG9hdCh0aGlzLndpZHRoLmJhc2VWYWwudmFsdWUpIC8gcGFyc2VGbG9hdCh2aWV3Qm94WzJdKTtcbiAgICAgICAgICAgICAgICBtaW5feCA9IDA7XG4gICAgICAgICAgICAgICAgbWluX3kgPSBwYXJzZUludCh2aWV3Qm94WzFdLDEwKTtcbiAgICAgICAgICAgICAgICB3aWR0aCA9IHBhcnNlSW50KHZpZXdCb3hbMl0sMTApO1xuICAgICAgICAgICAgICAgIGhlaWdodCA9IHBhcnNlSW50KHZpZXdCb3hbM10sMTApO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtaW5feCA9IDA7XG4gICAgICAgICAgICAgICAgbWluX3kgPSAwO1xuICAgICAgICAgICAgICAgIHdpZHRoID0gdGFyZ2V0RWxlbWVudC53aWR0aDtcbiAgICAgICAgICAgICAgICBoZWlnaHQgPSB0YXJnZXRFbGVtZW50LmhlaWdodDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRhcmdldEVsZW1lbnQuc3R5bGUuR29tYXBTY3JvbGxMZWZ0TWFyZ2luKSB7XG4gICAgICAgICAgICAgICAgbWluX3ggKz0gdGFyZ2V0RWxlbWVudC5zdHlsZS5Hb21hcFNjcm9sbExlZnRNYXJnaW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmICggc2VsZi5kcmFnZ2luZyApIHtcbiAgICAgICAgICAgICAgICBwLnggPSB2aWV3Qm94U2NhbGUqKHAueCAtIHNlbGYub1gpO1xuICAgICAgICAgICAgICAgIHAueSA9IHZpZXdCb3hTY2FsZSoocC55IC0gc2VsZi5vWSk7XG5cbiAgICAgICAgICAgICAgICBwLnggKz0gc2VsZi5kWDtcbiAgICAgICAgICAgICAgICBwLnkgKz0gc2VsZi5kWTtcbiAgICAgICAgICAgICAgICBwLnkgPSAwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGFyZ2V0RWxlbWVudC5fc25hcGJhY2spIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGFyZ2V0RWxlbWVudC5fc25hcGJhY2spO1xuICAgICAgICAgICAgICAgIHRhcmdldEVsZW1lbnQuX3NuYXBiYWNrID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKHAueCA+IHZpZXdCb3hTY2FsZSAqIG1pbl94KSB7XG4gICAgICAgICAgICAgICAgLyogRWxlbWVudCBoYXMgc2hpZnRlZCB0b28gZmFyIHRvIHRoZSByaWdodFxuICAgICAgICAgICAgICAgICAgIEluZHVjZSBzb21lIGdyYXZpdHkgdG93YXJkcyB0aGUgbGVmdCBzaWRlXG4gICAgICAgICAgICAgICAgICAgb2YgdGhlIHNjcmVlblxuICAgICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgICAgICBsZXQgZG9fc25hcGJhY2sgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGV2T2JqO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHJhbnNsYXRlID0gdGFyZ2V0RWxlbWVudC5jdXJyZW50VHJhbnNsYXRlQ2FjaGUgfHwgdGFyZ2V0RWxlbWVudC5jdXJyZW50VHJhbnNsYXRlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnModHJhbnNsYXRlLnggLSAodmlld0JveFNjYWxlICogbWluX3gpKSA+IDM1ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5ld19wb3MgPSAwLjk1Kih0cmFuc2xhdGUueCAtICh2aWV3Qm94U2NhbGUgKiBtaW5feCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5ld19wb3MgPCAodmlld0JveFNjYWxlICogbWluX3gpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3X3BvcyA9ICh2aWV3Qm94U2NhbGUgKiBtaW5feCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldEVsZW1lbnQuc2V0Q3VycmVudFRyYW5zbGF0ZVhZKCBuZXdfcG9zLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZG9fc25hcGJhY2ssIHRhcmdldEVsZW1lbnQpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRFbGVtZW50Ll9zbmFwYmFjayA9IHNldFRpbWVvdXQoYXJndW1lbnRzLmNhbGxlZSwxMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG9jdW1lbnQuY3JlYXRlRXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXZPYmogPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnRzJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZPYmouaW5pdEV2ZW50KCdwYW5zdGFydCcsZmFsc2UsdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0RWxlbWVudC5kaXNwYXRjaEV2ZW50KGV2T2JqKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldEVsZW1lbnQuc2V0Q3VycmVudFRyYW5zbGF0ZVhZKCAodmlld0JveFNjYWxlICogbWluX3gpLCAwICk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG9jdW1lbnQuY3JlYXRlRXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZXZPYmogPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnRzJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZPYmouaW5pdEV2ZW50KCdwYW4nLGZhbHNlLHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldEVsZW1lbnQuZGlzcGF0Y2hFdmVudChldk9iaik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoISBzZWxmLmRyYWdnaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVhbi5maXJlKHRhcmdldEVsZW1lbnQsJ3BhbmVuZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0RWxlbWVudC5fc25hcGJhY2sgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0YXJnZXRFbGVtZW50Ll9zbmFwYmFjayA9IHNldFRpbWVvdXQoZG9fc25hcGJhY2ssMzAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIG1pbl92YWwgPSB2aWV3Qm94U2NhbGUgKiAoIHdpZHRoIC0gMiAqIG1pbl94ICk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChtaW5feCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIG1pbl92YWwgKj0gMC45MDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwLnggPCAwICYmIE1hdGguYWJzKHAueCkgPiBtaW5fdmFsKSB7XG4gICAgICAgICAgICAgICAgLyogRWxlbWVudCBoYXMgc2hpZnRlZCB0b28gZmFyIHRvIHRoZSBsZWZ0XG4gICAgICAgICAgICAgICAgICAgSW5kdWNlIHNvbWUgZ3Jhdml0eSB0byB0aGUgcmlnaHQgc2lkZSBvZiB0aGUgc2NyZWVuXG4gICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBsZXQgZG9fc25hcGJhY2sgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGV2T2JqO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHJhbnNsYXRlID0gdGFyZ2V0RWxlbWVudC5jdXJyZW50VHJhbnNsYXRlQ2FjaGUgfHwgdGFyZ2V0RWxlbWVudC5jdXJyZW50VHJhbnNsYXRlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnModHJhbnNsYXRlLnggLSAoLTEgKiBtaW5fdmFsKSkgPiAzNSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXdfcG9zID0gMC45NSoodHJhbnNsYXRlLngpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5ld19wb3MgPiAoLTEqbWluX3ZhbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdfcG9zID0gLTEqbWluX3ZhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldEVsZW1lbnQuc2V0Q3VycmVudFRyYW5zbGF0ZVhZKCBuZXdfcG9zLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZG9fc25hcGJhY2ssIHRhcmdldEVsZW1lbnQpO1xuLy8gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRFbGVtZW50Ll9zbmFwYmFjayA9IHNldFRpbWVvdXQoYXJndW1lbnRzLmNhbGxlZSwxMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG9jdW1lbnQuY3JlYXRlRXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldk9iaiA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudHMnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldk9iai5pbml0RXZlbnQoJ3BhbnN0YXJ0JyxmYWxzZSx0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRFbGVtZW50LmRpc3BhdGNoRXZlbnQoZXZPYmopO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0RWxlbWVudC5zZXRDdXJyZW50VHJhbnNsYXRlWFkoIC0xKm1pbl92YWwsIDApOyAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvY3VtZW50LmNyZWF0ZUV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZPYmogPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnRzJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZPYmouaW5pdEV2ZW50KCdwYW4nLGZhbHNlLHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldEVsZW1lbnQuZGlzcGF0Y2hFdmVudChldk9iaik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoISBzZWxmLmRyYWdnaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVhbi5maXJlKHRhcmdldEVsZW1lbnQsJ3BhbmVuZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0RWxlbWVudC5fc25hcGJhY2sgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0YXJnZXRFbGVtZW50Ll9zbmFwYmFjayA9IHNldFRpbWVvdXQoZG9fc25hcGJhY2ssMzAwKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHAueSA+IHZpZXdCb3hTY2FsZSAqIG1pbl95KSB7XG4gICAgICAgICAgICAgICAgcC55ID0gdmlld0JveFNjYWxlICogbWluX3k7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMocC55KSA+IDAuNTAqdmlld0JveFNjYWxlICogaGVpZ2h0ICkge1xuICAgICAgICAgICAgICAgIHAueSA9IC0wLjUwICogdmlld0JveFNjYWxlICogaGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuc2V0Q3VycmVudFRyYW5zbGF0ZVhZKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRDdXJyZW50VHJhbnNsYXRlWFkocC54LHAueSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuY3VycmVudFRyYW5zbGF0ZS5zZXRYWSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFRyYW5zbGF0ZS5zZXRYWShwLngscC55KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50VHJhbnNsYXRlLnggPSBwLng7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50VHJhbnNsYXRlLnkgPSBwLnk7ICAgICAgICAgIFxuICAgICAgICAgICAgfSAgICAgICAgICAgIFxuXG4gICAgICAgICAgICBpZiAoZG9jdW1lbnQuY3JlYXRlRXZlbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXZPYmogPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnRzJyk7XG4gICAgICAgICAgICAgICAgZXZPYmouaW5pdEV2ZW50KCdwYW4nLGZhbHNlLHRydWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChldk9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGFyZ2V0RWxlbWVudC5nZXRQb3NpdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIFt0aGlzLnNjcm9sbExlZnQsIHRoaXMuc2Nyb2xsVG9wXTtcbiAgICAgICAgfTtcbiAgICAgICAgdGFyZ2V0RWxlbWVudC5zaGlmdFBvc2l0aW9uID0gZnVuY3Rpb24oeCx5KSB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbExlZnQgPSBzZWxmLmRYICsgKHNlbGYub1ggLSB4KTtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsVG9wID0gc2VsZi5kWSArIChzZWxmLm9ZIC0geSk7XG5cbiAgICAgICAgICAgIGlmIChkb2N1bWVudC5jcmVhdGVFdmVudCkge1xuICAgICAgICAgICAgICAgIHZhciBldk9iaiA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudHMnKTtcbiAgICAgICAgICAgICAgICBldk9iai5pbml0RXZlbnQoJ3BhbicsZmFsc2UsdHJ1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2T2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgc3RhdGlvbmFyeTtcblxuICAgIHZhciBzdmdNb3VzZURvd24gPSBmdW5jdGlvbihldnQpIHtcbiAgICAgIGlmICggISBzZWxmLmVuYWJsZWQgKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIHZhciB0YXJnID0gc2VsZi50YXJnZXRFbGVtZW50ID8gc2VsZi50YXJnZXRFbGVtZW50IDogdGFyZ2V0RWxlbWVudDtcbiAgICAgIHZhciBwb3NpdGlvbnMgPSBtb3VzZVBvc2l0aW9uKGV2dCk7XG4gICAgICBzZWxmLmRyYWdnaW5nID0gdHJ1ZTtcbiAgICAgIHNlbGYubW92ZWQgPSBmYWxzZTtcbiAgICAgIHRhcmcuc2V0QXR0cmlidXRlKCdkcmFnZ2luZycsJ3RydWUnKTtcblxuICAgICAgaWYgKHNlbGYudGFyZ2V0RWxlbWVudCkge1xuXG4gICAgICAgICAgc2VsZi5vWCA9IHBvc2l0aW9uc1swXTtcbiAgICAgICAgICBzZWxmLm9ZID0gcG9zaXRpb25zWzFdO1xuICAgICAgICAgIHNlbGYuZFggPSBzZWxmLnRhcmdldEVsZW1lbnQuc2Nyb2xsTGVmdDtcbiAgICAgICAgICBzZWxmLmRZID0gc2VsZi50YXJnZXRFbGVtZW50LnNjcm9sbFRvcDtcbiAgICAgICAgICBldnQucHJldmVudERlZmF1bHQodHJ1ZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgcCA9IHRhcmdldEVsZW1lbnQuY3JlYXRlU1ZHUG9pbnQoKTtcbiAgICAgIHBvc2l0aW9ucyA9IG1vdXNlUG9zaXRpb24oZXZ0KTtcbiAgICAgIHAueCA9IHBvc2l0aW9uc1swXTtcbiAgICAgIHAueSA9IHBvc2l0aW9uc1sxXTtcblxuICAgICAgdmFyIHJvb3RDVE0gPSB0aGlzLmZpcnN0RWxlbWVudENoaWxkLmdldFNjcmVlbkNUTSgpO1xuICAgICAgc2VsZi5tYXRyaXggPSByb290Q1RNLmludmVyc2UoKTtcbiAgICAgIFxuICAgICAgcCA9IHAubWF0cml4VHJhbnNmb3JtKHNlbGYubWF0cml4KTtcblxuICAgICAgc2VsZi5kWCA9IHRhcmdldEVsZW1lbnQuZ2V0UG9zaXRpb24oKVswXTtcbiAgICAgIHNlbGYuZFkgPSB0YXJnZXRFbGVtZW50LmdldFBvc2l0aW9uKClbMV07XG5cbiAgICAgIHNlbGYub1ggPSBwLng7XG4gICAgICBzZWxmLm9ZID0gcC55O1xuXG4gICAgICBldnQucHJldmVudERlZmF1bHQodHJ1ZSk7XG4gICAgICBcbiAgICAgIGlmIChkb2N1bWVudC5jcmVhdGVFdmVudCkge1xuICAgICAgICAgIHNlbGYuY2xpY2t0aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgdmFyIGV2T2JqID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50cycpO1xuICAgICAgICAgICAgICBzZWxmLmNsaWNrdGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICAgIGV2T2JqLmluaXRFdmVudCgncGFuc3RhcnQnLGZhbHNlLHRydWUpO1xuICAgICAgICAgICAgICB0YXJnLmRpc3BhdGNoRXZlbnQoZXZPYmopO1xuICAgICAgICAgIH0sMjAwKTtcbiAgICAgIH1cblxuICAgIH07XG4gICAgXG4gICAgdmFyIG1vdXNlUG9zaXRpb24gPSBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgdmFyIHBvc3ggPSAwO1xuICAgICAgICB2YXIgcG9zeSA9IDA7XG4gICAgICAgIGlmICghZXZ0KSB7XG4gICAgICAgICAgICBldnQgPSB3aW5kb3cuZXZlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2dC5wYWdlWCB8fCBldnQucGFnZVkpICAgICB7XG4gICAgICAgICAgICBwb3N4ID0gZXZ0LnBhZ2VYO1xuICAgICAgICAgICAgcG9zeSA9IGV2dC5wYWdlWTtcbiAgICAgICAgfSBlbHNlIGlmIChldnQuY2xpZW50WCB8fCBldnQuY2xpZW50WSkgIHtcbiAgICAgICAgICAgIHBvc3ggPSBldnQuY2xpZW50WCArIGRvY3VtZW50LmJvZHkuc2Nyb2xsTGVmdCArIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0O1xuICAgICAgICAgICAgcG9zeSA9IGV2dC5jbGllbnRZICsgZG9jdW1lbnQuYm9keS5zY3JvbGxUb3AgKyBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWxmLnRhcmdldEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHBvc3ggPSBldnQuc2NyZWVuWDtcbiAgICAgICAgICAgIHBvc3kgPSBldnQuc2NyZWVuWTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gWyBwb3N4LCBwb3N5IF07XG4gICAgfTtcbiAgICBcbiAgICB2YXIgbW91c2VNb3ZlID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIHZhciBwb3NpdGlvbnMgPSBtb3VzZVBvc2l0aW9uKGV2dCk7XG4gICAgICAgIGlmIChzZWxmLmNsaWNrdGltZW91dCAmJiBNYXRoLmFicyhwb3NpdGlvbnNbMF0gLSBzZWxmLm9YKSA8IDEwICkge1xuICAgICAgICAgICAgbW91c2VVcCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc2VsZi5kcmFnZ2luZykge1xuICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0YXJnZXRFbGVtZW50LnNoaWZ0UG9zaXRpb24ocG9zaXRpb25zWzBdLHBvc2l0aW9uc1sxXSk7XG4gICAgICAgIFxuICAgICAgICBldnQucHJldmVudERlZmF1bHQodHJ1ZSk7XG4gICAgfTtcbiAgICBcbiAgICB2YXIgbW91c2VEb3duID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIHNlbGYuZHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICBzZWxmLm1vdmVkID0gZmFsc2U7XG4gICAgICAgIHZhciBwb3NpdGlvbnMgPSBtb3VzZVBvc2l0aW9uKGV2dCk7XG4gICAgICAgIHNlbGYub1ggPSBwb3NpdGlvbnNbMF07XG4gICAgICAgIHNlbGYub1kgPSBwb3NpdGlvbnNbMV07XG4gICAgICAgIHNlbGYuZFggPSB0YXJnZXRFbGVtZW50LmdldFBvc2l0aW9uKClbMF07XG4gICAgICAgIHNlbGYuZFkgPSB0YXJnZXRFbGVtZW50LmdldFBvc2l0aW9uKClbMV07XG4gICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCh0cnVlKTtcbiAgICAgICAgdmFyIHRhcmcgPSBzZWxmLnRhcmdldEVsZW1lbnQgPyBzZWxmLnRhcmdldEVsZW1lbnQgOiB0YXJnZXRFbGVtZW50O1xuICAgICAgICB0YXJnLnNldEF0dHJpYnV0ZSgnZHJhZ2dpbmcnLCd0cnVlJyk7XG4gICAgICAgIGlmIChkb2N1bWVudC5jcmVhdGVFdmVudCkge1xuICAgICAgICAgICAgdmFyIGV2T2JqID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50cycpO1xuICAgICAgICAgICAgZXZPYmouaW5pdEV2ZW50KCdwYW5zdGFydCcsZmFsc2UsdHJ1ZSk7XG4gICAgICAgICAgICB0YXJnLmRpc3BhdGNoRXZlbnQoZXZPYmopO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBcbiAgICB2YXIgc3ZnTW91c2VNb3ZlID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIGlmICghc2VsZi5lbmFibGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyB0aGlzLnN0eWxlLmN1cnNvciA9ICd1cmwoaHR0cDovL21hcHMuZ3N0YXRpYy5jb20vaW50bC9lbl91cy9tYXBmaWxlcy9vcGVuaGFuZF84XzguY3VyKSwgbW92ZSc7XG4gICAgICAgIGlmICghc2VsZi5kcmFnZ2luZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgKHN0YXRpb25hcnkpIHtcbiAgICAgICAgLy8gICAgIGNsZWFyVGltZW91dChzdGF0aW9uYXJ5KTtcbiAgICAgICAgLy8gICAgIHN0YXRpb25hcnkgPSBudWxsO1xuICAgICAgICAvLyB9XG4gICAgICAgIC8vIFxuICAgICAgICAvLyBzdGF0aW9uYXJ5ID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vICAgICBzZWxmLmRyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgIC8vIH0sMjAwKTsgICAgICAgIFxuICAgICAgICBcbiAgICAgICAgZG9Nb3VzZU1vdmUuY2FsbCh0aGlzLGV2dCk7XG4gICAgfTtcblxuICAgIHZhciBkb01vdXNlTW92ZSA9IGZ1bmN0aW9uKGV2dCkgeyAgICAgICAgXG4gICAgICAgIHZhciBwb3NpdGlvbnMgPSBtb3VzZVBvc2l0aW9uKGV2dCk7XG4gICAgICAgIC8vIHRoaXMuc3R5bGUuY3Vyc29yID0gJ3VybChodHRwOi8vbWFwcy5nc3RhdGljLmNvbS9pbnRsL2VuX3VzL21hcGZpbGVzL2Nsb3NlZGhhbmRfOF84LmN1ciksIC1tb3otZ3JhYmJpbmcnO1xuXG4gICAgICAgIGlmIChzZWxmLnRhcmdldEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHNlbGYudGFyZ2V0RWxlbWVudC5zaGlmdFBvc2l0aW9uKHBvc2l0aW9uc1swXSxwb3NpdGlvbnNbMV0pO1xuICAgICAgICAgICAgc2VsZi5tb3ZlZCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBcbiAgICAgICAgdmFyIHAgPSB0YXJnZXRFbGVtZW50Ll9jYWNoZWRwb2ludCB8fCB0YXJnZXRFbGVtZW50LmNyZWF0ZVNWR1BvaW50KCk7XG4gICAgICAgIHRhcmdldEVsZW1lbnQuX2NhY2hlZHBvaW50ID0gcDtcbiAgICAgICAgXG4gICAgICAgIHBvc2l0aW9ucyA9IG1vdXNlUG9zaXRpb24oZXZ0KTtcblxuICAgICAgICBwLnggPSBwb3NpdGlvbnNbMF07XG4gICAgICAgIHAueSA9IHBvc2l0aW9uc1sxXTtcblxuICAgICAgICB2YXIgcm9vdENUTSA9IHRhcmdldEVsZW1lbnQuX2NhY2hlZHJjdG0gfHwgdGFyZ2V0RWxlbWVudC5maXJzdEVsZW1lbnRDaGlsZC5nZXRTY3JlZW5DVE0oKTtcbiAgICAgICAgdGFyZ2V0RWxlbWVudC5fY2FjaGVkcmN0bSA9IHJvb3RDVE07XG4gICAgICAgIFxuICAgICAgICBwID0gcC5tYXRyaXhUcmFuc2Zvcm0oc2VsZi5tYXRyaXgpO1xuICAgICAgICB0YXJnZXRFbGVtZW50LnNoaWZ0UG9zaXRpb24ocC54LHAueSk7XG4gICAgICAgIHNlbGYubW92ZWQgPSB0cnVlO1xuLy8gICAgICAgIG1vbWVudHVtID0gcC54OyAgICAgICAgXG4gICAgfTtcblxuICAgIHZhciBjYXB0dXJlQ2xpY2sgPSBmdW5jdGlvbihldnQpIHtcbiAgICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIGNhcHR1cmVDbGljaywgdHJ1ZSk7XG4gICAgfTtcblxuICAgIHZhciBtb3VzZVVwID0gZnVuY3Rpb24oZXZ0KSB7IFxuICAgICAgaWYgKHNlbGYuY2xpY2t0aW1lb3V0KSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHNlbGYuY2xpY2t0aW1lb3V0KTtcbiAgICAgICAgICBzZWxmLmNsaWNrdGltZW91dCA9IG51bGw7XG4gICAgICB9XG4gICAgICBpZiAoICEgc2VsZi5lbmFibGVkICkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgc2VsZi5vWCA9IDA7XG4gICAgICBzZWxmLm9ZID0gMDtcbiAgICAgIHNlbGYuZFggPSBudWxsO1xuICAgICAgc2VsZi5kWSA9IG51bGw7XG4gICAgICBzZWxmLmRyYWdnaW5nID0gZmFsc2U7XG4gICAgICBldnQucHJldmVudERlZmF1bHQodHJ1ZSk7XG4gICAgICBcbiAgICAgIHZhciB0YXJnID0gc2VsZi50YXJnZXRFbGVtZW50ID8gc2VsZi50YXJnZXRFbGVtZW50IDogdGFyZ2V0RWxlbWVudDsgICAgICBcblxuICAgICAgdGFyZy5yZW1vdmVBdHRyaWJ1dGUoJ2RyYWdnaW5nJyk7XG4gICAgICBcbiAgICAgIGlmICghIHRhcmcuX3NuYXBiYWNrKSB7XG4gICAgICAgIGJlYW4uZmlyZSh0YXJnLCdwYW5lbmQnLHRydWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZXZ0LnR5cGUgPT0gJ21vdXNldXAnICYmIHNlbGYubW92ZWQpIHtcbiAgICAgICAgdGFyZy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsY2FwdHVyZUNsaWNrLHRydWUpO1xuICAgICAgfVxuICAgICAgc2VsZi5tb3ZlZCA9IGZhbHNlO1xuXG4gICAgfTtcblxuICAgIHZhciBtb3VzZU91dCA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKCFzZWxmLmRyYWdnaW5nIHx8ICEgc2VsZi5lbmFibGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcyA9PSBzZWxmLnRhcmdldEVsZW1lbnQpIHtcbiAgICAgICAgICAgIG1vdXNlVXAoZSk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIFxuICAgICAgICBpZiAoIGUudGFyZ2V0ICE9IHRoaXMgJiYgISBlLmN1cnJlbnRUYXJnZXQgKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdG9UYXJnZXQgPSBlLnJlbGF0ZWRUYXJnZXQgPyBlLnJlbGF0ZWRUYXJnZXQgOiBlLnRvRWxlbWVudDtcbiAgICAgICAgXG4gICAgICAgIHdoaWxlICh0b1RhcmdldCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRvVGFyZ2V0ID09IHRoaXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0b1RhcmdldCA9IHRvVGFyZ2V0LnBhcmVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgbW91c2VVcChlKTtcbiAgICB9O1xuICAgICAgICBcbiAgICBcbiAgICBpZiAoICEgdGFyZ2V0RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgIHRhcmdldEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKG5hbWUsZnVuYyxib29sKSB7XG4gICAgICAgICAgICB0aGlzLmF0dGFjaEV2ZW50KG5hbWUsZnVuYyk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIFxuICAgIHRhcmdldEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAoICEgc2VsZi5lbmFibGVkICkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0YXJnID0gc2VsZi50YXJnZXRFbGVtZW50ID8gc2VsZi50YXJnZXRFbGVtZW50IDogdGFyZ2V0RWxlbWVudDtcbiAgICAgICAgaWYgKHNlbGYubW9tZW50dW0pIHtcbiAgICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQoc2VsZi5tb21lbnR1bSk7XG4gICAgICAgICAgICBzZWxmLm1vbWVudHVtID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZS50b3VjaGVzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICB2YXIgcG9zaXRpb25zID0gbW91c2VQb3NpdGlvbihlLnRvdWNoZXNbMF0pO1xuICAgICAgICAgICAgdmFyIHA7XG4gICAgICAgICAgICBpZiAodGFyZy5ub2RlTmFtZSA9PSAnc3ZnJykge1xuICAgICAgICAgICAgICAgIHAgPSB0YXJnLmNyZWF0ZVNWR1BvaW50KCk7XG4gICAgICAgICAgICAgICAgcC54ID0gcG9zaXRpb25zWzBdO1xuICAgICAgICAgICAgICAgIHAueSA9IHBvc2l0aW9uc1sxXTtcbiAgICAgICAgICAgICAgICB2YXIgcm9vdENUTSA9IHRoaXMuZ2V0U2NyZWVuQ1RNKCk7XG4gICAgICAgICAgICAgICAgc2VsZi5tYXRyaXggPSByb290Q1RNLmludmVyc2UoKTtcbiAgICAgICAgICAgICAgICBwID0gcC5tYXRyaXhUcmFuc2Zvcm0oc2VsZi5tYXRyaXgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwLnggPSBwb3NpdGlvbnNbMF07XG4gICAgICAgICAgICAgICAgcC55ID0gcG9zaXRpb25zWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5vWCA9IHAueDtcbiAgICAgICAgICAgIHNlbGYub1kgPSBwLnk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHNlbGYuZHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICAgICAgc2VsZi5kWCA9IHRhcmcuZ2V0UG9zaXRpb24oKVswXTtcbiAgICAgICAgICAgIHNlbGYuZFkgPSB0YXJnLmdldFBvc2l0aW9uKClbMV07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHNlbGYuX21vbWVudHVtX3Nocmlua2VyID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgbW9tZW50dW0uc2hpZnQoKTtcbiAgICAgICAgICAgIH0sMjApO1xuICAgICAgICAgICAgaWYgKGRvY3VtZW50LmNyZWF0ZUV2ZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIGV2T2JqID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50cycpO1xuICAgICAgICAgICAgICAgIGV2T2JqLmluaXRFdmVudCgncGFuc3RhcnQnLGZhbHNlLHRydWUpO1xuICAgICAgICAgICAgICAgIHRhcmcuZGlzcGF0Y2hFdmVudChldk9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICB9LGZhbHNlKTtcblxuXG4gICAgLy8gZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJyxmdW5jdGlvbihlKSB7XG4gICAgLy8gICAgIGNvbnNvbGUubG9nKCd0b3VjaG1vdmUgZm9yIHRoZSBkb2N1bWVudCcpO1xuICAgIC8vICAgICBjb25zb2xlLmxvZyhzZWxmLmRyYWdnaW5nKTtcbiAgICAvLyAgICAgaWYgKCAhIHNlbGYuZHJhZ2dpbmcgKSB7XG4gICAgLy8gICAgICAgICByZXR1cm47XG4gICAgLy8gICAgIH1cbiAgICAvLyAgICAgY29uc29sZS5sb2coXCJFbmRpbmcgdGhlIGRyYWcgZm9yIGRvY3VtZW50IG1vdmVcIik7XG4gICAgLy8gICAgIHNlbGYub1ggPSAwO1xuICAgIC8vICAgICBzZWxmLm9ZID0gMDtcbiAgICAvLyAgICAgc2VsZi5kWCA9IG51bGw7XG4gICAgLy8gICAgIHNlbGYuZFkgPSBudWxsO1xuICAgIC8vICAgICBzZWxmLmRyYWdnaW5nID0gZmFsc2U7XG4gICAgLy8gXG4gICAgLy8gICAgIHZhciB0YXJnID0gc2VsZi50YXJnZXRFbGVtZW50ID8gc2VsZi50YXJnZXRFbGVtZW50IDogdGFyZ2V0RWxlbWVudDsgICAgICBcbiAgICAvLyBcbiAgICAvLyAgICAgaWYgKGRvY3VtZW50LmNyZWF0ZUV2ZW50KSB7XG4gICAgLy8gICAgICAgICB2YXIgZXZPYmogPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnRzJyk7XG4gICAgLy8gICAgICAgICBldk9iai5pbml0RXZlbnQoJ3BhbmVuZCcsZmFsc2UsdHJ1ZSk7XG4gICAgLy8gICAgICAgICB0YXJnLmRpc3BhdGNoRXZlbnQoZXZPYmopO1xuICAgIC8vICAgICB9ICAgICAgXG4gICAgLy8gfSxmYWxzZSk7XG5cbiAgICB0YXJnZXRFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAoc2VsZi5kcmFnX3pvb20pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VsZi5tb21lbnR1bSkge1xuICAgICAgICAgICAgd2luZG93LmNsZWFyVGltZW91dChzZWxmLm1vbWVudHVtKTtcbiAgICAgICAgICAgIHNlbGYubW9tZW50dW0gPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGUudG91Y2hlcy5sZW5ndGggIT0gMSkge1xuICAgICAgICAgICAgc2VsZi5kcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRhcmcgPSBzZWxmLnRhcmdldEVsZW1lbnQgPyBzZWxmLnRhcmdldEVsZW1lbnQgOiB0YXJnZXRFbGVtZW50O1xuXG4gICAgICAgIHZhciBwb3NpdGlvbnMgPSBtb3VzZVBvc2l0aW9uKGUudG91Y2hlc1swXSk7XG5cbiAgICAgICAgaWYgKCEgcG9zaXRpb25zIHx8ICEgc2VsZi5tYXRyaXgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwO1xuICAgICAgICBpZiAodGFyZy5ub2RlTmFtZSA9PSAnc3ZnJykge1xuICAgICAgICAgICAgcCA9IHRhcmcuY3JlYXRlU1ZHUG9pbnQoKTtcbiAgICAgICAgICAgIHAueCA9IHBvc2l0aW9uc1swXTtcbiAgICAgICAgICAgIHAueSA9IHBvc2l0aW9uc1sxXTtcbiAgICAgICAgICAgIHAgPSBwLm1hdHJpeFRyYW5zZm9ybShzZWxmLm1hdHJpeCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwLnggPSBwb3NpdGlvbnNbMF07XG4gICAgICAgICAgICBwLnkgPSBwb3NpdGlvbnNbMV07XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmIChzZWxmLmRyYWdnaW5nICYmICgoNipNYXRoLmFicyhzZWxmLm9YIC0gcC54KSkgPiBNYXRoLmFicyhzZWxmLm9ZIC0gcC55KSkpIHtcbiAgICAgICAgICAgIC8vIEZJWE1FIC0gUEFTU0lWRVxuICAgICAgICAgICAgLy8gZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFzZWxmLmRyYWdnaW5nKSB7XG4gICAgICAgICAgICBzZWxmLm9YID0gMDtcbiAgICAgICAgICAgIHNlbGYub1kgPSAwO1xuICAgICAgICAgICAgc2VsZi5kWCA9IG51bGw7XG4gICAgICAgICAgICBzZWxmLmRZID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobW9tZW50dW0ubGVuZ3RoID4gMykge1xuICAgICAgICAgICAgbW9tZW50dW0uc3BsaWNlKDIpO1xuICAgICAgICB9XG4gICAgICAgIHRhcmcuc2hpZnRQb3NpdGlvbihwLngscC55KTtcbiAgICAgICAgbW9tZW50dW0ucHVzaCh0YXJnLmdldFBvc2l0aW9uKClbMF0gLSBzZWxmLmRYKTtcbiAgICB9LHtwYXNzaXZlOnRydWV9KTtcbiAgICAvLyBGSVhNRSAtIFBBU1NJVkVcbiAgICBcbiAgICB2YXIgbW9tZW50dW1fZnVuYyA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKCAhIHNlbGYuZW5hYmxlZCApIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICggISBzZWxmLmRyYWdnaW5nICkge1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChzZWxmLl9tb21lbnR1bV9zaHJpbmtlcik7XG4gICAgICAgICAgICBtb3VzZVVwKGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0YXJnID0gc2VsZi50YXJnZXRFbGVtZW50ID8gc2VsZi50YXJnZXRFbGVtZW50IDogdGFyZ2V0RWxlbWVudDtcbiAgICAgICAgdmFyIGRlbHRhID0gMDtcbiAgICAgICAgXG4gICAgICAgIGlmIChtb21lbnR1bS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YXIgbGFzdF92YWwgPSBtb21lbnR1bVswXTtcbiAgICAgICAgICAgIG1vbWVudHVtLmZvckVhY2goZnVuY3Rpb24obSkge1xuICAgICAgICAgICAgICAgIGlmICgodHlwZW9mIGxhc3RfdmFsKSAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICBkZWx0YSArPSBtIC0gbGFzdF92YWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxhc3RfdmFsID0gbTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZGVsdGEgPSBkZWx0YSAvIG1vbWVudHVtLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RhcnQgPSB0YXJnLmdldFBvc2l0aW9uKClbMF07XG4gICAgICAgIHZhciBzdGFydF9kZWx0YSA9IGRlbHRhO1xuICAgICAgICBzZWxmLmRyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgIGlmIChzZWxmLm1vbWVudHVtKSB7XG4gICAgICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHNlbGYubW9tZW50dW0pO1xuICAgICAgICB9XG4gICAgICAgIHNlbGYubW9tZW50dW0gPSAxO1xuICAgICAgICBsZXQgbW9tZW50ID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc3RhcnQgPSB0YXJnLmdldFBvc2l0aW9uKClbMF07XG4gICAgICAgICAgICBpZiAoc2VsZi5kcmFnZ2luZykge1xuICAgICAgICAgICAgICAgIHN0YXJ0ICs9IHNlbGYub1ggLSBzZWxmLmRYO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWxmLm9YID0gMDtcbiAgICAgICAgICAgICAgICBzZWxmLmRYID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRhcmcuc2hpZnRQb3NpdGlvbihzdGFydCtkZWx0YSwwKTtcbiAgICAgICAgICAgIHN0YXJ0ID0gc3RhcnQrZGVsdGE7XG4gICAgICAgICAgICBkZWx0YSA9IGRlbHRhICogMC41O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoZGVsdGEgPiAwICYmIE1hdGguYWJzKHN0YXJ0X2RlbHRhIC8gZGVsdGEpIDwgMTApIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKG1vbWVudCwgdGFyZyk7XG4vLyAgICAgICAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dChhcmd1bWVudHMuY2FsbGVlLDUwKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VsZi5tb21lbnR1bSA9IG51bGw7XG4gICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChzZWxmLl9tb21lbnR1bV9zaHJpbmtlcik7XG4gICAgICAgICAgICAgICAgbW91c2VVcChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgbW9tZW50KCk7XG4gICAgfTtcbiAgICBcbiAgICB0YXJnZXRFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJyxtb21lbnR1bV9mdW5jLGZhbHNlKTtcblxuXG4gICAgaWYgKHRhcmdldEVsZW1lbnQubm9kZU5hbWUgPT0gJ3N2ZycpIHtcbiAgICAgICAgdGFyZ2V0RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBzdmdNb3VzZURvd24sIGZhbHNlKTtcbiAgICAgICAgdGFyZ2V0RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBzdmdNb3VzZU1vdmUsIGZhbHNlKTsgICAgICAgIFxuICAgICAgICB0YXJnZXRFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLG1vdXNlVXAsZmFsc2UpO1xuICAgICAgICB0YXJnZXRFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3V0Jyxtb3VzZU91dCwgZmFsc2UpOyBcbiAgICAgICAgaWYgKHNlbGYudGFyZ2V0RWxlbWVudCkge1xuICAgICAgICAgICAgc2VsZi50YXJnZXRFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3V0Jyxtb3VzZU91dCxmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGFyZ2V0RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsZnVuY3Rpb24oZXYpIHsgZXYucHJldmVudERlZmF1bHQoKTsgZXYuc3RvcFByb3BhZ2F0aW9uKCk7IH0sZmFsc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRhcmdldEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgbW91c2VEb3duLCBmYWxzZSk7XG4gICAgICAgIHRhcmdldEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgbW91c2VNb3ZlLCBmYWxzZSk7ICAgICAgICBcbiAgICAgICAgdGFyZ2V0RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgbW91c2VVcCwgZmFsc2UpOyAgICAgICAgXG4gICAgICAgIHRhcmdldEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdXQnLG1vdXNlT3V0LCBmYWxzZSk7XG4gICAgfVxuXG59O1xuXG5cbkRyYWdnZXIuYWRkVG91Y2hab29tQ29udHJvbHMgPSBmdW5jdGlvbih6b29tRWxlbWVudCx0b3VjaEVsZW1lbnQsY29udHJvbGxlcikge1xuICAgIGlmICggISBjb250cm9sbGVyICkge1xuICAgICAgICBjb250cm9sbGVyID0ge1wiZW5hYmxlZFwiIDogdHJ1ZX07XG4gICAgfVxuICAgIERyYWdnZXIucHJvdG90eXBlLmFkZFRvdWNoWm9vbUNvbnRyb2xzLmNhbGwoY29udHJvbGxlcix6b29tRWxlbWVudCx0b3VjaEVsZW1lbnQpO1xuICAgIHJldHVybiBjb250cm9sbGVyO1xufTtcblxuRHJhZ2dlci5wcm90b3R5cGUuYWRkVG91Y2hab29tQ29udHJvbHMgPSBmdW5jdGlvbih6b29tRWxlbWVudCx0b3VjaEVsZW1lbnQpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGxhc3RfdG91Y2hfc3RhcnQgPSBudWxsO1xuICAgIHZhciB4Zm9ybSA9IG51bGw7XG4gICAgdmFyIG1heF95ID0gbnVsbDtcbiAgICB2YXIgbW91c2VQb3NpdGlvbiA9IGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICB2YXIgcG9zeCA9IDA7XG4gICAgICAgIHZhciBwb3N5ID0gMDtcbiAgICAgICAgaWYgKCFldnQpIHtcbiAgICAgICAgICAgIGV2dCA9IHdpbmRvdy5ldmVudDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXZ0LnBhZ2VYIHx8IGV2dC5wYWdlWSkgICAgIHtcbiAgICAgICAgICAgIHBvc3ggPSBldnQucGFnZVg7XG4gICAgICAgICAgICBwb3N5ID0gZXZ0LnBhZ2VZO1xuICAgICAgICB9IGVsc2UgaWYgKGV2dC5jbGllbnRYIHx8IGV2dC5jbGllbnRZKSAge1xuICAgICAgICAgICAgcG9zeCA9IGV2dC5jbGllbnRYICsgZG9jdW1lbnQuYm9keS5zY3JvbGxMZWZ0ICsgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQ7XG4gICAgICAgICAgICBwb3N5ID0gZXZ0LmNsaWVudFkgKyBkb2N1bWVudC5ib2R5LnNjcm9sbFRvcCArIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3A7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlbGYudGFyZ2V0RWxlbWVudCkge1xuICAgICAgICAgICAgcG9zeCA9IGV2dC5zY3JlZW5YO1xuICAgICAgICAgICAgcG9zeSA9IGV2dC5zY3JlZW5ZO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbIHBvc3gsIHBvc3kgXTtcbiAgICB9O1xuXG4gICAgdmFyIGRyYWdfem9vbV9tb3ZlID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIGlmICggISBzZWxmLmVuYWJsZWQgfHwgISBzZWxmLmRyYWdfem9vbSApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXZ0LnRvdWNoZXMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgIHZhciBwb3NpdGlvbnMgPSBtb3VzZVBvc2l0aW9uKGV2dC50b3VjaGVzWzBdKTtcbiAgICAgICAgICAgIHZhciBwID0ge307XG4gICAgICAgICAgICBwLnggPSBwb3NpdGlvbnNbMF07XG4gICAgICAgICAgICBwLnkgPSBwb3NpdGlvbnNbMV07XG5cbiAgICAgICAgICAgIGlmICh0b3VjaEVsZW1lbnQubm9kZU5hbWUgPT0gJ3N2ZycpIHtcbiAgICAgICAgICAgICAgICBwID0gdG91Y2hFbGVtZW50LmNyZWF0ZVNWR1BvaW50KCk7XG4gICAgICAgICAgICAgICAgcC54ID0gcG9zaXRpb25zWzBdO1xuICAgICAgICAgICAgICAgIHAueSA9IHBvc2l0aW9uc1sxXTtcbiAgICAgICAgICAgICAgICBwID0gcC5tYXRyaXhUcmFuc2Zvcm0oeGZvcm0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgem9vbUVsZW1lbnQuem9vbSA9IHNlbGYuem9vbV9zdGFydCAqIE1hdGgucG93KDEwLCAocC55IC0gem9vbUVsZW1lbnQuem9vbUNlbnRlci55KS9tYXhfeSApO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBkcmFnX3pvb21fZW5kID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIHRvdWNoRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLGRyYWdfem9vbV9tb3ZlKTtcbiAgICAgICAgdG91Y2hFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJyxkcmFnX3pvb21fZW5kKTtcbiAgICAgICAgc2VsZi5kcmFnX3pvb20gPSBmYWxzZTtcbiAgICB9O1xuXG4gICAgdG91Y2hFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKCAhIHNlbGYuZW5hYmxlZCApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZS50b3VjaGVzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgICAgICBpZiAoKG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gbGFzdF90b3VjaF9zdGFydCkgPD0gMzAwKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5kcmFnX3pvb20gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHNlbGYuem9vbV9zdGFydCA9IHpvb21FbGVtZW50Lnpvb207XG5cbiAgICAgICAgICAgICAgICB2YXIgcG9zaXRpb25zID0gbW91c2VQb3NpdGlvbihlLnRvdWNoZXNbMF0pO1xuICAgICAgICAgICAgICAgIHZhciBwb3NpdGlvbnMyID0gbW91c2VQb3NpdGlvbihlLnRvdWNoZXNbMF0pO1xuICAgICAgICAgICAgICAgIHZhciBwO1xuICAgICAgICAgICAgICAgIGlmICh0b3VjaEVsZW1lbnQubm9kZU5hbWUgPT0gJ3N2ZycpIHtcbiAgICAgICAgICAgICAgICAgICAgcCA9IHRvdWNoRWxlbWVudC5jcmVhdGVTVkdQb2ludCgpO1xuICAgICAgICAgICAgICAgICAgICBwLnggPSAwLjUqKHBvc2l0aW9uc1swXSArIHBvc2l0aW9uczJbMF0pO1xuICAgICAgICAgICAgICAgICAgICBwLnkgPSAwLjUqKHBvc2l0aW9uc1sxXSArIHBvc2l0aW9uczJbMV0pO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcm9vdENUTSA9IHRoaXMuZ2V0U2NyZWVuQ1RNKCk7XG4gICAgICAgICAgICAgICAgICAgIHhmb3JtID0gcm9vdENUTS5pbnZlcnNlKCk7XG4gICAgICAgICAgICAgICAgICAgIHAgPSBwLm1hdHJpeFRyYW5zZm9ybSh4Zm9ybSk7XG4gICAgICAgICAgICAgICAgICAgIG1heF95ID0gcGFyc2VJbnQodG91Y2hFbGVtZW50LmdldEF0dHJpYnV0ZSgndmlld0JveCcpLnNwbGl0KCcgJylbM10pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHAueCA9IDAuNSoocG9zaXRpb25zWzBdICsgcG9zaXRpb25zMlswXSk7XG4gICAgICAgICAgICAgICAgICAgIHAueSA9IDAuNSoocG9zaXRpb25zWzFdICsgcG9zaXRpb25zMlsxXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHpvb21FbGVtZW50Lnpvb21DZW50ZXIgPSBwO1xuICAgICAgICAgICAgICAgIHRvdWNoRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLGRyYWdfem9vbV9tb3ZlLHtwYXNzaXZlOnRydWV9KTtcbiAgICAgICAgICAgICAgICB0b3VjaEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLGRyYWdfem9vbV9lbmQsZmFsc2UpO1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxhc3RfdG91Y2hfc3RhcnQgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlLnRvdWNoZXMubGVuZ3RoID09IDIpIHtcbiAgICAgICAgICAgIHZhciBwb3NpdGlvbnMgPSBtb3VzZVBvc2l0aW9uKGUudG91Y2hlc1swXSk7XG4gICAgICAgICAgICB2YXIgcG9zaXRpb25zMiA9IG1vdXNlUG9zaXRpb24oZS50b3VjaGVzWzFdKTtcbiAgICAgICAgICAgIHZhciBwO1xuICAgICAgICAgICAgaWYgKHRvdWNoRWxlbWVudC5ub2RlTmFtZSA9PSAnc3ZnJykge1xuICAgICAgICAgICAgICAgIHAgPSB0b3VjaEVsZW1lbnQuY3JlYXRlU1ZHUG9pbnQoKTtcbiAgICAgICAgICAgICAgICBwLnggPSAwLjUqKHBvc2l0aW9uc1swXSArIHBvc2l0aW9uczJbMF0pO1xuICAgICAgICAgICAgICAgIHAueSA9IDAuNSoocG9zaXRpb25zWzFdICsgcG9zaXRpb25zMlsxXSk7XG4gICAgICAgICAgICAgICAgdmFyIHJvb3RDVE0gPSB0aGlzLmdldFNjcmVlbkNUTSgpO1xuICAgICAgICAgICAgICAgIHNlbGYubWF0cml4ID0gcm9vdENUTS5pbnZlcnNlKCk7XG4gICAgICAgICAgICAgICAgcCA9IHAubWF0cml4VHJhbnNmb3JtKHNlbGYubWF0cml4KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcC54ID0gMC41Kihwb3NpdGlvbnNbMF0gKyBwb3NpdGlvbnMyWzBdKTtcbiAgICAgICAgICAgICAgICBwLnkgPSAwLjUqKHBvc2l0aW9uc1sxXSArIHBvc2l0aW9uczJbMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgem9vbUVsZW1lbnQuem9vbUNlbnRlciA9IHA7ICBcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgIH0sZmFsc2UpO1xuXG5cbiAgICAvLyB0b3VjaEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZ2VzdHVyZXN0YXJ0JyxmdW5jdGlvbihlKSB7XG4gICAgSGFtbWVyKHRvdWNoRWxlbWVudCkub24oXCJ0b3VjaFwiLGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKCAhIHNlbGYuZW5hYmxlZCApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyB6b29tRWxlbWVudC56b29tTGVmdCA9IG51bGw7XG4gICAgICAgIHZhciB6b29tU3RhcnQgPSB6b29tRWxlbWVudC56b29tO1xuXG4gICAgICAgIHZhciB6b29tc2NhbGUgPSBmdW5jdGlvbihldikge1xuICAgICAgICAgICAgaWYgKCB6b29tRWxlbWVudC56b29tQ2VudGVyICkge1xuICAgICAgICAgICAgICAgIHpvb21FbGVtZW50Lnpvb20gPSB6b29tU3RhcnQgKiBldi5nZXN0dXJlLnNjYWxlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfTtcbiAgICAgICAgSGFtbWVyKHRvdWNoRWxlbWVudCkub24oJ3BpbmNoJyx6b29tc2NhbGUsZmFsc2UpO1xuICAgICAgICBsZXQgaGFtbWVyX3JlbGVhc2UgPSBmdW5jdGlvbihldikge1xuICAgICAgICAgICAgSGFtbWVyKHRvdWNoRWxlbWVudCkub2ZmKCdwaW5jaCcsem9vbXNjYWxlKTtcbiAgICAgICAgICAgIEhhbW1lcih0b3VjaEVsZW1lbnQpLm9mZigncmVsZWFzZScsaGFtbWVyX3JlbGVhc2UpO1xuICAgICAgICAgICAgem9vbUVsZW1lbnQuem9vbUNlbnRlciA9IG51bGw7XG4gICAgICAgICAgICB6b29tRWxlbWVudC56b29tTGVmdCA9IG51bGw7XG4gICAgICAgICAgICBiZWFuLmZpcmUoem9vbUVsZW1lbnQsJ2dlc3R1cmVlbmQnKVxuICAgICAgICB9O1xuICAgICAgICBIYW1tZXIodG91Y2hFbGVtZW50KS5vbigncmVsZWFzZScsaGFtbWVyX3JlbGVhc2UsZmFsc2UpO1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSxmYWxzZSk7XG5cbn07XG5cbi8qKlxuICogR2l2ZW4gYW4gZWxlbWVudCB0aGF0IGltcGxlbWVudHMgYSB6b29tIGF0dHJpYnV0ZSwgY3JlYXRlcyBhIGRpdiB0aGF0IGNvbnRhaW5zIGNvbnRyb2xzIGZvciBjb250cm9sbGluZyB0aGUgem9vbSBhdHRyaWJ1dGUuIFRoZVxuICogem9vbUVsZW1lbnQgbXVzdCBoYXZlIGEgem9vbSBhdHRyaWJ1dGUsIGFuZCBjYW4gZmlyZSB0aGUgem9vbUNoYW5nZSBldmVudCB3aGVuZXZlciB0aGUgem9vbSB2YWx1ZSBpcyBjaGFuZ2VkIG9uIHRoZSBvYmplY3QuIFRoZVxuICogc2Nyb2xsd2hlZWwgaXMgY29ubmVjdGVkIHRvIHRoaXMgZWxlbWVudCBzbyB0aGF0IHdoZW4gdGhlIG1vdXNlIGhvdmVycyBvdmVyIHRoZSBjb250cm9scywgaXQgY2FuIGNvbnRyb2wgdGhlIHpvb20gdXNpbmcgb25seVxuICogdGhlIHNjcm9sbCB3aGVlbC5cbiAqIEBwYXJhbSB7T2JqZWN0fSB6b29tRWxlbWVudCBFbGVtZW50IHRvIGNvbnRyb2wgdGhlIHpvb21pbmcgZm9yLlxuICogQHBhcmFtIHtOdW1iZXJ9IG1pbiBNaW5pbXVtIHZhbHVlIGZvciB0aGUgem9vbSBhdHRyaWJ1dGUgKGRlZmF1bHQgMClcbiAqIEBwYXJhbSB7TnVtYmVyfSBtYXggTWF4aW11bSB2YWx1ZSBmb3IgdGhlIHpvb20gYXR0cmlidXRlIChkZWZhdWx0IDEwKVxuICogQHBhcmFtIHtOdW1iZXJ9IHByZWNpc2lvbiBTdGVwIHByZWNpc2lvbiBmb3IgdGhlIHpvb20gY29udHJvbCAoZGVmYXVsdCAwLjUpXG4gKiBAcGFyYW0ge051bWJlcn0gdmFsdWUgRGVmYXVsdCB2YWx1ZSBmb3IgdGhpcyBjb250cm9sXG4gKiBAcmV0dXJucyBESVYgZWxlbWVudCBjb250YWluaW5nIHRoZSBjb250cm9sc1xuICogQHR5cGUgRWxlbWVudFxuICogQHNlZSBHT01hcC5EaWFncmFtI2V2ZW50Onpvb21DaGFuZ2VcbiAqL1xuRHJhZ2dlci5hZGRab29tQ29udHJvbHMgPSBmdW5jdGlvbih6b29tRWxlbWVudCxtaW4sbWF4LHByZWNpc2lvbix2YWx1ZSkge1xuICAgIG1pbiA9IG1pbiB8fCAwO1xuICAgIG1heCA9IG1heCB8fCAxMDtcbiAgICBwcmVjaXNpb24gPSBwcmVjaXNpb24gfHwgMC41O1xuICAgIHZhbHVlID0gdmFsdWUgfHwgem9vbUVsZW1lbnQuem9vbSB8fCBtaW47IFxuICAgIFxuICAgIHZhciBjb250cm9sc19jb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBcbiAgICB2YXIgem9vbUluID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICB6b29tSW4uc2V0QXR0cmlidXRlKCd0eXBlJywnYnV0dG9uJyk7XG4gICAgem9vbUluLnNldEF0dHJpYnV0ZSgndmFsdWUnLCcrJyk7XG4gICAgdmFyIHpvb21PdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgIHpvb21PdXQuc2V0QXR0cmlidXRlKCd0eXBlJywnYnV0dG9uJyk7XG4gICAgem9vbU91dC5zZXRBdHRyaWJ1dGUoJ3ZhbHVlJywnLScpO1xuICAgIHZhciByZXNldCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgcmVzZXQuc2V0QXR0cmlidXRlKCd0eXBlJywnYnV0dG9uJyk7XG4gICAgcmVzZXQuc2V0QXR0cmlidXRlKCd2YWx1ZScsJ1Jlc2V0Jyk7XG5cbiAgICBjb250cm9sc19jb250YWluZXIuYXBwZW5kQ2hpbGQocmVzZXQpOyAgICBcblxuICAgIHJlc2V0LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJyxmdW5jdGlvbigpIHtcbiAgICAgICAgem9vbUVsZW1lbnQuem9vbSA9IHpvb21FbGVtZW50LmRlZmF1bHRab29tIHx8IHZhbHVlO1xuICAgIH0sZmFsc2UpO1xuICAgIFxuICAgIHZhciByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgcmFuZ2Uuc2V0QXR0cmlidXRlKCdtaW4nLG1pbik7XG4gICAgcmFuZ2Uuc2V0QXR0cmlidXRlKCdtYXgnLG1heCk7XG4gICAgcmFuZ2Uuc2V0QXR0cmlidXRlKCdzdGVwJyxwcmVjaXNpb24pO1xuICAgIHJhbmdlLnNldEF0dHJpYnV0ZSgndmFsdWUnLHZhbHVlKTsgXG4gICAgcmFuZ2Uuc2V0QXR0cmlidXRlKCd0eXBlJywncmFuZ2UnKTtcbiAgICByYW5nZS5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywnLXdlYmtpdC1hcHBlYXJhbmNlOiBzbGlkZXItaG9yaXpvbnRhbDsgd2lkdGg6IDEwMCU7IHBvc2l0aW9uOiBhYnNvbHV0ZTsgdG9wOiAwcHg7IGJvdHRvbTogMHB4OyBtYXJnaW4tdG9wOiAwLjVlbTsgbGVmdDogMTAwJTsgbWFyZ2luLWxlZnQ6IC0wLjVlbTsnKTtcblxuICAgIGlmIChyYW5nZS50eXBlID09ICdyYW5nZScpIHtcbiAgICAgICAgXG4gICAgICAgIHJhbmdlLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB6b29tRWxlbWVudC56b29tID0gdGhpcy52YWx1ZTtcbiAgICAgICAgfSxmYWxzZSk7XG4gICAgICAgIFxuICAgICAgICB2YXIgZXZGdW5jdGlvbiA9IG51bGw7XG4gICAgICAgIGlmICh6b29tRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICBldkZ1bmN0aW9uID0gem9vbUVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcjtcbiAgICAgICAgfSBlbHNlIGlmICh6b29tRWxlbWVudC5iaW5kKXtcbiAgICAgICAgICAgIGV2RnVuY3Rpb24gPSB6b29tRWxlbWVudC5iaW5kO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBldkZ1bmN0aW9uLmFwcGx5KHpvb21FbGVtZW50LFsnem9vbUNoYW5nZScsZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByYW5nZS52YWx1ZSA9IHpvb21FbGVtZW50Lnpvb207XG4gICAgICAgIH0sZmFsc2VdKTtcbiAgICAgICAgXG5cbiAgICAgICAgcmVzZXQuc3R5bGUubWFyZ2luID0gJzBweCc7XG4gICAgICAgIHJlc2V0LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICByZXNldC5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgIHJlc2V0LnN0eWxlLnRvcCA9ICcwcHgnO1xuICAgICAgICBcbiAgICAgICAgY29udHJvbHNfY29udGFpbmVyLmFwcGVuZENoaWxkKHJhbmdlKTtcbiAgICAgICAgY29udHJvbHNfY29udGFpbmVyLnN0eWxlLmhlaWdodCA9ICcxMDAlJztcbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoISB6b29tSW4uYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgdmFyIGFkZGV2bGlzID0gZnVuY3Rpb24obmFtZSxmdW5jKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hdHRhY2hFdmVudChuYW1lLGZ1bmMpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHpvb21Jbi5hZGRFdmVudExpc3RlbmVyID0gYWRkZXZsaXM7XG4gICAgICAgICAgICByZXNldC5hZGRFdmVudExpc3RlbmVyID0gYWRkZXZsaXM7XG4gICAgICAgICAgICB6b29tT3V0LmFkZEV2ZW50TGlzdGVuZXIgPSBhZGRldmxpczsgICAgICAgIFxuICAgICAgICB9XG4gICAgICAgIHpvb21Jbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB6b29tRWxlbWVudC56b29tICs9IHByZWNpc2lvbjtcbiAgICAgICAgfSxmYWxzZSk7XG4gICAgICAgIHpvb21PdXQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgem9vbUVsZW1lbnQuem9vbSAtPSBwcmVjaXNpb247XG4gICAgICAgIH0sZmFsc2UpO1xuXG4gICAgICAgIHpvb21Jbi5zdHlsZS5tYXJnaW4gPSAnMHB4JztcbiAgICAgICAgem9vbUluLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICB6b29tSW4uc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICB6b29tSW4uc3R5bGUudG9wID0gJzBweCc7XG4gICAgICAgIHpvb21Jbi5zdHlsZS5sZWZ0ID0gJzI5cHgnO1xuXG4gICAgICAgIHpvb21PdXQuc3R5bGUubWFyZ2luID0gJzBweCc7XG4gICAgICAgIHpvb21PdXQuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgIHpvb21PdXQuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICB6b29tT3V0LnN0eWxlLnRvcCA9ICcwcHgnO1xuXG4gICAgICAgIHJlc2V0LnN0eWxlLm1hcmdpbiA9ICcwcHgnO1xuICAgICAgICByZXNldC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgcmVzZXQuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICByZXNldC5zdHlsZS50b3AgPSAnMjNweCc7XG4gICAgICAgIHJlc2V0LnN0eWxlLmxlZnQgPSAnM3B4JztcblxuICAgICAgICBjb250cm9sc19jb250YWluZXIuYXBwZW5kQ2hpbGQoem9vbU91dCk7XG4gICAgICAgIGNvbnRyb2xzX2NvbnRhaW5lci5hcHBlbmRDaGlsZCh6b29tSW4pO1xuICAgICAgICBjb250cm9sc19jb250YWluZXIuYXBwZW5kQ2hpbGQocmVzZXQpO1xuICAgIH1cblxuICAgIHRoaXMuYWRkU2Nyb2xsWm9vbUNvbnRyb2xzKHpvb21FbGVtZW50LGNvbnRyb2xzX2NvbnRhaW5lcixwcmVjaXNpb24pO1xuXG4gICAgcmV0dXJuIGNvbnRyb2xzX2NvbnRhaW5lcjtcbn07XG5cbkRyYWdnZXIuYWRkU2Nyb2xsQmFyID0gZnVuY3Rpb24odGFyZ2V0LGNvbnRyb2xFbGVtZW50LHNjcm9sbENvbnRhaW5lcikge1xuICAgIHJldHVybjtcbiAgICB2YXIgc2Nyb2xsZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICB3aGlsZSAoc2Nyb2xsQ29udGFpbmVyLmNoaWxkTm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBzY3JvbGxDb250YWluZXIucmVtb3ZlQ2hpbGQoc2Nyb2xsQ29udGFpbmVyLmZpcnN0Q2hpbGQpO1xuICAgIH1cbiAgICBzY3JvbGxDb250YWluZXIuYXBwZW5kQ2hpbGQoc2Nyb2xsZXIpO1xuICAgIGlmICggISBzY3JvbGxDb250YWluZXIuc3R5bGUucG9zaXRpb24gKSB7XG4gICAgICAgIHNjcm9sbENvbnRhaW5lci5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG4gICAgfVxuICAgIHNjcm9sbENvbnRhaW5lci5zdHlsZS5vdmVyZmxvd1ggPSAnc2Nyb2xsJztcbiAgICBzY3JvbGxDb250YWluZXIuc3R5bGUub3ZlcmZsb3dZID0gJ2hpZGRlbic7XG5cbiAgICBzY3JvbGxlci5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgc2Nyb2xsZXIuc3R5bGUubGVmdCA9ICcwcHgnO1xuICAgIHNjcm9sbGVyLnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgIHNjcm9sbGVyLnN0eWxlLmhlaWdodD0gJzEwMCUnO1xuXG4gICAgYmVhbi5yZW1vdmUoc2Nyb2xsQ29udGFpbmVyLCdzY3JvbGwnKTtcbiAgICBiZWFuLnJlbW92ZShzY3JvbGxDb250YWluZXIsJ21vdXNlZW50ZXInKTtcbiAgICBiZWFuLmFkZChzY3JvbGxDb250YWluZXIsJ21vdXNlZW50ZXInLGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2l6ZSA9IDEwMCp0YXJnZXQuZ2V0VG90YWxMZW5ndGgoKSAvICh0YXJnZXQuZ2V0VmlzaWJsZUxlbmd0aCgpKTtcbiAgICAgICAgc2Nyb2xsZXIuY2FjaGVkX3dpZHRoID0gc2Nyb2xsZXIuY2xpZW50V2lkdGggLyBzaXplO1xuICAgICAgICBkaXNhYmxlZCA9IHRydWU7XG4gICAgICAgIHNjcm9sbENvbnRhaW5lci5zY3JvbGxMZWZ0ICs9IDE7XG4gICAgICAgIHNjcm9sbENvbnRhaW5lci5zY3JvbGxMZWZ0IC09IDE7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBkaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICB9LDApO1xuICAgICAgICBiZWFuLnJlbW92ZShzY3JvbGxDb250YWluZXIsJ3Njcm9sbCcsc2Nyb2xsX2Z1bmMpO1xuICAgICAgICBiZWFuLmFkZChzY3JvbGxDb250YWluZXIsJ3Njcm9sbCcsc2Nyb2xsX2Z1bmMpO1xuICAgIH0pO1xuICAgIHZhciBkaXNhYmxlZCA9IGZhbHNlO1xuXG4gICAgaWYgKHdpbmRvdy5tYXRjaE1lZGlhKSB7XG4gICAgICAgIHdpbmRvdy5tYXRjaE1lZGlhKCdwcmludCcpLmFkZExpc3RlbmVyKGZ1bmN0aW9uKG1hdGNoZXIpIHtcbiAgICAgICAgICAgIGRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgZGlzYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH0sMCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB2YXIgc2Nyb2xsX2Z1bmMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKGRpc2FibGVkIHx8ICEgY29uc29sZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkb2N1bWVudC5jcmVhdGVFdmVudCkge1xuICAgICAgICAgICAgdmFyIGV2T2JqID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50cycpO1xuICAgICAgICAgICAgZXZPYmouaW5pdEV2ZW50KCdwYW5zdGFydCcsZmFsc2UsdHJ1ZSk7XG4gICAgICAgICAgICBjb250cm9sRWxlbWVudC5kaXNwYXRjaEV2ZW50KGV2T2JqKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2l6ZSA9IDEwMCp0YXJnZXQuZ2V0VG90YWxMZW5ndGgoKSAvICh0YXJnZXQuZ2V0VmlzaWJsZUxlbmd0aCgpKTtcbiAgICAgICAgdmFyIHdpZHRoID0gc2Nyb2xsZXIuY2FjaGVkX3dpZHRoID8gcGFyc2VJbnQoc2Nyb2xsZXIuY2FjaGVkX3dpZHRoICogc2l6ZSkgOiBzY3JvbGxlci5jbGllbnRXaWR0aCA7XG4gICAgICAgIHRhcmdldC5zZXRMZWZ0UG9zaXRpb24ocGFyc2VJbnQoc2Nyb2xsQ29udGFpbmVyLnNjcm9sbExlZnQgKiB0YXJnZXQuZ2V0VG90YWxMZW5ndGgoKSAvIHdpZHRoKSk7XG4gICAgICAgIGJlYW4uZmlyZShjb250cm9sRWxlbWVudCwncGFuZW5kJyk7XG4gICAgfTtcblxuICAgIGJlYW4uYWRkKHNjcm9sbENvbnRhaW5lciwnc2Nyb2xsJyxzY3JvbGxfZnVuYyk7XG5cbiAgICB2YXIgbGVmdF9zZXR0ZXI7XG5cbiAgICBiZWFuLmFkZChjb250cm9sRWxlbWVudCwncGFuJyxmdW5jdGlvbigpIHtcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUobGVmdF9zZXR0ZXIpO1xuICAgICAgICB2YXIgc2l6ZSA9IDEwMCp0YXJnZXQuZ2V0VG90YWxMZW5ndGgoKSAvICh0YXJnZXQuZ2V0VmlzaWJsZUxlbmd0aCgpKTtcbiAgICAgICAgc2Nyb2xsZXIuc3R5bGUud2lkdGggPSBwYXJzZUludChzaXplKSsnJSc7XG4gICAgICAgIHZhciB3aWR0aCA9IHNjcm9sbGVyLmNhY2hlZF93aWR0aCA/IHBhcnNlSW50KHNjcm9sbGVyLmNhY2hlZF93aWR0aCAqIHNpemUpIDogc2Nyb2xsZXIuY2xpZW50V2lkdGggO1xuICAgICAgICBzY3JvbGxlci5jYWNoZWRfd2lkdGggPSB3aWR0aCAvIHNpemU7XG5cbiAgICAgICAgdmFyIGxlZnRfc2hpZnQgPSBwYXJzZUludCh3aWR0aCAqICh0YXJnZXQuZ2V0TGVmdFBvc2l0aW9uKCkgLyB0YXJnZXQuZ2V0VG90YWxMZW5ndGgoKSApKTtcbiAgICAgICAgYmVhbi5yZW1vdmUoc2Nyb2xsQ29udGFpbmVyLCdzY3JvbGwnLHNjcm9sbF9mdW5jKTtcbiAgICAgICAgbGVmdF9zZXR0ZXIgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBSZW5kZXJpbmcgYm90dGxlbmVja1xuICAgICAgICAgICAgc2Nyb2xsQ29udGFpbmVyLnNjcm9sbExlZnQgPSBsZWZ0X3NoaWZ0O1xuICAgICAgICB9KTtcbiAgICB9KTtcbn07XG5cbi8qKlxuICogQ29ubmVjdCB0aGUgc2Nyb2xsIHdoZWVsIHRvIHRoZSBjb250cm9scyB0byBjb250cm9sIHpvb21cbiAqL1xuRHJhZ2dlci5hZGRTY3JvbGxab29tQ29udHJvbHMgPSBmdW5jdGlvbih0YXJnZXQsY29udHJvbEVsZW1lbnQscHJlY2lzaW9uKSB7XG4gICAgcHJlY2lzaW9uID0gcHJlY2lzaW9uIHx8IDAuNTtcbiAgICB2YXIgc2VsZjtcblxuICAgIGlmICh0aGlzLmVuYWJsZWQgPT09IG51bGwgKSB7XG4gICAgICAgIHNlbGYgPSB7J2VuYWJsZWQnIDogdHJ1ZSB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGYgPSB0aGlzO1xuICAgIH1cbiAgICB2YXIgaG9va0V2ZW50ID0gZnVuY3Rpb24oZWxlbWVudCwgZXZlbnROYW1lLCBjYWxsYmFjaykge1xuICAgICAgaWYgKHR5cGVvZihlbGVtZW50KSA9PSAnc3RyaW5nJykge1xuICAgICAgICBlbGVtZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZWxlbWVudCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbGVtZW50ID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICBpZiAoZXZlbnROYW1lID09ICdtb3VzZXdoZWVsJykge1xuICAgICAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NTW91c2VTY3JvbGwnLCBjYWxsYmFjaywgZmFsc2UpOyAgXG4gICAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCd3aGVlbCcsIGNhbGxiYWNrLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgY2FsbGJhY2ssIGZhbHNlKTtcbiAgICAgIH0gZWxzZSBpZiAoZWxlbWVudC5hdHRhY2hFdmVudCkge1xuICAgICAgICBlbGVtZW50LmF0dGFjaEV2ZW50KFwib25cIiArIGV2ZW50TmFtZSwgY2FsbGJhY2spO1xuICAgICAgfVxuICAgIH07XG5cblxuICAgIHZhciBtb3VzZVBvc2l0aW9uID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgICAgaWYgKCAhIHNlbGYuZW5hYmxlZCApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIHBvc3ggPSAwO1xuICAgICAgICAgIHZhciBwb3N5ID0gMDtcbiAgICAgICAgICBpZiAoIWV2dCkge1xuICAgICAgICAgICAgICBldnQgPSB3aW5kb3cuZXZlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChldnQucGFnZVggfHwgZXZ0LnBhZ2VZKSAgIHtcbiAgICAgICAgICAgICAgcG9zeCA9IGV2dC5wYWdlWDtcbiAgICAgICAgICAgICAgcG9zeSA9IGV2dC5wYWdlWTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGV2dC5jbGllbnRYIHx8IGV2dC5jbGllbnRZKSAgICB7XG4gICAgICAgICAgICAgIHBvc3ggPSBldnQuY2xpZW50WCArIGRvY3VtZW50LmJvZHkuc2Nyb2xsTGVmdCArIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0O1xuICAgICAgICAgICAgICBwb3N5ID0gZXZ0LmNsaWVudFkgKyBkb2N1bWVudC5ib2R5LnNjcm9sbFRvcCArIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3A7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHAgPSB7fTtcblxuICAgICAgICAgIGlmIChjb250cm9sRWxlbWVudC5ub2RlTmFtZSA9PSAnc3ZnJykge1xuICAgICAgICAgICAgICBwID0gY29udHJvbEVsZW1lbnQuY3JlYXRlU1ZHUG9pbnQoKTtcbiAgICAgICAgICAgICAgcC54ID0gcG9zeDtcbiAgICAgICAgICAgICAgcC55ID0gcG9zeTtcbiAgICAgICAgICAgICAgLyogRml4IGZvciBtb3VzZSBwb3NpdGlvbiBpbiBmaXJlZm94IC0gaHR0cDovL2pzZmlkZGxlLm5ldC9KTktnUi82LyAqL1xuICAgICAgICAgICAgICB2YXIgcm9vdENUTSA9IGNvbnRyb2xFbGVtZW50LmZpcnN0RWxlbWVudENoaWxkLmdldFNjcmVlbkNUTSgpO1xuICAgICAgICAgICAgICBzZWxmLm1hdHJpeCA9IHJvb3RDVE0uaW52ZXJzZSgpO1xuICAgICAgICAgICAgICBwID0gcC5tYXRyaXhUcmFuc2Zvcm0oc2VsZi5tYXRyaXgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHAueCA9IHBvc3g7XG4gICAgICAgICAgICAgIHAueSA9IHBvc3k7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBwO1xuICAgIH07XG5cbiAgICB2YXIgbW91c2VXaGVlbCA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmICggISBzZWxmLmVuYWJsZWQgKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGUgPSBlID8gZSA6IHdpbmRvdy5ldmVudDtcbiAgICAgIHZhciB3aGVlbERhdGEgPSBlLmRldGFpbCA/IGUuZGV0YWlsICogLTEgOiBlLndoZWVsRGVsdGE7XG4gICAgICBpZiAoICEgd2hlZWxEYXRhICkge1xuICAgICAgICB3aGVlbERhdGEgPSBlLmRlbHRhWTtcbiAgICAgIH1cbiAgICAgIHRhcmdldC56b29tQ2VudGVyID0gbW91c2VQb3NpdGlvbihlKTtcblxuICAgICAgaWYgKHdoZWVsRGF0YSA+IDApIHtcbiAgICAgICAgdGFyZ2V0Lnpvb20gPSB0YXJnZXQuem9vbSArPSBwcmVjaXNpb247XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0YXJnZXQuem9vbSA9IHRhcmdldC56b29tIC09IHByZWNpc2lvbjtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgXG4gICAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG5cbiAgICAgIGUucmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgdmFyIGlzRkYgPSBmYWxzZTtcblxuICAgIGlmIChuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0dlY2tvJykgPj0gMCkge1xuICAgICAgaXNGRiA9IHBhcnNlRmxvYXQobmF2aWdhdG9yLnVzZXJBZ2VudC5zcGxpdCgnRmlyZWZveC8nKVsxXSkgfHwgdW5kZWZpbmVkO1xuICAgIH0gICAgICAgICAgICAgICAgICAgICAgICAgXG5cbiAgICBpZiAoaXNGRiAmJiAodHlwZW9mIHN2Z3dlYiAhPSAndW5kZWZpbmVkJykmJiBzdmd3ZWIuZ2V0SGFuZGxlclR5cGUoKSA9PSAnbmF0aXZlJykge1xuICAgICAgaG9va0V2ZW50KGNvbnRyb2xFbGVtZW50LCAnbW91c2V3aGVlbCcsXG4gICAgICAgICAgICAgICAgbW91c2VXaGVlbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhvb2tFdmVudChjb250cm9sRWxlbWVudCwgJ21vdXNld2hlZWwnLCBtb3VzZVdoZWVsKTtcbiAgICB9XG5cbiAgICBob29rRXZlbnQoY29udHJvbEVsZW1lbnQsJ21vdXNlbW92ZScsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKCEgc2VsZi5lbmFibGVkICkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0YXJnZXQuem9vbUNlbnRlciAmJiBNYXRoLmFicyh0YXJnZXQuem9vbUNlbnRlci54IC0gbW91c2VQb3NpdGlvbihlKS54KSA+IDEwMCkge1xuICAgICAgICAgICAgdGFyZ2V0Lnpvb21DZW50ZXIgPSBudWxsO1xuICAgICAgICAgICAgdGFyZ2V0Lnpvb21MZWZ0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHNlbGY7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBEcmFnZ2VyO1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7OztBQWNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./js/lib/Dragger.js\n");

/***/ }),

/***/ "./js/lib/GatorComponent.js":
/*!**********************************!*\
  !*** ./js/lib/GatorComponent.js ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Dragger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Dragger */ \"./js/lib/Dragger.js\");\n/* harmony import */ var _CondensedSequenceRenderer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CondensedSequenceRenderer */ \"./js/lib/CondensedSequenceRenderer.js\");\n/* harmony import */ var _Service__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Service */ \"./js/lib/Service.js\");\n/* harmony import */ var _MASCP__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./MASCP */ \"./js/lib/MASCP.js\");\n\n\n\n\n\n\nclass DraggableRenderer extends _CondensedSequenceRenderer__WEBPACK_IMPORTED_MODULE_1__[\"default\"] {\n  constructor(container) {\n    super(container);\n  }\n  getVisibleLength() {\n    return this.rightVisibleResidue() - this.leftVisibleResidue();\n  }\n  getTotalLength() {\n    return this.sequence.length;\n  }\n  getLeftPosition() {\n    return this.leftVisibleResidue();\n  }\n  setLeftPosition(pos) {\n    return this.setLeftVisibleResidue(pos);\n  }\n}\n\nconst tmpl = document.createElement('template');\n\ntmpl.innerHTML = `\n<style>\n  :host {\n    display: block;\n    position: relative;\n  }\n  :host([resizeable]) {\n    resize: both;\n    overflow: auto;\n    padding-right: 5px;\n    padding-bottom: 5px;\n  }\n  #container, .widget_contents {\n    width: 100%;\n    height: 100%;\n  }\n  #container {\n  }\n</style>\n<div class=\"widget_contents\" >\n  <div id=\"container\">\n  </div>\n</div>\n<slot></slot>\n`;\n\nconst interactive_symb = Symbol('interactive');\n\nclass InteractiveState {\n  constructor(component) {\n    this.component = component;\n  }\n  get enabled() {\n    return this.component.interactive;\n  }\n  set enabled(toggle) {\n    this.component.interactive = toggle;\n  }\n}\n\nclass ComponentDragger extends _Dragger__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {\n  constructor(component) {\n    super();\n    this.component = component;\n  }\n  get enabled() {\n    return this.component.interactive;\n  }\n  set enabled(toggle) {\n    this.component.interactive = toggle;\n  }\n}\n\nfunction WrapHTML() {\n  return Reflect.construct(HTMLElement, [], Object.getPrototypeOf(this).constructor);\n}\nObject.setPrototypeOf(WrapHTML.prototype, HTMLElement.prototype);\nObject.setPrototypeOf(WrapHTML, HTMLElement);\n\nif (window.ShadyCSS) {\n  ShadyCSS.prepareTemplate(tmpl, 'x-protviewer');\n}\n\nlet setup_renderer = function setup_renderer(renderer) {\n  renderer.font_order = 'Helvetica, Arial, sans-serif';\n  renderer.zoom = 0.81;\n  renderer.padding = 10;\n  renderer.trackOrder = [];\n  renderer.reset();\n  renderer.trackGap = 6;\n  renderer.trackHeight = 5;\n  renderer.fixedFontScale = 1;\n};\n\nlet create_renderer = function create_renderer(container) {\n  let renderer = new DraggableRenderer(container);\n  setup_renderer(renderer);\n  wire_renderer_sequence_change.call(this, renderer);\n  return renderer;\n};\n\nlet try_import_symbols = (renderer, namespace, url) => {\n  _Service__WEBPACK_IMPORTED_MODULE_2__[\"default\"].request(url, function (err, doc) {\n    if (doc) {\n      renderer.importIcons(namespace, doc.documentElement, url);\n    }\n  }, \"xml\");\n};\n\nlet zoom_to_fit = renderer => {\n  renderer.fitZoom();\n};\n\nlet make_draggable = function make_draggable(renderer, dragger) {\n  dragger.applyToElement(renderer._canvas);\n  dragger.addTouchZoomControls(renderer, renderer._canvas, this[interactive_symb]);\n  _Dragger__WEBPACK_IMPORTED_MODULE_0__[\"default\"].addScrollZoomControls.call(this[interactive_symb], renderer, renderer._canvas, 0.1);\n};\n\nlet wire_renderer_sequence_change = function wire_renderer_sequence_change(renderer) {\n  var dragger = new ComponentDragger(this);\n  let seq_change_func = () => {\n    try_import_symbols(renderer, \"ui\", \"https://glycodomain.glycomics.ku.dk/icons.svg\");\n    try_import_symbols(renderer, \"sugar\", \"https://glycodomain.glycomics.ku.dk/sugars.svg\");\n    zoom_to_fit(renderer);\n    make_draggable.call(this, renderer, dragger);\n    populate_tracks.call(this);\n    setup_renderer(renderer);\n    renderer.navigation.show();\n    renderer.refresh();\n  };\n  renderer.bind('sequenceChange', seq_change_func);\n};\n\nlet populate_tracks = function populate_tracks() {\n  for (let track of this.querySelectorAll('x-gatortrack')) {\n    this.createTrack(track);\n  }\n};\n\nclass GatorComponent extends WrapHTML {\n\n  static get observedAttributes() {\n    return [];\n  }\n\n  constructor() {\n    super();\n  }\n\n  attributeChangedCallback(name) {}\n\n  connectedCallback() {\n    if (window.ShadyCSS) {\n      ShadyCSS.styleElement(this);\n    }\n    let shadowRoot = this.attachShadow({ mode: 'open' });\n    shadowRoot.appendChild(tmpl.content.cloneNode(true));\n    this[interactive_symb] = new InteractiveState(this);\n    this.renderer = create_renderer.call(this, shadowRoot.getElementById('container'));\n    this.renderer.grow_container = true;\n    if (window.getComputedStyle(this).height && window.getComputedStyle(this).height !== '0px' && window.getComputedStyle(this).height !== 'auto') {\n      this.renderer.grow_container = false;\n      if (window.getComputedStyle(this).getPropertyValue('--fill-viewer')) {\n        this.renderer.fixed_size = true;\n      }\n    }\n  }\n  fitToZoom() {\n    zoom_to_fit(this.renderer);\n  }\n  createTrack(track) {\n    _MASCP__WEBPACK_IMPORTED_MODULE_3__[\"default\"].registerLayer(track.name, {}, [this.renderer]);\n    this.renderer.trackOrder = this.renderer.trackOrder.concat([track.name]);\n    this.renderer.showLayer(track.name);\n    this.renderer.refresh();\n  }\n\n  refreshTracks() {\n    populate_tracks.call(this);\n  }\n\n  get interactive() {\n    return this.hasAttribute('interactive');\n  }\n  set interactive(toggle) {\n    if (toggle) {\n      this.setAttribute('interactive', '');\n    } else {\n      this.removeAttribute('interactive');\n    }\n  }\n}\n\ncustomElements.define('x-protviewer', GatorComponent);\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (GatorComponent);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9qcy9saWIvR2F0b3JDb21wb25lbnQuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vanMvbGliL0dhdG9yQ29tcG9uZW50LmpzPzY4ODUiXSwic291cmNlc0NvbnRlbnQiOlsiXG5pbXBvcnQgRHJhZ2dlciBmcm9tICcuL0RyYWdnZXInO1xuaW1wb3J0IENvbmRlbnNlZFNlcXVlbmNlUmVuZGVyZXIgZnJvbSAnLi9Db25kZW5zZWRTZXF1ZW5jZVJlbmRlcmVyJztcbmltcG9ydCBTZXJ2aWNlIGZyb20gJy4vU2VydmljZSc7XG5pbXBvcnQgTUFTQ1AgZnJvbSAnLi9NQVNDUCc7XG5cbmNsYXNzIERyYWdnYWJsZVJlbmRlcmVyIGV4dGVuZHMgQ29uZGVuc2VkU2VxdWVuY2VSZW5kZXJlciB7XG4gIGNvbnN0cnVjdG9yKGNvbnRhaW5lcikge1xuICAgIHN1cGVyKGNvbnRhaW5lcik7XG4gIH1cbiAgZ2V0VmlzaWJsZUxlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5yaWdodFZpc2libGVSZXNpZHVlKCkgLSB0aGlzLmxlZnRWaXNpYmxlUmVzaWR1ZSgpO1xuICB9XG4gIGdldFRvdGFsTGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLnNlcXVlbmNlLmxlbmd0aDtcbiAgfVxuICBnZXRMZWZ0UG9zaXRpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubGVmdFZpc2libGVSZXNpZHVlKCk7XG4gIH1cbiAgc2V0TGVmdFBvc2l0aW9uKHBvcykge1xuICAgIHJldHVybiB0aGlzLnNldExlZnRWaXNpYmxlUmVzaWR1ZShwb3MpO1xuICB9XG59XG5cbmNvbnN0IHRtcGwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScpO1xuXG50bXBsLmlubmVySFRNTCA9IGBcbjxzdHlsZT5cbiAgOmhvc3Qge1xuICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgfVxuICA6aG9zdChbcmVzaXplYWJsZV0pIHtcbiAgICByZXNpemU6IGJvdGg7XG4gICAgb3ZlcmZsb3c6IGF1dG87XG4gICAgcGFkZGluZy1yaWdodDogNXB4O1xuICAgIHBhZGRpbmctYm90dG9tOiA1cHg7XG4gIH1cbiAgI2NvbnRhaW5lciwgLndpZGdldF9jb250ZW50cyB7XG4gICAgd2lkdGg6IDEwMCU7XG4gICAgaGVpZ2h0OiAxMDAlO1xuICB9XG4gICNjb250YWluZXIge1xuICB9XG48L3N0eWxlPlxuPGRpdiBjbGFzcz1cIndpZGdldF9jb250ZW50c1wiID5cbiAgPGRpdiBpZD1cImNvbnRhaW5lclwiPlxuICA8L2Rpdj5cbjwvZGl2PlxuPHNsb3Q+PC9zbG90PlxuYDtcblxuY29uc3QgaW50ZXJhY3RpdmVfc3ltYiA9IFN5bWJvbCgnaW50ZXJhY3RpdmUnKTtcblxuY2xhc3MgSW50ZXJhY3RpdmVTdGF0ZSB7XG4gIGNvbnN0cnVjdG9yKGNvbXBvbmVudCkge1xuICAgIHRoaXMuY29tcG9uZW50ID0gY29tcG9uZW50O1xuICB9XG4gIGdldCBlbmFibGVkKCkge1xuICAgIHJldHVybiB0aGlzLmNvbXBvbmVudC5pbnRlcmFjdGl2ZTtcbiAgfVxuICBzZXQgZW5hYmxlZCh0b2dnbGUpIHtcbiAgICB0aGlzLmNvbXBvbmVudC5pbnRlcmFjdGl2ZSA9IHRvZ2dsZTtcbiAgfVxufVxuXG5jbGFzcyBDb21wb25lbnREcmFnZ2VyIGV4dGVuZHMgRHJhZ2dlciB7XG4gIGNvbnN0cnVjdG9yKGNvbXBvbmVudCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5jb21wb25lbnQgPSBjb21wb25lbnQ7XG4gIH1cbiAgZ2V0IGVuYWJsZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29tcG9uZW50LmludGVyYWN0aXZlO1xuICB9XG4gIHNldCBlbmFibGVkKHRvZ2dsZSkge1xuICAgIHRoaXMuY29tcG9uZW50LmludGVyYWN0aXZlID0gdG9nZ2xlO1xuICB9XG59XG5cbmZ1bmN0aW9uIFdyYXBIVE1MKCkgeyByZXR1cm4gUmVmbGVjdC5jb25zdHJ1Y3QoSFRNTEVsZW1lbnQsIFtdLCBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3IpOyB9XG5PYmplY3Quc2V0UHJvdG90eXBlT2YoV3JhcEhUTUwucHJvdG90eXBlLCBIVE1MRWxlbWVudC5wcm90b3R5cGUpO1xuT2JqZWN0LnNldFByb3RvdHlwZU9mKFdyYXBIVE1MLCBIVE1MRWxlbWVudCk7XG5cbmlmICh3aW5kb3cuU2hhZHlDU1MpIHtcbiAgU2hhZHlDU1MucHJlcGFyZVRlbXBsYXRlKHRtcGwsICd4LXByb3R2aWV3ZXInKTtcbn1cblxubGV0IHNldHVwX3JlbmRlcmVyID0gZnVuY3Rpb24ocmVuZGVyZXIpIHtcbiAgcmVuZGVyZXIuZm9udF9vcmRlciA9ICdIZWx2ZXRpY2EsIEFyaWFsLCBzYW5zLXNlcmlmJztcbiAgcmVuZGVyZXIuem9vbSA9IDAuODE7XG4gIHJlbmRlcmVyLnBhZGRpbmcgPSAxMDtcbiAgcmVuZGVyZXIudHJhY2tPcmRlciA9IFtdO1xuICByZW5kZXJlci5yZXNldCgpO1xuICByZW5kZXJlci50cmFja0dhcCA9IDY7XG4gIHJlbmRlcmVyLnRyYWNrSGVpZ2h0ID0gNTtcbiAgcmVuZGVyZXIuZml4ZWRGb250U2NhbGUgPSAxO1xufTtcblxubGV0IGNyZWF0ZV9yZW5kZXJlciA9IGZ1bmN0aW9uKGNvbnRhaW5lcil7XG4gIGxldCByZW5kZXJlciA9IG5ldyBEcmFnZ2FibGVSZW5kZXJlcihjb250YWluZXIpO1xuICBzZXR1cF9yZW5kZXJlcihyZW5kZXJlcik7XG4gIHdpcmVfcmVuZGVyZXJfc2VxdWVuY2VfY2hhbmdlLmNhbGwodGhpcyxyZW5kZXJlcik7XG4gIHJldHVybiByZW5kZXJlcjtcbn07XG5cbmxldCB0cnlfaW1wb3J0X3N5bWJvbHMgPSAocmVuZGVyZXIsbmFtZXNwYWNlLHVybCkgPT4ge1xuICBTZXJ2aWNlLnJlcXVlc3QodXJsLGZ1bmN0aW9uKGVycixkb2MpIHtcbiAgICBpZiAoZG9jKSB7XG4gICAgICByZW5kZXJlci5pbXBvcnRJY29ucyhuYW1lc3BhY2UsZG9jLmRvY3VtZW50RWxlbWVudCx1cmwpO1xuICAgIH1cbiAgfSxcInhtbFwiKTtcbn07XG5cbmxldCB6b29tX3RvX2ZpdCA9IChyZW5kZXJlcikgPT4ge1xuICByZW5kZXJlci5maXRab29tKCk7XG59O1xuXG5sZXQgbWFrZV9kcmFnZ2FibGUgPSBmdW5jdGlvbihyZW5kZXJlcixkcmFnZ2VyKSB7XG4gIGRyYWdnZXIuYXBwbHlUb0VsZW1lbnQocmVuZGVyZXIuX2NhbnZhcyk7XG4gIGRyYWdnZXIuYWRkVG91Y2hab29tQ29udHJvbHMocmVuZGVyZXIsIHJlbmRlcmVyLl9jYW52YXMsdGhpc1tpbnRlcmFjdGl2ZV9zeW1iXSk7XG4gIERyYWdnZXIuYWRkU2Nyb2xsWm9vbUNvbnRyb2xzLmNhbGwodGhpc1tpbnRlcmFjdGl2ZV9zeW1iXSxyZW5kZXJlciwgcmVuZGVyZXIuX2NhbnZhcywwLjEpO1xufTtcblxubGV0IHdpcmVfcmVuZGVyZXJfc2VxdWVuY2VfY2hhbmdlID0gZnVuY3Rpb24ocmVuZGVyZXIpIHtcbiAgdmFyIGRyYWdnZXIgPSBuZXcgQ29tcG9uZW50RHJhZ2dlcih0aGlzKTtcbiAgbGV0IHNlcV9jaGFuZ2VfZnVuYyA9ICgpID0+IHtcbiAgICB0cnlfaW1wb3J0X3N5bWJvbHMocmVuZGVyZXIsIFwidWlcIiwgXCJodHRwczovL2dseWNvZG9tYWluLmdseWNvbWljcy5rdS5kay9pY29ucy5zdmdcIik7XG4gICAgdHJ5X2ltcG9ydF9zeW1ib2xzKHJlbmRlcmVyLCBcInN1Z2FyXCIsIFwiaHR0cHM6Ly9nbHljb2RvbWFpbi5nbHljb21pY3Mua3UuZGsvc3VnYXJzLnN2Z1wiKTtcbiAgICB6b29tX3RvX2ZpdChyZW5kZXJlcik7XG4gICAgbWFrZV9kcmFnZ2FibGUuY2FsbCh0aGlzLHJlbmRlcmVyLGRyYWdnZXIpO1xuICAgIHBvcHVsYXRlX3RyYWNrcy5jYWxsKHRoaXMpO1xuICAgIHNldHVwX3JlbmRlcmVyKHJlbmRlcmVyKTtcbiAgICByZW5kZXJlci5uYXZpZ2F0aW9uLnNob3coKTtcbiAgICByZW5kZXJlci5yZWZyZXNoKCk7XG4gIH07XG4gIHJlbmRlcmVyLmJpbmQoJ3NlcXVlbmNlQ2hhbmdlJywgc2VxX2NoYW5nZV9mdW5jKTtcbn07XG5cbmxldCBwb3B1bGF0ZV90cmFja3MgPSBmdW5jdGlvbigpIHtcbiAgZm9yIChsZXQgdHJhY2sgb2YgdGhpcy5xdWVyeVNlbGVjdG9yQWxsKCd4LWdhdG9ydHJhY2snKSkge1xuICAgIHRoaXMuY3JlYXRlVHJhY2sodHJhY2spO1xuICB9XG59XG5cbmNsYXNzIEdhdG9yQ29tcG9uZW50IGV4dGVuZHMgV3JhcEhUTUwge1xuXG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gIH1cblxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lKSB7XG4gIH1cblxuICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICBpZiAod2luZG93LlNoYWR5Q1NTKSB7XG4gICAgICBTaGFkeUNTUy5zdHlsZUVsZW1lbnQodGhpcyk7XG4gICAgfVxuICAgIGxldCBzaGFkb3dSb290ID0gdGhpcy5hdHRhY2hTaGFkb3coe21vZGU6ICdvcGVuJ30pO1xuICAgIHNoYWRvd1Jvb3QuYXBwZW5kQ2hpbGQodG1wbC5jb250ZW50LmNsb25lTm9kZSh0cnVlKSk7XG4gICAgdGhpc1tpbnRlcmFjdGl2ZV9zeW1iXSA9IG5ldyBJbnRlcmFjdGl2ZVN0YXRlKHRoaXMpO1xuICAgIHRoaXMucmVuZGVyZXIgPSBjcmVhdGVfcmVuZGVyZXIuY2FsbCh0aGlzLHNoYWRvd1Jvb3QuZ2V0RWxlbWVudEJ5SWQoJ2NvbnRhaW5lcicpKTtcbiAgICB0aGlzLnJlbmRlcmVyLmdyb3dfY29udGFpbmVyID0gdHJ1ZTtcbiAgICBpZiAoIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMpLmhlaWdodCAmJiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzKS5oZWlnaHQgIT09ICcwcHgnICYmIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMpLmhlaWdodCAhPT0gJ2F1dG8nICkge1xuICAgICAgdGhpcy5yZW5kZXJlci5ncm93X2NvbnRhaW5lciA9IGZhbHNlO1xuICAgICAgaWYgKHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMpLmdldFByb3BlcnR5VmFsdWUoJy0tZmlsbC12aWV3ZXInKSkge1xuICAgICAgICB0aGlzLnJlbmRlcmVyLmZpeGVkX3NpemUgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmaXRUb1pvb20oKSB7XG4gICAgem9vbV90b19maXQodGhpcy5yZW5kZXJlcik7XG4gIH1cbiAgY3JlYXRlVHJhY2sodHJhY2spIHtcbiAgICBNQVNDUC5yZWdpc3RlckxheWVyKHRyYWNrLm5hbWUse30sW3RoaXMucmVuZGVyZXJdKTtcbiAgICB0aGlzLnJlbmRlcmVyLnRyYWNrT3JkZXIgPSB0aGlzLnJlbmRlcmVyLnRyYWNrT3JkZXIuY29uY2F0KFt0cmFjay5uYW1lXSk7XG4gICAgdGhpcy5yZW5kZXJlci5zaG93TGF5ZXIodHJhY2submFtZSk7XG4gICAgdGhpcy5yZW5kZXJlci5yZWZyZXNoKCk7XG4gIH1cblxuICByZWZyZXNoVHJhY2tzKCkge1xuICAgIHBvcHVsYXRlX3RyYWNrcy5jYWxsKHRoaXMpO1xuICB9XG5cbiAgZ2V0IGludGVyYWN0aXZlKCkge1xuICAgIHJldHVybiB0aGlzLmhhc0F0dHJpYnV0ZSgnaW50ZXJhY3RpdmUnKTtcbiAgfVxuICBzZXQgaW50ZXJhY3RpdmUodG9nZ2xlKSB7XG4gICAgaWYgKHRvZ2dsZSkge1xuICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2ludGVyYWN0aXZlJywnJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVtb3ZlQXR0cmlidXRlKCdpbnRlcmFjdGl2ZScpO1xuICAgIH1cbiAgfVxufVxuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ3gtcHJvdHZpZXdlcicsR2F0b3JDb21wb25lbnQpO1xuXG5leHBvcnQgZGVmYXVsdCBHYXRvckNvbXBvbmVudDsiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQWZBO0FBQ0E7QUFpQkE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBeUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVRBO0FBQ0E7QUFXQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBVkE7QUFDQTtBQVlBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFyREE7QUFDQTtBQXVEQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./js/lib/GatorComponent.js\n");

/***/ }),

/***/ "./js/lib/GatorDataReader.js":
/*!***********************************!*\
  !*** ./js/lib/GatorDataReader.js ***!
  \***********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Service__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Service */ \"./js/lib/Service.js\");\n/* harmony import */ var _MASCP__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./MASCP */ \"./js/lib/MASCP.js\");\n/* harmony import */ var _ClustalRunner__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ClustalRunner */ \"./js/lib/ClustalRunner.js\");\n/* harmony import */ var _UniprotReader__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./UniprotReader */ \"./js/lib/UniprotReader.js\");\n/* harmony import */ var _bean__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../bean */ \"./js/bean.js\");\n/**\n * @fileOverview    Retrieve data from the Gator web service\n */\n\n\n\n\n\n\n\nvar localhosts = ['localhost', '10.0.2.2'];\nvar url_base = localhosts.indexOf(window.location.hostname) >= 0 ? 'https://test.glycocode.com/api' : '/api';\nvar cloudfront_host = '';\n\nvar data_parser = function data_parser(data) {\n  var doc = this.datasetname || (data || {}).datasetname || 'combined';\n  if (!data || !data.data) {\n    return this;\n  }\n  var actual_data = data.data.filter(function (set) {\n    return set.dataset.indexOf(doc) >= 0;\n  })[0] || { 'data': [] };\n\n  if (doc.split(',').length > 1) {\n    doc = doc.split(',');\n    var data_by_mime = {};\n    data.data.filter(function (set) {\n      return doc.indexOf(set.dataset) >= 0;\n    }).forEach(function (set) {\n      var mimetype = set.metadata.mimetype;\n      set.data.forEach(function (dat) {\n        dat.dataset = set.dataset;\n        dat.acc = set.acc;\n        if (set.metadata.sample) {\n          dat.species = set.metadata.sample.species;\n        }\n      });\n      data_by_mime[mimetype] = (data_by_mime[mimetype] || []).concat(set.data);\n    });\n    actual_data = { 'data': data_by_mime };\n  }\n\n  if (doc == 'glycodomain') {\n    actual_data = data.data.filter(function (set) {\n      return set.metadata.mimetype == 'application/json+glycodomain';\n    })[0] || { 'data': [] };\n    console.log(actual_data);\n  }\n  if (doc == 'combined' || doc == 'homology' || doc == 'predictions') {\n    var data_by_mime = {};\n    data.data.forEach(function (set) {\n      var mimetype = set.metadata.mimetype;\n      if (!mimetype) {\n        return;\n      }\n      set.data.forEach(function (dat) {\n        dat.dataset = set.dataset;\n        dat.acc = set.acc;\n        if (set.metadata.sample) {\n          dat.species = set.metadata.sample.species;\n        }\n      });\n      data_by_mime[mimetype] = (data_by_mime[mimetype] || []).concat(set.data);\n    });\n    actual_data = { 'data': data_by_mime };\n  }\n  if (doc == 'homology') {\n    actual_data.alignments = data.data.filter(function (set) {\n      return set.dataset == 'homology_alignment';\n    })[0].data;\n  }\n  this._raw_data = actual_data;\n  return this;\n};\n\n/** Default class constructor\n */\nconst GatorDataReader = _Service__WEBPACK_IMPORTED_MODULE_0__[\"default\"].buildService(data_parser);\n\nGatorDataReader.prototype.requestData = function () {\n  var reader_conf = {\n    type: \"GET\",\n    dataType: \"json\",\n    data: {}\n  };\n  var acc = (this._requestset || 'combined') + '/' + (this.agi || this.acc).toLowerCase();\n  var gatorURL = (this._endpointURL || GatorDataReader.server).slice(-1) == '/' ? this._endpointURL + acc : this._endpointURL + '/' + acc;\n  reader_conf.auth = _MASCP__WEBPACK_IMPORTED_MODULE_1__[\"default\"].GATOR_AUTH_TOKEN;\n  reader_conf.api_key = _MASCP__WEBPACK_IMPORTED_MODULE_1__[\"default\"].GATOR_CLIENT_ID;\n  reader_conf.session_cache = true;\n  reader_conf.url = gatorURL;\n  return reader_conf;\n};\n\nvar id_token;\n\nObject.defineProperty(GatorDataReader, 'server', {\n  get: function get() {\n    return url_base.replace('/api', '');\n  },\n  set: function set(url) {\n    url_base = url.replace('/$', '') + '/api';\n  }\n});\n\nObject.defineProperty(GatorDataReader, 'ID_TOKEN', {\n  get: function get() {\n    return id_token;\n  },\n  set: function set(token) {\n    id_token = token;\n    authenticating_promise = null;\n    _bean__WEBPACK_IMPORTED_MODULE_4__[\"default\"].fire(GatorDataReader, 'idtoken');\n  }\n});\n\nvar is_anonymous;\n\nObject.defineProperty(GatorDataReader, 'anonymous', {\n  get: function get() {\n    return is_anonymous;\n  },\n  set: function set(anon) {\n    is_anonymous = anon;\n    id_token = null;\n    authenticating_promise = null;\n  }\n});\n\nvar authenticating_promise;\n\nvar anonymous_login = function anonymous_login() {\n  return new Promise(function (resolve, reject) {\n    _Service__WEBPACK_IMPORTED_MODULE_0__[\"default\"].request({ 'url': url_base + '/login?cachebuster=' + new Date().getTime(),\n      'type': 'GET'\n    }, function (err, token) {\n      if (err) {\n        reject(err);\n      } else {\n        var auth_token = JSON.parse(token);\n        if (typeof auth_token == 'string') {\n          auth_token = { id_token: auth_token };\n        }\n        GatorDataReader.ID_TOKEN = auth_token.id_token;\n        resolve(url_base);\n      }\n    }, true);\n  });\n};\n\nvar reading_was_ok = true;\n\nvar reauth_reader = function reauth_reader(reader_class) {\n  var current_retrieve = reader_class.prototype.retrieve;\n  reader_class.prototype.retrieve = function () {\n    console.log('Retrieve with auth retry');\n    var current_arguments = [].slice.call(arguments);\n    var self = this;\n    this.bind('error', function (err) {\n      if (err.status == 401 || err.status == 403) {\n        if (!self.tried_auth) {\n          self.unbind('error');\n          self.tried_auth = true;\n          if (reading_was_ok) {\n            delete _MASCP__WEBPACK_IMPORTED_MODULE_1__[\"default\"].GATOR_AUTH_TOKEN;\n            GatorDataReader.ID_TOKEN = null;\n            authenticating_promise = null;\n            _bean__WEBPACK_IMPORTED_MODULE_4__[\"default\"].fire(GatorDataReader, 'unauthorized');\n            reading_was_ok = false;\n          }\n          authenticate_gator().catch(function (err) {\n            console.log(\"Error after auth\", err);\n            throw err;\n          }).then(function () {\n            reading_was_ok = true;\n            self.retrieve.apply(self, current_arguments);\n          }).catch(function (err) {\n            console.log(\"Died on doing the reauth\", err);\n          });\n        }\n      }\n    });\n    current_retrieve.apply(self, current_arguments);\n  };\n};\n\nreauth_reader(GatorDataReader);\n\nwindow.addEventListener(\"unhandledrejection\", function (err, promise) {\n  if (err.reason && err.reason.message == 'Unauthorized' && !err.reason.handled) {\n    err.reason.handled = true;\n    _bean__WEBPACK_IMPORTED_MODULE_4__[\"default\"].fire(GatorDataReader, 'unauthorized');\n    return;\n  }\n  console.log(err);\n});\n\nvar authenticate_gator = function authenticate_gator() {\n  if (authenticating_promise) {\n    return authenticating_promise;\n  }\n  // Need to put this somewhere for the moment\n  // Temporary code until we move to a single host\n  _ClustalRunner__WEBPACK_IMPORTED_MODULE_2__[\"default\"].SERVICE_URL = url_base + '/tools/clustal';\n  _UniprotReader__WEBPACK_IMPORTED_MODULE_3__[\"default\"].SERVICE_URL = url_base + '/data/latest/uniprot';\n  if (!_UniprotReader__WEBPACK_IMPORTED_MODULE_3__[\"default\"].reauthed) {\n    reauth_reader(_UniprotReader__WEBPACK_IMPORTED_MODULE_3__[\"default\"]);\n  }\n  _UniprotReader__WEBPACK_IMPORTED_MODULE_3__[\"default\"].reauthed = true;\n\n  if (!GatorDataReader.ID_TOKEN && GatorDataReader.anonymous) {\n    console.log(\"Doing an anonymous login\");\n    authenticating_promise = anonymous_login().then(function () {\n      authenticating_promise = null;\n    }).then(authenticate_gator);\n    return authenticating_promise;\n  }\n\n  if (!GatorDataReader.ID_TOKEN && !GatorDataReader.anonymous) {\n    console.log(\"We cannot log in without an ID TOKEN, waiting for token\");\n\n    authenticating_promise = new Promise(function (resolve, reject) {\n      var resolver = function resolver() {\n        console.log(\"Got a new ID token\");\n        _bean__WEBPACK_IMPORTED_MODULE_4__[\"default\"].remove(GatorDataReader, 'idtoken', resolver);\n        _MASCP__WEBPACK_IMPORTED_MODULE_1__[\"default\"].GATOR_AUTH_TOKEN = GatorDataReader.ID_TOKEN;\n        resolve(url_base);\n      };\n      _bean__WEBPACK_IMPORTED_MODULE_4__[\"default\"].add(GatorDataReader, 'idtoken', resolver);\n      setTimeout(function () {\n        console.log(\"Timed out logging in\");\n        reject(new Error('Timed out'));\n      }, 5000);\n    });\n    return authenticating_promise;\n  }\n\n  authenticating_promise = new Promise(function (resolve, reject) {\n    setTimeout(function () {\n      _MASCP__WEBPACK_IMPORTED_MODULE_1__[\"default\"].GATOR_AUTH_TOKEN = GatorDataReader.ID_TOKEN;\n      _bean__WEBPACK_IMPORTED_MODULE_4__[\"default\"].fire(GatorDataReader, 'auth', [url_base]);\n      resolve(url_base);\n    }, 0);\n  });\n\n  return authenticating_promise;\n};\n\nGatorDataReader.prototype.setupSequenceRenderer = function (renderer) {\n  var self = this;\n  if (this.datasetname !== 'homology') {\n    return;\n  }\n  renderer.forceTrackAccs = true;\n  renderer.addAxisScale('homology', function (pos, accession, inverse) {\n    if (!self.result || self.agi === accession.name || self.acc === accession.name) {\n      return pos;\n    }\n    if (inverse) {\n      return self.result.calculateSequencePositionFromPosition(self.agi || self.acc, accession.name.toLowerCase(), pos);\n    }\n    return self.result.calculatePositionForSequence(self.agi || self.acc, accession.name.toLowerCase(), pos);\n  });\n};\n\n(function () {\n  var normalise_insertions = function normalise_insertions(inserts) {\n    var pos;\n    var positions = [];\n    var result_data = {};\n    for (pos in inserts) {\n      if (inserts.hasOwnProperty(pos) && parseInt(pos) >= -1) {\n        positions.push(parseInt(pos));\n      }\n    }\n    positions = positions.sort(function sortfunction(a, b) {\n      return a - b;\n    });\n\n    // From highest to lowest position, loop through and\n    // subtract the lengths of previous subtratctions from\n    // the final position value.\n\n    for (var i = positions.length - 1; i >= 0; i--) {\n      var j = i - 1;\n      pos = parseInt(positions[i]);\n      var value = inserts[pos];\n      while (j >= 0) {\n        pos -= inserts[positions[j]].length;\n        j--;\n      }\n      if (!value.match(/^\\s+$/)) {\n        result_data[pos + 1] = value + (result_data[pos + 1] || '');\n      }\n    }\n    //    delete result_data[0];\n    return result_data;\n  };\n\n  var splice_char = function splice_char(seqs, index, insertions) {\n    for (var i = 0; i < seqs.length; i++) {\n      var seq = seqs[i].toString();\n      if (seq.charAt(index) != '-') {\n        if (!insertions[i]) {\n          insertions[i] = {};\n          insertions[i][-1] = '';\n        }\n        insertions[i][index - 1] = seq.charAt(index);\n        if (insertions[i][index] && insertions[i][index].match(/\\w/)) {\n          insertions[i][index - 1] += insertions[i][index];\n          delete insertions[i][index];\n        }\n      } else {\n        if (insertions[i]) {\n          insertions[i][index - 1] = ' ';\n          if ((insertions[i][index] || '').match(/^\\s+$/)) {\n            insertions[i][index - 1] += insertions[i][index];\n            delete insertions[i][index];\n          }\n        }\n      }\n      seqs[i] = seq.slice(0, index) + seq.slice(index + 1);\n    }\n  };\n\n  GatorDataReader.Result.prototype.makeSequences = function (ref_acc, alignments) {\n    var seqs = [];\n    var insertions = [];\n    var accs = [];\n    var ref_cigar = '';\n    alignments.forEach(function (align) {\n      if (!align.cigar && align.cigar_line) {\n        align.cigar = align.cigar_line;\n        delete align.cigar_line;\n      }\n      // If the cigar line hasn't already been revivified\n      if (!align.cigar.match(/^[\\-\\.]*$/)) {\n        // Expand out the cigar line replacing M with . and D with -\n        align.cigar = align.cigar.match(/\\d*[MD]/g).map(function (bit) {\n          return new Array((parseInt(bit.slice(0, -1)) || 1) + 1).join(bit.slice(-1) == 'M' ? '.' : '-');\n        }).join('');\n      }\n      if (align.uniprot !== ref_acc.toUpperCase()) {\n        accs.push(align.uniprot);\n        seqs.push(align.cigar);\n      } else {\n        ref_cigar = align.cigar;\n      }\n    });\n    var aligning_seq = ref_cigar,\n        i = aligning_seq.length - 1;\n    for (i; i >= 0; i--) {\n      if (aligning_seq.charAt(i) == '-') {\n        splice_char(seqs, i, insertions);\n      }\n    }\n    for (i = 0; i < seqs.length; i++) {\n      if (insertions[i]) {\n        insertions[i] = normalise_insertions(insertions[i]);\n        var seq = seqs[i];\n        seqs[i] = { 'sequence': seq, 'insertions': insertions[i] };\n        seqs[i].toString = function () {\n          return this.sequence;\n        };\n      }\n    }\n    var result = {};\n    accs.forEach(function (acc, idx) {\n      result[acc.toLowerCase()] = seqs[idx];\n    });\n    result[ref_acc.toLowerCase()] = ref_cigar.replace('-', '');\n    return result;\n  };\n})();\n\nGatorDataReader.Result.prototype.calculatePositionForSequence = function (ref_acc, idx, pos) {\n  if (ref_acc.toLowerCase() === idx.toLowerCase()) {\n    return pos;\n  }\n  if (!this.sequences) {\n    this.sequences = this.makeSequences(ref_acc, this._raw_data.alignments);\n  }\n\n  var inserts = this.sequences[idx.toLowerCase()].insertions || {};\n  var result = pos;\n  var actual_position = 0;\n  var seq = this.sequences[idx.toLowerCase()].toString();\n  for (var i = 0; i < seq.length; i++) {\n    if (inserts[i]) {\n      actual_position += inserts[i].length;\n    }\n    actual_position += 1;\n    if (seq.charAt(i) == '-') {\n      actual_position -= 1;\n    }\n    if (pos <= actual_position) {\n      if (pos == actual_position) {\n        return i + 1;\n      } else {\n        if (i == 0) {\n          i = 1;\n        }\n        return -1 * i;\n      }\n    }\n  }\n  return -1 * seq.length;\n};\n\nGatorDataReader.Result.prototype.calculateSequencePositionFromPosition = function (ref_acc, idx, pos) {\n  if (ref_acc.toLowerCase() === idx.toLowerCase()) {\n    return pos;\n  }\n  if (!this.sequences) {\n    this.sequences = this.makeSequences(ref_acc, this._raw_data.alignments);\n  }\n  var inserts = this.sequences[idx.toLowerCase()].insertions || {};\n  var result = pos;\n  var actual_position = 0;\n  var seq = this.sequences[idx.toLowerCase()].toString();\n  for (var i = 0; i < pos; i++) {\n    if (inserts[i]) {\n      actual_position += inserts[i].length;\n    }\n    actual_position += 1;\n    if (seq.charAt(i) == '-') {\n      actual_position -= 1;\n    }\n  }\n  if (actual_position == 0) {\n    actual_position += 1;\n  }\n  return actual_position;\n};\n\nvar default_result = GatorDataReader.Result;\n\nObject.defineProperty(GatorDataReader.prototype, 'datasetname', {\n  get: function get() {\n    return this._datasetname;\n  },\n  set: function set(value) {\n    this._datasetname = value;\n    this._requestset = value === 'homology' ? 'homology' : 'combined';\n    let alt_result = class extends default_result {\n      constructor(data) {\n        data.datasetname = value;\n        super(data);\n        return this;\n      }\n    };\n    this.Result = alt_result;\n  }\n});\nGatorDataReader.authenticate = function () {\n  return authenticate_gator();\n};\n\nvar running_promises = {};\n\nvar new_retrieve = function new_retrieve(acc) {\n  var self = this;\n  var orig_arguments = [].slice.call(arguments);\n  if (running_promises[acc + '-' + this._requestset]) {\n    running_promises[acc + '-' + this._requestset].then(function (result) {\n      GatorDataReader.prototype.retrieve.apply(self, orig_arguments);\n    }).catch(function (err) {\n      authenticate_gator().then(function () {\n        new_retrieve.apply(self, orig_arguments);\n      });\n    });\n    return;\n  }\n  running_promises[acc + '-' + this._requestset] = new Promise(function (resolve, reject) {\n    self.bind('resultReceived', resolve);\n    self.once('error', reject);\n  });\n\n  running_promises[acc + '-' + this._requestset].catch(function (err) {\n    authenticate_gator().then(function () {\n      running_promises[acc + '-' + self._requestset] = null;\n    });\n  });\n\n  GatorDataReader.prototype.retrieve.apply(self, orig_arguments);\n};\n\nGatorDataReader.createReader = function (doc) {\n  // Do the auth dance here\n\n  var reader = new GatorDataReader(null, url_base + '/data/latest/');\n  console.log(doc);\n  reader.datasetname = doc;\n  // MASCP.Service.CacheService(reader);\n\n  authenticate_gator().then(function () {\n    reader.retrieve = new_retrieve;\n    _bean__WEBPACK_IMPORTED_MODULE_4__[\"default\"].fire(reader, 'ready');\n  });\n\n  return reader;\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (GatorDataReader);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9qcy9saWIvR2F0b3JEYXRhUmVhZGVyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL2pzL2xpYi9HYXRvckRhdGFSZWFkZXIuanM/OWEyZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBmaWxlT3ZlcnZpZXcgICAgUmV0cmlldmUgZGF0YSBmcm9tIHRoZSBHYXRvciB3ZWIgc2VydmljZVxuICovXG5cbmltcG9ydCBTZXJ2aWNlIGZyb20gJy4vU2VydmljZSc7XG5pbXBvcnQgTUFTQ1AgZnJvbSAnLi9NQVNDUCc7XG5pbXBvcnQgQ2x1c3RhbFJ1bm5lciBmcm9tICcuL0NsdXN0YWxSdW5uZXInO1xuaW1wb3J0IFVuaXByb3RSZWFkZXIgZnJvbSAnLi9Vbmlwcm90UmVhZGVyJztcbmltcG9ydCBiZWFuIGZyb20gJy4uL2JlYW4nO1xuXG5cbnZhciBsb2NhbGhvc3RzID0gWydsb2NhbGhvc3QnLCcxMC4wLjIuMiddO1xudmFyIHVybF9iYXNlID0gbG9jYWxob3N0cy5pbmRleE9mKHdpbmRvdy5sb2NhdGlvbi5ob3N0bmFtZSkgPj0gMCA/ICdodHRwczovL3Rlc3QuZ2x5Y29jb2RlLmNvbS9hcGknIDogJy9hcGknO1xudmFyIGNsb3VkZnJvbnRfaG9zdCA9ICcnO1xuXG52YXIgZGF0YV9wYXJzZXIgPSAgIGZ1bmN0aW9uKGRhdGEpIHtcbiAgdmFyIGRvYyA9IHRoaXMuZGF0YXNldG5hbWUgfHwgKGRhdGEgfHwge30pLmRhdGFzZXRuYW1lIHx8ICdjb21iaW5lZCc7XG4gIGlmICggISBkYXRhIHx8ICEgZGF0YS5kYXRhICkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHZhciBhY3R1YWxfZGF0YSA9IGRhdGEuZGF0YS5maWx0ZXIoZnVuY3Rpb24oc2V0KSB7XG4gICAgcmV0dXJuIHNldC5kYXRhc2V0LmluZGV4T2YoZG9jKSA+PSAwO1xuICB9KVswXSB8fCB7J2RhdGEnIDogW10gfTtcblxuICBpZiAoZG9jLnNwbGl0KCcsJykubGVuZ3RoID4gMSkge1xuICAgIGRvYyA9IGRvYy5zcGxpdCgnLCcpO1xuICAgIHZhciBkYXRhX2J5X21pbWUgPSB7fTtcbiAgICBkYXRhLmRhdGEuZmlsdGVyKGZ1bmN0aW9uKHNldCkge1xuICAgICAgcmV0dXJuIGRvYy5pbmRleE9mKHNldC5kYXRhc2V0KSA+PSAwO1xuICAgIH0pLmZvckVhY2goZnVuY3Rpb24oc2V0KSB7XG4gICAgICAgIHZhciBtaW1ldHlwZSA9IHNldC5tZXRhZGF0YS5taW1ldHlwZTtcbiAgICAgICAgc2V0LmRhdGEuZm9yRWFjaChmdW5jdGlvbihkYXQpIHtcbiAgICAgICAgICAgIGRhdC5kYXRhc2V0ID0gc2V0LmRhdGFzZXQ7XG4gICAgICAgICAgICBkYXQuYWNjID0gc2V0LmFjYztcbiAgICAgICAgICAgIGlmIChzZXQubWV0YWRhdGEuc2FtcGxlKSB7XG4gICAgICAgICAgICAgIGRhdC5zcGVjaWVzID0gc2V0Lm1ldGFkYXRhLnNhbXBsZS5zcGVjaWVzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICBkYXRhX2J5X21pbWVbbWltZXR5cGVdID0gKGRhdGFfYnlfbWltZVttaW1ldHlwZV0gfHwgW10pLmNvbmNhdChzZXQuZGF0YSk7XG4gICAgfSk7XG4gICAgYWN0dWFsX2RhdGEgPSB7ICdkYXRhJyA6IGRhdGFfYnlfbWltZSB9O1xuICB9XG5cbiAgaWYgKGRvYyA9PSAnZ2x5Y29kb21haW4nKSB7XG4gICAgICBhY3R1YWxfZGF0YSA9IGRhdGEuZGF0YS5maWx0ZXIoZnVuY3Rpb24oc2V0KSB7XG4gICAgICAgICAgcmV0dXJuIHNldC5tZXRhZGF0YS5taW1ldHlwZSA9PSAnYXBwbGljYXRpb24vanNvbitnbHljb2RvbWFpbic7XG4gICAgICB9KVswXSB8fCB7J2RhdGEnIDogW10gfTtcbiAgICAgIGNvbnNvbGUubG9nKGFjdHVhbF9kYXRhKTtcbiAgfVxuICBpZiAoZG9jID09ICdjb21iaW5lZCcgfHwgZG9jID09ICdob21vbG9neScgfHwgZG9jID09ICdwcmVkaWN0aW9ucycpIHtcbiAgICAgIHZhciBkYXRhX2J5X21pbWUgPSB7fTtcbiAgICAgIGRhdGEuZGF0YS5mb3JFYWNoKGZ1bmN0aW9uKHNldCkge1xuICAgICAgICAgIHZhciBtaW1ldHlwZSA9IHNldC5tZXRhZGF0YS5taW1ldHlwZTtcbiAgICAgICAgICBpZiAoICEgbWltZXR5cGUgKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHNldC5kYXRhLmZvckVhY2goZnVuY3Rpb24oZGF0KSB7XG4gICAgICAgICAgICAgIGRhdC5kYXRhc2V0ID0gc2V0LmRhdGFzZXQ7XG4gICAgICAgICAgICAgIGRhdC5hY2MgPSBzZXQuYWNjO1xuICAgICAgICAgICAgICBpZiAoc2V0Lm1ldGFkYXRhLnNhbXBsZSkge1xuICAgICAgICAgICAgICAgIGRhdC5zcGVjaWVzID0gc2V0Lm1ldGFkYXRhLnNhbXBsZS5zcGVjaWVzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgZGF0YV9ieV9taW1lW21pbWV0eXBlXSA9IChkYXRhX2J5X21pbWVbbWltZXR5cGVdIHx8IFtdKS5jb25jYXQoc2V0LmRhdGEpO1xuICAgICAgfSk7XG4gICAgICBhY3R1YWxfZGF0YSA9IHsgJ2RhdGEnIDogZGF0YV9ieV9taW1lIH07XG4gIH1cbiAgaWYgKGRvYyA9PSAnaG9tb2xvZ3knKSB7XG4gICAgYWN0dWFsX2RhdGEuYWxpZ25tZW50cyA9IGRhdGEuZGF0YS5maWx0ZXIoZnVuY3Rpb24oc2V0KSB7IHJldHVybiBzZXQuZGF0YXNldCA9PSAnaG9tb2xvZ3lfYWxpZ25tZW50JzsgfSlbMF0uZGF0YTtcbiAgfVxuICB0aGlzLl9yYXdfZGF0YSA9IGFjdHVhbF9kYXRhO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKiBEZWZhdWx0IGNsYXNzIGNvbnN0cnVjdG9yXG4gKi9cbmNvbnN0IEdhdG9yRGF0YVJlYWRlciA9IFNlcnZpY2UuYnVpbGRTZXJ2aWNlKGRhdGFfcGFyc2VyKTtcblxuR2F0b3JEYXRhUmVhZGVyLnByb3RvdHlwZS5yZXF1ZXN0RGF0YSA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcmVhZGVyX2NvbmYgPSB7XG4gICAgICAgICAgdHlwZTogXCJHRVRcIixcbiAgICAgICAgICBkYXRhVHlwZTogXCJqc29uXCIsXG4gICAgICAgICAgZGF0YTogeyB9XG4gICAgICB9O1xuICB2YXIgYWNjID0gKCB0aGlzLl9yZXF1ZXN0c2V0IHx8ICdjb21iaW5lZCcgKSArICcvJyArICh0aGlzLmFnaSB8fCB0aGlzLmFjYykudG9Mb3dlckNhc2UoKTtcbiAgdmFyIGdhdG9yVVJMID0gKHRoaXMuX2VuZHBvaW50VVJMIHx8IEdhdG9yRGF0YVJlYWRlci5zZXJ2ZXIpLnNsaWNlKC0xKSA9PSAnLycgPyB0aGlzLl9lbmRwb2ludFVSTCsgYWNjIDogdGhpcy5fZW5kcG9pbnRVUkwrJy8nK2FjYztcbiAgcmVhZGVyX2NvbmYuYXV0aCA9IE1BU0NQLkdBVE9SX0FVVEhfVE9LRU47XG4gIHJlYWRlcl9jb25mLmFwaV9rZXkgPSBNQVNDUC5HQVRPUl9DTElFTlRfSUQ7XG4gIHJlYWRlcl9jb25mLnNlc3Npb25fY2FjaGUgPSB0cnVlO1xuICByZWFkZXJfY29uZi51cmwgPSBnYXRvclVSTDtcbiAgcmV0dXJuIHJlYWRlcl9jb25mO1xufTtcblxudmFyIGlkX3Rva2VuO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoR2F0b3JEYXRhUmVhZGVyLCAnc2VydmVyJywge1xuICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB1cmxfYmFzZS5yZXBsYWNlKCcvYXBpJywnJyk7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24odXJsKSB7XG4gICAgdXJsX2Jhc2UgPSB1cmwucmVwbGFjZSgnLyQnLCcnKSArICcvYXBpJztcbiAgfVxufSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShHYXRvckRhdGFSZWFkZXIsICdJRF9UT0tFTicsIHtcbiAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gaWRfdG9rZW47XG4gIH0sXG4gIHNldDogZnVuY3Rpb24odG9rZW4pIHtcbiAgICBpZF90b2tlbiA9IHRva2VuO1xuICAgIGF1dGhlbnRpY2F0aW5nX3Byb21pc2UgPSBudWxsO1xuICAgIGJlYW4uZmlyZShHYXRvckRhdGFSZWFkZXIsJ2lkdG9rZW4nKTtcbiAgfVxufSk7XG5cbnZhciBpc19hbm9ueW1vdXM7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShHYXRvckRhdGFSZWFkZXIsICdhbm9ueW1vdXMnLCB7XG4gIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGlzX2Fub255bW91cztcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbihhbm9uKSB7XG4gICAgaXNfYW5vbnltb3VzID0gYW5vbjtcbiAgICBpZF90b2tlbiA9IG51bGw7XG4gICAgYXV0aGVudGljYXRpbmdfcHJvbWlzZSA9IG51bGw7XG4gIH1cbn0pO1xuXG52YXIgYXV0aGVudGljYXRpbmdfcHJvbWlzZTtcblxudmFyIGFub255bW91c19sb2dpbiA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSxyZWplY3QpIHtcbiAgICAgIFNlcnZpY2UucmVxdWVzdCh7J3VybCcgOiB1cmxfYmFzZSArICcvbG9naW4/Y2FjaGVidXN0ZXI9JysobmV3IERhdGUoKSkuZ2V0VGltZSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAndHlwZScgOiAnR0VUJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sZnVuY3Rpb24oZXJyLHRva2VuKSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgYXV0aF90b2tlbiA9IEpTT04ucGFyc2UodG9rZW4pO1xuICAgICAgICAgIGlmICh0eXBlb2YgYXV0aF90b2tlbiA9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgYXV0aF90b2tlbiA9IHsgaWRfdG9rZW46IGF1dGhfdG9rZW4gfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgR2F0b3JEYXRhUmVhZGVyLklEX1RPS0VOID0gYXV0aF90b2tlbi5pZF90b2tlbjtcbiAgICAgICAgICByZXNvbHZlKHVybF9iYXNlKTtcbiAgICAgICAgfVxuICAgICAgfSx0cnVlKTtcbiAgICB9KTtcbn07XG5cbnZhciByZWFkaW5nX3dhc19vayA9IHRydWU7XG5cbnZhciByZWF1dGhfcmVhZGVyID0gZnVuY3Rpb24ocmVhZGVyX2NsYXNzKSB7XG4gIHZhciBjdXJyZW50X3JldHJpZXZlID0gcmVhZGVyX2NsYXNzLnByb3RvdHlwZS5yZXRyaWV2ZTtcbiAgcmVhZGVyX2NsYXNzLnByb3RvdHlwZS5yZXRyaWV2ZSA9IGZ1bmN0aW9uKCkge1xuICAgIGNvbnNvbGUubG9nKCdSZXRyaWV2ZSB3aXRoIGF1dGggcmV0cnknKTtcbiAgICB2YXIgY3VycmVudF9hcmd1bWVudHMgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHRoaXMuYmluZCgnZXJyb3InLGZ1bmN0aW9uKGVycikge1xuICAgICAgaWYgKGVyci5zdGF0dXMgPT0gNDAxIHx8IGVyci5zdGF0dXMgPT0gNDAzKSB7XG4gICAgICAgIGlmICggISBzZWxmLnRyaWVkX2F1dGggKSB7XG4gICAgICAgICAgc2VsZi51bmJpbmQoJ2Vycm9yJyk7XG4gICAgICAgICAgc2VsZi50cmllZF9hdXRoID0gdHJ1ZTtcbiAgICAgICAgICBpZiAocmVhZGluZ193YXNfb2spIHtcbiAgICAgICAgICAgIGRlbGV0ZSBNQVNDUC5HQVRPUl9BVVRIX1RPS0VOO1xuICAgICAgICAgICAgR2F0b3JEYXRhUmVhZGVyLklEX1RPS0VOID0gbnVsbDtcbiAgICAgICAgICAgIGF1dGhlbnRpY2F0aW5nX3Byb21pc2UgPSBudWxsO1xuICAgICAgICAgICAgYmVhbi5maXJlKEdhdG9yRGF0YVJlYWRlciwndW5hdXRob3JpemVkJyk7XG4gICAgICAgICAgICByZWFkaW5nX3dhc19vayA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhdXRoZW50aWNhdGVfZ2F0b3IoKS5jYXRjaChmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRXJyb3IgYWZ0ZXIgYXV0aFwiLGVycik7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJlYWRpbmdfd2FzX29rID0gdHJ1ZTtcbiAgICAgICAgICAgIHNlbGYucmV0cmlldmUuYXBwbHkoc2VsZixjdXJyZW50X2FyZ3VtZW50cyk7XG4gICAgICAgICAgfSkuY2F0Y2goZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIkRpZWQgb24gZG9pbmcgdGhlIHJlYXV0aFwiLGVycik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICBjdXJyZW50X3JldHJpZXZlLmFwcGx5KHNlbGYsY3VycmVudF9hcmd1bWVudHMpO1xuICB9O1xufTtcblxucmVhdXRoX3JlYWRlcihHYXRvckRhdGFSZWFkZXIpO1xuXG5cbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwidW5oYW5kbGVkcmVqZWN0aW9uXCIsIGZ1bmN0aW9uKGVyciwgcHJvbWlzZSkge1xuICBpZiAoZXJyLnJlYXNvbiAmJiBlcnIucmVhc29uLm1lc3NhZ2UgPT0gJ1VuYXV0aG9yaXplZCcgJiYgISBlcnIucmVhc29uLmhhbmRsZWQpIHtcbiAgICBlcnIucmVhc29uLmhhbmRsZWQgPSB0cnVlO1xuICAgIGJlYW4uZmlyZShHYXRvckRhdGFSZWFkZXIsJ3VuYXV0aG9yaXplZCcpO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zb2xlLmxvZyhlcnIpO1xufSk7XG5cbnZhciBhdXRoZW50aWNhdGVfZ2F0b3IgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoYXV0aGVudGljYXRpbmdfcHJvbWlzZSkge1xuICAgICAgcmV0dXJuIGF1dGhlbnRpY2F0aW5nX3Byb21pc2U7XG4gICAgfVxuICAgIC8vIE5lZWQgdG8gcHV0IHRoaXMgc29tZXdoZXJlIGZvciB0aGUgbW9tZW50XG4gICAgLy8gVGVtcG9yYXJ5IGNvZGUgdW50aWwgd2UgbW92ZSB0byBhIHNpbmdsZSBob3N0XG4gICAgQ2x1c3RhbFJ1bm5lci5TRVJWSUNFX1VSTCA9IHVybF9iYXNlICsgJy90b29scy9jbHVzdGFsJztcbiAgICBVbmlwcm90UmVhZGVyLlNFUlZJQ0VfVVJMID0gdXJsX2Jhc2UgKyAnL2RhdGEvbGF0ZXN0L3VuaXByb3QnO1xuICAgIGlmICggISBVbmlwcm90UmVhZGVyLnJlYXV0aGVkICkge1xuICAgICAgcmVhdXRoX3JlYWRlcihVbmlwcm90UmVhZGVyKTtcbiAgICB9XG4gICAgVW5pcHJvdFJlYWRlci5yZWF1dGhlZCA9IHRydWU7XG5cbiAgICBpZiAoICEgR2F0b3JEYXRhUmVhZGVyLklEX1RPS0VOICYmIEdhdG9yRGF0YVJlYWRlci5hbm9ueW1vdXMgKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIkRvaW5nIGFuIGFub255bW91cyBsb2dpblwiKTtcbiAgICAgIGF1dGhlbnRpY2F0aW5nX3Byb21pc2UgPSBhbm9ueW1vdXNfbG9naW4oKS50aGVuKGZ1bmN0aW9uKCkgeyBhdXRoZW50aWNhdGluZ19wcm9taXNlID0gbnVsbDsgfSkudGhlbihhdXRoZW50aWNhdGVfZ2F0b3IpO1xuICAgICAgcmV0dXJuIGF1dGhlbnRpY2F0aW5nX3Byb21pc2U7XG4gICAgfVxuXG4gICAgaWYgKCAhIEdhdG9yRGF0YVJlYWRlci5JRF9UT0tFTiAmJiAhIEdhdG9yRGF0YVJlYWRlci5hbm9ueW1vdXMgKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIldlIGNhbm5vdCBsb2cgaW4gd2l0aG91dCBhbiBJRCBUT0tFTiwgd2FpdGluZyBmb3IgdG9rZW5cIik7XG5cbiAgICAgIGF1dGhlbnRpY2F0aW5nX3Byb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLHJlamVjdCkge1xuICAgICAgICB2YXIgcmVzb2x2ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIkdvdCBhIG5ldyBJRCB0b2tlblwiKTtcbiAgICAgICAgICBiZWFuLnJlbW92ZShHYXRvckRhdGFSZWFkZXIsJ2lkdG9rZW4nLHJlc29sdmVyKTtcbiAgICAgICAgICBNQVNDUC5HQVRPUl9BVVRIX1RPS0VOID0gR2F0b3JEYXRhUmVhZGVyLklEX1RPS0VOO1xuICAgICAgICAgIHJlc29sdmUodXJsX2Jhc2UpO1xuICAgICAgICB9O1xuICAgICAgICBiZWFuLmFkZChHYXRvckRhdGFSZWFkZXIsJ2lkdG9rZW4nLHJlc29sdmVyKTtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIlRpbWVkIG91dCBsb2dnaW5nIGluXCIpO1xuICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ1RpbWVkIG91dCcpKTtcbiAgICAgICAgfSw1MDAwKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGF1dGhlbnRpY2F0aW5nX3Byb21pc2U7XG4gICAgfVxuXG4gICAgYXV0aGVudGljYXRpbmdfcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUscmVqZWN0KSB7XG4gICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICBNQVNDUC5HQVRPUl9BVVRIX1RPS0VOID0gR2F0b3JEYXRhUmVhZGVyLklEX1RPS0VOO1xuICAgICAgICBiZWFuLmZpcmUoR2F0b3JEYXRhUmVhZGVyLCdhdXRoJyxbdXJsX2Jhc2VdKTtcbiAgICAgICAgcmVzb2x2ZSh1cmxfYmFzZSk7XG4gICAgICB9LDApO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGF1dGhlbnRpY2F0aW5nX3Byb21pc2U7XG59O1xuXG5HYXRvckRhdGFSZWFkZXIucHJvdG90eXBlLnNldHVwU2VxdWVuY2VSZW5kZXJlciA9IGZ1bmN0aW9uKHJlbmRlcmVyKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGlmICh0aGlzLmRhdGFzZXRuYW1lICE9PSAnaG9tb2xvZ3knKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJlbmRlcmVyLmZvcmNlVHJhY2tBY2NzID0gdHJ1ZTtcbiAgICByZW5kZXJlci5hZGRBeGlzU2NhbGUoJ2hvbW9sb2d5JyxmdW5jdGlvbihwb3MsYWNjZXNzaW9uLGludmVyc2UpIHtcbiAgICAgICAgaWYgKCAhIHNlbGYucmVzdWx0IHx8IHNlbGYuYWdpID09PSBhY2Nlc3Npb24ubmFtZSB8fCBzZWxmLmFjYyA9PT0gYWNjZXNzaW9uLm5hbWUgKSB7XG4gICAgICAgICAgcmV0dXJuIHBvcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIGludmVyc2UgKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5yZXN1bHQuY2FsY3VsYXRlU2VxdWVuY2VQb3NpdGlvbkZyb21Qb3NpdGlvbihzZWxmLmFnaSB8fCBzZWxmLmFjYyxhY2Nlc3Npb24ubmFtZS50b0xvd2VyQ2FzZSgpLHBvcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlbGYucmVzdWx0LmNhbGN1bGF0ZVBvc2l0aW9uRm9yU2VxdWVuY2Uoc2VsZi5hZ2kgfHwgc2VsZi5hY2MsYWNjZXNzaW9uLm5hbWUudG9Mb3dlckNhc2UoKSxwb3MpO1xuICAgIH0pO1xufTtcblxuXG4oZnVuY3Rpb24oKSB7XG52YXIgbm9ybWFsaXNlX2luc2VydGlvbnMgPSBmdW5jdGlvbihpbnNlcnRzKSB7XG4gICAgdmFyIHBvcztcbiAgICB2YXIgcG9zaXRpb25zID0gW107XG4gICAgdmFyIHJlc3VsdF9kYXRhID0ge307XG4gICAgZm9yIChwb3MgaW4gaW5zZXJ0cykge1xuICAgICAgICBpZiAoaW5zZXJ0cy5oYXNPd25Qcm9wZXJ0eShwb3MpICYmIHBhcnNlSW50KHBvcykgPj0gLTEpIHtcbiAgICAgICAgICAgIHBvc2l0aW9ucy5wdXNoKHBhcnNlSW50KHBvcykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHBvc2l0aW9ucyA9IHBvc2l0aW9ucy5zb3J0KGZ1bmN0aW9uIHNvcnRmdW5jdGlvbihhLCBiKXtcbiAgICAgICAgcmV0dXJuIChhIC0gYik7XG4gICAgfSk7XG5cbiAgICAvLyBGcm9tIGhpZ2hlc3QgdG8gbG93ZXN0IHBvc2l0aW9uLCBsb29wIHRocm91Z2ggYW5kXG4gICAgLy8gc3VidHJhY3QgdGhlIGxlbmd0aHMgb2YgcHJldmlvdXMgc3VidHJhdGN0aW9ucyBmcm9tXG4gICAgLy8gdGhlIGZpbmFsIHBvc2l0aW9uIHZhbHVlLlxuXG4gICAgZm9yICh2YXIgaSA9IHBvc2l0aW9ucy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICB2YXIgaiA9IGkgLSAxO1xuICAgICAgICBwb3MgPSBwYXJzZUludChwb3NpdGlvbnNbaV0pO1xuICAgICAgICB2YXIgdmFsdWUgPSBpbnNlcnRzW3Bvc107XG4gICAgICAgIHdoaWxlIChqID49IDApIHtcbiAgICAgICAgICAgIHBvcyAtPSBpbnNlcnRzW3Bvc2l0aW9uc1tqXV0ubGVuZ3RoO1xuICAgICAgICAgICAgai0tO1xuICAgICAgICB9XG4gICAgICAgIGlmICghIHZhbHVlLm1hdGNoKC9eXFxzKyQvKSkge1xuICAgICAgICAgICAgcmVzdWx0X2RhdGFbcG9zKzFdID0gdmFsdWUgKyAocmVzdWx0X2RhdGFbcG9zKzFdIHx8ICcnKTtcbiAgICAgICAgfVxuICAgIH1cbi8vICAgIGRlbGV0ZSByZXN1bHRfZGF0YVswXTtcbiAgICByZXR1cm4gcmVzdWx0X2RhdGE7XG59O1xuXG52YXIgc3BsaWNlX2NoYXIgPSBmdW5jdGlvbihzZXFzLGluZGV4LGluc2VydGlvbnMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlcXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHNlcSA9IHNlcXNbaV0udG9TdHJpbmcoKTtcbiAgICAgICAgaWYgKHNlcS5jaGFyQXQoaW5kZXgpICE9ICctJykge1xuICAgICAgICAgICAgaWYgKCAhIGluc2VydGlvbnNbaV0gKSB7XG4gICAgICAgICAgICAgICAgaW5zZXJ0aW9uc1tpXSA9IHt9O1xuICAgICAgICAgICAgICAgIGluc2VydGlvbnNbaV1bLTFdID0gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbnNlcnRpb25zW2ldW2luZGV4IC0gMV0gPSBzZXEuY2hhckF0KGluZGV4KTtcbiAgICAgICAgICAgIGlmIChpbnNlcnRpb25zW2ldW2luZGV4XSAmJiBpbnNlcnRpb25zW2ldW2luZGV4XS5tYXRjaCgvXFx3LykpIHtcbiAgICAgICAgICAgICAgICBpbnNlcnRpb25zW2ldW2luZGV4LTFdICs9IGluc2VydGlvbnNbaV1baW5kZXhdO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBpbnNlcnRpb25zW2ldW2luZGV4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICggaW5zZXJ0aW9uc1tpXSApIHtcbiAgICAgICAgICAgICAgICBpbnNlcnRpb25zW2ldW2luZGV4IC0gMV0gPSAnICc7XG4gICAgICAgICAgICAgICAgaWYgKChpbnNlcnRpb25zW2ldW2luZGV4XSB8fCAnJykubWF0Y2goL15cXHMrJC8pKSB7XG4gICAgICAgICAgICAgICAgICAgIGluc2VydGlvbnNbaV1baW5kZXgtMV0gKz0gaW5zZXJ0aW9uc1tpXVtpbmRleF07XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBpbnNlcnRpb25zW2ldW2luZGV4XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2Vxc1tpXSA9IHNlcS5zbGljZSgwLGluZGV4KSArIHNlcS5zbGljZShpbmRleCsxKTtcbiAgICB9XG59O1xuXG5HYXRvckRhdGFSZWFkZXIuUmVzdWx0LnByb3RvdHlwZS5tYWtlU2VxdWVuY2VzID0gZnVuY3Rpb24ocmVmX2FjYyxhbGlnbm1lbnRzKSB7XG4gIHZhciBzZXFzID0gW107XG4gIHZhciBpbnNlcnRpb25zID0gW107XG4gIHZhciBhY2NzID0gW107XG4gIHZhciByZWZfY2lnYXIgPSAnJztcbiAgYWxpZ25tZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGFsaWduKSB7XG4gICAgaWYgKCAhIGFsaWduLmNpZ2FyICYmIGFsaWduLmNpZ2FyX2xpbmUpIHtcbiAgICAgIGFsaWduLmNpZ2FyID0gYWxpZ24uY2lnYXJfbGluZTtcbiAgICAgIGRlbGV0ZSBhbGlnbi5jaWdhcl9saW5lO1xuICAgIH1cbiAgICAvLyBJZiB0aGUgY2lnYXIgbGluZSBoYXNuJ3QgYWxyZWFkeSBiZWVuIHJldml2aWZpZWRcbiAgICBpZiAoISBhbGlnbi5jaWdhci5tYXRjaCgvXltcXC1cXC5dKiQvKSkge1xuICAgICAgLy8gRXhwYW5kIG91dCB0aGUgY2lnYXIgbGluZSByZXBsYWNpbmcgTSB3aXRoIC4gYW5kIEQgd2l0aCAtXG4gICAgICBhbGlnbi5jaWdhciA9IGFsaWduLmNpZ2FyLm1hdGNoKC9cXGQqW01EXS9nKVxuICAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24oYml0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBcnJheSgocGFyc2VJbnQoYml0LnNsaWNlKDAsLTEpKSB8fCAxKSsxKS5qb2luKCBiaXQuc2xpY2UoLTEpID09ICdNJyA/ICcuJyA6ICctJyApO1xuICAgICAgICAgICAgICAgICAgICAgICAgIH0pLmpvaW4oJycpO1xuICAgIH1cbiAgICBpZiAoYWxpZ24udW5pcHJvdCAhPT0gcmVmX2FjYy50b1VwcGVyQ2FzZSgpKSB7XG4gICAgICBhY2NzLnB1c2goYWxpZ24udW5pcHJvdCk7XG4gICAgICBzZXFzLnB1c2goYWxpZ24uY2lnYXIpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJlZl9jaWdhciA9IGFsaWduLmNpZ2FyO1xuICAgIH1cbiAgfSk7XG4gIHZhciBhbGlnbmluZ19zZXEgPSByZWZfY2lnYXIsIGkgPSBhbGlnbmluZ19zZXEubGVuZ3RoIC0gMTtcbiAgZm9yIChpOyBpID49IDA7IGktLSkge1xuICAgICAgaWYgKGFsaWduaW5nX3NlcS5jaGFyQXQoaSkgPT0gJy0nKSB7XG4gICAgICAgICAgc3BsaWNlX2NoYXIoc2VxcyxpLGluc2VydGlvbnMpO1xuICAgICAgfVxuICB9XG4gIGZvciAoaSA9IDA7IGkgPCBzZXFzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoaW5zZXJ0aW9uc1tpXSkge1xuICAgICAgICAgIGluc2VydGlvbnNbaV0gPSBub3JtYWxpc2VfaW5zZXJ0aW9ucyhpbnNlcnRpb25zW2ldKTtcbiAgICAgICAgICB2YXIgc2VxID0gc2Vxc1tpXTtcbiAgICAgICAgICBzZXFzW2ldID0geyAnc2VxdWVuY2UnIDogc2VxLCAnaW5zZXJ0aW9ucycgOiBpbnNlcnRpb25zW2ldIH07XG4gICAgICAgICAgc2Vxc1tpXS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZXF1ZW5jZTtcbiAgICAgICAgICB9O1xuICAgICAgfVxuICB9XG4gIHZhciByZXN1bHQgPSB7fTtcbiAgYWNjcy5mb3JFYWNoKGZ1bmN0aW9uKGFjYyxpZHgpIHtcbiAgICByZXN1bHRbYWNjLnRvTG93ZXJDYXNlKCldID0gc2Vxc1tpZHhdO1xuICB9KTtcbiAgcmVzdWx0W3JlZl9hY2MudG9Mb3dlckNhc2UoKV0gPSByZWZfY2lnYXIucmVwbGFjZSgnLScsJycpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcbn0pKCk7XG5cblxuR2F0b3JEYXRhUmVhZGVyLlJlc3VsdC5wcm90b3R5cGUuY2FsY3VsYXRlUG9zaXRpb25Gb3JTZXF1ZW5jZSA9IGZ1bmN0aW9uKHJlZl9hY2MsaWR4LHBvcykge1xuICBpZiAocmVmX2FjYy50b0xvd2VyQ2FzZSgpID09PSBpZHgudG9Mb3dlckNhc2UoKSkge1xuICAgIHJldHVybiBwb3M7XG4gIH1cbiAgaWYgKCAhIHRoaXMuc2VxdWVuY2VzICkge1xuICAgIHRoaXMuc2VxdWVuY2VzID0gdGhpcy5tYWtlU2VxdWVuY2VzKHJlZl9hY2MsdGhpcy5fcmF3X2RhdGEuYWxpZ25tZW50cyk7XG4gIH1cblxuICB2YXIgaW5zZXJ0cyA9IHRoaXMuc2VxdWVuY2VzW2lkeC50b0xvd2VyQ2FzZSgpXS5pbnNlcnRpb25zIHx8IHt9O1xuICB2YXIgcmVzdWx0ID0gcG9zO1xuICB2YXIgYWN0dWFsX3Bvc2l0aW9uID0gMDtcbiAgdmFyIHNlcSA9IHRoaXMuc2VxdWVuY2VzW2lkeC50b0xvd2VyQ2FzZSgpXS50b1N0cmluZygpO1xuICBmb3IgKHZhciBpID0gMCA7IGkgPCBzZXEubGVuZ3RoOyBpKysgKSB7XG4gICAgICBpZiAoaW5zZXJ0c1tpXSkge1xuICAgICAgICAgIGFjdHVhbF9wb3NpdGlvbiArPSBpbnNlcnRzW2ldLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGFjdHVhbF9wb3NpdGlvbiArPSAxO1xuICAgICAgaWYgKHNlcS5jaGFyQXQoaSkgPT0gJy0nKSB7XG4gICAgICAgICAgYWN0dWFsX3Bvc2l0aW9uIC09IDE7XG4gICAgICB9XG4gICAgICBpZiAocG9zIDw9IGFjdHVhbF9wb3NpdGlvbikge1xuICAgICAgICAgIGlmIChwb3MgPT0gYWN0dWFsX3Bvc2l0aW9uKSB7XG4gICAgICAgICAgICAgIHJldHVybiAoaSsxKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoaSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICBpID0gMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gLTEgKiBpO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgfVxuICByZXR1cm4gLTEgKiBzZXEubGVuZ3RoO1xufTtcblxuR2F0b3JEYXRhUmVhZGVyLlJlc3VsdC5wcm90b3R5cGUuY2FsY3VsYXRlU2VxdWVuY2VQb3NpdGlvbkZyb21Qb3NpdGlvbiA9IGZ1bmN0aW9uKHJlZl9hY2MsaWR4LHBvcykge1xuICBpZiAocmVmX2FjYy50b0xvd2VyQ2FzZSgpID09PSBpZHgudG9Mb3dlckNhc2UoKSkge1xuICAgIHJldHVybiBwb3M7XG4gIH1cbiAgaWYgKCAhIHRoaXMuc2VxdWVuY2VzICkge1xuICAgIHRoaXMuc2VxdWVuY2VzID0gdGhpcy5tYWtlU2VxdWVuY2VzKHJlZl9hY2MsdGhpcy5fcmF3X2RhdGEuYWxpZ25tZW50cyk7XG4gIH1cbiAgdmFyIGluc2VydHMgPSB0aGlzLnNlcXVlbmNlc1tpZHgudG9Mb3dlckNhc2UoKV0uaW5zZXJ0aW9ucyB8fCB7fTtcbiAgdmFyIHJlc3VsdCA9IHBvcztcbiAgdmFyIGFjdHVhbF9wb3NpdGlvbiA9IDA7XG4gIHZhciBzZXEgPSB0aGlzLnNlcXVlbmNlc1tpZHgudG9Mb3dlckNhc2UoKV0udG9TdHJpbmcoKTtcbiAgZm9yICh2YXIgaSA9IDAgOyBpIDwgcG9zOyBpKysgKSB7XG4gICAgICBpZiAoaW5zZXJ0c1tpXSkge1xuICAgICAgICAgIGFjdHVhbF9wb3NpdGlvbiArPSBpbnNlcnRzW2ldLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGFjdHVhbF9wb3NpdGlvbiArPSAxO1xuICAgICAgaWYgKHNlcS5jaGFyQXQoaSkgPT0gJy0nKSB7XG4gICAgICAgICAgYWN0dWFsX3Bvc2l0aW9uIC09IDE7XG4gICAgICB9XG4gIH1cbiAgaWYgKGFjdHVhbF9wb3NpdGlvbiA9PSAwKSB7XG4gICAgICBhY3R1YWxfcG9zaXRpb24gKz0gMTtcbiAgfVxuICByZXR1cm4gYWN0dWFsX3Bvc2l0aW9uO1xufTtcblxuXG5cblxudmFyIGRlZmF1bHRfcmVzdWx0ID0gR2F0b3JEYXRhUmVhZGVyLlJlc3VsdDtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEdhdG9yRGF0YVJlYWRlci5wcm90b3R5cGUsICdkYXRhc2V0bmFtZScsIHtcbiAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2RhdGFzZXRuYW1lO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgdGhpcy5fZGF0YXNldG5hbWUgPSB2YWx1ZTtcbiAgICAgIHRoaXMuX3JlcXVlc3RzZXQgPSAodmFsdWUgPT09ICdob21vbG9neScpID8gJ2hvbW9sb2d5JyA6ICdjb21iaW5lZCc7XG4gICAgICBsZXQgYWx0X3Jlc3VsdCA9IGNsYXNzIGV4dGVuZHMgZGVmYXVsdF9yZXN1bHQge1xuICAgICAgICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgICAgICAgZGF0YS5kYXRhc2V0bmFtZSA9IHZhbHVlO1xuICAgICAgICAgIHN1cGVyKGRhdGEpO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdGhpcy5SZXN1bHQgPSBhbHRfcmVzdWx0O1xuICAgIH1cbn0pO1xuR2F0b3JEYXRhUmVhZGVyLmF1dGhlbnRpY2F0ZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gYXV0aGVudGljYXRlX2dhdG9yKCk7XG59O1xuXG52YXIgcnVubmluZ19wcm9taXNlcyA9IHt9O1xuXG52YXIgbmV3X3JldHJpZXZlID0gZnVuY3Rpb24oYWNjKSB7XG4gIHZhciBzZWxmID0gdGhpcztcbiAgdmFyIG9yaWdfYXJndW1lbnRzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICBpZiAocnVubmluZ19wcm9taXNlc1thY2MrJy0nK3RoaXMuX3JlcXVlc3RzZXRdKSB7XG4gICAgcnVubmluZ19wcm9taXNlc1thY2MrJy0nK3RoaXMuX3JlcXVlc3RzZXRdLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICBHYXRvckRhdGFSZWFkZXIucHJvdG90eXBlLnJldHJpZXZlLmFwcGx5KHNlbGYsb3JpZ19hcmd1bWVudHMpO1xuICAgIH0pLmNhdGNoKGZ1bmN0aW9uKGVycikge1xuICAgICAgYXV0aGVudGljYXRlX2dhdG9yKCkudGhlbihmdW5jdGlvbigpe1xuICAgICAgICBuZXdfcmV0cmlldmUuYXBwbHkoc2VsZixvcmlnX2FyZ3VtZW50cyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm47XG4gIH1cbiAgcnVubmluZ19wcm9taXNlc1thY2MrJy0nK3RoaXMuX3JlcXVlc3RzZXRdID0gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSxyZWplY3QpIHtcbiAgICBzZWxmLmJpbmQoJ3Jlc3VsdFJlY2VpdmVkJyxyZXNvbHZlKTtcbiAgICBzZWxmLm9uY2UoJ2Vycm9yJyxyZWplY3QpO1xuICB9KTtcblxuICBydW5uaW5nX3Byb21pc2VzW2FjYysnLScrdGhpcy5fcmVxdWVzdHNldF0uY2F0Y2goZnVuY3Rpb24oZXJyKSB7XG4gICAgYXV0aGVudGljYXRlX2dhdG9yKCkudGhlbihmdW5jdGlvbigpeyBydW5uaW5nX3Byb21pc2VzW2FjYysnLScrc2VsZi5fcmVxdWVzdHNldF0gPSBudWxsIH0pO1xuICB9KTtcblxuICBHYXRvckRhdGFSZWFkZXIucHJvdG90eXBlLnJldHJpZXZlLmFwcGx5KHNlbGYsb3JpZ19hcmd1bWVudHMpO1xufTtcblxuR2F0b3JEYXRhUmVhZGVyLmNyZWF0ZVJlYWRlciA9IGZ1bmN0aW9uKGRvYykge1xuICAgIC8vIERvIHRoZSBhdXRoIGRhbmNlIGhlcmVcblxuICAgIHZhciByZWFkZXIgPSBuZXcgR2F0b3JEYXRhUmVhZGVyKG51bGwsdXJsX2Jhc2UrJy9kYXRhL2xhdGVzdC8nKTtcbiAgICBjb25zb2xlLmxvZyhkb2MpO1xuICAgIHJlYWRlci5kYXRhc2V0bmFtZSA9IGRvYztcbiAgICAvLyBNQVNDUC5TZXJ2aWNlLkNhY2hlU2VydmljZShyZWFkZXIpO1xuXG4gICAgYXV0aGVudGljYXRlX2dhdG9yKCkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgIHJlYWRlci5yZXRyaWV2ZSA9IG5ld19yZXRyaWV2ZTtcbiAgICAgIGJlYW4uZmlyZShyZWFkZXIsJ3JlYWR5Jyk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVhZGVyO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgR2F0b3JEYXRhUmVhZGVyOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQU5BO0FBQ0E7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFSQTtBQUNBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVJBO0FBQ0E7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFEQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFMQTtBQU9BO0FBQ0E7QUFmQTtBQWlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./js/lib/GatorDataReader.js\n");

/***/ }),

/***/ "./js/lib/GeneComponent.js":
/*!*********************************!*\
  !*** ./js/lib/GeneComponent.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _GenomeReader__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GenomeReader */ \"./js/lib/GenomeReader.js\");\n/* harmony import */ var _GatorComponent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GatorComponent */ \"./js/lib/GatorComponent.js\");\n\n\n\n\nclass GeneComponent extends _GatorComponent__WEBPACK_IMPORTED_MODULE_1__[\"default\"] {\n  static get observedAttributes() {\n    return ['geneid'];\n  }\n\n  constructor() {\n    super();\n  }\n\n  connectedCallback() {\n    super.connectedCallback();\n    setup_renderer.call(this);\n    retrieve_data.call(this);\n  }\n\n  attributeChangedCallback(name) {\n    if (name === 'geneid' && this.renderer) {\n      retrieve_data.call(this);\n      return;\n    }\n  }\n\n  get geneid() {\n    return this.getAttribute('geneid');\n  }\n  set geneid(id) {\n    this.setAttribute('geneid', id);\n  }\n}\n\nlet reader_has_data = function reader_has_data() {\n  if (!this.geneid) {\n    return;\n  }\n  console.log('Getting data for ', this.geneid);\n  var reader = new _GenomeReader__WEBPACK_IMPORTED_MODULE_0__[\"default\"]();\n  reader.geneid = this.geneid;\n  if (this.hasAttribute('reviewed')) {\n    reader.reviewed = true;\n  }\n  // reader.uniprot = 'Q10472';\n  reader.exon_margin = 300; //..this.exonmargin || 300;\n  if (this.nt_mapping) {\n    reader.nt_mapping = this.nt_mapping;\n  }\n  if (!this.ready) {\n    reader.registerSequenceRenderer(this.renderer);\n    reader.bind('requestComplete', () => {\n      this.renderer.hideAxis();\n      this.renderer.fitZoom();\n    });\n    this.ready = new Promise(resolve => {\n      reader.bind('requestComplete', () => {\n        this.uniprots = Object.keys(reader.result._raw_data.data).map(up => up.toUpperCase());\n        if (reader.reviewed) {\n          this.uniprots = this.uniprots.filter(up => up === reader.swissprot.toUpperCase());\n        }\n        this.refreshTracks();\n        resolve();\n        delete this.ready;\n        var event = new Event('ready', { bubbles: true });\n        this.dispatchEvent(event);\n      });\n    });\n  }\n\n  reader.retrieve(this.accession || \"\" + this.geneid);\n};\n\nlet setup_renderer = function setup_renderer() {\n  this.renderer.trackOrder = [];\n  this.renderer.reset();\n};\n\nlet retrieve_data = function retrieve_data() {\n  this.renderer.bind('sequenceChange', reader_has_data.bind(this));\n  this.renderer.setSequence('M');\n};\n\ncustomElements.define('x-geneviewer', GeneComponent);\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (GeneComponent);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9qcy9saWIvR2VuZUNvbXBvbmVudC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9qcy9saWIvR2VuZUNvbXBvbmVudC5qcz85ODFiIl0sInNvdXJjZXNDb250ZW50IjpbIiBcbmltcG9ydCBHZW5vbWVSZWFkZXIgZnJvbSAnLi9HZW5vbWVSZWFkZXInO1xuaW1wb3J0IEdhdG9yQ29tcG9uZW50IGZyb20gJy4vR2F0b3JDb21wb25lbnQnO1xuXG5cbmNsYXNzIEdlbmVDb21wb25lbnQgZXh0ZW5kcyBHYXRvckNvbXBvbmVudCB7XG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbJ2dlbmVpZCddO1xuICB9XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgfVxuXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIHN1cGVyLmNvbm5lY3RlZENhbGxiYWNrKCk7XG4gICAgc2V0dXBfcmVuZGVyZXIuY2FsbCh0aGlzKTtcbiAgICByZXRyaWV2ZV9kYXRhLmNhbGwodGhpcyk7XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSkge1xuICAgIGlmIChuYW1lID09PSAnZ2VuZWlkJyAmJiB0aGlzLnJlbmRlcmVyKSB7XG4gICAgICByZXRyaWV2ZV9kYXRhLmNhbGwodGhpcyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgZ2V0IGdlbmVpZCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ2dlbmVpZCcpO1xuICB9XG4gIHNldCBnZW5laWQoaWQpIHtcbiAgICB0aGlzLnNldEF0dHJpYnV0ZSgnZ2VuZWlkJyxpZCk7XG4gIH1cbn1cblxubGV0IHJlYWRlcl9oYXNfZGF0YSA9IGZ1bmN0aW9uKCkge1xuICBpZiAoICEgdGhpcy5nZW5laWQgKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnNvbGUubG9nKCdHZXR0aW5nIGRhdGEgZm9yICcsdGhpcy5nZW5laWQpO1xuICB2YXIgcmVhZGVyID0gbmV3IEdlbm9tZVJlYWRlcigpO1xuICByZWFkZXIuZ2VuZWlkID0gdGhpcy5nZW5laWQ7XG4gIGlmICh0aGlzLmhhc0F0dHJpYnV0ZSgncmV2aWV3ZWQnKSkge1xuICAgIHJlYWRlci5yZXZpZXdlZCA9IHRydWU7XG4gIH1cbiAgLy8gcmVhZGVyLnVuaXByb3QgPSAnUTEwNDcyJztcbiAgcmVhZGVyLmV4b25fbWFyZ2luID0gMzAwOy8vLi50aGlzLmV4b25tYXJnaW4gfHwgMzAwO1xuICBpZiAodGhpcy5udF9tYXBwaW5nKSB7XG4gICAgcmVhZGVyLm50X21hcHBpbmcgPSB0aGlzLm50X21hcHBpbmc7XG4gIH1cbiAgaWYgKCAhIHRoaXMucmVhZHkgKSB7XG4gICAgcmVhZGVyLnJlZ2lzdGVyU2VxdWVuY2VSZW5kZXJlcih0aGlzLnJlbmRlcmVyKTtcbiAgICByZWFkZXIuYmluZCgncmVxdWVzdENvbXBsZXRlJywoKSA9PiB7XG4gICAgICB0aGlzLnJlbmRlcmVyLmhpZGVBeGlzKCk7XG4gICAgICB0aGlzLnJlbmRlcmVyLmZpdFpvb20oKTtcbiAgICB9KTtcbiAgICB0aGlzLnJlYWR5ID0gbmV3IFByb21pc2UoIChyZXNvbHZlKSA9PiB7XG4gICAgICByZWFkZXIuYmluZCgncmVxdWVzdENvbXBsZXRlJywoKSA9PiB7XG4gICAgICAgIHRoaXMudW5pcHJvdHMgPSBPYmplY3Qua2V5cyhyZWFkZXIucmVzdWx0Ll9yYXdfZGF0YS5kYXRhKS5tYXAoIHVwID0+IHVwLnRvVXBwZXJDYXNlKCkgKTtcbiAgICAgICAgaWYgKHJlYWRlci5yZXZpZXdlZCkge1xuICAgICAgICAgIHRoaXMudW5pcHJvdHMgPSB0aGlzLnVuaXByb3RzLmZpbHRlciggdXAgPT4gdXAgPT09IHJlYWRlci5zd2lzc3Byb3QudG9VcHBlckNhc2UoKSApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVmcmVzaFRyYWNrcygpO1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnJlYWR5O1xuICAgICAgICB2YXIgZXZlbnQgPSBuZXcgRXZlbnQoJ3JlYWR5Jyx7YnViYmxlczogdHJ1ZX0pO1xuICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICByZWFkZXIucmV0cmlldmUodGhpcy5hY2Nlc3Npb24gfHwgXCJcIit0aGlzLmdlbmVpZCk7XG5cbn07XG5cbmxldCBzZXR1cF9yZW5kZXJlciA9IGZ1bmN0aW9uKCkge1xuICB0aGlzLnJlbmRlcmVyLnRyYWNrT3JkZXIgPSBbXTtcbiAgdGhpcy5yZW5kZXJlci5yZXNldCgpO1xufTtcblxubGV0IHJldHJpZXZlX2RhdGEgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5yZW5kZXJlci5iaW5kKCdzZXF1ZW5jZUNoYW5nZScscmVhZGVyX2hhc19kYXRhLmJpbmQodGhpcykpO1xuICB0aGlzLnJlbmRlcmVyLnNldFNlcXVlbmNlKCdNJyk7XG59O1xuXG5jdXN0b21FbGVtZW50cy5kZWZpbmUoJ3gtZ2VuZXZpZXdlcicsR2VuZUNvbXBvbmVudCk7XG5cbmV4cG9ydCBkZWZhdWx0IEdlbmVDb21wb25lbnQ7Il0sIm1hcHBpbmdzIjoiOzs7O0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUEzQkE7QUFDQTtBQTZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./js/lib/GeneComponent.js\n");

/***/ }),

/***/ "./js/lib/GenomeReader.js":
/*!********************************!*\
  !*** ./js/lib/GenomeReader.js ***!
  \********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _MASCP__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MASCP */ \"./js/lib/MASCP.js\");\n/* harmony import */ var _Service__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Service */ \"./js/lib/Service.js\");\n/* harmony import */ var _bean__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../bean */ \"./js/bean.js\");\n/** @fileOverview   Classes for reading data from MyGene.info */\n\n\n\n\n\n/** Default class constructor\n *  @class      Service class that will retrieve data from Mygene.info for given sequences\n *  @param      {String} endpointURL    Endpoint URL for this service\n *  @extends    MASCP.Service\n */\nconst GenomeReader = _Service__WEBPACK_IMPORTED_MODULE_1__[\"default\"].buildService(function (data) {\n    this._raw_data = data;\n    return this;\n});\n\nGenomeReader.SERVICE_URL = 'http://mygene.info/v2/query';\nGenomeReader.prototype.requestData = function () {\n    this.acc = this.agi;\n\n    if (!this.geneid) {\n        return {\n            type: \"GET\",\n            dataType: \"json\",\n            url: 'https://mygene.info/v2/query',\n            data: { 'q': 'uniprot:' + this.acc.toUpperCase(),\n                'fields': 'entrezgene',\n                'email': 'joshi%40sund.ku.dk'\n            }\n        };\n    } else if (!this.acc) {\n        this.acc = this.agi = \"\" + this.geneid;\n    }\n\n    if (!this.exons) {\n        return {\n            type: \"GET\",\n            url: 'https://mygene.info/v3/gene/' + this.geneid,\n            dataType: \"json\",\n            data: {\n                'fields': 'exons_hg19,uniprot.Swiss-Prot'\n            }\n        };\n    }\n\n    return {\n        type: \"GET\",\n        dataType: \"txt\",\n        url: \"https://www.uniprot.org/mapping/\",\n        data: {\n            \"from\": \"REFSEQ_NT_ID\",\n            \"to\": \"ACC\",\n            \"format\": \"tab\",\n            \"query\": Object.keys(this.exons).join(' ')\n        }\n    };\n};\n\nlet update_structure = data => {\n    let result = {};\n    for (let transcript of data) {\n        result[transcript.transcript] = transcript;\n        transcript.exons = transcript.position;\n        delete transcript.position;\n    }\n    return result;\n};\n\n(function (serv) {\n    var defaultDataReceived = serv.prototype._dataReceived;\n\n    serv.prototype._dataReceived = function (data, status) {\n        var self = this;\n        if (data.data && status === \"db\") {\n            self.sequences = [{ \"agi\": \"genome\" }];\n            Object.keys(data.data).forEach(function (uniprot) {\n                self.sequences.push({ \"agi\": uniprot.toLowerCase() });\n            });\n            return defaultDataReceived.call(this, data, status);\n        }\n        if (status < 200 || status >= 400) {\n            return defaultDataReceived.call(this, null, status);\n        }\n\n        if (!this.geneid) {\n            this.geneid = data.hits[0].entrezgene;\n            this.retrieve(this.acc || this.agi);\n            return;\n        }\n        if (!this.exons) {\n            this.exons = update_structure(data.exons_hg19 || data.exons);\n            this.swissprot = (data.uniprot || {})['Swiss-Prot'].toLowerCase();\n            if (!this.nt_mapping) {\n                this.retrieve(this.acc || this.agi);\n                return;\n            }\n            data = this.nt_mapping.map(function (map) {\n                return map.join('\\t');\n            }).join('\\n');\n        }\n        var mapped = {};\n        self.sequences = [{ \"agi\": \"genome\" }];\n        (data || \"\").split('\\n').forEach(function (row) {\n            var bits = row.split('\\t');\n            if (!bits[1]) {\n                return;\n            }\n            var uniprot = bits[1].toLowerCase();\n            var nuc = bits[0];\n            nuc = nuc.replace(/\\..*$/, '');\n            if (!self.exons[nuc]) {\n                return;\n            }\n            if (!self.agi || !self.acc) {\n                self.acc = uniprot;\n                self.agi = uniprot;\n            }\n\n            if (!mapped[uniprot]) {\n                mapped[uniprot] = [];\n            }\n            self.exons[nuc]._id = nuc;\n            mapped[uniprot].push(self.exons[nuc]);\n            self.sequences.push({ \"agi\": uniprot.toLowerCase() });\n        });\n        return defaultDataReceived.call(this, { \"data\": mapped }, status);\n    };\n})(GenomeReader);\n\nGenomeReader.Result.prototype.getSequences = function () {\n    var results = [];\n    var cds_data = this._raw_data.data;\n    var uniprots = Object.keys(cds_data);\n    let min, max;\n    min = max = null;\n    uniprots.forEach(function (uniprot) {\n        var ends = cds_data[uniprot].map(function (cd) {\n            if (Array.isArray(cd)) {\n                cd = cd.filter(function (c) {\n                    return c.chr.match(/^[\\dXx]+$/);\n                })[0];\n            }\n            return [cd.txstart, cd.txend];\n        });\n        ends.forEach(function (cd) {\n            if (!min || cd[0] < min) {\n                min = cd[0];\n            }\n            if (!max || cd[1] > max) {\n                max = cd[1];\n            }\n        });\n    });\n    results = [Array(Math.floor((max - min) / 3)).join('.')];\n    this.min = min;\n    this.max = max;\n    return results;\n};\n\nGenomeReader.Result.prototype.getIntrons = function (margin) {\n    var self = this;\n    var results = [];\n    var uprots = Object.keys(self._raw_data.data);\n    uprots.forEach(function (up) {\n        var cds = self._raw_data.data[up];\n        cds.forEach(function (target_cds) {\n            if (Array.isArray(target_cds)) {\n                target_cds = target_cds.filter(function (c) {\n                    return c.chr.match(/^[\\dXx]+$/);\n                })[0];\n                if (!target_cds) {\n                    return null;\n                }\n            }\n\n            var exons = target_cds.exons;\n            var target_position;\n\n            for (var i = 0; i < exons.length; i++) {\n                if (i == 0) {\n                    results.push([self.min, exons[i][0] - margin]);\n                } else {\n                    results.push([exons[i - 1][1] + margin, exons[i][0] - margin]);\n                }\n                if (i == exons.length - 1) {\n                    results.push([exons[i][1] + margin, self.max]);\n                }\n                if (results.slice(-1)[0][0] > results.slice(-1)[0][1]) {\n                    results.splice(results.length - 1, 1);\n                }\n            }\n        });\n    });\n    return results;\n};\n\nGenomeReader.prototype.proteinLength = function (target_cds) {\n    var exons = target_cds.exons;\n    var total = 0;\n    for (var i = 0; i < exons.length; i++) {\n        if (target_cds.cdsstart > exons[i][1] & target_cds.cdsstart > exons[i][0]) {\n            continue;\n        }\n        if (target_cds.cdsend < exons[i][0]) {\n            continue;\n        }\n\n        var start = target_cds.cdsstart > exons[i][0] ? target_cds.cdsstart : exons[i][0];\n        var end = target_cds.cdsend < exons[i][1] ? target_cds.cdsend : exons[i][1];\n        total += end - start;\n    }\n    return Math.floor(total / 3) - 1;\n};\n\nGenomeReader.prototype.calculateSequencePositionFromProteinPosition = function (idx, pos) {\n    var self = this;\n    var wanted_identifier = idx;\n    var cds = self.result._raw_data.data[wanted_identifier.toLowerCase()];\n    if (!cds) {\n        return -1;\n    }\n\n    if (!cds.txstart) {\n        cds = cds.map(function (cd) {\n            if (Array.isArray(cd)) {\n                cd = cd.filter(function (c) {\n                    return c.chr.match(/^[\\dXx]+$/);\n                })[0];\n                if (!cd) {\n                    return null;\n                }\n            }\n            return cd;\n        });\n    }\n\n    var target_cds = cds[0] || {};\n    var exons = target_cds.exons || [];\n\n    var position_genome = Math.floor(pos / 3);\n\n    var target_position = 0;\n\n    if (pos < target_cds.cdsstart) {\n        target_position = 6;\n        if (target_cds.strand == -1) {\n            target_position = 3;\n        }\n    }\n\n    if (pos > target_cds.cdsend) {\n        target_position = self.proteinLength(target_cds) * 3;\n        if (target_cds.strand == 1) {\n            target_position += 3;\n        }\n    }\n    if (target_position == 0) {\n        for (var i = 0; i < exons.length; i++) {\n            if (target_cds.cdsstart > exons[i][1] & target_cds.cdsstart > exons[i][0]) {\n                continue;\n            }\n            var start = target_cds.cdsstart > exons[i][0] ? target_cds.cdsstart : exons[i][0];\n            var end = target_cds.cdsend < exons[i][1] ? target_cds.cdsend : exons[i][1];\n\n            if (pos < start) {\n                break;\n            }\n\n            if (pos <= end && pos >= start) {\n                target_position += pos - start;\n                break;\n            } else {\n                target_position += end - start;\n            }\n        }\n    }\n    target_position = Math.floor(target_position / 3) - 1;\n\n    if (target_cds.strand == -1) {\n        target_position = self.proteinLength(target_cds) - target_position;\n    }\n\n    return target_position;\n};\n\nGenomeReader.prototype.calculateProteinPositionForSequence = function (idx, pos) {\n    var self = this;\n    var wanted_identifier = idx;\n    var cds = self.result._raw_data.data[wanted_identifier.toLowerCase()];\n    if (!cds) {\n        return -1;\n    }\n\n    if (!cds.txstart) {\n        cds = cds.map(function (cd) {\n            if (Array.isArray(cd)) {\n                cd = cd.filter(function (c) {\n                    return c.chr.match(/^[\\dXx]+$/);\n                })[0];\n                if (!cd) {\n                    return null;\n                }\n            }\n            return cd;\n        });\n    }\n\n    var target_cds = cds[0] || {};\n    var exons = target_cds.exons || [];\n\n    if (target_cds.strand == -1) {\n        pos = self.proteinLength(target_cds) - pos;\n    }\n    var position_genome = pos * 3;\n\n    var target_position;\n\n    for (var i = 0; i < exons.length; i++) {\n        if (target_cds.cdsstart > exons[i][1] & target_cds.cdsstart > exons[i][0]) {\n            continue;\n        }\n        var start = target_cds.cdsstart > exons[i][0] ? target_cds.cdsstart : exons[i][0];\n        var bases = exons[i][1] - start;\n        if (bases >= position_genome) {\n            target_position = start + position_genome;\n            break;\n        } else {\n            position_genome -= bases;\n        }\n    }\n    return target_position;\n};\n\nGenomeReader.prototype.calculatePositionForSequence = function (idx, pos) {\n    var self = this;\n    var wanted_identifier = self.sequences[idx].agi;\n    var empty_regions = [];\n    var calculated_pos = pos;\n\n    if (wanted_identifier == 'genome') {\n        // Don't change the genome identifier\n    } else {\n        calculated_pos = self.calculateProteinPositionForSequence(idx, pos);\n    }\n\n    for (var i = 0; i < empty_regions.length; i++) {\n        if (pos > empty_regions[i][1]) {\n            calculated_pos -= empty_regions[i][1] - empty_regions[i][0];\n        }\n        if (pos < empty_regions[i][1] && pos > empty_regions[i][0]) {\n            calculated_pos = -1;\n        }\n    }\n\n    return calculated_pos;\n};\n\n(function (serv) {\n    var get_exon_boxes = function get_exon_boxes(result, uniprot) {\n        var cds_data = result._raw_data.data;\n        if (uniprot) {\n            console.log('Filtering exons so we only show', uniprot);\n        }\n        var uniprots = Object.keys(cds_data);\n        var max = result.max;\n        var min = result.min;\n        var return_data = [];\n        var base_offset = 0;\n        uniprots.filter(up => uniprot ? up === (uniprot || '').toLowerCase() : true).forEach(function (uniprot) {\n            var ends = cds_data[uniprot].map(function (cd, idx) {\n                if (Array.isArray(cd)) {\n                    cd = cd.filter(function (c) {\n                        return c.chr.match(/^[\\dXx]+$/);\n                    })[0];\n                    if (!cd) {\n                        return;\n                    }\n                }\n\n                var exons = cd.exons;\n                var color = idx == 0 ? '#999' : '#f99';\n                exons.forEach(function (exon) {\n                    return_data.push({ \"aa\": 1 + exon[0], \"type\": \"box\", \"width\": exon[1] - exon[0], \"options\": { \"offset\": base_offset, \"height_scale\": 1, \"fill\": color, \"merge\": false } });\n                    if (cd.strand > 0) {\n                        return_data.push({ \"aa\": exon[1] - 1, \"type\": \"marker\", \"options\": { \"height\": 4, \"content\": { \"type\": \"right_triangle\", \"fill\": '#aaa' }, \"offset\": base_offset + 2, \"bare_element\": true } });\n                    } else {\n                        return_data.push({ \"aa\": exon[0] + 1, \"type\": \"marker\", \"options\": { \"height\": 4, \"content\": { \"type\": \"left_triangle\", \"fill\": '#aaa' }, \"offset\": base_offset + 2, \"bare_element\": true } });\n                    }\n                });\n                return_data.push({ \"aa\": cd.cdsstart, \"type\": \"box\", \"width\": 1, \"options\": { \"fill\": \"#0000ff\", \"height_scale\": 2, \"offset\": base_offset - 2, \"merge\": false } });\n                return_data.push({ \"aa\": cd.cdsend, \"type\": \"box\", \"width\": 1, \"options\": { \"fill\": \"#0000ff\", \"height_scale\": 2, \"offset\": base_offset - 2, \"merge\": false } });\n                base_offset += 1;\n            });\n            base_offset += 2;\n        });\n        return return_data;\n    };\n\n    var get_removed_labels = function get_removed_labels(result) {\n        var removed = result.removed_regions || [];\n        var results = [];\n        var max = result.max;\n        var min = result.min;\n        var cds_data = result._raw_data.data;\n        var uniprots = Object.keys(cds_data);\n        var total = uniprots.reduce(function (prev, up) {\n            return prev + cds_data[up].length;\n        }, 0);\n        removed.forEach(function (vals) {\n            var start = vals[0];\n            var end = vals[1];\n            var start_txt = Math.floor(start % 1e6 / 1000) + \"kb\";\n            var end_txt = Math.floor(end % 1e6 / 1000) + \"kb\";\n            results.push({ \"aa\": start - 1, \"type\": \"box\", width: end - start + 3, \"options\": { \"fill\": \"#999\", \"height_scale\": total * 3, \"offset\": -1 * total } });\n            results.push({ \"aa\": start - 3, \"type\": \"text\", \"options\": { \"txt\": start_txt, \"fill\": \"#000\", \"height\": 4, \"offset\": -4, \"align\": \"right\" } });\n            results.push({ \"aa\": end + 3, \"type\": \"text\", \"options\": { \"txt\": end_txt, \"fill\": \"#000\", \"height\": 4, \"offset\": 4, \"align\": \"left\" } });\n        });\n        return results;\n    };\n\n    var calculate_removed_regions = function calculate_removed_regions(result, margin) {\n        var introns = result.getIntrons(margin);\n\n        var intervals = [{ \"index\": result.min - 2, \"start\": true, \"idx\": -1 }, { \"index\": result.min, \"start\": false, \"idx\": -1 }];\n        introns.forEach(function (intron, idx) {\n            intervals.push({ \"index\": intron[0], \"start\": true, \"idx\": idx });\n            intervals.push({ \"index\": intron[1], \"start\": false, \"idx\": idx });\n        });\n\n        intervals.sort(function (a, b) {\n            if (a.index < b.index) {\n                return -1;\n            }\n            if (a.index > b.index) {\n                return 1;\n            }\n            if (a.index == b.index) {\n                return a.start ? -1 : 1;\n            }\n        });\n        var results = [];\n        intervals.forEach(function (intr, idx) {\n            if (intr.start && intervals[idx + 1] && intervals[idx + 1].start == false) {\n                if (intr.index != intervals[idx + 1].index && intervals[idx + 1].index != result.min) {\n                    results.push([intr.index, intervals[idx + 1].index]);\n                }\n            }\n        });\n        result.removed_regions = results;\n    };\n    var generate_scaler_function = function generate_scaler_function(reader) {\n        return function (in_pos, layer, inverse) {\n            var pos = in_pos;\n\n            if (!reader.result) {\n                return inverse ? pos * 3 : Math.floor(pos / 3);\n            }\n\n            var introns = reader.result.removed_regions || [];\n\n            if (inverse) {\n                pos = in_pos * 3;\n                calculated_pos = pos;\n                for (var i = 0; i < introns.length && pos > 0; i++) {\n                    var left_exon = i > 0 ? introns[i - 1] : [null, reader.result.min];\n                    var right_exon = introns[i] || [reader.result.max, null];\n                    pos -= right_exon[0] - left_exon[1];\n                    if (pos > 0) {\n                        calculated_pos += introns[i][1] - introns[i][0];\n                    }\n                }\n                return calculated_pos + reader.result.min;\n            }\n\n            var calculated_pos = pos - reader.result.min;\n            for (var i = 0; i < introns.length; i++) {\n                if (pos > introns[i][1]) {\n                    calculated_pos -= introns[i][1] - introns[i][0];\n                }\n                if (pos < introns[i][1] && pos > introns[i][0]) {\n                    calculated_pos = introns[i][1] - reader.result.min;\n                }\n            }\n            if (calculated_pos < 3) {\n                calculated_pos = 3;\n            }\n            return Math.floor(calculated_pos / 3);\n        };\n    };\n    Object.defineProperty(serv.prototype, 'exon_margin', {\n        set: function set(val) {\n            this._exon_margin = val;\n            if (this.result) {\n                calculate_removed_regions(this.result, val);\n                this.redrawIntrons();\n            }\n        },\n        get: function get() {\n            return this._exon_margin;\n        }\n    });\n\n    var redrawIntrons = function redrawIntrons(renderer, controller_name, scaler_function) {\n        var labs = [];\n        var zoomCheck = function zoomCheck() {\n            if (labs.length < 1 || !labs[0].parentNode) {\n                return;\n            }\n            var hidden = false;\n            for (var i = 0; !hidden && i < labs.length - 3; i += 3) {\n                if (labs[i].hasAttribute('display')) {\n                    hidden = true;\n                    continue;\n                }\n                if (labs[i].getBoundingClientRect().right > labs[i + 3].getBoundingClientRect().left) {\n                    hidden = true;\n                }\n            }\n            labs.forEach(function (lab) {\n                if (lab.nodeName == 'rect') {\n                    return;\n                }if (hidden) {\n                    lab.setAttribute('display', 'none');\n                } else {\n                    lab.removeAttribute('display');\n                }\n            });\n        };\n        renderer.bind('zoomChange', zoomCheck);\n\n        return function () {\n            var result = this.result;\n            renderer.sequence = Array(scaler_function(result.max)).join('.');\n\n            if (labs.length > 0) {\n                labs.forEach(function (lab) {\n                    renderer.remove(controller_name, lab);\n                });\n                labs = [];\n            }\n            var proxy_reader = {\n                agi: controller_name,\n                gotResult: function gotResult() {\n                    labs = renderer.renderObjects(controller_name, get_removed_labels(result));\n                    renderer.refresh();\n                    zoomCheck();\n                }\n            };\n            _Service__WEBPACK_IMPORTED_MODULE_1__[\"default\"].prototype.registerSequenceRenderer.call(proxy_reader, renderer);\n            proxy_reader.gotResult();\n        };\n    };\n\n    serv.prototype.setupSequenceRenderer = function (renderer) {\n        var self = this;\n        renderer.addAxisScale('genome', function (pos, layer, inverse) {\n            if (layer && layer.scales.has('genomic')) {\n                return pos;\n            }\n            let all_scales = Object.keys(self.result._raw_data.data);\n            let identifier = layer.name;\n            for (let scale of all_scales) {\n                if (layer.scales.has(scale.toUpperCase()) || layer.scales.has(scale.toLowerCase())) {\n                    identifier = scale;\n                }\n            }\n            if (inverse) {\n                return self.calculateSequencePositionFromProteinPosition(identifier, pos);\n            }\n            return self.calculateProteinPositionForSequence(identifier, pos);\n        });\n        var controller_name = 'cds';\n        var redraw_alignments = function redraw_alignments(sequence_index) {\n            if (!sequence_index) {\n                sequence_index = 0;\n            }\n            _MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"].registerLayer(controller_name, { 'fullname': 'Exons', 'color': '#000000' });\n            _MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getLayer(controller_name).scales.add('genomic');\n\n            if (renderer.trackOrder.indexOf(controller_name) < 0) {\n                renderer.trackOrder.push(controller_name);\n            }\n            renderer.showLayer(controller_name);\n\n            var result = this.result;\n\n            var aligned = result.getSequences();\n            var scaler_function = generate_scaler_function(self);\n\n            renderer.addAxisScale('removeIntrons', scaler_function);\n\n            calculate_removed_regions(self.result, self.exon_margin || 300);\n\n            if (!renderer.sequence) {\n                // Not sure what to do with this bit here\n\n                renderer.setSequence(Array(scaler_function(result.max)).join('.'))(function () {\n                    redraw_alignments(sequence_index);\n                });\n                return;\n            } else {\n                renderer.sequence = Array(scaler_function(result.max)).join('.');\n                renderer.redrawAxis();\n            }\n            var proxy_reader = {\n                agi: controller_name,\n                gotResult: function gotResult() {\n                    renderer.renderObjects(controller_name, get_exon_boxes(result, self.reviewed ? self.swissprot : self.uniprot));\n                }\n            };\n            _Service__WEBPACK_IMPORTED_MODULE_1__[\"default\"].prototype.registerSequenceRenderer.call(proxy_reader, renderer);\n            proxy_reader.gotResult();\n\n            self.redrawIntrons = redrawIntrons(renderer, controller_name, scaler_function);\n            self.redrawIntrons();\n        };\n\n        this.bind('resultReceived', redraw_alignments);\n    };\n})(GenomeReader);\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (GenomeReader);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9qcy9saWIvR2Vub21lUmVhZGVyLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL2pzL2xpYi9HZW5vbWVSZWFkZXIuanM/ODMyYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiogQGZpbGVPdmVydmlldyAgIENsYXNzZXMgZm9yIHJlYWRpbmcgZGF0YSBmcm9tIE15R2VuZS5pbmZvICovXG5cbmltcG9ydCBNQVNDUCBmcm9tICcuL01BU0NQJztcbmltcG9ydCBTZXJ2aWNlIGZyb20gJy4vU2VydmljZSc7XG5pbXBvcnQgYmVhbiBmcm9tICcuLi9iZWFuJztcblxuXG4vKiogRGVmYXVsdCBjbGFzcyBjb25zdHJ1Y3RvclxuICogIEBjbGFzcyAgICAgIFNlcnZpY2UgY2xhc3MgdGhhdCB3aWxsIHJldHJpZXZlIGRhdGEgZnJvbSBNeWdlbmUuaW5mbyBmb3IgZ2l2ZW4gc2VxdWVuY2VzXG4gKiAgQHBhcmFtICAgICAge1N0cmluZ30gZW5kcG9pbnRVUkwgICAgRW5kcG9pbnQgVVJMIGZvciB0aGlzIHNlcnZpY2VcbiAqICBAZXh0ZW5kcyAgICBNQVNDUC5TZXJ2aWNlXG4gKi9cbmNvbnN0IEdlbm9tZVJlYWRlciA9IFNlcnZpY2UuYnVpbGRTZXJ2aWNlKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Jhd19kYXRhID0gZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuR2Vub21lUmVhZGVyLlNFUlZJQ0VfVVJMID0gJ2h0dHA6Ly9teWdlbmUuaW5mby92Mi9xdWVyeSc7XG5HZW5vbWVSZWFkZXIucHJvdG90eXBlLnJlcXVlc3REYXRhID0gZnVuY3Rpb24oKVxue1xuICAgIHRoaXMuYWNjID0gdGhpcy5hZ2k7XG5cbiAgICBpZiAoISB0aGlzLmdlbmVpZCApIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwiR0VUXCIsXG4gICAgICAgICAgICBkYXRhVHlwZTogXCJqc29uXCIsXG4gICAgICAgICAgICB1cmwgOiAnaHR0cHM6Ly9teWdlbmUuaW5mby92Mi9xdWVyeScsXG4gICAgICAgICAgICBkYXRhOiB7ICdxJyA6ICd1bmlwcm90OicrdGhpcy5hY2MudG9VcHBlckNhc2UoKSxcbiAgICAgICAgICAgICAgICAgICAgJ2ZpZWxkcycgICA6ICdlbnRyZXpnZW5lJyxcbiAgICAgICAgICAgICAgICAgICAgJ2VtYWlsJyAgICA6ICdqb3NoaSU0MHN1bmQua3UuZGsnXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSBlbHNlIGlmICggISB0aGlzLmFjYyApIHtcbiAgICAgICAgdGhpcy5hY2MgPSB0aGlzLmFnaSA9IFwiXCIrdGhpcy5nZW5laWQ7XG4gICAgfVxuXG4gICAgaWYgKCEgdGhpcy5leG9ucyApIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwiR0VUXCIsXG4gICAgICAgICAgICB1cmwgOiAnaHR0cHM6Ly9teWdlbmUuaW5mby92My9nZW5lLycrdGhpcy5nZW5laWQsXG4gICAgICAgICAgICBkYXRhVHlwZTogXCJqc29uXCIsXG4gICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgJ2ZpZWxkcycgOiAnZXhvbnNfaGcxOSx1bmlwcm90LlN3aXNzLVByb3QnXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJHRVRcIixcbiAgICAgICAgZGF0YVR5cGU6IFwidHh0XCIsXG4gICAgICAgIHVybDogXCJodHRwczovL3d3dy51bmlwcm90Lm9yZy9tYXBwaW5nL1wiLFxuICAgICAgICBkYXRhIDoge1xuICAgICAgICAgICAgXCJmcm9tXCIgOiBcIlJFRlNFUV9OVF9JRFwiLFxuICAgICAgICAgICAgXCJ0b1wiIDogXCJBQ0NcIixcbiAgICAgICAgICAgIFwiZm9ybWF0XCIgOiBcInRhYlwiLFxuICAgICAgICAgICAgXCJxdWVyeVwiIDogT2JqZWN0LmtleXModGhpcy5leG9ucykuam9pbignICcpXG4gICAgICAgIH1cbiAgICB9O1xufTtcblxubGV0IHVwZGF0ZV9zdHJ1Y3R1cmUgPSAoZGF0YSkgPT4ge1xuICAgIGxldCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGxldCB0cmFuc2NyaXB0IG9mIGRhdGEpIHtcbiAgICAgICAgcmVzdWx0W3RyYW5zY3JpcHQudHJhbnNjcmlwdF0gPSB0cmFuc2NyaXB0O1xuICAgICAgICB0cmFuc2NyaXB0LmV4b25zID0gdHJhbnNjcmlwdC5wb3NpdGlvbjtcbiAgICAgICAgZGVsZXRlIHRyYW5zY3JpcHQucG9zaXRpb247XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4oZnVuY3Rpb24oc2Vydikge1xuICAgIHZhciBkZWZhdWx0RGF0YVJlY2VpdmVkID0gc2Vydi5wcm90b3R5cGUuX2RhdGFSZWNlaXZlZDtcblxuICAgIHNlcnYucHJvdG90eXBlLl9kYXRhUmVjZWl2ZWQgPSBmdW5jdGlvbihkYXRhLHN0YXR1cylcbiAgICB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgaWYgKGRhdGEuZGF0YSAmJiBzdGF0dXMgPT09IFwiZGJcIikge1xuICAgICAgICAgICAgc2VsZi5zZXF1ZW5jZXMgPSBbeyBcImFnaVwiIDogXCJnZW5vbWVcIiB9XTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGRhdGEuZGF0YSkuZm9yRWFjaChmdW5jdGlvbih1bmlwcm90KSB7XG4gICAgICAgICAgICAgICAgc2VsZi5zZXF1ZW5jZXMucHVzaCh7IFwiYWdpXCIgOiB1bmlwcm90LnRvTG93ZXJDYXNlKCkgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBkZWZhdWx0RGF0YVJlY2VpdmVkLmNhbGwodGhpcyxkYXRhLHN0YXR1cyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXR1cyA8IDIwMCB8fCBzdGF0dXMgPj0gNDAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVmYXVsdERhdGFSZWNlaXZlZC5jYWxsKHRoaXMsbnVsbCxzdGF0dXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCAhIHRoaXMuZ2VuZWlkKSB7XG4gICAgICAgICAgICB0aGlzLmdlbmVpZCA9IGRhdGEuaGl0c1swXS5lbnRyZXpnZW5lO1xuICAgICAgICAgICAgdGhpcy5yZXRyaWV2ZSh0aGlzLmFjYyB8fCB0aGlzLmFnaSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCAhIHRoaXMuZXhvbnMgKSB7XG4gICAgICAgICAgICB0aGlzLmV4b25zID0gdXBkYXRlX3N0cnVjdHVyZShkYXRhLmV4b25zX2hnMTkgfHwgZGF0YS5leG9ucyk7XG4gICAgICAgICAgICB0aGlzLnN3aXNzcHJvdCA9IChkYXRhLnVuaXByb3QgfHwge30pWydTd2lzcy1Qcm90J10udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGlmICggISB0aGlzLm50X21hcHBpbmcgKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXRyaWV2ZSh0aGlzLmFjYyB8fCB0aGlzLmFnaSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGF0YSA9IHRoaXMubnRfbWFwcGluZy5tYXAoZnVuY3Rpb24obWFwKSB7IHJldHVybiBtYXAuam9pbignXFx0Jyk7IH0gKS5qb2luKCdcXG4nKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWFwcGVkID0ge307XG4gICAgICAgIHNlbGYuc2VxdWVuY2VzID0gW3sgXCJhZ2lcIiA6IFwiZ2Vub21lXCIgfV07XG4gICAgICAgIChkYXRhIHx8IFwiXCIpLnNwbGl0KCdcXG4nKS5mb3JFYWNoKGZ1bmN0aW9uKHJvdykge1xuICAgICAgICAgICAgdmFyIGJpdHMgPSByb3cuc3BsaXQoJ1xcdCcpO1xuICAgICAgICAgICAgaWYgKCAhIGJpdHNbMV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdW5pcHJvdCA9IGJpdHNbMV0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIHZhciBudWMgPSBiaXRzWzBdO1xuICAgICAgICAgICAgbnVjID0gbnVjLnJlcGxhY2UoL1xcLi4qJC8sJycpO1xuICAgICAgICAgICAgaWYgKCEgc2VsZi5leG9uc1tudWNdKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCEgc2VsZi5hZ2kgfHwgISBzZWxmLmFjYykge1xuICAgICAgICAgICAgICAgIHNlbGYuYWNjID0gdW5pcHJvdDtcbiAgICAgICAgICAgICAgICBzZWxmLmFnaSA9IHVuaXByb3Q7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICggISBtYXBwZWRbdW5pcHJvdF0gKSB7XG4gICAgICAgICAgICAgICAgbWFwcGVkW3VuaXByb3RdID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLmV4b25zW251Y10uX2lkID0gbnVjO1xuICAgICAgICAgICAgbWFwcGVkW3VuaXByb3RdLnB1c2goc2VsZi5leG9uc1tudWNdKTtcbiAgICAgICAgICAgIHNlbGYuc2VxdWVuY2VzLnB1c2goeyBcImFnaVwiIDogdW5pcHJvdC50b0xvd2VyQ2FzZSgpIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHREYXRhUmVjZWl2ZWQuY2FsbCh0aGlzLHtcImRhdGFcIjptYXBwZWR9LHN0YXR1cyk7XG4gICAgfTtcbn0pKEdlbm9tZVJlYWRlcik7XG5cblxuR2Vub21lUmVhZGVyLlJlc3VsdC5wcm90b3R5cGUuZ2V0U2VxdWVuY2VzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICB2YXIgY2RzX2RhdGEgPSB0aGlzLl9yYXdfZGF0YS5kYXRhO1xuICAgIHZhciB1bmlwcm90cyA9IE9iamVjdC5rZXlzKGNkc19kYXRhKTtcbiAgICBsZXQgbWluLCBtYXg7XG4gICAgbWluID0gbWF4ID0gbnVsbDtcbiAgICB1bmlwcm90cy5mb3JFYWNoKGZ1bmN0aW9uKHVuaXByb3QpIHtcbiAgICAgICAgdmFyIGVuZHMgPSBjZHNfZGF0YVt1bmlwcm90XS5tYXAoZnVuY3Rpb24oY2QpIHtcbiAgICAgICAgICAgIGlmICggQXJyYXkuaXNBcnJheShjZCkgKSB7XG4gICAgICAgICAgICAgICAgY2QgPSBjZC5maWx0ZXIoZnVuY3Rpb24oYykgeyByZXR1cm4gYy5jaHIubWF0Y2goL15bXFxkWHhdKyQvICk7IH0pWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIFsgY2QudHhzdGFydCwgY2QudHhlbmQgXTtcbiAgICAgICAgfSk7XG4gICAgICAgIGVuZHMuZm9yRWFjaChmdW5jdGlvbihjZCkge1xuICAgICAgICAgICAgaWYgKCEgbWluIHx8IGNkWzBdIDwgbWluKSB7XG4gICAgICAgICAgICAgICAgbWluID0gY2RbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoISBtYXggfHwgY2RbMV0gPiBtYXgpIHtcbiAgICAgICAgICAgICAgICBtYXggPSBjZFsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmVzdWx0cyA9IFsgQXJyYXkoIE1hdGguZmxvb3IoIChtYXggLSBtaW4pIC8gMyApICkuam9pbignLicpIF07XG4gICAgdGhpcy5taW4gPSBtaW47XG4gICAgdGhpcy5tYXggPSBtYXg7XG4gICAgcmV0dXJuIHJlc3VsdHM7XG59O1xuXG5HZW5vbWVSZWFkZXIuUmVzdWx0LnByb3RvdHlwZS5nZXRJbnRyb25zID0gZnVuY3Rpb24obWFyZ2luKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciByZXN1bHRzID0gW107XG4gICAgdmFyIHVwcm90cyA9IE9iamVjdC5rZXlzKHNlbGYuX3Jhd19kYXRhLmRhdGEpO1xuICAgIHVwcm90cy5mb3JFYWNoKGZ1bmN0aW9uKHVwKSB7XG4gICAgICAgIHZhciBjZHMgPSBzZWxmLl9yYXdfZGF0YS5kYXRhW3VwXTtcbiAgICAgICAgY2RzLmZvckVhY2goZnVuY3Rpb24odGFyZ2V0X2Nkcykge1xuICAgICAgICAgICAgaWYgKCBBcnJheS5pc0FycmF5KHRhcmdldF9jZHMpICkge1xuICAgICAgICAgICAgICAgIHRhcmdldF9jZHMgPSB0YXJnZXRfY2RzLmZpbHRlcihmdW5jdGlvbihjKSB7IHJldHVybiBjLmNoci5tYXRjaCgvXltcXGRYeF0rJC8gKTsgfSlbMF07XG4gICAgICAgICAgICAgICAgaWYgKCAhIHRhcmdldF9jZHMgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGV4b25zID0gdGFyZ2V0X2Nkcy5leG9ucztcbiAgICAgICAgICAgIHZhciB0YXJnZXRfcG9zaXRpb247XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChbIHNlbGYubWluLCBleG9uc1tpXVswXSAtIG1hcmdpbiBdKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goWyBleG9uc1tpLTFdWzFdICsgbWFyZ2luLCBleG9uc1tpXVswXSAtIG1hcmdpbl0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaSA9PSAoZXhvbnMubGVuZ3RoIC0gMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKFsgZXhvbnNbaV1bMV0gKyBtYXJnaW4sIHNlbGYubWF4IF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0cy5zbGljZSgtMSlbMF1bMF0gPiByZXN1bHRzLnNsaWNlKC0xKVswXVsxXSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnNwbGljZShyZXN1bHRzLmxlbmd0aCAtIDEsMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0cztcbn07XG5cbkdlbm9tZVJlYWRlci5wcm90b3R5cGUucHJvdGVpbkxlbmd0aCA9IGZ1bmN0aW9uKHRhcmdldF9jZHMpIHtcbiAgICB2YXIgZXhvbnMgPSB0YXJnZXRfY2RzLmV4b25zO1xuICAgIHZhciB0b3RhbCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleG9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAodGFyZ2V0X2Nkcy5jZHNzdGFydCA+IGV4b25zW2ldWzFdICYgdGFyZ2V0X2Nkcy5jZHNzdGFydCA+IGV4b25zW2ldWzBdKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGFyZ2V0X2Nkcy5jZHNlbmQgPCBleG9uc1tpXVswXSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3RhcnQgPSB0YXJnZXRfY2RzLmNkc3N0YXJ0ID4gZXhvbnNbaV1bMF0gPyB0YXJnZXRfY2RzLmNkc3N0YXJ0IDogZXhvbnNbaV1bMF07XG4gICAgICAgIHZhciBlbmQgPSB0YXJnZXRfY2RzLmNkc2VuZCA8IGV4b25zW2ldWzFdID8gdGFyZ2V0X2Nkcy5jZHNlbmQgOiBleG9uc1tpXVsxXTtcbiAgICAgICAgdG90YWwgKz0gKGVuZCAtIHN0YXJ0KTtcbiAgICB9XG4gICAgcmV0dXJuIE1hdGguZmxvb3IodG90YWwvMyktMTtcbn07XG5cbkdlbm9tZVJlYWRlci5wcm90b3R5cGUuY2FsY3VsYXRlU2VxdWVuY2VQb3NpdGlvbkZyb21Qcm90ZWluUG9zaXRpb24gPSBmdW5jdGlvbihpZHgscG9zKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciB3YW50ZWRfaWRlbnRpZmllciA9IGlkeDtcbiAgICB2YXIgY2RzID0gc2VsZi5yZXN1bHQuX3Jhd19kYXRhLmRhdGFbd2FudGVkX2lkZW50aWZpZXIudG9Mb3dlckNhc2UoKV07XG4gICAgaWYgKCEgY2RzICkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgfVxuXG4gICAgaWYgKCEgY2RzLnR4c3RhcnQgKSB7XG4gICAgICAgIGNkcyA9IGNkcy5tYXAoIGZ1bmN0aW9uKGNkKSB7XG4gICAgICAgICAgICBpZiAoIEFycmF5LmlzQXJyYXkoY2QpICkge1xuICAgICAgICAgICAgICAgIGNkID0gY2QuZmlsdGVyKGZ1bmN0aW9uKGMpIHsgcmV0dXJuIGMuY2hyLm1hdGNoKC9eW1xcZFh4XSskLyApOyB9KVswXTtcbiAgICAgICAgICAgICAgICBpZiAoICEgY2QgKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjZDtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIHRhcmdldF9jZHMgPSBjZHNbMF0gfHwge307XG4gICAgdmFyIGV4b25zID0gdGFyZ2V0X2Nkcy5leG9ucyB8fCBbXTtcblxuICAgIHZhciBwb3NpdGlvbl9nZW5vbWUgPSBNYXRoLmZsb29yKHBvcyAvIDMpO1xuXG5cbiAgICB2YXIgdGFyZ2V0X3Bvc2l0aW9uID0gMDtcblxuICAgIGlmIChwb3MgPCB0YXJnZXRfY2RzLmNkc3N0YXJ0KSB7XG4gICAgICAgIHRhcmdldF9wb3NpdGlvbiA9IDY7XG4gICAgICAgIGlmICh0YXJnZXRfY2RzLnN0cmFuZCA9PSAtMSkge1xuICAgICAgICAgICAgdGFyZ2V0X3Bvc2l0aW9uID0gMztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwb3MgPiB0YXJnZXRfY2RzLmNkc2VuZCkge1xuICAgICAgICB0YXJnZXRfcG9zaXRpb24gPSBzZWxmLnByb3RlaW5MZW5ndGgodGFyZ2V0X2NkcykgKiAzO1xuICAgICAgICBpZiAodGFyZ2V0X2Nkcy5zdHJhbmQgPT0gMSkge1xuICAgICAgICAgICAgdGFyZ2V0X3Bvc2l0aW9uICs9IDM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCB0YXJnZXRfcG9zaXRpb24gPT0gMCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4b25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGFyZ2V0X2Nkcy5jZHNzdGFydCA+IGV4b25zW2ldWzFdICYgdGFyZ2V0X2Nkcy5jZHNzdGFydCA+IGV4b25zW2ldWzBdKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc3RhcnQgPSB0YXJnZXRfY2RzLmNkc3N0YXJ0ID4gZXhvbnNbaV1bMF0gPyB0YXJnZXRfY2RzLmNkc3N0YXJ0IDogZXhvbnNbaV1bMF07XG4gICAgICAgICAgICB2YXIgZW5kID0gdGFyZ2V0X2Nkcy5jZHNlbmQgPCBleG9uc1tpXVsxXSA/IHRhcmdldF9jZHMuY2RzZW5kOiBleG9uc1tpXVsxXTtcblxuICAgICAgICAgICAgaWYgKHBvcyA8IHN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwb3MgPD0gZW5kICYmIHBvcyA+PSBzdGFydCkge1xuICAgICAgICAgICAgICAgIHRhcmdldF9wb3NpdGlvbiArPSAocG9zIC0gc3RhcnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRfcG9zaXRpb24gKz0gZW5kIC0gc3RhcnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGFyZ2V0X3Bvc2l0aW9uID0gTWF0aC5mbG9vcih0YXJnZXRfcG9zaXRpb24gLyAzKSAtIDE7XG5cbiAgICBpZiAodGFyZ2V0X2Nkcy5zdHJhbmQgPT0gLTEpIHtcbiAgICAgICAgdGFyZ2V0X3Bvc2l0aW9uID0gc2VsZi5wcm90ZWluTGVuZ3RoKHRhcmdldF9jZHMpIC0gdGFyZ2V0X3Bvc2l0aW9uO1xuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXRfcG9zaXRpb247XG59O1xuXG5HZW5vbWVSZWFkZXIucHJvdG90eXBlLmNhbGN1bGF0ZVByb3RlaW5Qb3NpdGlvbkZvclNlcXVlbmNlID0gZnVuY3Rpb24oaWR4LHBvcykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgd2FudGVkX2lkZW50aWZpZXIgPSBpZHg7XG4gICAgdmFyIGNkcyA9IHNlbGYucmVzdWx0Ll9yYXdfZGF0YS5kYXRhW3dhbnRlZF9pZGVudGlmaWVyLnRvTG93ZXJDYXNlKCldO1xuICAgIGlmICghIGNkcyApIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIGlmICghIGNkcy50eHN0YXJ0ICkge1xuICAgICAgICBjZHMgPSBjZHMubWFwKCBmdW5jdGlvbihjZCkge1xuICAgICAgICAgICAgaWYgKCBBcnJheS5pc0FycmF5KGNkKSApIHtcbiAgICAgICAgICAgICAgICBjZCA9IGNkLmZpbHRlcihmdW5jdGlvbihjKSB7IHJldHVybiBjLmNoci5tYXRjaCgvXltcXGRYeF0rJC8gKTsgfSlbMF07XG4gICAgICAgICAgICAgICAgaWYgKCAhIGNkICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2Q7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciB0YXJnZXRfY2RzID0gY2RzWzBdIHx8IHt9O1xuICAgIHZhciBleG9ucyA9IHRhcmdldF9jZHMuZXhvbnMgfHwgW107XG5cbiAgICBpZiAodGFyZ2V0X2Nkcy5zdHJhbmQgPT0gLTEpIHtcbiAgICAgICAgcG9zID0gc2VsZi5wcm90ZWluTGVuZ3RoKHRhcmdldF9jZHMpIC0gcG9zO1xuICAgIH1cbiAgICB2YXIgcG9zaXRpb25fZ2Vub21lID0gcG9zICogMztcblxuXG4gICAgdmFyIHRhcmdldF9wb3NpdGlvbjtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHRhcmdldF9jZHMuY2Rzc3RhcnQgPiBleG9uc1tpXVsxXSAmIHRhcmdldF9jZHMuY2Rzc3RhcnQgPiBleG9uc1tpXVswXSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN0YXJ0ID0gdGFyZ2V0X2Nkcy5jZHNzdGFydCA+IGV4b25zW2ldWzBdID8gdGFyZ2V0X2Nkcy5jZHNzdGFydCA6IGV4b25zW2ldWzBdO1xuICAgICAgICB2YXIgYmFzZXMgPSAoZXhvbnNbaV1bMV0gLSBzdGFydCk7XG4gICAgICAgIGlmIChiYXNlcyA+PSBwb3NpdGlvbl9nZW5vbWUpIHtcbiAgICAgICAgICAgIHRhcmdldF9wb3NpdGlvbiA9IHN0YXJ0ICsgcG9zaXRpb25fZ2Vub21lO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwb3NpdGlvbl9nZW5vbWUgLT0gYmFzZXM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldF9wb3NpdGlvbjtcbn07XG5cbkdlbm9tZVJlYWRlci5wcm90b3R5cGUuY2FsY3VsYXRlUG9zaXRpb25Gb3JTZXF1ZW5jZSA9IGZ1bmN0aW9uKGlkeCxwb3MpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHdhbnRlZF9pZGVudGlmaWVyID0gc2VsZi5zZXF1ZW5jZXNbaWR4XS5hZ2k7XG4gICAgdmFyIGVtcHR5X3JlZ2lvbnMgPSAgW107XG4gICAgdmFyIGNhbGN1bGF0ZWRfcG9zID0gcG9zO1xuXG4gICAgaWYgKHdhbnRlZF9pZGVudGlmaWVyID09ICdnZW5vbWUnKSB7XG4gICAgLy8gRG9uJ3QgY2hhbmdlIHRoZSBnZW5vbWUgaWRlbnRpZmllclxuICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbGN1bGF0ZWRfcG9zID0gc2VsZi5jYWxjdWxhdGVQcm90ZWluUG9zaXRpb25Gb3JTZXF1ZW5jZShpZHgscG9zKTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVtcHR5X3JlZ2lvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHBvcyA+IGVtcHR5X3JlZ2lvbnNbaV1bMV0pIHtcbiAgICAgICAgICAgIGNhbGN1bGF0ZWRfcG9zIC09IChlbXB0eV9yZWdpb25zW2ldWzFdIC0gZW1wdHlfcmVnaW9uc1tpXVswXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvcyA8IGVtcHR5X3JlZ2lvbnNbaV1bMV0gJiYgcG9zID4gZW1wdHlfcmVnaW9uc1tpXVswXSkge1xuICAgICAgICAgICAgY2FsY3VsYXRlZF9wb3MgPSAtMTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAoY2FsY3VsYXRlZF9wb3MpO1xufTtcblxuKGZ1bmN0aW9uKHNlcnYpIHtcbiAgICB2YXIgZ2V0X2V4b25fYm94ZXMgPSBmdW5jdGlvbihyZXN1bHQsdW5pcHJvdCkge1xuICAgICAgICB2YXIgY2RzX2RhdGEgPSByZXN1bHQuX3Jhd19kYXRhLmRhdGE7XG4gICAgICAgIGlmICh1bmlwcm90KSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnRmlsdGVyaW5nIGV4b25zIHNvIHdlIG9ubHkgc2hvdycsdW5pcHJvdCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHVuaXByb3RzID0gT2JqZWN0LmtleXMoY2RzX2RhdGEpO1xuICAgICAgICB2YXIgbWF4ID0gcmVzdWx0Lm1heDtcbiAgICAgICAgdmFyIG1pbiA9IHJlc3VsdC5taW47XG4gICAgICAgIHZhciByZXR1cm5fZGF0YSA9IFtdO1xuICAgICAgICB2YXIgYmFzZV9vZmZzZXQgPSAwO1xuICAgICAgICB1bmlwcm90cy5maWx0ZXIoIHVwID0+IHVuaXByb3QgPyB1cCA9PT0gKHVuaXByb3QgfHwgJycpLnRvTG93ZXJDYXNlKCkgOiB0cnVlICkuZm9yRWFjaChmdW5jdGlvbih1bmlwcm90KSB7XG4gICAgICAgICAgICB2YXIgZW5kcyA9IGNkc19kYXRhW3VuaXByb3RdLm1hcChmdW5jdGlvbihjZCxpZHgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIEFycmF5LmlzQXJyYXkoY2QpICkge1xuICAgICAgICAgICAgICAgICAgICBjZCA9IGNkLmZpbHRlcihmdW5jdGlvbihjKSB7IHJldHVybiBjLmNoci5tYXRjaCgvXltcXGRYeF0rJC8gKTsgfSlbMF07XG4gICAgICAgICAgICAgICAgICAgIGlmICggISBjZCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBleG9ucyA9IGNkLmV4b25zO1xuICAgICAgICAgICAgICAgIHZhciBjb2xvciA9IChpZHggPT0gMCkgPyAnIzk5OScgOiAnI2Y5OSc7XG4gICAgICAgICAgICAgICAgZXhvbnMuZm9yRWFjaChmdW5jdGlvbihleG9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybl9kYXRhLnB1c2goeyBcImFhXCI6IDErZXhvblswXSwgXCJ0eXBlXCIgOiBcImJveFwiICwgXCJ3aWR0aFwiIDogZXhvblsxXSAtIGV4b25bMF0sIFwib3B0aW9uc1wiIDogeyBcIm9mZnNldFwiIDogYmFzZV9vZmZzZXQsIFwiaGVpZ2h0X3NjYWxlXCIgOiAxLCBcImZpbGxcIiA6IGNvbG9yLCBcIm1lcmdlXCIgOiBmYWxzZSAgfX0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2Quc3RyYW5kICA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybl9kYXRhLnB1c2goeyBcImFhXCI6IGV4b25bMV0gLSAxLCBcInR5cGVcIiA6IFwibWFya2VyXCIsIFwib3B0aW9uc1wiIDogeyBcImhlaWdodFwiIDogNCwgXCJjb250ZW50XCIgOiB7XCJ0eXBlXCIgOiBcInJpZ2h0X3RyaWFuZ2xlXCIsIFwiZmlsbFwiIDogJyNhYWEnIH0sIFwib2Zmc2V0XCIgOiBiYXNlX29mZnNldCsyLCBcImJhcmVfZWxlbWVudFwiIDogdHJ1ZSB9fSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5fZGF0YS5wdXNoKHsgXCJhYVwiOiBleG9uWzBdICsgMSwgXCJ0eXBlXCIgOiBcIm1hcmtlclwiLCBcIm9wdGlvbnNcIiA6IHsgXCJoZWlnaHRcIiA6IDQsIFwiY29udGVudFwiIDoge1widHlwZVwiIDogXCJsZWZ0X3RyaWFuZ2xlXCIsIFwiZmlsbFwiIDogJyNhYWEnIH0sIFwib2Zmc2V0XCIgOiBiYXNlX29mZnNldCsyLCBcImJhcmVfZWxlbWVudFwiIDogdHJ1ZSB9fSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm5fZGF0YS5wdXNoKHtcImFhXCIgOiBjZC5jZHNzdGFydCwgXCJ0eXBlXCIgOiBcImJveFwiICwgXCJ3aWR0aFwiIDogMSwgXCJvcHRpb25zXCIgOiB7IFwiZmlsbFwiIDogXCIjMDAwMGZmXCIsIFwiaGVpZ2h0X3NjYWxlXCIgOiAyLCBcIm9mZnNldFwiIDogYmFzZV9vZmZzZXQgLSAyICwgXCJtZXJnZVwiIDogZmFsc2UgfSB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm5fZGF0YS5wdXNoKHtcImFhXCIgOiBjZC5jZHNlbmQsIFwidHlwZVwiIDogXCJib3hcIiAsIFwid2lkdGhcIiA6IDEsIFwib3B0aW9uc1wiIDogeyBcImZpbGxcIiA6IFwiIzAwMDBmZlwiLCBcImhlaWdodF9zY2FsZVwiIDogMiwgXCJvZmZzZXRcIiA6IGJhc2Vfb2Zmc2V0ICAtIDIsIFwibWVyZ2VcIiA6IGZhbHNlIH0gfSk7XG4gICAgICAgICAgICAgICAgYmFzZV9vZmZzZXQgKz0gMTtcblxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBiYXNlX29mZnNldCArPSAyO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJldHVybl9kYXRhO1xuICAgIH07XG5cbiAgICB2YXIgZ2V0X3JlbW92ZWRfbGFiZWxzID0gZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgIHZhciByZW1vdmVkID0gcmVzdWx0LnJlbW92ZWRfcmVnaW9ucyB8fCBbXTtcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgdmFyIG1heCA9IHJlc3VsdC5tYXg7XG4gICAgICAgIHZhciBtaW4gPSByZXN1bHQubWluO1xuICAgICAgICB2YXIgY2RzX2RhdGEgPSByZXN1bHQuX3Jhd19kYXRhLmRhdGE7XG4gICAgICAgIHZhciB1bmlwcm90cyA9IE9iamVjdC5rZXlzKGNkc19kYXRhKTtcbiAgICAgICAgdmFyIHRvdGFsID0gdW5pcHJvdHMucmVkdWNlKGZ1bmN0aW9uKHByZXYsdXApIHsgcmV0dXJuIHByZXYgKyBjZHNfZGF0YVt1cF0ubGVuZ3RoOyAgfSwwKTtcbiAgICAgICAgcmVtb3ZlZC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHMpIHtcbiAgICAgICAgICAgIHZhciBzdGFydCA9IHZhbHNbMF07XG4gICAgICAgICAgICB2YXIgZW5kID0gdmFsc1sxXTtcbiAgICAgICAgICAgIHZhciBzdGFydF90eHQgPSBNYXRoLmZsb29yICggKHN0YXJ0ICUgMWU2ICkgLyAxMDAwKStcImtiXCI7XG4gICAgICAgICAgICB2YXIgZW5kX3R4dCA9IE1hdGguZmxvb3IgKCAoZW5kICUgMWU2ICkgLyAxMDAwKStcImtiXCI7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2goe1wiYWFcIiA6IHN0YXJ0IC0gMSwgXCJ0eXBlXCIgOiBcImJveFwiLCB3aWR0aCA6IChlbmQgLSBzdGFydCkgKyAzLCBcIm9wdGlvbnNcIiA6IHtcImZpbGxcIiA6IFwiIzk5OVwiLCBcImhlaWdodF9zY2FsZVwiIDogdG90YWwqMywgXCJvZmZzZXRcIiA6IC0xKnRvdGFsIH0gfSk7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2goe1wiYWFcIiA6IHN0YXJ0IC0gMywgXCJ0eXBlXCIgOiBcInRleHRcIiwgXCJvcHRpb25zXCIgOiB7XCJ0eHRcIiA6IHN0YXJ0X3R4dCwgXCJmaWxsXCIgOiBcIiMwMDBcIiwgXCJoZWlnaHRcIiA6IDQsIFwib2Zmc2V0XCIgOiAtNCwgXCJhbGlnblwiIDogXCJyaWdodFwiIH0gfSk7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2goe1wiYWFcIiA6IGVuZCArIDMsIFwidHlwZVwiIDogXCJ0ZXh0XCIsIFwib3B0aW9uc1wiIDoge1widHh0XCIgOiBlbmRfdHh0LCBcImZpbGxcIiA6IFwiIzAwMFwiLCBcImhlaWdodFwiIDogNCwgXCJvZmZzZXRcIiA6IDQsIFwiYWxpZ25cIiA6IFwibGVmdFwiIH0gfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9O1xuXG4gICAgdmFyIGNhbGN1bGF0ZV9yZW1vdmVkX3JlZ2lvbnMgPSBmdW5jdGlvbihyZXN1bHQsbWFyZ2luKSB7XG4gICAgICAgIHZhciBpbnRyb25zID0gIHJlc3VsdC5nZXRJbnRyb25zKG1hcmdpbik7XG5cbiAgICAgICAgdmFyIGludGVydmFscyA9IFt7IFwiaW5kZXhcIiA6IHJlc3VsdC5taW4gLSAyLCBcInN0YXJ0XCIgOiB0cnVlLCBcImlkeFwiIDogLTEgfSAsIHtcImluZGV4XCIgOiByZXN1bHQubWluLCBcInN0YXJ0XCIgOiBmYWxzZSwgXCJpZHhcIiA6IC0xIH1dO1xuICAgICAgICBpbnRyb25zLmZvckVhY2goZnVuY3Rpb24oaW50cm9uLGlkeCkge1xuICAgICAgICAgICAgaW50ZXJ2YWxzLnB1c2goeyBcImluZGV4XCIgOiBpbnRyb25bMF0sIFwic3RhcnRcIiA6IHRydWUsICBcImlkeFwiIDogaWR4IH0pO1xuICAgICAgICAgICAgaW50ZXJ2YWxzLnB1c2goeyBcImluZGV4XCIgOiBpbnRyb25bMV0sIFwic3RhcnRcIiA6IGZhbHNlICwgXCJpZHhcIiA6IGlkeCB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaW50ZXJ2YWxzLnNvcnQoZnVuY3Rpb24oYSxiKSB7XG4gICAgICAgICAgICBpZiAoYS5pbmRleCA8IGIuaW5kZXggKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGEuaW5kZXggPiBiLmluZGV4ICkge1xuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGEuaW5kZXggPT0gYi5pbmRleCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhLnN0YXJ0ID8gLTEgOiAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgaW50ZXJ2YWxzLmZvckVhY2goZnVuY3Rpb24oaW50cixpZHgpIHtcbiAgICAgICAgICAgIGlmIChpbnRyLnN0YXJ0ICYmIGludGVydmFsc1tpZHgrMV0gJiYgaW50ZXJ2YWxzW2lkeCsxXS5zdGFydCA9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGlmIChpbnRyLmluZGV4ICE9IGludGVydmFsc1tpZHgrMV0uaW5kZXggJiYgaW50ZXJ2YWxzW2lkeCsxXS5pbmRleCAhPSByZXN1bHQubWluKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaCggW2ludHIuaW5kZXggLCBpbnRlcnZhbHNbaWR4KzFdLmluZGV4IF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJlc3VsdC5yZW1vdmVkX3JlZ2lvbnMgPSByZXN1bHRzO1xuICAgIH07XG4gICAgdmFyIGdlbmVyYXRlX3NjYWxlcl9mdW5jdGlvbiA9IGZ1bmN0aW9uKHJlYWRlcikge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oaW5fcG9zLGxheWVyLGludmVyc2UpIHtcbiAgICAgICAgICAgIHZhciBwb3MgPSBpbl9wb3M7XG5cbiAgICAgICAgICAgIGlmICggISByZWFkZXIucmVzdWx0ICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbnZlcnNlID8gKHBvcyAqIDMpIDogTWF0aC5mbG9vcihwb3MgLyAzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGludHJvbnMgPSByZWFkZXIucmVzdWx0LnJlbW92ZWRfcmVnaW9ucyB8fCBbXTtcblxuICAgICAgICAgICAgaWYgKGludmVyc2UpIHtcbiAgICAgICAgICAgICAgICBwb3MgPSAoaW5fcG9zICogMyk7XG4gICAgICAgICAgICAgICAgY2FsY3VsYXRlZF9wb3MgPSBwb3M7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbnRyb25zLmxlbmd0aCAmJiBwb3MgPiAwOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxlZnRfZXhvbiA9IGkgPiAwID8gaW50cm9uc1tpLTFdIDogW251bGwscmVhZGVyLnJlc3VsdC5taW5dO1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmlnaHRfZXhvbiA9IGludHJvbnNbaV0gfHwgW3JlYWRlci5yZXN1bHQubWF4LG51bGxdO1xuICAgICAgICAgICAgICAgICAgICBwb3MgLT0gKHJpZ2h0X2V4b25bMF0gLSBsZWZ0X2V4b25bMV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9zID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsY3VsYXRlZF9wb3MgKz0gaW50cm9uc1tpXVsxXSAtIGludHJvbnNbaV1bMF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGN1bGF0ZWRfcG9zICsgcmVhZGVyLnJlc3VsdC5taW47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBjYWxjdWxhdGVkX3BvcyA9IHBvcyAtIHJlYWRlci5yZXN1bHQubWluO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbnRyb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBvcyA+IGludHJvbnNbaV1bMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsY3VsYXRlZF9wb3MgLT0gKGludHJvbnNbaV1bMV0gLSBpbnRyb25zW2ldWzBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHBvcyA8IGludHJvbnNbaV1bMV0gJiYgcG9zID4gaW50cm9uc1tpXVswXSkge1xuICAgICAgICAgICAgICAgICAgICBjYWxjdWxhdGVkX3BvcyA9IChpbnRyb25zW2ldWzFdIC0gcmVhZGVyLnJlc3VsdC5taW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjYWxjdWxhdGVkX3BvcyA8IDMpIHtcbiAgICAgICAgICAgICAgICBjYWxjdWxhdGVkX3BvcyA9IDM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gKE1hdGguZmxvb3IoY2FsY3VsYXRlZF9wb3MgLyAzKSk7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc2Vydi5wcm90b3R5cGUsICdleG9uX21hcmdpbicsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAgIHRoaXMuX2V4b25fbWFyZ2luID0gdmFsO1xuICAgICAgICAgICAgaWYgKHRoaXMucmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgY2FsY3VsYXRlX3JlbW92ZWRfcmVnaW9ucyh0aGlzLnJlc3VsdCx2YWwpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVkcmF3SW50cm9ucygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5fZXhvbl9tYXJnaW47IH1cbiAgICB9KTtcblxuICAgIHZhciByZWRyYXdJbnRyb25zID0gZnVuY3Rpb24ocmVuZGVyZXIsY29udHJvbGxlcl9uYW1lLHNjYWxlcl9mdW5jdGlvbikge1xuICAgICAgICB2YXIgbGFicyA9IFtdO1xuICAgICAgICB2YXIgem9vbUNoZWNrID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAobGFicy5sZW5ndGggPCAxIHx8ICEgbGFic1swXS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGhpZGRlbiA9IGZhbHNlO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAgOyAhIGhpZGRlbiAmJiBpIDwgKGxhYnMubGVuZ3RoIC0gMyk7IGkgKz0gMykge1xuICAgICAgICAgICAgICAgIGlmIChsYWJzW2ldLmhhc0F0dHJpYnV0ZSgnZGlzcGxheScpKSB7XG4gICAgICAgICAgICAgICAgICAgIGhpZGRlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH0gXG4gICAgICAgICAgICAgICAgaWYgKGxhYnNbaV0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkucmlnaHQgPiBsYWJzW2krM10uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCkge1xuICAgICAgICAgICAgICAgICAgICBoaWRkZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxhYnMuZm9yRWFjaChmdW5jdGlvbihsYWIpIHsgaWYobGFiLm5vZGVOYW1lID09ICdyZWN0JykgeyByZXR1cm47IH0gaWYgKGhpZGRlbikgeyBsYWIuc2V0QXR0cmlidXRlKCdkaXNwbGF5Jywnbm9uZScpIH0gZWxzZSB7IGxhYi5yZW1vdmVBdHRyaWJ1dGUoJ2Rpc3BsYXknKSB9IH0pO1xuICAgICAgICB9O1xuICAgICAgICByZW5kZXJlci5iaW5kKCd6b29tQ2hhbmdlJyx6b29tQ2hlY2spO1xuXG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnJlc3VsdDtcbiAgICAgICAgICAgIHJlbmRlcmVyLnNlcXVlbmNlID0gQXJyYXkoIHNjYWxlcl9mdW5jdGlvbihyZXN1bHQubWF4KSkuam9pbignLicpO1xuXG4gICAgICAgICAgICBpZiAobGFicy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgbGFicy5mb3JFYWNoKGZ1bmN0aW9uKGxhYikge1xuICAgICAgICAgICAgICAgICAgICByZW5kZXJlci5yZW1vdmUoY29udHJvbGxlcl9uYW1lLGxhYik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgbGFicyA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHByb3h5X3JlYWRlciA9IHtcbiAgICAgICAgICAgICAgICBhZ2k6IGNvbnRyb2xsZXJfbmFtZSxcbiAgICAgICAgICAgICAgICBnb3RSZXN1bHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBsYWJzID0gcmVuZGVyZXIucmVuZGVyT2JqZWN0cyhjb250cm9sbGVyX25hbWUsZ2V0X3JlbW92ZWRfbGFiZWxzKHJlc3VsdCkpO1xuICAgICAgICAgICAgICAgICAgICByZW5kZXJlci5yZWZyZXNoKCk7XG4gICAgICAgICAgICAgICAgICAgIHpvb21DaGVjaygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBTZXJ2aWNlLnByb3RvdHlwZS5yZWdpc3RlclNlcXVlbmNlUmVuZGVyZXIuY2FsbChwcm94eV9yZWFkZXIscmVuZGVyZXIpO1xuICAgICAgICAgICAgcHJveHlfcmVhZGVyLmdvdFJlc3VsdCgpO1xuICAgICAgICB9O1xuICAgIH07XG5cbiAgICBzZXJ2LnByb3RvdHlwZS5zZXR1cFNlcXVlbmNlUmVuZGVyZXIgPSBmdW5jdGlvbihyZW5kZXJlcikge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHJlbmRlcmVyLmFkZEF4aXNTY2FsZSgnZ2Vub21lJyxmdW5jdGlvbihwb3MsbGF5ZXIsaW52ZXJzZSkge1xuICAgICAgICAgICAgaWYgKGxheWVyICYmIGxheWVyLnNjYWxlcy5oYXMoJ2dlbm9taWMnKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBwb3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgYWxsX3NjYWxlcyA9IE9iamVjdC5rZXlzKHNlbGYucmVzdWx0Ll9yYXdfZGF0YS5kYXRhKTtcbiAgICAgICAgICAgIGxldCBpZGVudGlmaWVyID0gbGF5ZXIubmFtZTtcbiAgICAgICAgICAgIGZvciAobGV0IHNjYWxlIG9mIGFsbF9zY2FsZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAobGF5ZXIuc2NhbGVzLmhhcyhzY2FsZS50b1VwcGVyQ2FzZSgpKSB8fCBsYXllci5zY2FsZXMuaGFzKHNjYWxlLnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlkZW50aWZpZXIgPSBzY2FsZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW52ZXJzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZWxmLmNhbGN1bGF0ZVNlcXVlbmNlUG9zaXRpb25Gcm9tUHJvdGVpblBvc2l0aW9uKGlkZW50aWZpZXIscG9zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzZWxmLmNhbGN1bGF0ZVByb3RlaW5Qb3NpdGlvbkZvclNlcXVlbmNlKGlkZW50aWZpZXIscG9zKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBjb250cm9sbGVyX25hbWUgPSAnY2RzJztcbiAgICAgICAgdmFyIHJlZHJhd19hbGlnbm1lbnRzID0gZnVuY3Rpb24oc2VxdWVuY2VfaW5kZXgpIHtcbiAgICAgICAgICAgIGlmICggISBzZXF1ZW5jZV9pbmRleCApIHtcbiAgICAgICAgICAgICAgICBzZXF1ZW5jZV9pbmRleCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBNQVNDUC5yZWdpc3RlckxheWVyKGNvbnRyb2xsZXJfbmFtZSwgeyAnZnVsbG5hbWUnIDogJ0V4b25zJywgJ2NvbG9yJyA6ICcjMDAwMDAwJyB9KTtcbiAgICAgICAgICAgIE1BU0NQLmdldExheWVyKGNvbnRyb2xsZXJfbmFtZSkuc2NhbGVzLmFkZCgnZ2Vub21pYycpO1xuXG4gICAgICAgICAgICBpZiAocmVuZGVyZXIudHJhY2tPcmRlci5pbmRleE9mKGNvbnRyb2xsZXJfbmFtZSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyZXIudHJhY2tPcmRlci5wdXNoKGNvbnRyb2xsZXJfbmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZW5kZXJlci5zaG93TGF5ZXIoY29udHJvbGxlcl9uYW1lKTtcblxuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMucmVzdWx0O1xuXG4gICAgICAgICAgICB2YXIgYWxpZ25lZCA9IHJlc3VsdC5nZXRTZXF1ZW5jZXMoKTtcbiAgICAgICAgICAgIHZhciBzY2FsZXJfZnVuY3Rpb24gPSBnZW5lcmF0ZV9zY2FsZXJfZnVuY3Rpb24oc2VsZik7XG5cbiAgICAgICAgICAgIHJlbmRlcmVyLmFkZEF4aXNTY2FsZSgncmVtb3ZlSW50cm9ucycsc2NhbGVyX2Z1bmN0aW9uKTtcblxuICAgICAgICAgICAgY2FsY3VsYXRlX3JlbW92ZWRfcmVnaW9ucyhzZWxmLnJlc3VsdCxzZWxmLmV4b25fbWFyZ2luIHx8IDMwMCk7XG5cbiAgICAgICAgICAgIGlmICggISByZW5kZXJlci5zZXF1ZW5jZSApIHtcbiAgICAgICAgICAgICAgICAvLyBOb3Qgc3VyZSB3aGF0IHRvIGRvIHdpdGggdGhpcyBiaXQgaGVyZVxuXG4gICAgICAgICAgICAgICAgcmVuZGVyZXIuc2V0U2VxdWVuY2UoQXJyYXkoIHNjYWxlcl9mdW5jdGlvbihyZXN1bHQubWF4KSApLmpvaW4oJy4nKSkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZHJhd19hbGlnbm1lbnRzKHNlcXVlbmNlX2luZGV4KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlbmRlcmVyLnNlcXVlbmNlID0gQXJyYXkoIHNjYWxlcl9mdW5jdGlvbihyZXN1bHQubWF4KSkuam9pbignLicpO1xuICAgICAgICAgICAgICAgIHJlbmRlcmVyLnJlZHJhd0F4aXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwcm94eV9yZWFkZXIgPSB7XG4gICAgICAgICAgICAgICAgYWdpOiBjb250cm9sbGVyX25hbWUsXG4gICAgICAgICAgICAgICAgZ290UmVzdWx0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyZXIucmVuZGVyT2JqZWN0cyhjb250cm9sbGVyX25hbWUsZ2V0X2V4b25fYm94ZXMocmVzdWx0LCBzZWxmLnJldmlld2VkID8gc2VsZi5zd2lzc3Byb3QgOiBzZWxmLnVuaXByb3QpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgU2VydmljZS5wcm90b3R5cGUucmVnaXN0ZXJTZXF1ZW5jZVJlbmRlcmVyLmNhbGwocHJveHlfcmVhZGVyLHJlbmRlcmVyKTtcbiAgICAgICAgICAgIHByb3h5X3JlYWRlci5nb3RSZXN1bHQoKTtcblxuICAgICAgICAgICAgc2VsZi5yZWRyYXdJbnRyb25zID0gcmVkcmF3SW50cm9ucyhyZW5kZXJlcixjb250cm9sbGVyX25hbWUsc2NhbGVyX2Z1bmN0aW9uKTtcbiAgICAgICAgICAgIHNlbGYucmVkcmF3SW50cm9ucygpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuYmluZCgncmVzdWx0UmVjZWl2ZWQnLHJlZHJhd19hbGlnbm1lbnRzKTtcblxuICAgIH07XG5cbn0pKEdlbm9tZVJlYWRlcik7XG5cbmV4cG9ydCBkZWZhdWx0IEdlbm9tZVJlYWRlcjtcblxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFGQTtBQUpBO0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBSkE7QUFRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFKQTtBQVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQVJBO0FBQ0E7QUFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./js/lib/GenomeReader.js\n");

/***/ }),

/***/ "./js/lib/MASCP.js":
/*!*************************!*\
  !*** ./js/lib/MASCP.js ***!
  \*************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _bean__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../bean */ \"./js/bean.js\");\n\n\n/**\n *  @namespace MASCP namespace\n */\nconst MASCP = {};\n\n/**\n *  @fileOverview   Basic classes and defitions for the MASCP services\n */\n\nif (Object.defineProperty && !MASCP.IE8) {\n    (function () {\n        var ready_callbacks = [];\n        var is_ready = false;\n        Object.defineProperty(MASCP, \"ready\", {\n            get: function get() {\n                if (ready_callbacks.length === 0 && !is_ready) {\n                    return false;\n                }\n                return function () {\n                    ready_callbacks.forEach(function (cb) {\n                        cb.call();\n                    });\n                };\n            },\n            set: function set(cb) {\n                if (cb === false || cb === true) {\n                    ready_callbacks = [];\n                    if (cb) {\n                        is_ready = true;\n                    }\n                    return is_ready;\n                } else {\n                    if (is_ready) {\n                        cb.call();\n                        return;\n                    }\n                    ready_callbacks.push(cb);\n                }\n            }\n        });\n    })();\n}\n\n/**\n *  @lends MASCP.Group.prototype\n *  @property   {String}        name                        Name for this group to be used as an identifier\n *  @property   {String}        fullname                    The full (long) name for this group, that can be used in UI widgets for labelling\n *  @property   {String}        color                       Color string to apply to this group\n *  @property   {Boolean}       hide_member_controllers     For controllers for this group, do not show the layer controllers for this group\n *  @property   {Boolean}       hide_group_controller       For controllers for this group do not show the parent group controller\n */\n\n/**\n * Register a group with metadata for all sequence renderers.\n * @static\n * @param {String} groupName    Name to give to this group\n * @param {Hash} options        Options to apply to this group - see MASCP.Group for all the fields\n * @returns New group object\n * @type MASCP.Group\n * @see MASCP.event:groupRegistered\n * @see MASCP.Group\n */\nMASCP.registerGroup = function (groupName, options) {\n    if (!this.groups) {\n        this.groups = {};\n    }\n    if (this.groups[groupName]) {\n        return;\n    }\n\n    var group = new MASCP.Group();\n\n    group.name = groupName;\n\n    options = options || {};\n\n    if (options.hide_member_controllers) {\n        group.hide_member_controllers = true;\n    }\n\n    if (options.hide_group_controller) {\n        group.hide_group_controller = true;\n    }\n\n    if (options.fullname) {\n        group.fullname = options.fullname;\n    }\n\n    if (options.color) {\n        group.color = options.color;\n    }\n\n    if (options.group) {\n        group.group = this.getGroup(options.group);\n        if (!group.group) {\n            throw \"Cannot register this layer with the given group - the group has not been registered yet\";\n        }\n        group.group._layers.push(group);\n    }\n\n    group._layers = [];\n\n    group.group_id = new Date().getMilliseconds();\n\n    this.groups[groupName] = group;\n\n    _bean__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fire(MASCP, 'groupRegistered', [group]);\n\n    return group;\n};\n\n/**\n *  @lends MASCP.Layer.prototype\n *  @property   {String}        name        Name for this layer to be used as an identifier\n *  @property   {String}        fullname    The full (long) name for this layer, that can be used in UI widgets for labelling\n *  @property   {String}        color       Color string to apply to this layer\n *  @property   {MASCP.Group}   group       Group that this layer is part of. Either a group object, or the name for the group.\n *  @property   {String}        css         CSS block for this layer. Active and inactive layers are children of the .active and .inactive classes respectively. To target a track-based rendering, use the .tracks class first, and to target overlays, use the .overlay class last\n *  @property   {Object}        data        Data for this layer\n */\n\n/**\n * Register a layer with metadata for all sequence renderers.\n * @static\n * @param {String} layerName    Name to give to this layer\n * @param {Hash} options        Options to set field values for this layer - see the fields for MASCP.Layer.\n * @returns New layer object\n * @type MASCP.Layer\n * @see MASCP.Layer\n * @see MASCP.event:layerRegistered\n */\nMASCP.registerLayer = function (layerName, options, renderers) {\n    if (!this.layers) {\n        this.layers = {};\n    }\n    if (!renderers) {\n        renderers = [];\n    }\n    var layer;\n    if (this.layers[layerName]) {\n        if (this.layers[layerName].disabled || renderers.length > 0) {\n            this.layers[layerName].disabled = false;\n            _bean__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fire(MASCP, 'layerRegistered', [this.layers[layerName]].concat(renderers));\n        }\n        layer = this.layers[layerName];\n    }\n\n    if (layer && options.group) {\n        if (layer.group !== this.getGroup(options.group)) {\n            layer.group = this.getGroup(options.group);\n            layer.group._layers.push(layer);\n        }\n        if (!layer.group) {\n            throw \"Cannot register this layer with the given group - the group has not been registered yet\";\n        }\n    }\n\n    if (layer) {\n        return layer;\n    }\n\n    layer = new MASCP.Layer();\n\n    layer.name = layerName;\n\n    options = options || {};\n\n    if (options.fullname) {\n        layer.fullname = options.fullname;\n    }\n\n    if (options.color) {\n        layer.color = options.color;\n    }\n\n    if (options.data) {\n        layer.data = options.data;\n    }\n\n    if (layer && options.group) {\n        layer.group = this.getGroup(options.group);\n        if (!layer.group) {\n            throw \"Cannot register this layer with the given group - the group has not been registered yet\";\n        }\n        layer.group._layers.push(layer);\n    }\n\n    this.layers[layerName] = layer;\n\n    if (options.css) {\n        console.log(\"options.css is deprecated\");\n    }\n    layer.layer_id = new Date().getMilliseconds();\n    _bean__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fire(MASCP, 'layerRegistered', [layer].concat(renderers));\n\n    return layer;\n};\n\n/**\n * @class\n * Metadata for a group of layers to be rendered\n */\nMASCP.Group = function () {\n    return;\n};\n\n/**\n * Describe what this method does\n * @private\n * @param {String|Object|Array|Boolean|Number} paramName Describe this parameter\n * @returns Describe what it returns\n * @type String|Object|Array|Boolean|Number\n */\nMASCP.Group.prototype.size = function () {\n    var counter = 0;\n    for (var i = 0; i < this._layers.length; i++) {\n        if (!this._layers[i].disabled) {\n            counter += 1;\n        }\n    }\n    return counter;\n};\n\nMASCP.Group.prototype.eachLayer = function (func) {\n    for (var i = 0; i < this._layers.length; i++) {\n        if (!this._layers[i].disabled) {\n            func.call(this._layers[i], this._layers[i]);\n        }\n    }\n};\n\n/**\n * @class\n * Metadata for a single layer to be rendered\n */\nMASCP.Layer = function () {\n    this.scales = new Set();\n    return;\n};\n\n/**\n * Retrieve a layer object from the layer registry. If a layer object is passed to this method, the same layer is returned.\n * @param {String} layer    Layer name\n * @returns Layer object\n * @type Object\n * @see MASCP.Layer\n */\nMASCP.getLayer = function (layer) {\n    if (!MASCP.layers) {\n        return;\n    }\n    return typeof layer == 'string' ? MASCP.layers[layer] : layer;\n};\n\n/**\n * Retrieve a group object from the group registry. If a grop object is passed to this method, the same group is returned.\n * @param {String} group    Group name\n * @returns Group object\n * @type Object\n * @see MASCP.Group\n */\nMASCP.getGroup = function (group) {\n    if (typeof group == 'undefined') {\n        return;\n    }\n    if (!MASCP.groups) {\n        return;\n    }\n    if (typeof group == 'string') {\n        return MASCP.groups[group];\n    }\n    return group == MASCP.groups[group.name] ? group : null;\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (MASCP);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9qcy9saWIvTUFTQ1AuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vanMvbGliL01BU0NQLmpzPzYxOGEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGJlYW4gZnJvbSAnLi4vYmVhbic7XG5cbi8qKlxuICogIEBuYW1lc3BhY2UgTUFTQ1AgbmFtZXNwYWNlXG4gKi9cbmNvbnN0IE1BU0NQID0ge307XG5cbi8qKlxuICogIEBmaWxlT3ZlcnZpZXcgICBCYXNpYyBjbGFzc2VzIGFuZCBkZWZpdGlvbnMgZm9yIHRoZSBNQVNDUCBzZXJ2aWNlc1xuICovXG5cbmlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgISBNQVNDUC5JRTggKSB7XG4gICAgKGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmVhZHlfY2FsbGJhY2tzID0gW107XG4gICAgICAgIHZhciBpc19yZWFkeSA9IGZhbHNlO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTUFTQ1AsXCJyZWFkeVwiLCB7XG4gICAgICAgICAgICBnZXQgOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAoKHJlYWR5X2NhbGxiYWNrcy5sZW5ndGggPT09IDApICYmICghIGlzX3JlYWR5ICkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlYWR5X2NhbGxiYWNrcy5mb3JFYWNoKGZ1bmN0aW9uKGNiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYi5jYWxsKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0IDogZnVuY3Rpb24oY2IpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2IgPT09IGZhbHNlIHx8IGNiID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlYWR5X2NhbGxiYWNrcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzX3JlYWR5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNfcmVhZHk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzX3JlYWR5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYi5jYWxsKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVhZHlfY2FsbGJhY2tzLnB1c2goY2IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSkoKTtcbn1cblxuXG4vKipcbiAqICBAbGVuZHMgTUFTQ1AuR3JvdXAucHJvdG90eXBlXG4gKiAgQHByb3BlcnR5ICAge1N0cmluZ30gICAgICAgIG5hbWUgICAgICAgICAgICAgICAgICAgICAgICBOYW1lIGZvciB0aGlzIGdyb3VwIHRvIGJlIHVzZWQgYXMgYW4gaWRlbnRpZmllclxuICogIEBwcm9wZXJ0eSAgIHtTdHJpbmd9ICAgICAgICBmdWxsbmFtZSAgICAgICAgICAgICAgICAgICAgVGhlIGZ1bGwgKGxvbmcpIG5hbWUgZm9yIHRoaXMgZ3JvdXAsIHRoYXQgY2FuIGJlIHVzZWQgaW4gVUkgd2lkZ2V0cyBmb3IgbGFiZWxsaW5nXG4gKiAgQHByb3BlcnR5ICAge1N0cmluZ30gICAgICAgIGNvbG9yICAgICAgICAgICAgICAgICAgICAgICBDb2xvciBzdHJpbmcgdG8gYXBwbHkgdG8gdGhpcyBncm91cFxuICogIEBwcm9wZXJ0eSAgIHtCb29sZWFufSAgICAgICBoaWRlX21lbWJlcl9jb250cm9sbGVycyAgICAgRm9yIGNvbnRyb2xsZXJzIGZvciB0aGlzIGdyb3VwLCBkbyBub3Qgc2hvdyB0aGUgbGF5ZXIgY29udHJvbGxlcnMgZm9yIHRoaXMgZ3JvdXBcbiAqICBAcHJvcGVydHkgICB7Qm9vbGVhbn0gICAgICAgaGlkZV9ncm91cF9jb250cm9sbGVyICAgICAgIEZvciBjb250cm9sbGVycyBmb3IgdGhpcyBncm91cCBkbyBub3Qgc2hvdyB0aGUgcGFyZW50IGdyb3VwIGNvbnRyb2xsZXJcbiAqL1xuXG4vKipcbiAqIFJlZ2lzdGVyIGEgZ3JvdXAgd2l0aCBtZXRhZGF0YSBmb3IgYWxsIHNlcXVlbmNlIHJlbmRlcmVycy5cbiAqIEBzdGF0aWNcbiAqIEBwYXJhbSB7U3RyaW5nfSBncm91cE5hbWUgICAgTmFtZSB0byBnaXZlIHRvIHRoaXMgZ3JvdXBcbiAqIEBwYXJhbSB7SGFzaH0gb3B0aW9ucyAgICAgICAgT3B0aW9ucyB0byBhcHBseSB0byB0aGlzIGdyb3VwIC0gc2VlIE1BU0NQLkdyb3VwIGZvciBhbGwgdGhlIGZpZWxkc1xuICogQHJldHVybnMgTmV3IGdyb3VwIG9iamVjdFxuICogQHR5cGUgTUFTQ1AuR3JvdXBcbiAqIEBzZWUgTUFTQ1AuZXZlbnQ6Z3JvdXBSZWdpc3RlcmVkXG4gKiBAc2VlIE1BU0NQLkdyb3VwXG4gKi9cbk1BU0NQLnJlZ2lzdGVyR3JvdXAgPSBmdW5jdGlvbihncm91cE5hbWUsIG9wdGlvbnMpXG57XG4gICAgaWYgKCAhIHRoaXMuZ3JvdXBzICkge1xuICAgICAgICB0aGlzLmdyb3VwcyA9IHt9O1xuICAgIH1cbiAgICBpZiAodGhpcy5ncm91cHNbZ3JvdXBOYW1lXSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIFxuICAgIHZhciBncm91cCA9IG5ldyBNQVNDUC5Hcm91cCgpO1xuICAgIFxuICAgIGdyb3VwLm5hbWUgPSBncm91cE5hbWU7XG4gICAgXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgXG4gICAgaWYgKG9wdGlvbnMuaGlkZV9tZW1iZXJfY29udHJvbGxlcnMpIHtcbiAgICAgICAgZ3JvdXAuaGlkZV9tZW1iZXJfY29udHJvbGxlcnMgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmhpZGVfZ3JvdXBfY29udHJvbGxlcikge1xuICAgICAgICBncm91cC5oaWRlX2dyb3VwX2NvbnRyb2xsZXIgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmZ1bGxuYW1lKSB7XG4gICAgICAgIGdyb3VwLmZ1bGxuYW1lID0gb3B0aW9ucy5mdWxsbmFtZTtcbiAgICB9XG4gICAgXG4gICAgaWYgKG9wdGlvbnMuY29sb3IpIHtcbiAgICAgICAgZ3JvdXAuY29sb3IgPSBvcHRpb25zLmNvbG9yO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmdyb3VwKSB7XG4gICAgICAgIGdyb3VwLmdyb3VwID0gdGhpcy5nZXRHcm91cChvcHRpb25zLmdyb3VwKTtcbiAgICAgICAgaWYgKCAhIGdyb3VwLmdyb3VwICkge1xuICAgICAgICAgICAgdGhyb3cgXCJDYW5ub3QgcmVnaXN0ZXIgdGhpcyBsYXllciB3aXRoIHRoZSBnaXZlbiBncm91cCAtIHRoZSBncm91cCBoYXMgbm90IGJlZW4gcmVnaXN0ZXJlZCB5ZXRcIjtcbiAgICAgICAgfVxuICAgICAgICBncm91cC5ncm91cC5fbGF5ZXJzLnB1c2goZ3JvdXApO1xuICAgIH1cblxuICAgIGdyb3VwLl9sYXllcnMgPSBbXTtcblxuICAgIGdyb3VwLmdyb3VwX2lkID0gbmV3IERhdGUoKS5nZXRNaWxsaXNlY29uZHMoKTtcbiAgICBcbiAgICB0aGlzLmdyb3Vwc1tncm91cE5hbWVdID0gZ3JvdXA7XG4gICAgXG4gICAgYmVhbi5maXJlKE1BU0NQLCdncm91cFJlZ2lzdGVyZWQnLFtncm91cF0pO1xuICAgIFxuICAgIHJldHVybiBncm91cDtcbn07XG5cbi8qKlxuICogIEBsZW5kcyBNQVNDUC5MYXllci5wcm90b3R5cGVcbiAqICBAcHJvcGVydHkgICB7U3RyaW5nfSAgICAgICAgbmFtZSAgICAgICAgTmFtZSBmb3IgdGhpcyBsYXllciB0byBiZSB1c2VkIGFzIGFuIGlkZW50aWZpZXJcbiAqICBAcHJvcGVydHkgICB7U3RyaW5nfSAgICAgICAgZnVsbG5hbWUgICAgVGhlIGZ1bGwgKGxvbmcpIG5hbWUgZm9yIHRoaXMgbGF5ZXIsIHRoYXQgY2FuIGJlIHVzZWQgaW4gVUkgd2lkZ2V0cyBmb3IgbGFiZWxsaW5nXG4gKiAgQHByb3BlcnR5ICAge1N0cmluZ30gICAgICAgIGNvbG9yICAgICAgIENvbG9yIHN0cmluZyB0byBhcHBseSB0byB0aGlzIGxheWVyXG4gKiAgQHByb3BlcnR5ICAge01BU0NQLkdyb3VwfSAgIGdyb3VwICAgICAgIEdyb3VwIHRoYXQgdGhpcyBsYXllciBpcyBwYXJ0IG9mLiBFaXRoZXIgYSBncm91cCBvYmplY3QsIG9yIHRoZSBuYW1lIGZvciB0aGUgZ3JvdXAuXG4gKiAgQHByb3BlcnR5ICAge1N0cmluZ30gICAgICAgIGNzcyAgICAgICAgIENTUyBibG9jayBmb3IgdGhpcyBsYXllci4gQWN0aXZlIGFuZCBpbmFjdGl2ZSBsYXllcnMgYXJlIGNoaWxkcmVuIG9mIHRoZSAuYWN0aXZlIGFuZCAuaW5hY3RpdmUgY2xhc3NlcyByZXNwZWN0aXZlbHkuIFRvIHRhcmdldCBhIHRyYWNrLWJhc2VkIHJlbmRlcmluZywgdXNlIHRoZSAudHJhY2tzIGNsYXNzIGZpcnN0LCBhbmQgdG8gdGFyZ2V0IG92ZXJsYXlzLCB1c2UgdGhlIC5vdmVybGF5IGNsYXNzIGxhc3RcbiAqICBAcHJvcGVydHkgICB7T2JqZWN0fSAgICAgICAgZGF0YSAgICAgICAgRGF0YSBmb3IgdGhpcyBsYXllclxuICovXG5cbi8qKlxuICogUmVnaXN0ZXIgYSBsYXllciB3aXRoIG1ldGFkYXRhIGZvciBhbGwgc2VxdWVuY2UgcmVuZGVyZXJzLlxuICogQHN0YXRpY1xuICogQHBhcmFtIHtTdHJpbmd9IGxheWVyTmFtZSAgICBOYW1lIHRvIGdpdmUgdG8gdGhpcyBsYXllclxuICogQHBhcmFtIHtIYXNofSBvcHRpb25zICAgICAgICBPcHRpb25zIHRvIHNldCBmaWVsZCB2YWx1ZXMgZm9yIHRoaXMgbGF5ZXIgLSBzZWUgdGhlIGZpZWxkcyBmb3IgTUFTQ1AuTGF5ZXIuXG4gKiBAcmV0dXJucyBOZXcgbGF5ZXIgb2JqZWN0XG4gKiBAdHlwZSBNQVNDUC5MYXllclxuICogQHNlZSBNQVNDUC5MYXllclxuICogQHNlZSBNQVNDUC5ldmVudDpsYXllclJlZ2lzdGVyZWRcbiAqL1xuTUFTQ1AucmVnaXN0ZXJMYXllciA9IGZ1bmN0aW9uKGxheWVyTmFtZSwgb3B0aW9ucywgcmVuZGVyZXJzKVxue1xuICAgIGlmICggISB0aGlzLmxheWVycyApIHtcbiAgICAgICAgdGhpcy5sYXllcnMgPSB7fTtcbiAgICB9XG4gICAgaWYgKCAhIHJlbmRlcmVycyApIHtcbiAgICAgICAgcmVuZGVyZXJzID0gW107XG4gICAgfVxuICAgIHZhciBsYXllcjtcbiAgICBpZiAodGhpcy5sYXllcnNbbGF5ZXJOYW1lXSkge1xuICAgICAgICBpZiAodGhpcy5sYXllcnNbbGF5ZXJOYW1lXS5kaXNhYmxlZCB8fCByZW5kZXJlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5sYXllcnNbbGF5ZXJOYW1lXS5kaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgYmVhbi5maXJlKE1BU0NQLCdsYXllclJlZ2lzdGVyZWQnLFt0aGlzLmxheWVyc1tsYXllck5hbWVdXS5jb25jYXQocmVuZGVyZXJzKSk7XG4gICAgICAgIH1cbiAgICAgICAgbGF5ZXIgPSB0aGlzLmxheWVyc1tsYXllck5hbWVdO1xuICAgIH1cblxuICAgIGlmIChsYXllciAmJiBvcHRpb25zLmdyb3VwKSB7XG4gICAgICAgIGlmIChsYXllci5ncm91cCAhPT0gdGhpcy5nZXRHcm91cChvcHRpb25zLmdyb3VwKSkge1xuICAgICAgICAgICAgbGF5ZXIuZ3JvdXAgPSB0aGlzLmdldEdyb3VwKG9wdGlvbnMuZ3JvdXApO1xuICAgICAgICAgICAgbGF5ZXIuZ3JvdXAuX2xheWVycy5wdXNoKGxheWVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoICEgbGF5ZXIuZ3JvdXAgKSB7XG4gICAgICAgICAgICB0aHJvdyBcIkNhbm5vdCByZWdpc3RlciB0aGlzIGxheWVyIHdpdGggdGhlIGdpdmVuIGdyb3VwIC0gdGhlIGdyb3VwIGhhcyBub3QgYmVlbiByZWdpc3RlcmVkIHlldFwiO1xuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIGlmIChsYXllcikge1xuICAgICAgICByZXR1cm4gbGF5ZXI7XG4gICAgfVxuXG4gICAgbGF5ZXIgPSBuZXcgTUFTQ1AuTGF5ZXIoKTtcbiAgICBcbiAgICBsYXllci5uYW1lID0gbGF5ZXJOYW1lO1xuICAgIFxuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIFxuICAgIGlmIChvcHRpb25zLmZ1bGxuYW1lKSB7XG4gICAgICAgIGxheWVyLmZ1bGxuYW1lID0gb3B0aW9ucy5mdWxsbmFtZTtcbiAgICB9XG4gICAgXG4gICAgaWYgKG9wdGlvbnMuY29sb3IpIHtcbiAgICAgICAgbGF5ZXIuY29sb3IgPSBvcHRpb25zLmNvbG9yO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmRhdGEpIHtcbiAgICAgICAgbGF5ZXIuZGF0YSA9IG9wdGlvbnMuZGF0YTtcbiAgICB9XG4gICAgXG4gICAgaWYgKGxheWVyICYmIG9wdGlvbnMuZ3JvdXApIHtcbiAgICAgICAgbGF5ZXIuZ3JvdXAgPSB0aGlzLmdldEdyb3VwKG9wdGlvbnMuZ3JvdXApO1xuICAgICAgICBpZiAoICEgbGF5ZXIuZ3JvdXAgKSB7XG4gICAgICAgICAgICB0aHJvdyBcIkNhbm5vdCByZWdpc3RlciB0aGlzIGxheWVyIHdpdGggdGhlIGdpdmVuIGdyb3VwIC0gdGhlIGdyb3VwIGhhcyBub3QgYmVlbiByZWdpc3RlcmVkIHlldFwiO1xuICAgICAgICB9XG4gICAgICAgIGxheWVyLmdyb3VwLl9sYXllcnMucHVzaChsYXllcik7XG4gICAgfVxuICAgIFxuICAgIHRoaXMubGF5ZXJzW2xheWVyTmFtZV0gPSBsYXllcjtcbiAgICBcbiAgICBpZiAob3B0aW9ucy5jc3MpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJvcHRpb25zLmNzcyBpcyBkZXByZWNhdGVkXCIpO1xuICAgIH1cbiAgICBsYXllci5sYXllcl9pZCA9IG5ldyBEYXRlKCkuZ2V0TWlsbGlzZWNvbmRzKCk7XG4gICAgYmVhbi5maXJlKE1BU0NQLCdsYXllclJlZ2lzdGVyZWQnLFtsYXllcl0uY29uY2F0KHJlbmRlcmVycykpO1xuICAgIFxuICAgIHJldHVybiBsYXllcjtcbn07XG5cbi8qKlxuICogQGNsYXNzXG4gKiBNZXRhZGF0YSBmb3IgYSBncm91cCBvZiBsYXllcnMgdG8gYmUgcmVuZGVyZWRcbiAqL1xuTUFTQ1AuR3JvdXAgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm47XG59O1xuXG4vKipcbiAqIERlc2NyaWJlIHdoYXQgdGhpcyBtZXRob2QgZG9lc1xuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdHxBcnJheXxCb29sZWFufE51bWJlcn0gcGFyYW1OYW1lIERlc2NyaWJlIHRoaXMgcGFyYW1ldGVyXG4gKiBAcmV0dXJucyBEZXNjcmliZSB3aGF0IGl0IHJldHVybnNcbiAqIEB0eXBlIFN0cmluZ3xPYmplY3R8QXJyYXl8Qm9vbGVhbnxOdW1iZXJcbiAqL1xuTUFTQ1AuR3JvdXAucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgY291bnRlciA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDAgOyBpIDwgdGhpcy5fbGF5ZXJzLmxlbmd0aDsgaSsrICkge1xuICAgICAgICBpZiAoISB0aGlzLl9sYXllcnNbaV0uZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIGNvdW50ZXIgKz0gMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY291bnRlcjtcbn07XG5cbk1BU0NQLkdyb3VwLnByb3RvdHlwZS5lYWNoTGF5ZXIgPSBmdW5jdGlvbihmdW5jKSB7XG4gICAgZm9yICh2YXIgaSA9IDAgOyBpIDwgdGhpcy5fbGF5ZXJzLmxlbmd0aDsgaSsrICkge1xuICAgICAgICBpZiAoISB0aGlzLl9sYXllcnNbaV0uZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIGZ1bmMuY2FsbCh0aGlzLl9sYXllcnNbaV0sdGhpcy5fbGF5ZXJzW2ldKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogQGNsYXNzXG4gKiBNZXRhZGF0YSBmb3IgYSBzaW5nbGUgbGF5ZXIgdG8gYmUgcmVuZGVyZWRcbiAqL1xuTUFTQ1AuTGF5ZXIgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnNjYWxlcyA9IG5ldyBTZXQoKTtcbiAgICByZXR1cm47XG59O1xuXG4vKipcbiAqIFJldHJpZXZlIGEgbGF5ZXIgb2JqZWN0IGZyb20gdGhlIGxheWVyIHJlZ2lzdHJ5LiBJZiBhIGxheWVyIG9iamVjdCBpcyBwYXNzZWQgdG8gdGhpcyBtZXRob2QsIHRoZSBzYW1lIGxheWVyIGlzIHJldHVybmVkLlxuICogQHBhcmFtIHtTdHJpbmd9IGxheWVyICAgIExheWVyIG5hbWVcbiAqIEByZXR1cm5zIExheWVyIG9iamVjdFxuICogQHR5cGUgT2JqZWN0XG4gKiBAc2VlIE1BU0NQLkxheWVyXG4gKi9cbk1BU0NQLmdldExheWVyID0gZnVuY3Rpb24obGF5ZXIpIHtcbiAgICBpZiAoICEgTUFTQ1AubGF5ZXJzICkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiAodHlwZW9mIGxheWVyID09ICdzdHJpbmcnKSA/IE1BU0NQLmxheWVyc1tsYXllcl0gOiBsYXllcjtcbn07XG5cbi8qKlxuICogUmV0cmlldmUgYSBncm91cCBvYmplY3QgZnJvbSB0aGUgZ3JvdXAgcmVnaXN0cnkuIElmIGEgZ3JvcCBvYmplY3QgaXMgcGFzc2VkIHRvIHRoaXMgbWV0aG9kLCB0aGUgc2FtZSBncm91cCBpcyByZXR1cm5lZC5cbiAqIEBwYXJhbSB7U3RyaW5nfSBncm91cCAgICBHcm91cCBuYW1lXG4gKiBAcmV0dXJucyBHcm91cCBvYmplY3RcbiAqIEB0eXBlIE9iamVjdFxuICogQHNlZSBNQVNDUC5Hcm91cFxuICovXG5NQVNDUC5nZXRHcm91cCA9IGZ1bmN0aW9uKGdyb3VwKSB7XG4gICAgaWYgKHR5cGVvZiBncm91cCA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICggISBNQVNDUC5ncm91cHMgKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBncm91cCA9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gTUFTQ1AuZ3JvdXBzW2dyb3VwXTtcbiAgICB9XG4gICAgcmV0dXJuIChncm91cCA9PSBNQVNDUC5ncm91cHNbZ3JvdXAubmFtZV0pID8gZ3JvdXAgOiBudWxsO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgTUFTQ1A7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXpCQTtBQTJCQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7O0FBU0E7Ozs7Ozs7Ozs7QUFVQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7O0FBVUE7Ozs7Ozs7Ozs7QUFVQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./js/lib/MASCP.js\n");

/***/ }),

/***/ "./js/lib/SVGCanvas.js":
/*!*****************************!*\
  !*** ./js/lib/SVGCanvas.js ***!
  \*****************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _bean__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../bean */ \"./js/bean.js\");\n\n\nconst SVGCanvas = function () {\n\n    var extended_elements = [];\n    var DEFAULT_RS = 1;\n    var svgns = 'http://www.w3.org/2000/svg';\n\n    function extend_array(an_array, RS) {\n        var curr_x, curr_y, curr_transform, targ_disp, a_disp;\n\n        an_array.visibility = function () {\n            var curr_disp = 'hidden';\n\n            for (var i = 0; i < an_array.length; i++) {\n                if (Array.isArray(an_array[i])) {\n                    continue;\n                }\n\n                a_disp = an_array[i].getAttribute('visibility');\n                if (a_disp && a_disp != 'hidden') {\n                    curr_disp = a_disp;\n                    break;\n                }\n            }\n            return curr_disp;\n        };\n\n        an_array.currenty = function () {\n            var a_y;\n            var filtered = an_array.filter(function (el) {\n                return el && !Array.isArray(el);\n            });\n            if (filtered[0] && filtered[0].getAttribute('transform')) {\n                a_y = /translate\\((-?\\d+\\.?\\d*)\\s*,?\\s*(-?\\d+\\.?\\d*)\\)/.exec(filtered[0].getAttribute('transform'));\n                if (a_y !== null && typeof a_y !== 'undefined') {\n                    a_y = a_y[2];\n                }\n            }\n            return filtered[0] ? parseInt(a_y || filtered[0].getAttribute('y') || 0, 10) : 0;\n        };\n\n        an_array.animate = function (hsh) {\n            if (typeof hsh.y == 'undefined') {\n                attr(hsh);\n                return;\n            }\n            if (an_array.length === 0) {\n                return;\n            }\n\n            var hash = {};\n            var key;\n\n            for (key in hsh) {\n                if (hsh.hasOwnProperty(key)) {\n                    hash[key] = hsh[key];\n                }\n            }\n\n            setup_anim_clocks();\n\n            if (an_array.animating) {\n                for (var i = 0; i < (anim_clock_funcs || []).length; i++) {\n                    if (anim_clock_funcs[i].target_set != an_array) {\n                        continue;\n                    }\n                    an_array.animating = false;\n                    anim_clock_funcs.splice(i, 1);\n                }\n            }\n\n            var curr_disp = an_array.visibility();\n\n            var target_disp = hash.visibility;\n            if (curr_disp == target_disp && target_disp == 'hidden') {\n                attr(hsh);\n                return;\n            }\n\n            var curr_y = an_array.currenty();\n\n            if (isNaN(parseInt(curr_y, 10))) {\n                console.log(\"Have a NaN y value, skipping\");\n                return;\n            }\n\n            var target_y = parseInt(hash.y, 10);\n\n            delete hash.y;\n\n            if (curr_disp == target_disp && target_disp == 'visible') {\n                delete hash.visibility;\n                target_disp = null;\n                attr({ 'visibility': 'visible' });\n            }\n\n            if (hash.visibility == 'hidden') {\n                delete hash.visibility;\n            }\n\n            attr(hash);\n            var counter = 0;\n\n            if (target_y != curr_y) {\n                var anim_steps = 1 * (Math.abs(parseInt((target_y - curr_y) / (50 * RS), 10) / rate) + 1);\n                var diff = (target_y - curr_y) / anim_steps;\n                hash.y = curr_y || 0;\n                var orig_func = an_array.animate;\n                an_array.animating = true;\n                hash.y = curr_y + diff * 1;\n\n                let step_func = function step_func(step) {\n                    if (diff < 0 && hash.y < target_y) {\n                        hash.y = target_y;\n                    }\n                    if (diff > 0 && hash.y > target_y) {\n                        hash.y = target_y;\n                    }\n                    attr(hash);\n                    counter += step || 1;\n                    if (hash.y != target_y) {\n                        hash.y = curr_y + diff * (counter + 1);\n                        return;\n                    }\n                    an_array.animating = false;\n                    if (target_disp) {\n                        attr({ 'visibility': target_disp });\n                    }\n                    anim_clock_funcs.splice(anim_clock_funcs.indexOf(step_func), 1);\n                };\n\n                anim_clock_funcs.push(step_func);\n                anim_clock_funcs[anim_clock_funcs.length - 1].target_set = an_array;\n            }\n            return;\n        };\n\n        an_array.attr = function (hsh) {\n            if (in_anim) {\n                return this.animate(hsh);\n            }\n            return attr(hsh);\n        };\n\n        var attr = function attr(hsh) {\n            var hash = {};\n            var key;\n            for (key in hsh) {\n                if (hsh.hasOwnProperty(key)) {\n                    hash[key] = hsh[key];\n                }\n            }\n\n            var curr_disp = an_array.visibility();\n\n            var targ_y = parseInt(hash.y, 10);\n            targ_disp = hash.visibility;\n\n            for (key in hash) {\n                if (hash.hasOwnProperty(key)) {\n                    for (var i = 0; i < an_array.length; i++) {\n                        if (!an_array[i]) {\n                            continue;\n                        }\n                        if (Array.isArray(an_array[i])) {\n                            continue;\n                        }\n                        if (an_array[i].style.display == 'none') {\n                            continue;\n                        }\n                        var value = hash[key];\n                        if (key == 'style' && an_array[i].hasAttribute('style')) {\n                            var curr_style = an_array[i].getAttribute('style');\n                            curr_style += '; ' + hash[key];\n                            value = curr_style;\n                        }\n                        var has_translate = an_array[i].hasAttribute('transform') && an_array[i].getAttribute('transform').indexOf('translate') >= 0;\n\n                        if (key == 'height' && an_array[i].setHeight) {\n                            //hasAttribute('transform') && ! an_array[i].no_scale) {\n                            an_array[i].setHeight(hash[key]);\n                        } else if (!(has_translate && (key == 'y' || key == 'x'))) {\n                            an_array[i].setAttribute(key, value);\n                        }\n                        if (key == 'y' && an_array[i].hasAttribute('d')) {\n                            var curr_path = an_array[i].getAttribute('d');\n                            var re = /M\\s*([\\d\\.]+) ([\\d\\.]+)/;\n                            curr_path = curr_path.replace(re, '');\n                            if (isNaN(parseInt(value, 10))) {\n                                throw \"Error \" + key + \" is \" + hash[key];\n                            }\n                            an_array[i].setAttribute('d', 'M0 ' + parseInt(value, 10) + ' ' + curr_path);\n                        }\n                        if (key == 'y' && an_array[i].hasAttribute('cy')) {\n                            an_array[i].setAttribute('cy', hash[key]);\n                        }\n\n                        if (key == 'y' && an_array[i].hasAttribute('transform')) {\n                            curr_transform = an_array[i].getAttribute('transform');\n\n                            curr_x = /translate\\((-?\\d+\\.?\\d*)\\s*,?\\s*(-?\\d+\\.?\\d*)?\\)/.exec(an_array[i].getAttribute('transform'));\n                            if (curr_x === null) {\n                                continue;\n                            }\n                            curr_x = curr_x[1];\n                            curr_transform = curr_transform.replace(/translate\\((-?\\d+\\.?\\d*)\\s*,?\\s*(-?\\d+\\.?\\d*)?\\)/, 'translate(' + curr_x + ',' + value + ')');\n                            an_array[i].setAttribute('transform', curr_transform);\n                        }\n                        if (key == 'x' && an_array[i].hasAttribute('transform')) {\n                            curr_transform = an_array[i].getAttribute('transform');\n\n                            curr_y = /translate\\((-?\\d+\\.?\\d*)\\s*,?\\s*(-?\\d+\\.?\\d*)\\)/.exec(an_array[i].getAttribute('transform'));\n                            if (curr_y === null) {\n                                continue;\n                            }\n                            curr_y = curr_y[2];\n                            curr_transform = curr_transform.replace(/translate\\((-?\\d+\\.?\\d*)\\s*,?\\s*(-?\\d+\\.?\\d*)\\)/, 'translate(' + value + ',' + curr_y + ')');\n                            an_array[i].setAttribute('transform', curr_transform);\n                        }\n                        if (key == 'text-anchor' && an_array[i].hasAttribute('style')) {\n                            an_array[i].style.textAnchor = hash[key];\n                        };\n                    }\n                }\n            }\n        };\n        an_array.hide = function () {\n            this.attr({ 'visibility': 'hidden' });\n        };\n        an_array.show = function () {\n            this.attr({ 'visibility': 'visible' });\n        };\n\n        an_array.refresh_zoom = function () {\n            for (var i = 0; i < an_array.length; i++) {\n                if (Array.isArray(an_array[i])) {\n                    continue;\n                }\n\n                if (an_array[i].zoom_level && an_array[i].zoom_level == 'text') {\n                    if (an_array[i].ownerSVGElement && an_array[i].ownerSVGElement.zoom > 3.5) {\n                        an_array[i].setAttribute('display', 'inline');\n                        an_array[i].setAttribute('opacity', 1);\n                    } else {\n                        an_array[i].setAttribute('display', 'none');\n                    }\n                }\n\n                if (an_array[i].zoom_level && an_array[i].zoom_level == 'summary') {\n                    if (an_array[i].ownerSVGElement && an_array[i].ownerSVGElement.zoom <= 3.5) {\n                        an_array[i].setAttribute('display', 'inline');\n                        an_array[i].setAttribute('opacity', 1);\n                    } else {\n                        an_array[i].setAttribute('display', 'none');\n                    }\n                }\n            }\n        };\n\n        return an_array;\n    }\n\n    var anim_clock_funcs = null,\n        in_anim = false;\n    var anim_clock = null;\n    var rate = 75;\n    var new_rate = null;\n\n    var setup_anim_clocks = function setup_anim_clocks() {\n        if (anim_clock_funcs === null) {\n            anim_clock_funcs = [];\n        } else {\n            anim_clock_funcs.forEach(function (func) {\n                func._last_step = null;\n            });\n            clearInterval(anim_clock);\n        }\n        if (!in_anim) {\n            extended_elements.forEach(function (canv) {\n                _bean__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fire(canv, '_anim_begin');\n            });\n            in_anim = true;\n        }\n        var start = null;\n        anim_clock = setInterval(function () {\n            if (!anim_clock_funcs || anim_clock_funcs.length === 0) {\n                clearInterval(anim_clock);\n                anim_clock = null;\n                anim_clock_funcs = null;\n                in_anim = false;\n                extended_elements.forEach(function (canv) {\n                    _bean__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fire(canv, '_anim_end');\n                });\n                return;\n            }\n\n            var suspended_ids = [];\n\n            extended_elements.forEach(function (canv) {\n                suspended_ids.push(canv.suspendRedraw(5000));\n            });\n            var tic = new Date().getTime();\n\n            if (!start) {\n                start = new Date().getTime();\n            }\n\n            for (var i = 0; i < (anim_clock_funcs || []).length; i++) {\n                var end = new Date().getTime();\n                var step_id = parseInt((end - start) / rate, 10);\n                if (new_rate === null && step_id - anim_clock_funcs[i]._last_step > 2) {\n                    new_rate = Math.round(1.6 * rate);\n                }\n                anim_clock_funcs[i].apply(null, [step_id - (anim_clock_funcs[i]._last_step || step_id)]);\n                if (anim_clock_funcs && anim_clock_funcs[i]) {\n                    anim_clock_funcs[i]._last_step = step_id;\n                }\n            }\n            var toc = new Date().getTime();\n\n            extended_elements.forEach(function (canv) {\n                canv.unsuspendRedraw(suspended_ids.shift());\n            });\n\n            var actual_speed = toc - tic;\n            if (actual_speed < rate && new_rate === null && actual_speed >= 1) {\n                rate = Math.round(1.5 * (toc - tic));\n                setup_anim_clocks();\n            } else if (new_rate !== null && new_rate != rate) {\n                rate = new_rate;\n                setup_anim_clocks();\n            }\n        }, rate);\n    };\n    var scale_re = /scale\\((-?\\d+\\.?\\d*)\\)/;\n    var setHeight = function setHeight(height) {\n        var curr_transform = this.getAttribute('transform').toString();\n\n        var curr_scale = scale_re.exec(curr_transform);\n\n        var curr_height = parseFloat(this.getAttribute('height') || 1);\n\n        var new_scale = 1;\n        if (curr_scale === null) {\n            curr_transform += ' scale(1) ';\n            curr_scale = 1;\n        } else {\n            curr_scale = parseFloat(curr_scale[1]);\n        }\n        new_scale = parseFloat(height) / curr_height * curr_scale;\n\n        curr_transform = curr_transform.replace(scale_re, 'scale(' + new_scale + ')');\n\n        this.setAttribute('transform', curr_transform);\n        this.setAttribute('height', height);\n        return new_scale;\n    };\n\n    return function (canvas) {\n\n        var RS = canvas.RS || DEFAULT_RS;\n        canvas.RS = RS;\n        canvas.font_order = 'Helvetica, Verdana, Arial, Sans-serif';\n        extended_elements.push(canvas);\n\n        canvas.makeEl = function (name, attributes) {\n            var result = canvas.ownerDocument.createElementNS(svgns, name);\n            for (var attribute in attributes) {\n                if (attributes.hasOwnProperty(attribute)) {\n                    result.setAttribute(attribute, attributes[attribute]);\n                }\n            }\n            return result;\n        };\n\n        canvas.make_gradient = function (id, x2, y2, stops, opacities) {\n            var gradient = this.makeEl('linearGradient', {\n                'id': id,\n                'x1': '0%',\n                'x2': x2,\n                'y1': '0%',\n                'y2': y2\n            });\n            var total_stops = stops.length;\n            while (stops.length > 0) {\n                var stop_id = Math.round((total_stops - stops.length) / total_stops * 100);\n                var stop = stops.shift();\n                var opacity = opacities.shift();\n                gradient.appendChild(this.makeEl('stop', {\n                    'offset': stop_id + '%',\n                    'style': 'stop-color:' + stop + ';stop-opacity:' + opacity\n                }));\n            }\n            return gradient;\n        };\n\n        canvas.path = function (pathdesc) {\n            var a_path = document.createElementNS(svgns, 'path');\n            a_path.setAttribute('d', pathdesc);\n            a_path.setAttribute('stroke', '#000000');\n            a_path.setAttribute('stroke-width', '1');\n            this.appendChild(a_path);\n            return a_path;\n        };\n\n        canvas.poly = function (points) {\n            var a_poly = document.createElementNS(svgns, 'polygon');\n            a_poly.setAttribute('points', points);\n            this.appendChild(a_poly);\n            return a_poly;\n        };\n\n        canvas.circle = function (x, y, radius) {\n            var a_circle = document.createElementNS(svgns, 'circle');\n            a_circle.setAttribute('cx', typeof x == 'string' ? x : x * RS);\n            a_circle.setAttribute('cy', typeof y == 'string' ? y : y * RS);\n            a_circle.setAttribute('r', typeof radius == 'string' ? radius : radius * RS);\n            a_circle.move = function (new_x) {\n                a_circle.setAttribute('cx', new_x * RS);\n            };\n            this.appendChild(a_circle);\n            return a_circle;\n        };\n\n        canvas.group = function () {\n            var a_g = document.createElementNS(svgns, 'g');\n            this.appendChild(a_g);\n            a_g.push = function (new_el) {\n                a_g.appendChild(new_el);\n            };\n\n            return a_g;\n        };\n\n        canvas.clipPath = function () {\n            var el = document.createElementNS(svgns, 'clipPath');\n            this.appendChild(el);\n            el.push = function (new_el) {\n                el.appendChild(new_el);\n            };\n            return el;\n        };\n\n        canvas.line = function (x, y, x2, y2) {\n            var a_line = document.createElementNS(svgns, 'line');\n            a_line.setAttribute('x1', typeof x == 'string' ? x : x * RS);\n            a_line.setAttribute('y1', typeof y == 'string' ? y : y * RS);\n            a_line.setAttribute('x2', typeof x2 == 'string' ? x2 : x2 * RS);\n            a_line.setAttribute('y2', typeof y2 == 'string' ? y2 : y2 * RS);\n            this.appendChild(a_line);\n            return a_line;\n        };\n\n        canvas.rect = function (x, y, width, height, opts) {\n            if (!opts) {\n                opts = {};\n            }\n            var a_rect = document.createElementNS(svgns, 'rect');\n            a_rect.setAttribute('x', typeof x == 'string' ? x : x * RS);\n            a_rect.setAttribute('y', typeof y == 'string' ? y : y * RS);\n            a_rect.setAttribute('width', typeof width == 'string' ? width : width * RS);\n            a_rect.setAttribute('height', typeof height == 'string' ? height : height * RS);\n            a_rect.setAttribute('stroke', '#000000');\n            this.appendChild(a_rect);\n            if (typeof opts.offset !== \"undefined\") {\n                a_rect.offset = opts.offset;\n                a_rect.setAttribute('transform', 'translate(' + a_rect.getAttribute('x') + ',' + a_rect.getAttribute('y') + ')');\n                a_rect.setAttribute('x', '0');\n                a_rect.setAttribute('y', a_rect.offset * RS);\n            }\n\n            a_rect.move = function (new_x, new_width) {\n                if (typeof this.offset !== \"undefined\" && this.getAttribute('transform')) {\n                    var transform_attr = this.getAttribute('transform');\n                    var matches = /translate\\(.*[,\\s](.*)\\)/.exec(transform_attr);\n                    if (matches[1]) {\n                        this.setAttribute('transform', 'translate(' + new_x * RS + ',' + matches[1] + ')');\n                    }\n                    this.setAttribute('width', new_width * RS);\n                } else {\n                    this.setAttribute('x', new_x * RS);\n                    this.setAttribute('width', new_width * RS);\n                }\n            };\n            return a_rect;\n        };\n\n        canvas.roundRect = function (x, y, width, height, r, opts) {\n            var a_rect = this.rect(x, y, width, height, opts);\n            if (typeof r != 'object' || !r.x) {\n                r = { 'x': r, 'y': r };\n            }\n            a_rect.setAttribute('rx', r.x * RS);\n            a_rect.setAttribute('ry', r.y * RS);\n            return a_rect;\n        };\n\n        canvas.ellipticalRect = function (x, y, width, height) {\n            return this.roundRect(x, y, width, height, { 'x': 0.25 * width, 'y': 0.5 * height });\n        };\n        canvas.pentagon = function (x, y, width, height, rotate) {\n            return this.nagon(x, y, width, height, 5, rotate);\n        };\n        canvas.hexagon = function (x, y, width, height, rotate) {\n            return this.nagon(x, y, width, height, 6, rotate);\n        };\n\n        var shape_set_attribute = function shape_set_attribute(attr, val) {\n            this.constructor.prototype.setAttribute.call(this, attr, val);\n            if (attr == 'height' || attr == 'width' || attr == 'x' || attr == 'y') {\n                this.redraw(Math.floor(parseFloat(this.getAttribute('height'))));\n            }\n        };\n\n        canvas.nagon = function (x, y, width, height, n, rotate) {\n            var shape = this.poly(\"\");\n            // shape.setAttribute('transform','translate('+(x*RS)+','+(RS*y)+')');\n            shape.setAttribute('x', x * RS);\n            shape.setAttribute('y', y * RS);\n            shape.setAttribute('width', width * RS);\n            shape.redraw = function (hght) {\n                if (hght) {\n                    this.last_height = hght;\n                } else {\n                    hght = this.last_height;\n                }\n                var a = 0.5 * Math.floor(parseFloat(shape.getAttribute('width')));\n                var b = 0.5 * hght;\n                var points = [];\n                var min_x = null;\n                var max_x = null;\n                for (var i = 0; i < n; i++) {\n                    var angle = rotate / 360 * 2 * Math.PI + 2 / n * Math.PI * i;\n                    var a_x = parseInt(a + a * Math.cos(angle));\n                    var a_y = parseInt(b + b * Math.sin(angle));\n                    points.push([a_x, a_y]);\n                    if (min_x === null || a_x < min_x) {\n                        min_x = a_x;\n                    }\n                    if (max_x === null || a_x > max_x) {\n                        max_x = a_x;\n                    }\n                }\n                var x_pos = Math.floor(parseFloat(shape.getAttribute('x')));\n                var y_pos = Math.floor(parseFloat(shape.getAttribute('y')));\n                points.map(function (points) {\n                    if (points[0] == min_x) {\n                        points[0] = 0;\n                    }\n                    if (points[0] == max_x) {\n                        points[0] = a * 2;\n                    }\n                    points[0] += x_pos;\n                    points[1] = y_pos + 0.5 * hght * (points[1] / b);\n                    return points.join(\",\");\n                });\n                this.setAttribute('points', points.join(\" \"));\n            };\n            shape.setHeight = shape.redraw;\n            shape.move = function (new_x, new_width) {\n                var curr_y = /translate\\((-?\\d+\\.?\\d*)\\s*,?\\s*(-?\\d+\\.?\\d*)\\)/.exec(this.getAttribute('transform'));\n                if (curr_y === null) {\n                    return;\n                }\n                curr_y = curr_y[2];\n                var curr_transform = this.getAttribute('transform').replace(/translate\\((-?\\d+\\.?\\d*)\\s*,?\\s*(-?\\d+\\.?\\d*)\\)/, 'translate(' + new_x * RS + ',' + curr_y + ')');\n                this.setAttribute('transform', curr_transform);\n                a = 0.5 * new_width * RS;\n            };\n            shape.setAttribute = shape_set_attribute;\n            shape.redraw(height * RS);\n            return shape;\n        };\n\n        canvas.use = function (ref, x, y, width, height) {\n            var a_use = document.createElementNS(svgns, 'use');\n            a_use.setAttribute('x', typeof x == 'string' ? x : x * RS);\n            a_use.setAttribute('y', typeof y == 'string' ? y : y * RS);\n            a_use.setAttribute('width', typeof width == 'string' ? width : width * RS);\n            a_use.setAttribute('height', typeof height == 'string' ? height : height * RS);\n            a_use.setAttributeNS('http://www.w3.org/1999/xlink', 'href', ref);\n            this.appendChild(a_use);\n\n            return a_use;\n        };\n\n        canvas.a = function (href) {\n            var a_anchor = document.createElementNS(svgns, 'a');\n            a_anchor.setAttribute('target', '_new');\n            a_anchor.setAttributeNS('http://www.w3.org/1999/xlink', 'href', href);\n            this.appendChild(a_anchor);\n            return a_anchor;\n        };\n\n        canvas.button = function (x, y, width, height, text) {\n            var fo = document.createElementNS(svgns, 'foreignObject');\n            fo.setAttribute('x', x);\n            fo.setAttribute('y', y);\n            fo.setAttribute('width', x + width);\n            fo.setAttribute('height', y + height);\n            if (!fo.style) {\n                fo.setAttribute('style', 'position: absolute;');\n            } else {\n                fo.style.position = 'absolute';\n            }\n            this.appendChild(fo);\n            var button = document.createElement('button');\n            button.style.display = 'block';\n            button.textContent = text;\n            fo.appendChild(button);\n            return button;\n        };\n\n        canvas.svgbutton = function (x, y, width, height, txt) {\n            var button = this.group();\n            var back = this.rect(x, y, width, height);\n            back.setAttribute('rx', '10');\n            back.setAttribute('ry', '10');\n            back.setAttribute('stroke', '#ffffff');\n            back.setAttribute('stroke-width', '2');\n            back.setAttribute('fill', 'url(#simple_gradient)');\n            x = back.x.baseVal.value;\n            y = back.y.baseVal.value;\n            width = back.width.baseVal.value;\n            height = back.height.baseVal.value;\n\n            var text = this.text(x + width / 2, y + height / 3, txt);\n            text.setAttribute('text-anchor', 'middle');\n            text.firstChild.setAttribute('dy', '1.5ex');\n            text.setAttribute('font-size', 0.5 * height);\n            text.setAttribute('fill', '#ffffff');\n            button.push(back);\n            button.push(text);\n            button.background_element = back;\n            button.text_element = text;\n\n            button.setAttribute('cursor', 'pointer');\n            var button_trigger = function button_trigger() {\n                back.setAttribute('fill', '#999999');\n                back.setAttribute('stroke', '#000000');\n            };\n            button.addEventListener('mousedown', button_trigger, false);\n            button.addEventListener('touchstart', button_trigger, false);\n            var button_reset = function button_reset() {\n                back.setAttribute('stroke', '#ffffff');\n                back.setAttribute('fill', 'url(#simple_gradient)');\n            };\n            button.addEventListener('mouseup', button_reset, false);\n            button.addEventListener('mouseout', button_reset, false);\n            button.addEventListener('touchend', button_reset, false);\n            return button;\n        };\n\n        canvas.callout = function (x, y, content, opts) {\n            var callout = this.group();\n            var back = this.roundRect(-0.5 * (opts.width + 4), 20, opts.width + 4, opts.height + 4, 4);\n            back.setAttribute('fill', '#000000');\n            var pres_box = this.roundRect(-0.5 * (opts.width + 1), 22, opts.width + 1, opts.height, 4);\n            pres_box.setAttribute('fill', '#eeeeee');\n            callout.push(back);\n            callout.push(pres_box);\n            var poly = this.poly('0,500 500,1000 -500,1000');\n            poly.setAttribute('fill', '#000000');\n            callout.push(poly);\n            var fo = document.createElementNS(svgns, 'foreignObject');\n            fo.setAttribute('x', -0.5 * (opts.width + 1) * RS);\n            fo.setAttribute('y', 22 * RS);\n            fo.setAttribute('width', opts.width * RS);\n            fo.setAttribute('height', opts.height * RS);\n            callout.push(fo);\n            var html = document.createElementNS('http://www.w3.org/1999/xhtml', 'html');\n            html.setAttribute('xmlns', 'http://www.w3.org/1999/xhtml');\n            var body = document.createElementNS('http://www.w3.org/1999/xhtml', 'body');\n            body.style.fontSize = (opts['font-size'] || 15) * RS + 'px';\n            body.style.margin = 5 * RS + 'px';\n            body.style.height = opts.height * RS * 10 + 'px';\n            html.appendChild(body);\n            body.appendChild(content);\n            fo.appendChild(html);\n            var scale = opts.height / 15;\n            callout.setAttribute('transform', 'translate(' + x * RS + ',' + (y + 20) * RS + ') scale(' + scale + ')');\n            callout.setHeight = setHeight;\n            if (!opts.align) {\n                var currVbox = parseFloat(this.getAttribute('viewBox').split(/\\s+/)[2]);\n                if ((x + 10 + 0.5 * opts.width) * RS > currVbox) {\n                    opts.align = 'right';\n                }\n                if ((x - 0.5 * opts.width) * RS < 0) {\n                    opts.align = 'left';\n                }\n            }\n            if (opts.align) {\n                var shifter = opts.align == \"right\" ? -0.5 : 0.5;\n                back.setAttribute('transform', 'translate(' + shifter * opts.width * RS + ',0)');\n                pres_box.setAttribute('transform', 'translate(' + shifter * opts.width * RS + ',0)');\n                poly.setAttribute('transform', 'translate(' + 0 * shifter * opts.width * RS + ',0)');\n                poly.setAttribute('points', shifter > 0 ? \"0,500 500,1000 0,1000\" : \"0,500 0,1000 -500,1000\");\n                fo.setAttribute('transform', 'translate(' + shifter * opts.width * RS + ',0)');\n            }\n            callout.setAttribute('height', opts.height * RS);\n            return callout;\n        };\n\n        canvas.growingMarker = function (x, y, symbol, opts) {\n            var container = document.createElementNS(svgns, 'svg');\n            if (!opts.stretch && !(Array.isArray && Array.isArray(opts.content))) {\n                container.setAttribute('viewBox', '-50 -100 200 250');\n                container.setAttribute('preserveAspectRatio', 'xMinYMin meet');\n            } else {\n                container = this.group();\n            }\n            container.setAttribute('x', x);\n            container.setAttribute('y', y);\n            var the_marker = this.marker(50 / RS, 50 / RS, 50 / RS, symbol, opts);\n            container.appendChild(the_marker);\n            container.contentElement = the_marker.contentElement;\n            var result = this.group();\n            var positioning_group = this.group();\n            result.appendChild(positioning_group);\n            positioning_group.appendChild(container);\n            if (!opts.stretch && !(Array.isArray && Array.isArray(opts.content))) {\n                container.setAttribute('width', '200');\n                container.setAttribute('height', '250');\n            }\n            if (opts.angle) {\n                result.angle = opts.angle;\n            }\n            // var rect = document.createElementNS(svgns,'rect');\n            // rect.setAttribute('stroke','#f00');\n            // rect.setAttribute('stroke-width','10');\n            // rect.setAttribute('x','-50');\n            // rect.setAttribute('y','-100');\n            // rect.setAttribute('width','100%');\n            // rect.setAttribute('height','100%');\n            // rect.setAttribute('fill','none');\n            // container.appendChild(rect);\n\n            // var rect = document.createElementNS(svgns,'rect');\n            // rect.setAttribute('stroke','#0f0');\n            // rect.setAttribute('stroke-width','10');\n            // rect.setAttribute('x','50');\n            // rect.setAttribute('y','25');\n            // rect.setAttribute('width','50%');\n            // rect.setAttribute('height','50%');\n            // rect.setAttribute('fill','none');\n\n            // container.appendChild(rect);\n\n            result.setAttribute('height', '250');\n            result.setAttribute('transform', 'scale(1)');\n            result.setHeight = function (height) {\n                // this.setAttribute('height',height);\n                var scale_val = setHeight.call(this, height);\n                this.setAttribute('height', height);\n                var top_offset = this.offset || 0;\n                if (!this.angle) {\n                    this.angle = 0;\n                }\n                this.firstChild.setAttribute('transform', 'translate(-100,' + top_offset * RS + ') rotate(' + this.angle + ',100,0)');\n            };\n            result.container = container;\n            return result;\n        };\n\n        canvas.marker = function (cx, cy, r, symbol, opts) {\n            var units = 0;\n            if (typeof cx == 'string') {\n                var parts = new RegExp(/(\\d+)(.*)/g).exec(cx);\n                units = parts[2];\n                cx = parseFloat(parts[1]);\n\n                parts = new RegExp(/(\\d+)(.*)/g).exec(cy);\n                cy = parseFloat(parts[1]);\n\n                parts = new RegExp(/(\\d+)(.*)/g).exec(r);\n                r = parseFloat(parts[1]);\n            }\n\n            var dim = {\n                CX: cx + units,\n                CY: cy + units,\n                R: r + units,\n                MIN_X: cx - r + units,\n                MAX_X: cx + r + units,\n                MIN_Y: cy - r + units,\n                MAX_Y: cy + r + units,\n                MID_X1: cx - r / 2 + units,\n                MID_X2: cx + r / 2 + units,\n                MID_Y1: cy - r / 2 + units,\n                MID_Y2: cy + r / 2 + units\n            };\n\n            var marker = this.group();\n            if (!opts) {\n                opts = {};\n            }\n            var fill_color = opts && opts.border ? opts.border : 'rgb(0,0,0)';\n            if (!opts.bare_element) {\n                if (opts.width) {\n                    marker.push(this.roundRect(-0.5 * opts.width - 1, -0.5, opts.width + 2, 3, 1.5));\n                    marker.lastChild.setAttribute('fill', fill_color);\n                } else {\n                    marker.push(this.circle(0, -0.5 * r, r));\n\n                    marker.lastChild.setAttribute('fill', fill_color);\n                    marker.lastChild.setAttribute('border', 'true');\n\n                    marker.push(this.circle(0, 1.5 * r, r));\n\n                    marker.lastChild.setAttribute('fill', fill_color);\n                    marker.lastChild.setAttribute('border', 'true');\n                    var arrow = this.poly(-0.9 * r * RS + ',' + 0 * r * RS + ' 0,' + -2.5 * r * RS + ' ' + 0.9 * r * RS + ',' + 0 * r * RS);\n\n                    arrow.setAttribute('fill', fill_color);\n                    arrow.setAttribute('stroke-width', '0');\n\n                    marker.push(arrow);\n                    marker.lastChild.setAttribute('border', 'true');\n                }\n            }\n            marker.setAttribute('transform', 'translate(' + cx * RS + ',' + 0.5 * cy * RS + ') scale(1)');\n            marker.setHeight = setHeight;\n            marker.setAttribute('height', dim.R * RS);\n            if (typeof symbol == 'string') {\n                if (symbol.match(/^(:?https?:)?\\/?.*#/)) {\n                    marker.contentElement = this.use(symbol, -r, 0, 2 * r, 2 * r);\n                    marker.contentElement.setAttribute('content', 'true');\n                } else {\n                    marker.contentElement = this.text_circle(0, 0, 2 * r, symbol, opts);\n                    marker.contentElement.firstChild.setAttribute('content', 'true');\n                }\n                marker.push(marker.contentElement);\n            } else if (Array.isArray && Array.isArray(symbol)) {\n                marker.contentElement = this.group();\n                var phase = Math.PI / symbol.length;\n                // phase -= (Math.PI / 2);\n                var needs_stretch = opts.stretch;\n                var nrow = 2;\n                symbol.forEach(function (symb, i) {\n                    var x_pos = i % nrow;\n                    var y_pos = 2 + Math.floor(i / nrow);\n                    x_pos *= 2 * r;\n                    y_pos *= 2 * r;\n                    x_pos -= 0.5 * r;\n                    var rotate_amount = 180 * i / symbol.length;\n                    rotate_amount -= 0 * 90;\n                    rotate_amount = 0;\n                    if (needs_stretch) {\n                        if (rotate_amount >= -90 && rotate_amount <= 90) {\n                            opts.stretch = 'right';\n                        } else {\n                            opts.stretch = 'left';\n                        }\n                        if (rotate_amount % 90 == 0 && rotate_amount != 90 && rotate_amount != -90) {\n                            if (rotate_amount == 0) {\n                                opts.stretch = 'right';\n                            }\n                            if (symbol.length == 1) {\n                                opts.stretch = true;\n                            }\n                        }\n                    }\n\n                    if (rotate_amount > 90 && rotate_amount < 270) {\n                        rotate_amount = 180 + rotate_amount;\n                    }\n                    let new_el = null;\n                    if (symb.match(/^(:?https?:)?\\/?.*#/)) {\n                        new_el = canvas.use(symb, (x_pos - 0.5) * r, (y_pos - 0.5) * r, 2 * r, 2 * r);\n                        new_el.setAttribute('pointer-events', 'none');\n                        new_el.setAttribute('content', 'true');\n                    } else {\n                        var opts_copy = JSON.parse(JSON.stringify(opts));\n                        opts_copy.no_tracer = true;\n                        delete opts_copy.offset;\n                        delete opts_copy.height;\n                        new_el = canvas.text_circle(x_pos * r, y_pos * r, 1.75 * r, symb, opts_copy);\n                        new_el.firstChild.setAttribute('content', 'true');\n                    }\n                    var curr_transform = new_el.getAttribute('transform') || '';\n                    curr_transform = curr_transform + ' rotate(' + rotate_amount + ',' + 0 * r * RS + ',' + y_pos * r * RS + ')';\n                    new_el.setAttribute('transform', curr_transform);\n                    marker.contentElement.push(new_el);\n                });\n                marker.push(marker.contentElement);\n            } else {\n                marker.contentElement = this.group();\n                if (!opts.bare_element) {\n                    marker.contentElement.push(this.text_circle(0, 0.5 * r, 1.75 * r, \"\", opts));\n                    marker.contentElement.lastChild.firstChild.setAttribute('content', 'true');\n                }\n                if (symbol) {\n                    if (!opts.bare_element) {\n                        symbol.setAttribute('transform', 'translate(0,' + 0.5 * r * RS + ')');\n                    }\n                    symbol.setAttribute('content', 'true');\n                    marker.contentElement.push(symbol);\n                }\n                marker.push(marker.contentElement);\n            }\n            marker.setAttribute('marker', 'true');\n            return marker;\n        };\n\n        canvas.text_circle = function (cx, cy, r, txt, opts) {\n\n            if (!opts) {\n                opts = {};\n            }\n\n            var units = 0;\n\n            if (typeof cx == 'string') {\n                var parts = new RegExp(/(\\d+)(.*)/g).exec(cx);\n                units = parts[2];\n                cx = parseFloat(parts[1]);\n\n                parts = new RegExp(/(\\d+)(.*)/g).exec(cy);\n                cy = parseFloat(parts[1]);\n\n                parts = new RegExp(/(\\d+)(.*)/g).exec(r);\n                r = parseFloat(parts[1]);\n            }\n            var dim = {\n                CX: cx + units,\n                CY: cy + units,\n                R: r + units,\n                MIN_X: cx - r + units,\n                MAX_X: cx + r + units,\n                MIN_Y: cy - r + units,\n                MAX_Y: cy + r + units,\n                MID_X1: cx - r / 2 + units,\n                MID_X2: cx + r / 2 + units,\n                MID_Y1: cy - r / 2 + units,\n                MID_Y2: cy + r / 2 + units\n            };\n\n            var marker_group = this.group();\n\n            var text = this.text(0, dim.CY, txt);\n            text.setAttribute('font-size', 10 * RS);\n            text.setAttribute('font-weight', opts.weight || 'bolder');\n            text.setAttribute('fill', opts.text_fill || '#ffffff');\n            text.setAttribute('style', 'font-family: sans-serif; text-anchor: middle;');\n            text.firstChild.setAttribute('dy', '0.35em');\n            text.setAttribute('text-anchor', 'middle');\n            var back;\n\n            if (!opts.stretch) {\n                back = this.circle(0, dim.CY, 9 / 10 * dim.R);\n            } else {\n                var text_width = 1.2 * (opts.font_size || r) * text.getBBox().width / (10 * RS);\n                var text_height = 3 / 2 * dim.R;\n                var left_pos = -0.5 * text_width;\n                if (text_width > 3 * dim.R) {\n                    left_pos = -0.5 * text_width;\n\n                    if (opts.stretch == 'right') {\n                        left_pos = -0.1 * text_width;\n                    }\n                    if (opts.stretch == 'left') {\n                        left_pos = -0.9 * text_width;\n                    }\n                } else {\n                    text_width = 3 * dim.R;\n                    left_pos = -0.5 * text_width;\n                }\n                text.setAttribute('x', (0.5 * text_width + left_pos) * RS);\n                back = this.roundRect(left_pos, dim.CY - 0.5 * text_height, text_width, text_height, { 'x': 0.5 * dim.R, 'y': 0.5 * text_height }, {});\n            }\n            text.setAttribute('font-size', (opts.font_size || r) * RS);\n\n            back.setAttribute('fill', opts.fill || 'url(#simple_gradient)');\n            window.matchMedia('print').addListener(function (match) {\n                back.setAttribute('fill', match.matches ? '#aaaaaa' : opts.fill || 'url(#simple_gradient)');\n            });\n            back.setAttribute('stroke', opts.border || '#000000');\n            back.setAttribute('stroke-width', r / 10 * RS);\n\n            marker_group.push(back);\n\n            marker_group.push(text);\n\n            marker_group.setAttribute('transform', 'translate(' + dim.CX * RS + ', 1) scale(1)');\n            marker_group.setAttribute('height', dim.R / 2 * RS);\n            marker_group.setHeight = setHeight;\n            return marker_group;\n        };\n\n        canvas.crossed_circle = function (cx, cy, r) {\n\n            var units = 0;\n\n            if (typeof cx == 'string') {\n                var parts = new RegExp(/(\\d+)(.*)/g).exec(cx);\n                units = parts[2];\n                cx = parseFloat(parts[1]);\n\n                parts = new RegExp(/(\\d+)(.*)/g).exec(cy);\n                cy = parseFloat(parts[1]);\n\n                parts = new RegExp(/(\\d+)(.*)/g).exec(r);\n                r = parseFloat(parts[1]);\n            }\n            var dim = {\n                CX: cx + units,\n                CY: cy + units,\n                R: r + units,\n                MIN_X: cx - r + units,\n                MAX_X: cx + r + units,\n                MIN_Y: cy - r + units,\n                MAX_Y: cy + r + units,\n                MID_X1: cx - r / 2 + units,\n                MID_X2: cx + r / 2 + units,\n                MID_Y1: cy - r / 2 + units,\n                MID_Y2: cy + r / 2 + units\n            };\n\n            var close_group = this.group();\n\n            var close_button = this.circle(dim.CX, dim.CY, dim.R);\n            close_button.setAttribute('fill', '#000000');\n            close_button.setAttribute('stroke', '#ffffff');\n            close_button.setAttribute('stroke-width', '2');\n\n            close_group._button = close_button;\n\n            close_group.push(close_button);\n\n            var a_line = this.line(dim.MID_X1, dim.MID_Y1, dim.MID_X2, dim.MID_Y2);\n            a_line.setAttribute('stroke', '#ffffff');\n            a_line.setAttribute('stroke-width', '2');\n\n            close_group.push(a_line);\n\n            var first_line = a_line;\n\n            var a_line = this.line(dim.MID_X1, dim.MID_Y2, dim.MID_X2, dim.MID_Y1);\n            a_line.setAttribute('stroke', '#ffffff');\n            a_line.setAttribute('stroke-width', '2');\n\n            close_group.push(a_line);\n\n            close_group.move = function (cx, cy) {\n                close_button.setAttribute('cx', cx);\n                dim.MID_X1 = cx - r / 2;\n                dim.MID_X2 = cx + r / 2;\n                dim.MID_Y1 = cy - r / 2;\n                dim.MID_Y2 = cy + r / 2;\n                first_line.setAttribute('x1', dim.MID_X1);\n                first_line.setAttribute('y1', dim.MID_Y1);\n                first_line.setAttribute('x2', dim.MID_X2);\n                first_line.setAttribute('y2', dim.MID_Y2);\n                a_line.setAttribute('x1', dim.MID_X1);\n                a_line.setAttribute('y1', dim.MID_Y2);\n                a_line.setAttribute('x2', dim.MID_X2);\n                a_line.setAttribute('y2', dim.MID_Y1);\n            };\n            return close_group;\n        };\n        canvas.text = function (x, y, text) {\n            var a_text = document.createElementNS(svgns, 'text');\n            var a_tspan = document.createElementNS(svgns, 'tspan');\n            if (typeof text != 'string') {\n                a_text.appendChild(text);\n            } else {\n                a_text.appendChild(a_tspan);\n                a_tspan.textContent = text;\n                a_tspan.setAttribute('dy', '0');\n            }\n            a_text.style.fontFamily = this.font_order || 'Helvetica, Verdana, Arial, Sans-serif';\n            a_text.setAttribute('x', typeof x == 'string' ? x : x * RS);\n            a_text.setAttribute('y', typeof y == 'string' ? y : y * RS);\n            a_text.move = function (new_x, new_width) {\n                if (typeof this.offset !== \"undefined\" && this.getAttribute('transform')) {\n                    var transform_attr = this.getAttribute('transform');\n                    var matches = /translate\\(.*[,\\s](.*)\\)/.exec(transform_attr);\n                    if (matches[1]) {\n                        this.setAttribute('transform', 'translate(' + new_x * RS + ',' + matches[1] + ')');\n                    }\n                } else {\n                    this.setAttribute('x', new_x * RS);\n                }\n            };\n\n            this.appendChild(a_text);\n            return a_text;\n        };\n        canvas.plus = function (x, y, height) {\n            var g = this.group();\n            g.appendChild(this.makeEl('rect', {\n                'x': Math.round(0.4 * height * RS).toString(),\n                'y': Math.round(0.1 * height * RS).toString(),\n                'stroke-width': '1',\n                'width': Math.round(0.2 * height * RS).toString(),\n                'height': Math.round(0.8 * height * RS).toString(),\n                'stroke': '#ffffff',\n                'fill': '#ffffff'\n            }));\n\n            g.appendChild(this.makeEl('rect', {\n                'x': Math.round(0.1 * height * RS).toString(),\n                'y': Math.round(0.4 * height * RS).toString(),\n                'stroke-width': '1',\n                'width': Math.round(0.8 * height * RS).toString(),\n                'height': Math.round(0.2 * height * RS).toString(),\n                'stroke': '#ffffff',\n                'fill': '#ffffff'\n            }));\n            g.setAttribute('transform', 'translate(' + x * RS + ',' + y * RS + ')');\n            return g;\n        };\n        canvas.minus = function (x, y, height) {\n            var g = this.group();\n\n            g.appendChild(this.makeEl('rect', {\n                'x': Math.round(0.1 * height * RS).toString(),\n                'y': Math.round(0.4 * height * RS).toString(),\n                'stroke-width': '1',\n                'width': Math.round(0.8 * height * RS).toString(),\n                'height': Math.round(0.2 * height * RS).toString(),\n                'stroke': '#ffffff',\n                'fill': '#ffffff'\n            }));\n            g.setAttribute('transform', 'translate(' + x * RS + ',' + y * RS + ')');\n            return g;\n        };\n\n        // Calculate the bounding box of an element with respect to its parent element\n        // Thanks to http://stackoverflow.com/questions/10623809/get-bounding-box-of-element-accounting-for-its-transform\n        canvas.transformedBoundingBox = function (el) {\n            var bb = el.getBBox(),\n                svg = el.ownerSVGElement,\n                m = el.parentNode.getScreenCTM().inverse().multiply(el.getScreenCTM()).inverse();\n            // Create an array of all four points for the original bounding box\n            var pts = [svg.createSVGPoint(), svg.createSVGPoint(), svg.createSVGPoint(), svg.createSVGPoint()];\n            pts[0].x = bb.x;pts[0].y = bb.y;\n            pts[1].x = bb.x + bb.width;pts[1].y = bb.y;\n            pts[2].x = bb.x + bb.width;pts[2].y = bb.y + bb.height;\n            pts[3].x = bb.x;pts[3].y = bb.y + bb.height;\n\n            // Transform each into the space of the parent,\n            // and calculate the min/max points from that.\n            var xMin = Infinity,\n                xMax = -Infinity,\n                yMin = Infinity,\n                yMax = -Infinity;\n            pts.forEach(function (pt) {\n                pt = pt.matrixTransform(m);\n                xMin = Math.min(xMin, pt.x);\n                xMax = Math.max(xMax, pt.x);\n                yMin = Math.min(yMin, pt.y);\n                yMax = Math.max(yMax, pt.y);\n            });\n\n            // Update the bounding box with the new values\n            try {\n                bb.x = xMin;bb.width = xMax - xMin;\n                bb.y = yMin;bb.height = yMax - yMin;\n            } catch (e) {\n                bb = { 'x': xMin, 'y': yMin, 'width': xMax - xMin, 'height': yMax - yMin };\n            }\n            return bb;\n        };\n\n        canvas.set = function () {\n            var an_array = [];\n            extend_array(an_array, RS);\n            return an_array;\n        };\n        canvas.hide = function () {\n            this.setAttribute('display', 'none');\n        };\n        canvas.show = function () {\n            this.setAttribute('display', 'inline');\n        };\n    };\n}();\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (SVGCanvas);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9qcy9saWIvU1ZHQ2FudmFzLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL2pzL2xpYi9TVkdDYW52YXMuanM/YzIzOSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgYmVhbiBmcm9tICcuLi9iZWFuJztcblxuY29uc3QgU1ZHQ2FudmFzID0gKGZ1bmN0aW9uKCkge1xuICAgIFxuICAgIHZhciBleHRlbmRlZF9lbGVtZW50cyA9IFtdO1xuICAgIHZhciBERUZBVUxUX1JTID0gMTtcbiAgICB2YXIgc3ZnbnMgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnO1xuICAgIFxuICAgIGZ1bmN0aW9uIGV4dGVuZF9hcnJheShhbl9hcnJheSxSUykge1xuICAgICAgICB2YXIgY3Vycl94LCBjdXJyX3ksIGN1cnJfdHJhbnNmb3JtLCB0YXJnX2Rpc3AsIGFfZGlzcDtcbiAgICAgICAgXG4gICAgICAgIGFuX2FycmF5LnZpc2liaWxpdHkgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBjdXJyX2Rpc3AgPSAnaGlkZGVuJztcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAgOyBpIDwgYW5fYXJyYXkubGVuZ3RoOyBpKysgKSB7XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYW5fYXJyYXlbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGFfZGlzcCA9IGFuX2FycmF5W2ldLmdldEF0dHJpYnV0ZSgndmlzaWJpbGl0eScpO1xuICAgICAgICAgICAgICAgIGlmIChhX2Rpc3AgJiYgYV9kaXNwICE9ICdoaWRkZW4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJfZGlzcCA9IGFfZGlzcDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGN1cnJfZGlzcDtcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIGFuX2FycmF5LmN1cnJlbnR5ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgYV95O1xuICAgICAgICAgICAgdmFyIGZpbHRlcmVkID0gYW5fYXJyYXkuZmlsdGVyKGZ1bmN0aW9uKGVsKSB7IHJldHVybiBlbCAmJiAhIEFycmF5LmlzQXJyYXkoZWwpOyB9KTtcbiAgICAgICAgICAgIGlmIChmaWx0ZXJlZFswXSAmJiBmaWx0ZXJlZFswXS5nZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScpKSB7XG4gICAgICAgICAgICAgICAgYV95ID0gL3RyYW5zbGF0ZVxcKCgtP1xcZCtcXC4/XFxkKilcXHMqLD9cXHMqKC0/XFxkK1xcLj9cXGQqKVxcKS8uZXhlYyhmaWx0ZXJlZFswXS5nZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScpKTtcbiAgICAgICAgICAgICAgICBpZiAoYV95ICE9PSBudWxsICYmICh0eXBlb2YoYV95KSAhPT0gJ3VuZGVmaW5lZCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFfeSA9IGFfeVsyXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmlsdGVyZWRbMF0gPyBwYXJzZUludCggYV95IHx8IGZpbHRlcmVkWzBdLmdldEF0dHJpYnV0ZSgneScpIHx8IDAsMTApIDogMDtcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIGFuX2FycmF5LmFuaW1hdGUgPSBmdW5jdGlvbihoc2gpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaHNoLnkgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBhdHRyKGhzaCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFuX2FycmF5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGhhc2ggPSB7fTtcbiAgICAgICAgICAgIHZhciBrZXk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGZvciAoa2V5IGluIGhzaCkge1xuICAgICAgICAgICAgICAgIGlmIChoc2guaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBoYXNoW2tleV0gPSBoc2hba2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHNldHVwX2FuaW1fY2xvY2tzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChhbl9hcnJheS5hbmltYXRpbmcpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IChhbmltX2Nsb2NrX2Z1bmNzIHx8IFtdKS5sZW5ndGg7IGkrKyApIHsgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBpZiAoYW5pbV9jbG9ja19mdW5jc1tpXS50YXJnZXRfc2V0ICE9IGFuX2FycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhbl9hcnJheS5hbmltYXRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgYW5pbV9jbG9ja19mdW5jcy5zcGxpY2UoaSwxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcblxuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgY3Vycl9kaXNwID0gYW5fYXJyYXkudmlzaWJpbGl0eSgpO1xuXG4gICAgICAgICAgICB2YXIgdGFyZ2V0X2Rpc3AgPSBoYXNoLnZpc2liaWxpdHk7XG4gICAgICAgICAgICBpZiAoY3Vycl9kaXNwID09IHRhcmdldF9kaXNwICYmIHRhcmdldF9kaXNwID09ICdoaWRkZW4nKSB7XG4gICAgICAgICAgICAgICAgYXR0cihoc2gpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGN1cnJfeSA9IGFuX2FycmF5LmN1cnJlbnR5KCk7XG5cbiAgICAgICAgICAgIGlmIChpc05hTihwYXJzZUludChjdXJyX3ksMTApKSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiSGF2ZSBhIE5hTiB5IHZhbHVlLCBza2lwcGluZ1wiKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB0YXJnZXRfeSA9IHBhcnNlSW50KGhhc2gueSwxMCk7XG5cbiAgICAgICAgICAgIGRlbGV0ZSBoYXNoLnk7XG5cbiAgICAgICAgICAgIGlmIChjdXJyX2Rpc3AgPT0gdGFyZ2V0X2Rpc3AgJiYgdGFyZ2V0X2Rpc3AgPT0gJ3Zpc2libGUnICkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBoYXNoLnZpc2liaWxpdHk7XG4gICAgICAgICAgICAgICAgdGFyZ2V0X2Rpc3AgPSBudWxsOyAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgYXR0cih7J3Zpc2liaWxpdHknIDogJ3Zpc2libGUnfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChoYXNoLnZpc2liaWxpdHkgPT0gJ2hpZGRlbicpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgaGFzaC52aXNpYmlsaXR5O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhdHRyKGhhc2gpO1xuICAgICAgICAgICAgdmFyIGNvdW50ZXIgPSAwO1xuXG4gICAgICAgICAgICBpZiAodGFyZ2V0X3kgIT0gY3Vycl95KSB7XG4gICAgICAgICAgICAgICAgdmFyIGFuaW1fc3RlcHMgPSAxICogKE1hdGguYWJzKHBhcnNlSW50KCgodGFyZ2V0X3kgLSBjdXJyX3kpLyg1MCpSUykpLDEwKS9yYXRlKSArIDEpO1xuICAgICAgICAgICAgICAgIHZhciBkaWZmID0gKHRhcmdldF95IC0gY3Vycl95KSAvIGFuaW1fc3RlcHM7XG4gICAgICAgICAgICAgICAgaGFzaC55ID0gY3Vycl95IHx8IDA7XG4gICAgICAgICAgICAgICAgdmFyIG9yaWdfZnVuYyA9IGFuX2FycmF5LmFuaW1hdGU7XG4gICAgICAgICAgICAgICAgYW5fYXJyYXkuYW5pbWF0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBoYXNoLnkgPSBjdXJyX3kgKyBkaWZmKjE7XG5cbiAgICAgICAgICAgICAgICBsZXQgc3RlcF9mdW5jID0gZnVuY3Rpb24oc3RlcCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGlmZiA8IDAgJiYgKGhhc2gueSA8IHRhcmdldF95KSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc2gueSA9IHRhcmdldF95O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChkaWZmID4gMCAmJiAoaGFzaC55ID4gdGFyZ2V0X3kpICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFzaC55ID0gdGFyZ2V0X3k7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYXR0cihoYXNoKTtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlciArPSAoc3RlcCB8fCAxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhc2gueSAhPSB0YXJnZXRfeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFzaC55ID0gY3Vycl95ICsgZGlmZiooY291bnRlcisxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhbl9hcnJheS5hbmltYXRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldF9kaXNwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyKHsndmlzaWJpbGl0eScgOiB0YXJnZXRfZGlzcH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGFuaW1fY2xvY2tfZnVuY3Muc3BsaWNlKGFuaW1fY2xvY2tfZnVuY3MuaW5kZXhPZihzdGVwX2Z1bmMpLDEpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGFuaW1fY2xvY2tfZnVuY3MucHVzaChzdGVwX2Z1bmMpO1xuICAgICAgICAgICAgICAgIGFuaW1fY2xvY2tfZnVuY3NbYW5pbV9jbG9ja19mdW5jcy5sZW5ndGggLSAxXS50YXJnZXRfc2V0ID0gYW5fYXJyYXk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICBhbl9hcnJheS5hdHRyID0gZnVuY3Rpb24oaHNoKSB7XG4gICAgICAgICAgICBpZiAoaW5fYW5pbSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFuaW1hdGUoaHNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhdHRyKGhzaCk7XG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICB2YXIgYXR0ciA9IGZ1bmN0aW9uKGhzaCkge1xuICAgICAgICAgICAgdmFyIGhhc2ggPSB7fTtcbiAgICAgICAgICAgIHZhciBrZXk7XG4gICAgICAgICAgICBmb3IgKGtleSBpbiBoc2gpIHtcbiAgICAgICAgICAgICAgICBpZiAoaHNoLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFzaFtrZXldID0gaHNoW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgY3Vycl9kaXNwID0gYW5fYXJyYXkudmlzaWJpbGl0eSgpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgdGFyZ195ID0gcGFyc2VJbnQoaGFzaC55LDEwKTtcbiAgICAgICAgICAgIHRhcmdfZGlzcCA9IGhhc2gudmlzaWJpbGl0eTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZm9yIChrZXkgaW4gaGFzaCkge1xuICAgICAgICAgICAgICAgIGlmIChoYXNoLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbl9hcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCAhIGFuX2FycmF5W2ldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShhbl9hcnJheVtpXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggYW5fYXJyYXlbaV0uc3R5bGUuZGlzcGxheSA9PSAnbm9uZScgKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IGhhc2hba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrZXkgPT0gJ3N0eWxlJyAmJiBhbl9hcnJheVtpXS5oYXNBdHRyaWJ1dGUoJ3N0eWxlJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3Vycl9zdHlsZSA9IGFuX2FycmF5W2ldLmdldEF0dHJpYnV0ZSgnc3R5bGUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyX3N0eWxlICs9ICc7ICcraGFzaFtrZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gY3Vycl9zdHlsZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoYXNfdHJhbnNsYXRlID0gYW5fYXJyYXlbaV0uaGFzQXR0cmlidXRlKCd0cmFuc2Zvcm0nKSAmJiAoYW5fYXJyYXlbaV0uZ2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nKS5pbmRleE9mKCd0cmFuc2xhdGUnKSA+PSAwKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtleSA9PSAnaGVpZ2h0JyAmJiBhbl9hcnJheVtpXS5zZXRIZWlnaHQgKSB7IC8vaGFzQXR0cmlidXRlKCd0cmFuc2Zvcm0nKSAmJiAhIGFuX2FycmF5W2ldLm5vX3NjYWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5fYXJyYXlbaV0uc2V0SGVpZ2h0KGhhc2hba2V5XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgICghIChoYXNfdHJhbnNsYXRlICYmIChrZXkgPT0gJ3knIHx8IGtleSA9PSAneCcpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuX2FycmF5W2ldLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTsgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrZXkgPT0gJ3knICYmIGFuX2FycmF5W2ldLmhhc0F0dHJpYnV0ZSgnZCcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGN1cnJfcGF0aCA9IGFuX2FycmF5W2ldLmdldEF0dHJpYnV0ZSgnZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZSA9IC9NXFxzKihbXFxkXFwuXSspIChbXFxkXFwuXSspLztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyX3BhdGggPSBjdXJyX3BhdGgucmVwbGFjZShyZSwnJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzTmFOKHBhcnNlSW50KHZhbHVlLDEwKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgXCJFcnJvciBcIitrZXkrXCIgaXMgXCIraGFzaFtrZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbl9hcnJheVtpXS5zZXRBdHRyaWJ1dGUoJ2QnLCAnTTAgJytwYXJzZUludCh2YWx1ZSwxMCkrJyAnK2N1cnJfcGF0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5ID09ICd5JyAmJiBhbl9hcnJheVtpXS5oYXNBdHRyaWJ1dGUoJ2N5JykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbl9hcnJheVtpXS5zZXRBdHRyaWJ1dGUoJ2N5JywgaGFzaFtrZXldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtleSA9PSAneScgJiYgYW5fYXJyYXlbaV0uaGFzQXR0cmlidXRlKCd0cmFuc2Zvcm0nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJfdHJhbnNmb3JtID0gYW5fYXJyYXlbaV0uZ2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJfeCA9IC90cmFuc2xhdGVcXCgoLT9cXGQrXFwuP1xcZCopXFxzKiw/XFxzKigtP1xcZCtcXC4/XFxkKik/XFwpLy5leGVjKGFuX2FycmF5W2ldLmdldEF0dHJpYnV0ZSgndHJhbnNmb3JtJykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyX3ggPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJfeCA9IGN1cnJfeFsxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyX3RyYW5zZm9ybSA9IGN1cnJfdHJhbnNmb3JtLnJlcGxhY2UoL3RyYW5zbGF0ZVxcKCgtP1xcZCtcXC4/XFxkKilcXHMqLD9cXHMqKC0/XFxkK1xcLj9cXGQqKT9cXCkvLCd0cmFuc2xhdGUoJytjdXJyX3grJywnK3ZhbHVlKycpJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5fYXJyYXlbaV0uc2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nLGN1cnJfdHJhbnNmb3JtKTsgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrZXkgPT0gJ3gnICYmIGFuX2FycmF5W2ldLmhhc0F0dHJpYnV0ZSgndHJhbnNmb3JtJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyX3RyYW5zZm9ybSA9IGFuX2FycmF5W2ldLmdldEF0dHJpYnV0ZSgndHJhbnNmb3JtJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyX3kgPSAvdHJhbnNsYXRlXFwoKC0/XFxkK1xcLj9cXGQqKVxccyosP1xccyooLT9cXGQrXFwuP1xcZCopXFwpLy5leGVjKGFuX2FycmF5W2ldLmdldEF0dHJpYnV0ZSgndHJhbnNmb3JtJykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyX3kgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJfeSA9IGN1cnJfeVsyXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyX3RyYW5zZm9ybSA9IGN1cnJfdHJhbnNmb3JtLnJlcGxhY2UoL3RyYW5zbGF0ZVxcKCgtP1xcZCtcXC4/XFxkKilcXHMqLD9cXHMqKC0/XFxkK1xcLj9cXGQqKVxcKS8sJ3RyYW5zbGF0ZSgnK3ZhbHVlKycsJytjdXJyX3krJyknKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbl9hcnJheVtpXS5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsY3Vycl90cmFuc2Zvcm0pOyAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtleSA9PSAndGV4dC1hbmNob3InICYmIGFuX2FycmF5W2ldLmhhc0F0dHJpYnV0ZSgnc3R5bGUnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuX2FycmF5W2ldLnN0eWxlLnRleHRBbmNob3IgPSBoYXNoW2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBhbl9hcnJheS5oaWRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLmF0dHIoeyAndmlzaWJpbGl0eScgOiAnaGlkZGVuJ30pO1xuICAgICAgICB9O1xuICAgICAgICBhbl9hcnJheS5zaG93ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLmF0dHIoeyAndmlzaWJpbGl0eScgOiAndmlzaWJsZSd9KTtcbiAgICAgICAgfTtcblxuICAgICAgICBhbl9hcnJheS5yZWZyZXNoX3pvb20gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW5fYXJyYXkubGVuZ3RoOyBpKysgKSB7XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYW5fYXJyYXlbaV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChhbl9hcnJheVtpXS56b29tX2xldmVsICYmIGFuX2FycmF5W2ldLnpvb21fbGV2ZWwgPT0gJ3RleHQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhbl9hcnJheVtpXS5vd25lclNWR0VsZW1lbnQgJiYgYW5fYXJyYXlbaV0ub3duZXJTVkdFbGVtZW50Lnpvb20gPiAzLjUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuX2FycmF5W2ldLnNldEF0dHJpYnV0ZSgnZGlzcGxheScsICdpbmxpbmUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuX2FycmF5W2ldLnNldEF0dHJpYnV0ZSgnb3BhY2l0eScsIDEpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYW5fYXJyYXlbaV0uc2V0QXR0cmlidXRlKCdkaXNwbGF5JywgJ25vbmUnKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIH0gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAoYW5fYXJyYXlbaV0uem9vbV9sZXZlbCAmJiBhbl9hcnJheVtpXS56b29tX2xldmVsID09ICdzdW1tYXJ5Jykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYW5fYXJyYXlbaV0ub3duZXJTVkdFbGVtZW50ICYmIGFuX2FycmF5W2ldLm93bmVyU1ZHRWxlbWVudC56b29tIDw9IDMuNSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYW5fYXJyYXlbaV0uc2V0QXR0cmlidXRlKCdkaXNwbGF5JywgJ2lubGluZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYW5fYXJyYXlbaV0uc2V0QXR0cmlidXRlKCdvcGFjaXR5JywgMSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbl9hcnJheVtpXS5zZXRBdHRyaWJ1dGUoJ2Rpc3BsYXknLCAnbm9uZScpOyAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiBhbl9hcnJheTtcbiAgICB9XG5cbiAgICB2YXIgYW5pbV9jbG9ja19mdW5jcyA9IG51bGwsIGluX2FuaW0gPSBmYWxzZTtcbiAgICB2YXIgYW5pbV9jbG9jayA9IG51bGw7XG4gICAgdmFyIHJhdGUgPSA3NTtcbiAgICB2YXIgbmV3X3JhdGUgPSBudWxsO1xuICAgIFxuICAgIHZhciBzZXR1cF9hbmltX2Nsb2NrcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoYW5pbV9jbG9ja19mdW5jcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgYW5pbV9jbG9ja19mdW5jcyA9IFtdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYW5pbV9jbG9ja19mdW5jcy5mb3JFYWNoKGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICAgICAgICAgICAgICBmdW5jLl9sYXN0X3N0ZXAgPSBudWxsO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKGFuaW1fY2xvY2spO1xuICAgICAgICB9XG4gICAgICAgIGlmICggISBpbl9hbmltICkge1xuICAgICAgICAgICAgZXh0ZW5kZWRfZWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbihjYW52KSB7XG4gICAgICAgICAgICAgICAgYmVhbi5maXJlKGNhbnYsJ19hbmltX2JlZ2luJyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGluX2FuaW0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzdGFydCA9IG51bGw7XG4gICAgICAgIGFuaW1fY2xvY2sgPSBzZXRJbnRlcnZhbChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICggISBhbmltX2Nsb2NrX2Z1bmNzIHx8IGFuaW1fY2xvY2tfZnVuY3MubGVuZ3RoID09PSAwICkge1xuICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoYW5pbV9jbG9jayk7XG4gICAgICAgICAgICAgICAgYW5pbV9jbG9jayA9IG51bGw7XG4gICAgICAgICAgICAgICAgYW5pbV9jbG9ja19mdW5jcyA9IG51bGw7XG4gICAgICAgICAgICAgICAgaW5fYW5pbSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGV4dGVuZGVkX2VsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24oY2Fudikge1xuICAgICAgICAgICAgICAgICAgICBiZWFuLmZpcmUoY2FudiwnX2FuaW1fZW5kJyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXIgc3VzcGVuZGVkX2lkcyA9IFtdO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBleHRlbmRlZF9lbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGNhbnYpIHtcbiAgICAgICAgICAgICAgICBzdXNwZW5kZWRfaWRzLnB1c2goY2Fudi5zdXNwZW5kUmVkcmF3KDUwMDApKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIHRpYyA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIGlmICghIHN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgc3RhcnQgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IChhbmltX2Nsb2NrX2Z1bmNzIHx8IFtdKS5sZW5ndGg7IGkrKyApIHtcbiAgICAgICAgICAgICAgICB2YXIgZW5kID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcbiAgICAgICAgICAgICAgICB2YXIgc3RlcF9pZCA9IHBhcnNlSW50KChlbmQgLSBzdGFydCkvcmF0ZSwxMCk7XG4gICAgICAgICAgICAgICAgaWYgKCBuZXdfcmF0ZSA9PT0gbnVsbCAmJiAoc3RlcF9pZCAtIGFuaW1fY2xvY2tfZnVuY3NbaV0uX2xhc3Rfc3RlcCkgPiAyKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld19yYXRlID0gTWF0aC5yb3VuZCgxLjYqcmF0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGFuaW1fY2xvY2tfZnVuY3NbaV0uYXBwbHkobnVsbCxbc3RlcF9pZCAtIChhbmltX2Nsb2NrX2Z1bmNzW2ldLl9sYXN0X3N0ZXAgfHwgc3RlcF9pZCldKTtcbiAgICAgICAgICAgICAgICBpZiAoYW5pbV9jbG9ja19mdW5jcyAmJiBhbmltX2Nsb2NrX2Z1bmNzW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgIGFuaW1fY2xvY2tfZnVuY3NbaV0uX2xhc3Rfc3RlcCA9IHN0ZXBfaWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHRvYyA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG5cbiAgICAgICAgICAgIGV4dGVuZGVkX2VsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24oY2Fudikge1xuICAgICAgICAgICAgICAgIGNhbnYudW5zdXNwZW5kUmVkcmF3KHN1c3BlbmRlZF9pZHMuc2hpZnQoKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIGFjdHVhbF9zcGVlZCA9ICh0b2MgLSB0aWMpO1xuICAgICAgICAgICAgaWYgKCggYWN0dWFsX3NwZWVkIDwgcmF0ZSkgJiYgKG5ld19yYXRlID09PSBudWxsKSAmJiBhY3R1YWxfc3BlZWQgPj0gMSApIHtcbiAgICAgICAgICAgICAgICByYXRlID0gTWF0aC5yb3VuZCgxLjUqKHRvYyAtIHRpYykpO1xuICAgICAgICAgICAgICAgIHNldHVwX2FuaW1fY2xvY2tzKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG5ld19yYXRlICE9PSBudWxsICYmIG5ld19yYXRlICE9IHJhdGUpIHtcbiAgICAgICAgICAgICAgICByYXRlID0gbmV3X3JhdGU7XG4gICAgICAgICAgICAgICAgc2V0dXBfYW5pbV9jbG9ja3MoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgXG4gICAgICAgIH0scmF0ZSk7XG4gICAgfTtcbiAgICB2YXIgc2NhbGVfcmUgPSAvc2NhbGVcXCgoLT9cXGQrXFwuP1xcZCopXFwpLztcbiAgICB2YXIgc2V0SGVpZ2h0ID0gZnVuY3Rpb24oaGVpZ2h0KSB7XG4gICAgICAgIHZhciBjdXJyX3RyYW5zZm9ybSA9IHRoaXMuZ2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nKS50b1N0cmluZygpO1xuXG4gICAgICAgIHZhciBjdXJyX3NjYWxlID0gc2NhbGVfcmUuZXhlYyhjdXJyX3RyYW5zZm9ybSk7XG4gICAgXG4gICAgICAgIHZhciBjdXJyX2hlaWdodCA9IHBhcnNlRmxvYXQodGhpcy5nZXRBdHRyaWJ1dGUoJ2hlaWdodCcpIHx8IDEpO1xuXG4gICAgICAgIHZhciBuZXdfc2NhbGUgPSAxO1xuICAgICAgICBpZiAoY3Vycl9zY2FsZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgY3Vycl90cmFuc2Zvcm0gKz0gJyBzY2FsZSgxKSAnO1xuICAgICAgICAgICAgY3Vycl9zY2FsZSA9IDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdXJyX3NjYWxlID0gcGFyc2VGbG9hdChjdXJyX3NjYWxlWzFdKTtcbiAgICAgICAgfVxuICAgICAgICBuZXdfc2NhbGUgPSAoIHBhcnNlRmxvYXQoaGVpZ2h0KSAvIGN1cnJfaGVpZ2h0ICkgKiBjdXJyX3NjYWxlO1xuXG4gICAgICAgIGN1cnJfdHJhbnNmb3JtID0gY3Vycl90cmFuc2Zvcm0ucmVwbGFjZShzY2FsZV9yZSwnc2NhbGUoJytuZXdfc2NhbGUrJyknKTtcblxuICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJyxjdXJyX3RyYW5zZm9ybSk7XG4gICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdoZWlnaHQnLGhlaWdodCk7XG4gICAgICAgIHJldHVybiBuZXdfc2NhbGU7XG4gICAgfTtcblxuICAgIHJldHVybiAoZnVuY3Rpb24oY2FudmFzKSB7XG4gICAgICAgIFxuICAgICAgICB2YXIgUlMgPSBjYW52YXMuUlMgfHwgREVGQVVMVF9SUztcbiAgICAgICAgY2FudmFzLlJTID0gUlM7XG4gICAgICAgIGNhbnZhcy5mb250X29yZGVyID0gJ0hlbHZldGljYSwgVmVyZGFuYSwgQXJpYWwsIFNhbnMtc2VyaWYnXG4gICAgICAgIGV4dGVuZGVkX2VsZW1lbnRzLnB1c2goY2FudmFzKTtcbiAgICAgICAgXG4gICAgICAgIGNhbnZhcy5tYWtlRWwgPSBmdW5jdGlvbihuYW1lLGF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBjYW52YXMub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoc3ZnbnMsbmFtZSk7XG4gICAgICAgICAgICBmb3IgKHZhciBhdHRyaWJ1dGUgaW4gYXR0cmlidXRlcykge1xuICAgICAgICAgICAgICAgIGlmIChhdHRyaWJ1dGVzLmhhc093blByb3BlcnR5KGF0dHJpYnV0ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnNldEF0dHJpYnV0ZShhdHRyaWJ1dGUsIGF0dHJpYnV0ZXNbYXR0cmlidXRlXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcblxuICAgICAgICBjYW52YXMubWFrZV9ncmFkaWVudCA9IGZ1bmN0aW9uKGlkLHgyLHkyLHN0b3BzLG9wYWNpdGllcykge1xuICAgICAgICAgICAgdmFyIGdyYWRpZW50ID0gdGhpcy5tYWtlRWwoJ2xpbmVhckdyYWRpZW50Jyx7XG4gICAgICAgICAgICAgICAgJ2lkJzogaWQsXG4gICAgICAgICAgICAgICAgJ3gxJzonMCUnLFxuICAgICAgICAgICAgICAgICd4Mic6IHgyLFxuICAgICAgICAgICAgICAgICd5MSc6JzAlJyxcbiAgICAgICAgICAgICAgICAneTInOiB5MlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgdG90YWxfc3RvcHMgPSBzdG9wcy5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZShzdG9wcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN0b3BfaWQgPSBNYXRoLnJvdW5kKCAoKHRvdGFsX3N0b3BzIC0gc3RvcHMubGVuZ3RoKSAvIHRvdGFsX3N0b3BzKSAqIDEwMCApO1xuICAgICAgICAgICAgICAgIHZhciBzdG9wID0gc3RvcHMuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICB2YXIgb3BhY2l0eSA9IG9wYWNpdGllcy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIGdyYWRpZW50LmFwcGVuZENoaWxkKHRoaXMubWFrZUVsKCdzdG9wJyx7XG4gICAgICAgICAgICAgICAgICAgICdvZmZzZXQnOiBzdG9wX2lkKyclJyxcbiAgICAgICAgICAgICAgICAgICAgJ3N0eWxlJzonc3RvcC1jb2xvcjonK3N0b3ArJztzdG9wLW9wYWNpdHk6JytvcGFjaXR5XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGdyYWRpZW50O1xuICAgICAgICB9O1xuXG5cbiAgICAgICAgY2FudmFzLnBhdGggPSBmdW5jdGlvbihwYXRoZGVzYykge1xuICAgICAgICAgICAgdmFyIGFfcGF0aCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhzdmducywncGF0aCcpO1xuICAgICAgICAgICAgYV9wYXRoLnNldEF0dHJpYnV0ZSgnZCcsIHBhdGhkZXNjKTtcbiAgICAgICAgICAgIGFfcGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZScsJyMwMDAwMDAnKTtcbiAgICAgICAgICAgIGFfcGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS13aWR0aCcsJzEnKTtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQoYV9wYXRoKTtcbiAgICAgICAgICAgIHJldHVybiBhX3BhdGg7XG4gICAgICAgIH07XG5cbiAgICAgICAgY2FudmFzLnBvbHkgPSBmdW5jdGlvbihwb2ludHMpIHtcbiAgICAgICAgICAgIHZhciBhX3BvbHkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoc3ZnbnMsJ3BvbHlnb24nKTtcbiAgICAgICAgICAgIGFfcG9seS5zZXRBdHRyaWJ1dGUoJ3BvaW50cycscG9pbnRzKTtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQoYV9wb2x5KTtcbiAgICAgICAgICAgIHJldHVybiBhX3BvbHk7XG4gICAgICAgIH07XG5cbiAgICAgICAgY2FudmFzLmNpcmNsZSA9IGZ1bmN0aW9uKHgseSxyYWRpdXMpIHtcbiAgICAgICAgICAgIHZhciBhX2NpcmNsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhzdmducywnY2lyY2xlJyk7XG4gICAgICAgICAgICBhX2NpcmNsZS5zZXRBdHRyaWJ1dGUoJ2N4JywgdHlwZW9mIHggPT0gJ3N0cmluZycgPyB4IDogeCAqIFJTKTtcbiAgICAgICAgICAgIGFfY2lyY2xlLnNldEF0dHJpYnV0ZSgnY3knLCB0eXBlb2YgeSA9PSAnc3RyaW5nJyA/IHkgOiB5ICogUlMpO1xuICAgICAgICAgICAgYV9jaXJjbGUuc2V0QXR0cmlidXRlKCdyJywgdHlwZW9mIHJhZGl1cyA9PSAnc3RyaW5nJyA/IHJhZGl1cyA6IHJhZGl1cyAqIFJTKTtcbiAgICAgICAgICAgIGFfY2lyY2xlLm1vdmUgPSBmdW5jdGlvbihuZXdfeCkge1xuICAgICAgICAgICAgICAgIGFfY2lyY2xlLnNldEF0dHJpYnV0ZSgnY3gnLG5ld194KlJTKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLmFwcGVuZENoaWxkKGFfY2lyY2xlKTtcbiAgICAgICAgICAgIHJldHVybiBhX2NpcmNsZTtcbiAgICAgICAgfTtcblxuICAgICAgICBjYW52YXMuZ3JvdXAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBhX2cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoc3ZnbnMsJ2cnKTtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQoYV9nKTtcbiAgICAgICAgICAgIGFfZy5wdXNoID0gZnVuY3Rpb24obmV3X2VsKSB7XG4gICAgICAgICAgICAgICAgYV9nLmFwcGVuZENoaWxkKG5ld19lbCk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXR1cm4gYV9nO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNhbnZhcy5jbGlwUGF0aCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHN2Z25zLCdjbGlwUGF0aCcpO1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRDaGlsZChlbCk7XG4gICAgICAgICAgICBlbC5wdXNoID0gZnVuY3Rpb24obmV3X2VsKSB7XG4gICAgICAgICAgICAgICAgZWwuYXBwZW5kQ2hpbGQobmV3X2VsKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gZWw7XG4gICAgICAgIH07XG5cblxuICAgICAgICBjYW52YXMubGluZSA9IGZ1bmN0aW9uKHgseSx4Mix5Mikge1xuICAgICAgICAgICAgdmFyIGFfbGluZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhzdmducywnbGluZScpO1xuICAgICAgICAgICAgYV9saW5lLnNldEF0dHJpYnV0ZSgneDEnLCB0eXBlb2YgeCA9PSAnc3RyaW5nJyA/IHggOiB4ICogUlMpO1xuICAgICAgICAgICAgYV9saW5lLnNldEF0dHJpYnV0ZSgneTEnLCB0eXBlb2YgeSA9PSAnc3RyaW5nJyA/IHkgOiB5ICogUlMpO1xuICAgICAgICAgICAgYV9saW5lLnNldEF0dHJpYnV0ZSgneDInLCB0eXBlb2YgeDIgPT0gJ3N0cmluZycgPyB4MiA6IHgyICogUlMpO1xuICAgICAgICAgICAgYV9saW5lLnNldEF0dHJpYnV0ZSgneTInLCB0eXBlb2YgeTIgPT0gJ3N0cmluZycgPyB5MiA6IHkyICogUlMpO1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRDaGlsZChhX2xpbmUpO1xuICAgICAgICAgICAgcmV0dXJuIGFfbGluZTsgICAgICAgIFxuICAgICAgICB9O1xuXG4gICAgICAgIGNhbnZhcy5yZWN0ID0gZnVuY3Rpb24oeCx5LHdpZHRoLGhlaWdodCxvcHRzKSB7XG4gICAgICAgICAgICBpZiAoICEgb3B0cyApIHtcbiAgICAgICAgICAgICAgICBvcHRzID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgYV9yZWN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHN2Z25zLCdyZWN0Jyk7XG4gICAgICAgICAgICBhX3JlY3Quc2V0QXR0cmlidXRlKCd4JywgdHlwZW9mIHggPT0gJ3N0cmluZycgPyB4IDogeCAqIFJTKTtcbiAgICAgICAgICAgIGFfcmVjdC5zZXRBdHRyaWJ1dGUoJ3knLCB0eXBlb2YgeSA9PSAnc3RyaW5nJyA/IHkgOiB5ICogUlMpO1xuICAgICAgICAgICAgYV9yZWN0LnNldEF0dHJpYnV0ZSgnd2lkdGgnLCB0eXBlb2Ygd2lkdGggPT0gJ3N0cmluZycgPyB3aWR0aCA6IHdpZHRoICogUlMpO1xuICAgICAgICAgICAgYV9yZWN0LnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgdHlwZW9mIGhlaWdodCA9PSAnc3RyaW5nJyA/IGhlaWdodCA6IGhlaWdodCAqIFJTKTtcbiAgICAgICAgICAgIGFfcmVjdC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZScsJyMwMDAwMDAnKTtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQoYV9yZWN0KTtcbiAgICAgICAgICAgIGlmICggdHlwZW9mKG9wdHMub2Zmc2V0KSAhPT0gXCJ1bmRlZmluZWRcIiApIHtcbiAgICAgICAgICAgICAgICBhX3JlY3Qub2Zmc2V0ID0gb3B0cy5vZmZzZXQ7XG4gICAgICAgICAgICAgICAgYV9yZWN0LnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJywndHJhbnNsYXRlKCcrYV9yZWN0LmdldEF0dHJpYnV0ZSgneCcpKycsJythX3JlY3QuZ2V0QXR0cmlidXRlKCd5JykrJyknKTtcbiAgICAgICAgICAgICAgICBhX3JlY3Quc2V0QXR0cmlidXRlKCd4JywnMCcpO1xuICAgICAgICAgICAgICAgIGFfcmVjdC5zZXRBdHRyaWJ1dGUoJ3knLGFfcmVjdC5vZmZzZXQqUlMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhX3JlY3QubW92ZSA9IGZ1bmN0aW9uKG5ld194LG5ld193aWR0aCkge1xuICAgICAgICAgICAgICAgIGlmICgodHlwZW9mKHRoaXMub2Zmc2V0KSAhPT0gXCJ1bmRlZmluZWRcIikgJiYgdGhpcy5nZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0cmFuc2Zvcm1fYXR0ciA9IHRoaXMuZ2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1hdGNoZXMgPSAvdHJhbnNsYXRlXFwoLipbLFxcc10oLiopXFwpLy5leGVjKHRyYW5zZm9ybV9hdHRyKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoZXNbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJywndHJhbnNsYXRlKCcrKG5ld194KlJTKSsnLCcrbWF0Y2hlc1sxXSsnKScpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCd3aWR0aCcsbmV3X3dpZHRoKlJTKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgneCcsbmV3X3gqUlMpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnd2lkdGgnLG5ld193aWR0aCpSUyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBhX3JlY3Q7XG4gICAgICAgIH07XG5cbiAgICAgICAgY2FudmFzLnJvdW5kUmVjdCA9IGZ1bmN0aW9uKHgseSx3aWR0aCxoZWlnaHQscixvcHRzKSB7XG4gICAgICAgICAgICB2YXIgYV9yZWN0ID0gdGhpcy5yZWN0KHgseSx3aWR0aCxoZWlnaHQsb3B0cyk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHIgIT0gJ29iamVjdCcgfHwgISByLnggKSB7XG4gICAgICAgICAgICAgICAgciA9IHsgJ3gnIDogciwgJ3knIDogciB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYV9yZWN0LnNldEF0dHJpYnV0ZSgncngnLHIueCpSUyk7XG4gICAgICAgICAgICBhX3JlY3Quc2V0QXR0cmlidXRlKCdyeScsci55KlJTKTtcbiAgICAgICAgICAgIHJldHVybiBhX3JlY3Q7XG4gICAgICAgIH07XG5cbiAgICAgICAgY2FudmFzLmVsbGlwdGljYWxSZWN0ID0gZnVuY3Rpb24oeCx5LHdpZHRoLGhlaWdodCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucm91bmRSZWN0KHgseSx3aWR0aCxoZWlnaHQseyd4JyA6IDAuMjUqd2lkdGgsICd5JyA6IDAuNSpoZWlnaHR9KTtcbiAgICAgICAgfTtcbiAgICAgICAgY2FudmFzLnBlbnRhZ29uID0gZnVuY3Rpb24oeCx5LHdpZHRoLGhlaWdodCxyb3RhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5hZ29uKHgseSx3aWR0aCxoZWlnaHQsNSxyb3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGNhbnZhcy5oZXhhZ29uID0gZnVuY3Rpb24oeCx5LHdpZHRoLGhlaWdodCxyb3RhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5hZ29uKHgseSx3aWR0aCxoZWlnaHQsNixyb3RhdGUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBzaGFwZV9zZXRfYXR0cmlidXRlID0gZnVuY3Rpb24oYXR0cix2YWwpIHtcbiAgICAgICAgICAgIHRoaXMuY29uc3RydWN0b3IucHJvdG90eXBlLnNldEF0dHJpYnV0ZS5jYWxsKHRoaXMsYXR0cix2YWwpO1xuICAgICAgICAgICAgaWYgKGF0dHIgPT0gJ2hlaWdodCcgfHwgYXR0ciA9PSAnd2lkdGgnIHx8IGF0dHIgPT0gJ3gnIHx8IGF0dHIgPT0gJ3knKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWRyYXcoTWF0aC5mbG9vcihwYXJzZUZsb2F0KHRoaXMuZ2V0QXR0cmlidXRlKCdoZWlnaHQnKSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBjYW52YXMubmFnb24gPSBmdW5jdGlvbih4LHksd2lkdGgsaGVpZ2h0LG4scm90YXRlKSB7XG4gICAgICAgICAgICB2YXIgc2hhcGUgPSB0aGlzLnBvbHkoXCJcIik7XG4gICAgICAgICAgICAvLyBzaGFwZS5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsJ3RyYW5zbGF0ZSgnKyh4KlJTKSsnLCcrKFJTKnkpKycpJyk7XG4gICAgICAgICAgICBzaGFwZS5zZXRBdHRyaWJ1dGUoJ3gnLHgqUlMpO1xuICAgICAgICAgICAgc2hhcGUuc2V0QXR0cmlidXRlKCd5Jyx5KlJTKTtcbiAgICAgICAgICAgIHNoYXBlLnNldEF0dHJpYnV0ZSgnd2lkdGgnLHdpZHRoKlJTKTtcbiAgICAgICAgICAgIHNoYXBlLnJlZHJhdyA9IGZ1bmN0aW9uKGhnaHQpIHtcbiAgICAgICAgICAgICAgICBpZiAoaGdodCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxhc3RfaGVpZ2h0ID0gaGdodDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBoZ2h0ID0gdGhpcy5sYXN0X2hlaWdodDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIGEgPSAwLjUqTWF0aC5mbG9vcihwYXJzZUZsb2F0KHNoYXBlLmdldEF0dHJpYnV0ZSgnd2lkdGgnKSkpO1xuICAgICAgICAgICAgICAgIHZhciBiID0gMC41KmhnaHQ7XG4gICAgICAgICAgICAgICAgdmFyIHBvaW50cyA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciBtaW5feCA9IG51bGw7XG4gICAgICAgICAgICAgICAgdmFyIG1heF94ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMCA7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFuZ2xlID0gKHJvdGF0ZS8zNjAgKiAyKk1hdGguUEkpICsgMi9uKk1hdGguUEkqaTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFfeCA9IHBhcnNlSW50KGErYSpNYXRoLmNvcyhhbmdsZSkpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYV95ID0gcGFyc2VJbnQoYitiKk1hdGguc2luKGFuZ2xlKSk7XG4gICAgICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKCBbYV94LCBhX3ldICk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtaW5feCA9PT0gbnVsbCB8fCBhX3ggPCBtaW5feCApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbl94ID0gYV94O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXhfeCA9PT0gbnVsbCB8fCBhX3ggPiBtYXhfeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF4X3ggPSBhX3g7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFyIHhfcG9zID0gTWF0aC5mbG9vcihwYXJzZUZsb2F0KHNoYXBlLmdldEF0dHJpYnV0ZSgneCcpKSk7XG4gICAgICAgICAgICAgICAgdmFyIHlfcG9zID0gTWF0aC5mbG9vcihwYXJzZUZsb2F0KHNoYXBlLmdldEF0dHJpYnV0ZSgneScpKSk7XG4gICAgICAgICAgICAgICAgcG9pbnRzLm1hcChmdW5jdGlvbihwb2ludHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBvaW50c1swXSA9PSBtaW5feCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRzWzBdID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocG9pbnRzWzBdID09IG1heF94KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludHNbMF0gPSBhKjI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzWzBdICs9IHhfcG9zO1xuICAgICAgICAgICAgICAgICAgICBwb2ludHNbMV0gPSB5X3BvcyArIDAuNSpoZ2h0Kihwb2ludHNbMV0gLyBiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBvaW50cy5qb2luKFwiLFwiKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgncG9pbnRzJyxwb2ludHMuam9pbihcIiBcIikpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHNoYXBlLnNldEhlaWdodCA9IHNoYXBlLnJlZHJhdztcbiAgICAgICAgICAgIHNoYXBlLm1vdmUgPSBmdW5jdGlvbihuZXdfeCxuZXdfd2lkdGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgY3Vycl95ID0gL3RyYW5zbGF0ZVxcKCgtP1xcZCtcXC4/XFxkKilcXHMqLD9cXHMqKC0/XFxkK1xcLj9cXGQqKVxcKS8uZXhlYyh0aGlzLmdldEF0dHJpYnV0ZSgndHJhbnNmb3JtJykpO1xuICAgICAgICAgICAgICAgIGlmIChjdXJyX3kgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXJyX3kgPSBjdXJyX3lbMl07XG4gICAgICAgICAgICAgICAgdmFyIGN1cnJfdHJhbnNmb3JtID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScpLnJlcGxhY2UoL3RyYW5zbGF0ZVxcKCgtP1xcZCtcXC4/XFxkKilcXHMqLD9cXHMqKC0/XFxkK1xcLj9cXGQqKVxcKS8sJ3RyYW5zbGF0ZSgnKyhuZXdfeCpSUykrJywnK2N1cnJfeSsnKScpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nLGN1cnJfdHJhbnNmb3JtKTtcbiAgICAgICAgICAgICAgICBhID0gMC41Km5ld193aWR0aCpSUztcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBzaGFwZS5zZXRBdHRyaWJ1dGUgPSBzaGFwZV9zZXRfYXR0cmlidXRlO1xuICAgICAgICAgICAgc2hhcGUucmVkcmF3KGhlaWdodCpSUyk7XG4gICAgICAgICAgICByZXR1cm4gc2hhcGU7XG4gICAgICAgIH07XG5cbiAgICAgICAgY2FudmFzLnVzZSA9IGZ1bmN0aW9uKHJlZix4LHksd2lkdGgsaGVpZ2h0KSB7XG4gICAgICAgICAgICB2YXIgYV91c2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoc3ZnbnMsJ3VzZScpO1xuICAgICAgICAgICAgYV91c2Uuc2V0QXR0cmlidXRlKCd4JywgdHlwZW9mIHggPT0gJ3N0cmluZycgPyB4IDogeCAqIFJTKTtcbiAgICAgICAgICAgIGFfdXNlLnNldEF0dHJpYnV0ZSgneScsIHR5cGVvZiB5ID09ICdzdHJpbmcnID8geSA6IHkgKiBSUyk7XG4gICAgICAgICAgICBhX3VzZS5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgdHlwZW9mIHdpZHRoID09ICdzdHJpbmcnID8gd2lkdGggOiB3aWR0aCAqIFJTKTtcbiAgICAgICAgICAgIGFfdXNlLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgdHlwZW9mIGhlaWdodCA9PSAnc3RyaW5nJyA/IGhlaWdodCA6IGhlaWdodCAqIFJTKTtcbiAgICAgICAgICAgIGFfdXNlLnNldEF0dHJpYnV0ZU5TKCdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJywnaHJlZicscmVmKTtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQoYV91c2UpO1xuXG4gICAgICAgICAgICByZXR1cm4gYV91c2U7ICAgICAgICBcbiAgICAgICAgfTtcblxuICAgICAgICBjYW52YXMuYSA9IGZ1bmN0aW9uKGhyZWYpIHtcbiAgICAgICAgICAgIHZhciBhX2FuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhzdmducywnYScpO1xuICAgICAgICAgICAgYV9hbmNob3Iuc2V0QXR0cmlidXRlKCd0YXJnZXQnLCdfbmV3Jyk7ICAgICAgICBcbiAgICAgICAgICAgIGFfYW5jaG9yLnNldEF0dHJpYnV0ZU5TKCdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJywnaHJlZicsaHJlZik7XG4gICAgICAgICAgICB0aGlzLmFwcGVuZENoaWxkKGFfYW5jaG9yKTtcbiAgICAgICAgICAgIHJldHVybiBhX2FuY2hvcjtcbiAgICAgICAgfTtcblxuICAgICAgICBjYW52YXMuYnV0dG9uID0gZnVuY3Rpb24oeCx5LHdpZHRoLGhlaWdodCx0ZXh0KSB7XG4gICAgICAgICAgICB2YXIgZm8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoc3ZnbnMsJ2ZvcmVpZ25PYmplY3QnKTtcbiAgICAgICAgICAgIGZvLnNldEF0dHJpYnV0ZSgneCcseCk7XG4gICAgICAgICAgICBmby5zZXRBdHRyaWJ1dGUoJ3knLHkpO1xuICAgICAgICAgICAgZm8uc2V0QXR0cmlidXRlKCd3aWR0aCcseCt3aWR0aCk7XG4gICAgICAgICAgICBmby5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcseStoZWlnaHQpO1xuICAgICAgICAgICAgaWYgKCAhIGZvLnN0eWxlICkge1xuICAgICAgICAgICAgICAgIGZvLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCdwb3NpdGlvbjogYWJzb2x1dGU7Jyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYXBwZW5kQ2hpbGQoZm8pO1xuICAgICAgICAgICAgdmFyIGJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICAgICAgICAgICAgYnV0dG9uLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICAgICAgYnV0dG9uLnRleHRDb250ZW50ID0gdGV4dDtcbiAgICAgICAgICAgIGZvLmFwcGVuZENoaWxkKGJ1dHRvbik7XG4gICAgICAgICAgICByZXR1cm4gYnV0dG9uO1xuICAgICAgICB9O1xuXG4gICAgICAgIGNhbnZhcy5zdmdidXR0b24gPSBmdW5jdGlvbih4LHksd2lkdGgsaGVpZ2h0LHR4dCkge1xuICAgICAgICAgICAgdmFyIGJ1dHRvbiA9IHRoaXMuZ3JvdXAoKTtcbiAgICAgICAgICAgIHZhciBiYWNrID0gdGhpcy5yZWN0KHgseSx3aWR0aCxoZWlnaHQpO1xuICAgICAgICAgICAgYmFjay5zZXRBdHRyaWJ1dGUoJ3J4JywnMTAnKTtcbiAgICAgICAgICAgIGJhY2suc2V0QXR0cmlidXRlKCdyeScsJzEwJyk7XG4gICAgICAgICAgICBiYWNrLnNldEF0dHJpYnV0ZSgnc3Ryb2tlJywnI2ZmZmZmZicpO1xuICAgICAgICAgICAgYmFjay5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS13aWR0aCcsJzInKTtcbiAgICAgICAgICAgIGJhY2suc2V0QXR0cmlidXRlKCdmaWxsJywndXJsKCNzaW1wbGVfZ3JhZGllbnQpJyk7XG4gICAgICAgICAgICB4ID0gYmFjay54LmJhc2VWYWwudmFsdWU7XG4gICAgICAgICAgICB5ID0gYmFjay55LmJhc2VWYWwudmFsdWU7XG4gICAgICAgICAgICB3aWR0aCA9IGJhY2sud2lkdGguYmFzZVZhbC52YWx1ZTtcbiAgICAgICAgICAgIGhlaWdodCA9IGJhY2suaGVpZ2h0LmJhc2VWYWwudmFsdWU7XG5cbiAgICAgICAgICAgIHZhciB0ZXh0ID0gdGhpcy50ZXh0KHgrd2lkdGgvMix5KyhoZWlnaHQvMyksdHh0KTsgICAgICAgIFxuICAgICAgICAgICAgdGV4dC5zZXRBdHRyaWJ1dGUoJ3RleHQtYW5jaG9yJywgJ21pZGRsZScpO1xuICAgICAgICAgICAgdGV4dC5maXJzdENoaWxkLnNldEF0dHJpYnV0ZSgnZHknLCAnMS41ZXgnKTtcbiAgICAgICAgICAgIHRleHQuc2V0QXR0cmlidXRlKCdmb250LXNpemUnLDAuNSpoZWlnaHQpO1xuICAgICAgICAgICAgdGV4dC5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLCcjZmZmZmZmJyk7XG4gICAgICAgICAgICBidXR0b24ucHVzaChiYWNrKTtcbiAgICAgICAgICAgIGJ1dHRvbi5wdXNoKHRleHQpO1xuICAgICAgICAgICAgYnV0dG9uLmJhY2tncm91bmRfZWxlbWVudCA9IGJhY2s7XG4gICAgICAgICAgICBidXR0b24udGV4dF9lbGVtZW50ID0gdGV4dDtcblxuICAgICAgICAgICAgYnV0dG9uLnNldEF0dHJpYnV0ZSgnY3Vyc29yJywncG9pbnRlcicpO1xuICAgICAgICAgICAgdmFyIGJ1dHRvbl90cmlnZ2VyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgYmFjay5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLCcjOTk5OTk5Jyk7XG4gICAgICAgICAgICAgICAgYmFjay5zZXRBdHRyaWJ1dGUoJ3N0cm9rZScsJyMwMDAwMDAnKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJyxidXR0b25fdHJpZ2dlcixmYWxzZSk7XG4gICAgICAgICAgICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsYnV0dG9uX3RyaWdnZXIsZmFsc2UpO1xuICAgICAgICAgICAgdmFyIGJ1dHRvbl9yZXNldCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGJhY2suc2V0QXR0cmlidXRlKCdzdHJva2UnLCcjZmZmZmZmJyk7XG4gICAgICAgICAgICAgICAgYmFjay5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLCd1cmwoI3NpbXBsZV9ncmFkaWVudCknKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsYnV0dG9uX3Jlc2V0LGZhbHNlKTtcbiAgICAgICAgICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW91dCcsYnV0dG9uX3Jlc2V0LGZhbHNlKTtcbiAgICAgICAgICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsYnV0dG9uX3Jlc2V0LGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybiBidXR0b247XG4gICAgICAgIH07XG5cbiAgICAgICAgY2FudmFzLmNhbGxvdXQgPSBmdW5jdGlvbih4LHksY29udGVudCxvcHRzKSB7XG4gICAgICAgICAgICB2YXIgY2FsbG91dCA9IHRoaXMuZ3JvdXAoKTtcbiAgICAgICAgICAgIHZhciBiYWNrID0gdGhpcy5yb3VuZFJlY3QoLTAuNSoob3B0cy53aWR0aCs0KSwyMCxvcHRzLndpZHRoKzQsb3B0cy5oZWlnaHQrNCw0KTtcbiAgICAgICAgICAgIGJhY2suc2V0QXR0cmlidXRlKCdmaWxsJywnIzAwMDAwMCcpO1xuICAgICAgICAgICAgdmFyIHByZXNfYm94ID0gdGhpcy5yb3VuZFJlY3QoLTAuNSoob3B0cy53aWR0aCsxKSwyMixvcHRzLndpZHRoKzEsb3B0cy5oZWlnaHQsNCk7XG4gICAgICAgICAgICBwcmVzX2JveC5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLCcjZWVlZWVlJyk7XG4gICAgICAgICAgICBjYWxsb3V0LnB1c2goYmFjayk7XG4gICAgICAgICAgICBjYWxsb3V0LnB1c2gocHJlc19ib3gpO1xuICAgICAgICAgICAgdmFyIHBvbHkgPSB0aGlzLnBvbHkoJzAsNTAwIDUwMCwxMDAwIC01MDAsMTAwMCcpO1xuICAgICAgICAgICAgcG9seS5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLCcjMDAwMDAwJyk7XG4gICAgICAgICAgICBjYWxsb3V0LnB1c2gocG9seSk7XG4gICAgICAgICAgICB2YXIgZm8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoc3ZnbnMsJ2ZvcmVpZ25PYmplY3QnKTtcbiAgICAgICAgICAgIGZvLnNldEF0dHJpYnV0ZSgneCcsLTAuNSoob3B0cy53aWR0aCsxKSpSUyk7XG4gICAgICAgICAgICBmby5zZXRBdHRyaWJ1dGUoJ3knLDIyKlJTKTtcbiAgICAgICAgICAgIGZvLnNldEF0dHJpYnV0ZSgnd2lkdGgnLG9wdHMud2lkdGgqUlMpO1xuICAgICAgICAgICAgZm8uc2V0QXR0cmlidXRlKCdoZWlnaHQnLG9wdHMuaGVpZ2h0KlJTKTtcbiAgICAgICAgICAgIGNhbGxvdXQucHVzaChmbyk7XG4gICAgICAgICAgICB2YXIgaHRtbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbCcsJ2h0bWwnKTtcbiAgICAgICAgICAgIGh0bWwuc2V0QXR0cmlidXRlKCd4bWxucycsJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwnKTtcbiAgICAgICAgICAgIHZhciBib2R5ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJywnYm9keScpO1xuICAgICAgICAgICAgYm9keS5zdHlsZS5mb250U2l6ZSA9ICgob3B0c1snZm9udC1zaXplJ10gfHwgMTUpKlJTKSArJ3B4JztcbiAgICAgICAgICAgIGJvZHkuc3R5bGUubWFyZ2luID0gKDUqUlMpKydweCc7XG4gICAgICAgICAgICBib2R5LnN0eWxlLmhlaWdodCA9IG9wdHMuaGVpZ2h0KlJTKjEwKydweCc7XG4gICAgICAgICAgICBodG1sLmFwcGVuZENoaWxkKGJvZHkpO1xuICAgICAgICAgICAgYm9keS5hcHBlbmRDaGlsZChjb250ZW50KTtcbiAgICAgICAgICAgIGZvLmFwcGVuZENoaWxkKGh0bWwpO1xuICAgICAgICAgICAgdmFyIHNjYWxlID0gb3B0cy5oZWlnaHQvMTU7XG4gICAgICAgICAgICBjYWxsb3V0LnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJywndHJhbnNsYXRlKCcrKHgqUlMpKycsJysoKHkrMjApKlJTKSsnKSBzY2FsZSgnK3NjYWxlKycpJyk7XG4gICAgICAgICAgICBjYWxsb3V0LnNldEhlaWdodCA9IHNldEhlaWdodDtcbiAgICAgICAgICAgIGlmICggISBvcHRzLmFsaWduICkge1xuICAgICAgICAgICAgICAgIHZhciBjdXJyVmJveCA9IHBhcnNlRmxvYXQodGhpcy5nZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnKS5zcGxpdCgvXFxzKy8pWzJdKTtcbiAgICAgICAgICAgICAgICBpZiAoKCh4ICsgMTApICsgMC41Km9wdHMud2lkdGgpKlJTID4gY3VyclZib3ggKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdHMuYWxpZ24gPSAncmlnaHQnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoKHggLSAwLjUqb3B0cy53aWR0aCkqUlMgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdHMuYWxpZ24gPSAnbGVmdCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdHMuYWxpZ24pIHtcbiAgICAgICAgICAgICAgICB2YXIgc2hpZnRlciA9IG9wdHMuYWxpZ24gPT0gXCJyaWdodFwiID8gLTAuNSA6IDAuNTtcbiAgICAgICAgICAgICAgICBiYWNrLnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnKyhzaGlmdGVyKm9wdHMud2lkdGgqUlMpKycsMCknKTtcbiAgICAgICAgICAgICAgICBwcmVzX2JveC5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJysoc2hpZnRlcipvcHRzLndpZHRoKlJTKSsnLDApJyk7XG4gICAgICAgICAgICAgICAgcG9seS5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJysoMCpzaGlmdGVyKm9wdHMud2lkdGgqUlMpKycsMCknKTtcbiAgICAgICAgICAgICAgICBwb2x5LnNldEF0dHJpYnV0ZSgncG9pbnRzJywgc2hpZnRlciA+IDAgPyBcIjAsNTAwIDUwMCwxMDAwIDAsMTAwMFwiIDogXCIwLDUwMCAwLDEwMDAgLTUwMCwxMDAwXCIpO1xuICAgICAgICAgICAgICAgIGZvLnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnKyhzaGlmdGVyKm9wdHMud2lkdGgqUlMpKycsMCknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbGxvdXQuc2V0QXR0cmlidXRlKCdoZWlnaHQnLChvcHRzLmhlaWdodCkqUlMpO1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxvdXQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgY2FudmFzLmdyb3dpbmdNYXJrZXIgPSBmdW5jdGlvbih4LHksc3ltYm9sLG9wdHMpIHtcbiAgICAgICAgICAgIHZhciBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoc3ZnbnMsJ3N2ZycpO1xuICAgICAgICAgICAgaWYgKCAhIG9wdHMuc3RyZXRjaCAmJiAhIChBcnJheS5pc0FycmF5ICYmIEFycmF5LmlzQXJyYXkob3B0cy5jb250ZW50KSkgKSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLnNldEF0dHJpYnV0ZSgndmlld0JveCcsICctNTAgLTEwMCAyMDAgMjUwJyk7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLnNldEF0dHJpYnV0ZSgncHJlc2VydmVBc3BlY3RSYXRpbycsICd4TWluWU1pbiBtZWV0Jyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lciA9IHRoaXMuZ3JvdXAoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ3gnLHgpO1xuICAgICAgICAgICAgY29udGFpbmVyLnNldEF0dHJpYnV0ZSgneScseSk7XG4gICAgICAgICAgICB2YXIgdGhlX21hcmtlciA9IHRoaXMubWFya2VyKDUwL1JTLCg1MCkvUlMsNTAvUlMsc3ltYm9sLG9wdHMpO1xuICAgICAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKHRoZV9tYXJrZXIpO1xuICAgICAgICAgICAgY29udGFpbmVyLmNvbnRlbnRFbGVtZW50ID0gdGhlX21hcmtlci5jb250ZW50RWxlbWVudDtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0aGlzLmdyb3VwKCk7XG4gICAgICAgICAgICB2YXIgcG9zaXRpb25pbmdfZ3JvdXAgPSB0aGlzLmdyb3VwKCk7XG4gICAgICAgICAgICByZXN1bHQuYXBwZW5kQ2hpbGQocG9zaXRpb25pbmdfZ3JvdXApO1xuICAgICAgICAgICAgcG9zaXRpb25pbmdfZ3JvdXAuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcbiAgICAgICAgICAgIGlmICggISBvcHRzLnN0cmV0Y2ggJiYgISAoQXJyYXkuaXNBcnJheSAmJiBBcnJheS5pc0FycmF5KG9wdHMuY29udGVudCkpICkge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywnMjAwJyk7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywnMjUwJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob3B0cy5hbmdsZSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5hbmdsZSA9IG9wdHMuYW5nbGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB2YXIgcmVjdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhzdmducywncmVjdCcpO1xuICAgICAgICAgICAgLy8gcmVjdC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZScsJyNmMDAnKTtcbiAgICAgICAgICAgIC8vIHJlY3Quc2V0QXR0cmlidXRlKCdzdHJva2Utd2lkdGgnLCcxMCcpO1xuICAgICAgICAgICAgLy8gcmVjdC5zZXRBdHRyaWJ1dGUoJ3gnLCctNTAnKTtcbiAgICAgICAgICAgIC8vIHJlY3Quc2V0QXR0cmlidXRlKCd5JywnLTEwMCcpO1xuICAgICAgICAgICAgLy8gcmVjdC5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywnMTAwJScpO1xuICAgICAgICAgICAgLy8gcmVjdC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsJzEwMCUnKTtcbiAgICAgICAgICAgIC8vIHJlY3Quc2V0QXR0cmlidXRlKCdmaWxsJywnbm9uZScpO1xuICAgICAgICAgICAgLy8gY29udGFpbmVyLmFwcGVuZENoaWxkKHJlY3QpO1xuXG4gICAgICAgICAgICAvLyB2YXIgcmVjdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhzdmducywncmVjdCcpO1xuICAgICAgICAgICAgLy8gcmVjdC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZScsJyMwZjAnKTtcbiAgICAgICAgICAgIC8vIHJlY3Quc2V0QXR0cmlidXRlKCdzdHJva2Utd2lkdGgnLCcxMCcpO1xuICAgICAgICAgICAgLy8gcmVjdC5zZXRBdHRyaWJ1dGUoJ3gnLCc1MCcpO1xuICAgICAgICAgICAgLy8gcmVjdC5zZXRBdHRyaWJ1dGUoJ3knLCcyNScpO1xuICAgICAgICAgICAgLy8gcmVjdC5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywnNTAlJyk7XG4gICAgICAgICAgICAvLyByZWN0LnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywnNTAlJyk7XG4gICAgICAgICAgICAvLyByZWN0LnNldEF0dHJpYnV0ZSgnZmlsbCcsJ25vbmUnKTtcblxuICAgICAgICAgICAgLy8gY29udGFpbmVyLmFwcGVuZENoaWxkKHJlY3QpO1xuXG4gICAgICAgICAgICByZXN1bHQuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCcyNTAnKTtcbiAgICAgICAgICAgIHJlc3VsdC5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsJ3NjYWxlKDEpJyk7XG4gICAgICAgICAgICByZXN1bHQuc2V0SGVpZ2h0ID0gZnVuY3Rpb24oaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgLy8gdGhpcy5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICB2YXIgc2NhbGVfdmFsID0gc2V0SGVpZ2h0LmNhbGwodGhpcyxoZWlnaHQpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdoZWlnaHQnLGhlaWdodCk7XG4gICAgICAgICAgICAgICAgdmFyIHRvcF9vZmZzZXQgPSB0aGlzLm9mZnNldCB8fCAwO1xuICAgICAgICAgICAgICAgIGlmICggISB0aGlzLmFuZ2xlICkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFuZ2xlID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5maXJzdENoaWxkLnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJywndHJhbnNsYXRlKC0xMDAsJysodG9wX29mZnNldCpSUykrJykgcm90YXRlKCcrdGhpcy5hbmdsZSsnLDEwMCwwKScpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlc3VsdC5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuXG4gICAgICAgIGNhbnZhcy5tYXJrZXIgPSBmdW5jdGlvbihjeCxjeSxyLHN5bWJvbCxvcHRzKSB7XG4gICAgICAgICAgICB2YXIgdW5pdHMgPSAwO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjeCA9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHZhciBwYXJ0cyA9IG5ldyBSZWdFeHAoLyhcXGQrKSguKikvZykuZXhlYyhjeCk7XG4gICAgICAgICAgICAgICAgdW5pdHMgPSBwYXJ0c1syXTtcbiAgICAgICAgICAgICAgICBjeCA9IHBhcnNlRmxvYXQocGFydHNbMV0pO1xuXG4gICAgICAgICAgICAgICAgcGFydHMgPSBuZXcgUmVnRXhwKC8oXFxkKykoLiopL2cpLmV4ZWMoY3kpO1xuICAgICAgICAgICAgICAgIGN5ID0gcGFyc2VGbG9hdChwYXJ0c1sxXSk7XG5cbiAgICAgICAgICAgICAgICBwYXJ0cyA9IG5ldyBSZWdFeHAoLyhcXGQrKSguKikvZykuZXhlYyhyKTtcbiAgICAgICAgICAgICAgICByID0gcGFyc2VGbG9hdChwYXJ0c1sxXSk7ICAgICAgICBcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZGltID0ge1xuICAgICAgICAgICAgICAgIENYICAgICAgOiBjeCt1bml0cyxcbiAgICAgICAgICAgICAgICBDWSAgICAgIDogY3krdW5pdHMsXG4gICAgICAgICAgICAgICAgUiAgICAgICA6IHIrdW5pdHMsXG4gICAgICAgICAgICAgICAgTUlOX1ggICA6IChjeC1yKSt1bml0cyxcbiAgICAgICAgICAgICAgICBNQVhfWCAgIDogKGN4K3IpK3VuaXRzLFxuICAgICAgICAgICAgICAgIE1JTl9ZICAgOiAoY3ktcikrdW5pdHMsXG4gICAgICAgICAgICAgICAgTUFYX1kgICA6IChjeStyKSt1bml0cyxcbiAgICAgICAgICAgICAgICBNSURfWDEgIDogKGN4LShyLzIpKSt1bml0cyxcbiAgICAgICAgICAgICAgICBNSURfWDIgIDogKGN4KyhyLzIpKSt1bml0cyxcbiAgICAgICAgICAgICAgICBNSURfWTEgIDogKGN5LShyLzIpKSt1bml0cyxcbiAgICAgICAgICAgICAgICBNSURfWTIgIDogKGN5KyhyLzIpKSt1bml0c1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdmFyIG1hcmtlciA9IHRoaXMuZ3JvdXAoKTtcbiAgICAgICAgICAgIGlmICghIG9wdHMgKSB7XG4gICAgICAgICAgICAgICAgb3B0cyA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGZpbGxfY29sb3IgPSAob3B0cyAmJiBvcHRzLmJvcmRlcikgPyBvcHRzLmJvcmRlciA6ICdyZ2IoMCwwLDApJztcbiAgICAgICAgICAgIGlmICggISBvcHRzLmJhcmVfZWxlbWVudCApIHtcbiAgICAgICAgICAgICAgICBpZiAoIG9wdHMud2lkdGggKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hcmtlci5wdXNoKHRoaXMucm91bmRSZWN0KC0wLjUqb3B0cy53aWR0aC0xLC0wLjUsb3B0cy53aWR0aCsyLDMsMS41KSk7XG4gICAgICAgICAgICAgICAgICAgIG1hcmtlci5sYXN0Q2hpbGQuc2V0QXR0cmlidXRlKCdmaWxsJyxmaWxsX2NvbG9yKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtYXJrZXIucHVzaCh0aGlzLmNpcmNsZSgwLC0wLjUqcixyKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgbWFya2VyLmxhc3RDaGlsZC5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLGZpbGxfY29sb3IpO1xuICAgICAgICAgICAgICAgICAgICBtYXJrZXIubGFzdENoaWxkLnNldEF0dHJpYnV0ZSgnYm9yZGVyJywndHJ1ZScpO1xuXG4gICAgICAgICAgICAgICAgICAgIG1hcmtlci5wdXNoKHRoaXMuY2lyY2xlKDAsMS41KnIscikpO1xuXG4gICAgICAgICAgICAgICAgICAgIG1hcmtlci5sYXN0Q2hpbGQuc2V0QXR0cmlidXRlKCdmaWxsJyxmaWxsX2NvbG9yKTtcbiAgICAgICAgICAgICAgICAgICAgbWFya2VyLmxhc3RDaGlsZC5zZXRBdHRyaWJ1dGUoJ2JvcmRlcicsJ3RydWUnKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFycm93ID0gdGhpcy5wb2x5KCgtMC45KnIqUlMpKycsJysoMCpyKlJTKSsnIDAsJysoLTIuNSpyKlJTKSsnICcrKDAuOSkqcipSUysnLCcrKDAqcipSUykpO1xuXG4gICAgICAgICAgICAgICAgICAgIGFycm93LnNldEF0dHJpYnV0ZSgnZmlsbCcsZmlsbF9jb2xvcik7XG4gICAgICAgICAgICAgICAgICAgIGFycm93LnNldEF0dHJpYnV0ZSgnc3Ryb2tlLXdpZHRoJywnMCcpO1xuXG4gICAgICAgICAgICAgICAgICAgIG1hcmtlci5wdXNoKGFycm93KTtcbiAgICAgICAgICAgICAgICAgICAgbWFya2VyLmxhc3RDaGlsZC5zZXRBdHRyaWJ1dGUoJ2JvcmRlcicsJ3RydWUnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtYXJrZXIuc2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nLCd0cmFuc2xhdGUoJysoKGN4KSpSUykrJywnKzAuNSpjeSpSUysnKSBzY2FsZSgxKScpO1xuICAgICAgICAgICAgbWFya2VyLnNldEhlaWdodCA9IHNldEhlaWdodDtcbiAgICAgICAgICAgIG1hcmtlci5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIGRpbS5SKlJTKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3ltYm9sID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN5bWJvbC5tYXRjaCgvXig6P2h0dHBzPzopP1xcLz8uKiMvKSkge1xuICAgICAgICAgICAgICAgICAgICBtYXJrZXIuY29udGVudEVsZW1lbnQgPSB0aGlzLnVzZShzeW1ib2wsLXIsMCwyKnIsMipyKTtcbiAgICAgICAgICAgICAgICAgICAgbWFya2VyLmNvbnRlbnRFbGVtZW50LnNldEF0dHJpYnV0ZSgnY29udGVudCcsJ3RydWUnKTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1hcmtlci5jb250ZW50RWxlbWVudCA9IHRoaXMudGV4dF9jaXJjbGUoMCwwLDIqcixzeW1ib2wsb3B0cyk7XG4gICAgICAgICAgICAgICAgICAgIG1hcmtlci5jb250ZW50RWxlbWVudC5maXJzdENoaWxkLnNldEF0dHJpYnV0ZSgnY29udGVudCcsJ3RydWUnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWFya2VyLnB1c2gobWFya2VyLmNvbnRlbnRFbGVtZW50KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSAmJiBBcnJheS5pc0FycmF5KHN5bWJvbCkpIHtcbiAgICAgICAgICAgICAgICBtYXJrZXIuY29udGVudEVsZW1lbnQgPSB0aGlzLmdyb3VwKCk7XG4gICAgICAgICAgICAgICAgdmFyIHBoYXNlID0gKCBNYXRoLlBJIC8gc3ltYm9sLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgLy8gcGhhc2UgLT0gKE1hdGguUEkgLyAyKTtcbiAgICAgICAgICAgICAgICB2YXIgbmVlZHNfc3RyZXRjaCA9IG9wdHMuc3RyZXRjaDtcbiAgICAgICAgICAgICAgICB2YXIgbnJvdyA9IDI7XG4gICAgICAgICAgICAgICAgc3ltYm9sLmZvckVhY2goZnVuY3Rpb24oc3ltYixpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB4X3BvcyA9IGkgJSBucm93O1xuICAgICAgICAgICAgICAgICAgICB2YXIgeV9wb3MgPSAyK01hdGguZmxvb3IoaSAvIG5yb3cpO1xuICAgICAgICAgICAgICAgICAgICB4X3BvcyAqPSAyKnI7XG4gICAgICAgICAgICAgICAgICAgIHlfcG9zICo9IDIqcjtcbiAgICAgICAgICAgICAgICAgICAgeF9wb3MgLT0gMC41KnI7XG4gICAgICAgICAgICAgICAgICAgIHZhciByb3RhdGVfYW1vdW50ID0gMTgwKmkvc3ltYm9sLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgcm90YXRlX2Ftb3VudCAtPSAwKjkwO1xuICAgICAgICAgICAgICAgICAgICByb3RhdGVfYW1vdW50ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5lZWRzX3N0cmV0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyb3RhdGVfYW1vdW50ID49IC05MCAmJiByb3RhdGVfYW1vdW50IDw9IDkwICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdHMuc3RyZXRjaCA9ICdyaWdodCc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdHMuc3RyZXRjaCA9ICdsZWZ0JztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgocm90YXRlX2Ftb3VudCAlIDkwKSA9PSAwICYmIHJvdGF0ZV9hbW91bnQgIT0gOTAgJiYgcm90YXRlX2Ftb3VudCAhPSAtOTApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocm90YXRlX2Ftb3VudCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdHMuc3RyZXRjaCA9ICdyaWdodCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzeW1ib2wubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3B0cy5zdHJldGNoID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChyb3RhdGVfYW1vdW50ID4gOTAgJiYgcm90YXRlX2Ftb3VudCA8IDI3MCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcm90YXRlX2Ftb3VudCA9IDE4MCArIHJvdGF0ZV9hbW91bnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGV0IG5ld19lbCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzeW1iLm1hdGNoKC9eKDo/aHR0cHM/Oik/XFwvPy4qIy8pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdfZWwgPSBjYW52YXMudXNlKHN5bWIsKHhfcG9zIC0gMC41KSpyLCh5X3BvcyAtIDAuNSkqciwyKnIsMipyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld19lbC5zZXRBdHRyaWJ1dGUoJ3BvaW50ZXItZXZlbnRzJywnbm9uZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV3X2VsLnNldEF0dHJpYnV0ZSgnY29udGVudCcsJ3RydWUnKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBvcHRzX2NvcHkgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9wdHMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdHNfY29weS5ub190cmFjZXIgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG9wdHNfY29weS5vZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgb3B0c19jb3B5LmhlaWdodDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld19lbCA9IGNhbnZhcy50ZXh0X2NpcmNsZSh4X3BvcypyLHlfcG9zKnIsMS43NSpyLHN5bWIsb3B0c19jb3B5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld19lbC5maXJzdENoaWxkLnNldEF0dHJpYnV0ZSgnY29udGVudCcsJ3RydWUnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIgY3Vycl90cmFuc2Zvcm0gPSBuZXdfZWwuZ2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nKSB8fCAnJztcbiAgICAgICAgICAgICAgICAgICAgY3Vycl90cmFuc2Zvcm0gPSBjdXJyX3RyYW5zZm9ybSArICcgcm90YXRlKCcrKHJvdGF0ZV9hbW91bnQpKycsJyswKnIqUlMrJywnK3lfcG9zKnIqUlMrJyknO1xuICAgICAgICAgICAgICAgICAgICBuZXdfZWwuc2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nLGN1cnJfdHJhbnNmb3JtKTtcbiAgICAgICAgICAgICAgICAgICAgbWFya2VyLmNvbnRlbnRFbGVtZW50LnB1c2gobmV3X2VsKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBtYXJrZXIucHVzaChtYXJrZXIuY29udGVudEVsZW1lbnQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtYXJrZXIuY29udGVudEVsZW1lbnQgPSB0aGlzLmdyb3VwKCk7XG4gICAgICAgICAgICAgICAgaWYgKCEgb3B0cy5iYXJlX2VsZW1lbnQgKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hcmtlci5jb250ZW50RWxlbWVudC5wdXNoKHRoaXMudGV4dF9jaXJjbGUoMCwwLjUqciwxLjc1KnIsXCJcIixvcHRzKSk7XG4gICAgICAgICAgICAgICAgICAgIG1hcmtlci5jb250ZW50RWxlbWVudC5sYXN0Q2hpbGQuZmlyc3RDaGlsZC5zZXRBdHRyaWJ1dGUoJ2NvbnRlbnQnLCd0cnVlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzeW1ib2wpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCAhIG9wdHMuYmFyZV9lbGVtZW50ICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3ltYm9sLnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJywndHJhbnNsYXRlKDAsJysoMC41KnIqUlMpKycpJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sLnNldEF0dHJpYnV0ZSgnY29udGVudCcsJ3RydWUnKTtcbiAgICAgICAgICAgICAgICAgICAgbWFya2VyLmNvbnRlbnRFbGVtZW50LnB1c2goc3ltYm9sKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbWFya2VyLnB1c2gobWFya2VyLmNvbnRlbnRFbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1hcmtlci5zZXRBdHRyaWJ1dGUoJ21hcmtlcicsJ3RydWUnKTtcbiAgICAgICAgICAgIHJldHVybiBtYXJrZXI7XG4gICAgICAgIH07XG5cbiAgICAgICAgY2FudmFzLnRleHRfY2lyY2xlID0gZnVuY3Rpb24oY3gsY3kscix0eHQsb3B0cykge1xuXG4gICAgICAgICAgICBpZiAoICEgb3B0cyApIHtcbiAgICAgICAgICAgICAgICBvcHRzID0ge307XG4gICAgICAgICAgICB9ICAgICAgICBcblxuICAgICAgICAgICAgdmFyIHVuaXRzID0gMDtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjeCA9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHZhciBwYXJ0cyA9IG5ldyBSZWdFeHAoLyhcXGQrKSguKikvZykuZXhlYyhjeCk7XG4gICAgICAgICAgICAgICAgdW5pdHMgPSBwYXJ0c1syXTtcbiAgICAgICAgICAgICAgICBjeCA9IHBhcnNlRmxvYXQocGFydHNbMV0pO1xuXG4gICAgICAgICAgICAgICAgcGFydHMgPSBuZXcgUmVnRXhwKC8oXFxkKykoLiopL2cpLmV4ZWMoY3kpO1xuICAgICAgICAgICAgICAgIGN5ID0gcGFyc2VGbG9hdChwYXJ0c1sxXSk7XG5cbiAgICAgICAgICAgICAgICBwYXJ0cyA9IG5ldyBSZWdFeHAoLyhcXGQrKSguKikvZykuZXhlYyhyKTtcbiAgICAgICAgICAgICAgICByID0gcGFyc2VGbG9hdChwYXJ0c1sxXSk7ICAgICAgICBcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGRpbSA9IHtcbiAgICAgICAgICAgICAgICBDWCAgICAgIDogY3grdW5pdHMsXG4gICAgICAgICAgICAgICAgQ1kgICAgICA6IGN5K3VuaXRzLFxuICAgICAgICAgICAgICAgIFIgICAgICAgOiByK3VuaXRzLFxuICAgICAgICAgICAgICAgIE1JTl9YICAgOiAoY3gtcikrdW5pdHMsXG4gICAgICAgICAgICAgICAgTUFYX1ggICA6IChjeCtyKSt1bml0cyxcbiAgICAgICAgICAgICAgICBNSU5fWSAgIDogKGN5LXIpK3VuaXRzLFxuICAgICAgICAgICAgICAgIE1BWF9ZICAgOiAoY3krcikrdW5pdHMsXG4gICAgICAgICAgICAgICAgTUlEX1gxICA6IChjeC0oci8yKSkrdW5pdHMsXG4gICAgICAgICAgICAgICAgTUlEX1gyICA6IChjeCsoci8yKSkrdW5pdHMsXG4gICAgICAgICAgICAgICAgTUlEX1kxICA6IChjeS0oci8yKSkrdW5pdHMsXG4gICAgICAgICAgICAgICAgTUlEX1kyICA6IChjeSsoci8yKSkrdW5pdHNcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciBtYXJrZXJfZ3JvdXAgPSB0aGlzLmdyb3VwKCk7XG5cblxuICAgICAgICAgICAgdmFyIHRleHQgPSB0aGlzLnRleHQoMCxkaW0uQ1ksdHh0KTtcbiAgICAgICAgICAgIHRleHQuc2V0QXR0cmlidXRlKCdmb250LXNpemUnLDEwKlJTKTtcbiAgICAgICAgICAgIHRleHQuc2V0QXR0cmlidXRlKCdmb250LXdlaWdodCcsb3B0cy53ZWlnaHQgfHwgJ2JvbGRlcicpO1xuICAgICAgICAgICAgdGV4dC5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLG9wdHMudGV4dF9maWxsIHx8ICcjZmZmZmZmJyk7XG4gICAgICAgICAgICB0ZXh0LnNldEF0dHJpYnV0ZSgnc3R5bGUnLCdmb250LWZhbWlseTogc2Fucy1zZXJpZjsgdGV4dC1hbmNob3I6IG1pZGRsZTsnKTtcbiAgICAgICAgICAgIHRleHQuZmlyc3RDaGlsZC5zZXRBdHRyaWJ1dGUoJ2R5JywnMC4zNWVtJyk7XG4gICAgICAgICAgICB0ZXh0LnNldEF0dHJpYnV0ZSgndGV4dC1hbmNob3InLCdtaWRkbGUnKTtcbiAgICAgICAgICAgIHZhciBiYWNrO1xuXG4gICAgICAgICAgICBpZiAoICEgb3B0cy5zdHJldGNoICkge1xuICAgICAgICAgICAgICAgIGJhY2sgPSB0aGlzLmNpcmNsZSgwLGRpbS5DWSw5LzEwKmRpbS5SKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHRleHRfd2lkdGggPSAxLjIgKiAob3B0cy5mb250X3NpemUgfHwgcikgKiB0ZXh0LmdldEJCb3goKS53aWR0aCAvICgxMCAqIFJTKTtcbiAgICAgICAgICAgICAgICB2YXIgdGV4dF9oZWlnaHQgPSAzLzIgKiBkaW0uUjtcbiAgICAgICAgICAgICAgICB2YXIgbGVmdF9wb3MgPSAtMC41KnRleHRfd2lkdGg7XG4gICAgICAgICAgICAgICAgaWYgKHRleHRfd2lkdGggPiAoMypkaW0uUikpIHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdF9wb3MgPSAtMC41KnRleHRfd2lkdGg7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdHMuc3RyZXRjaCA9PSAncmlnaHQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZWZ0X3BvcyA9IC0wLjEqdGV4dF93aWR0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAob3B0cy5zdHJldGNoID09ICdsZWZ0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdF9wb3MgPSAtMC45KnRleHRfd2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0X3dpZHRoID0gMyAqIGRpbS5SO1xuICAgICAgICAgICAgICAgICAgICBsZWZ0X3BvcyA9IC0wLjUqdGV4dF93aWR0aDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGV4dC5zZXRBdHRyaWJ1dGUoJ3gnLCgwLjUqdGV4dF93aWR0aCArIGxlZnRfcG9zKSpSUyk7XG4gICAgICAgICAgICAgICAgYmFjayA9IHRoaXMucm91bmRSZWN0KGxlZnRfcG9zLGRpbS5DWS0wLjUqdGV4dF9oZWlnaHQsdGV4dF93aWR0aCx0ZXh0X2hlaWdodCx7J3gnIDogMC41KmRpbS5SLCAneScgOiAwLjUqdGV4dF9oZWlnaHQgfSx7fSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ZXh0LnNldEF0dHJpYnV0ZSgnZm9udC1zaXplJywob3B0cy5mb250X3NpemUgfHwgcikqUlMpO1xuXG4gICAgICAgICAgICBiYWNrLnNldEF0dHJpYnV0ZSgnZmlsbCcsb3B0cy5maWxsIHx8ICd1cmwoI3NpbXBsZV9ncmFkaWVudCknKTtcbiAgICAgICAgICAgIHdpbmRvdy5tYXRjaE1lZGlhKCdwcmludCcpLmFkZExpc3RlbmVyKGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgYmFjay5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLG1hdGNoLm1hdGNoZXMgPyAnI2FhYWFhYSc6IChvcHRzLmZpbGwgfHwgJ3VybCgjc2ltcGxlX2dyYWRpZW50KScpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYmFjay5zZXRBdHRyaWJ1dGUoJ3N0cm9rZScsIG9wdHMuYm9yZGVyIHx8ICcjMDAwMDAwJyk7XG4gICAgICAgICAgICBiYWNrLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLXdpZHRoJywgKHIvMTApKlJTKTtcblxuICAgICAgICAgICAgbWFya2VyX2dyb3VwLnB1c2goYmFjayk7XG5cbiAgICAgICAgICAgIG1hcmtlcl9ncm91cC5wdXNoKHRleHQpO1xuXG4gICAgICAgICAgICBtYXJrZXJfZ3JvdXAuc2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nLCd0cmFuc2xhdGUoJytkaW0uQ1gqUlMrJywgMSkgc2NhbGUoMSknKTtcbiAgICAgICAgICAgIG1hcmtlcl9ncm91cC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIChkaW0uUi8yKSpSUyApO1xuICAgICAgICAgICAgbWFya2VyX2dyb3VwLnNldEhlaWdodCA9IHNldEhlaWdodDtcbiAgICAgICAgICAgIHJldHVybiBtYXJrZXJfZ3JvdXA7XG4gICAgICAgIH07XG5cbiAgICAgICAgY2FudmFzLmNyb3NzZWRfY2lyY2xlID0gZnVuY3Rpb24oY3gsY3kscikge1xuXG4gICAgICAgICAgICB2YXIgdW5pdHMgPSAwO1xuXG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgY3ggPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFydHMgPSBuZXcgUmVnRXhwKC8oXFxkKykoLiopL2cpLmV4ZWMoY3gpO1xuICAgICAgICAgICAgICAgIHVuaXRzID0gcGFydHNbMl07XG4gICAgICAgICAgICAgICAgY3ggPSBwYXJzZUZsb2F0KHBhcnRzWzFdKTtcblxuICAgICAgICAgICAgICAgIHBhcnRzID0gbmV3IFJlZ0V4cCgvKFxcZCspKC4qKS9nKS5leGVjKGN5KTtcbiAgICAgICAgICAgICAgICBjeSA9IHBhcnNlRmxvYXQocGFydHNbMV0pO1xuXG4gICAgICAgICAgICAgICAgcGFydHMgPSBuZXcgUmVnRXhwKC8oXFxkKykoLiopL2cpLmV4ZWMocik7XG4gICAgICAgICAgICAgICAgciA9IHBhcnNlRmxvYXQocGFydHNbMV0pOyAgICAgICAgXG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBkaW0gPSB7XG4gICAgICAgICAgICAgICAgQ1ggICAgICA6IGN4K3VuaXRzLFxuICAgICAgICAgICAgICAgIENZICAgICAgOiBjeSt1bml0cyxcbiAgICAgICAgICAgICAgICBSICAgICAgIDogcit1bml0cyxcbiAgICAgICAgICAgICAgICBNSU5fWCAgIDogKGN4LXIpK3VuaXRzLFxuICAgICAgICAgICAgICAgIE1BWF9YICAgOiAoY3grcikrdW5pdHMsXG4gICAgICAgICAgICAgICAgTUlOX1kgICA6IChjeS1yKSt1bml0cyxcbiAgICAgICAgICAgICAgICBNQVhfWSAgIDogKGN5K3IpK3VuaXRzLFxuICAgICAgICAgICAgICAgIE1JRF9YMSAgOiAoY3gtKHIvMikpK3VuaXRzLFxuICAgICAgICAgICAgICAgIE1JRF9YMiAgOiAoY3grKHIvMikpK3VuaXRzLFxuICAgICAgICAgICAgICAgIE1JRF9ZMSAgOiAoY3ktKHIvMikpK3VuaXRzLFxuICAgICAgICAgICAgICAgIE1JRF9ZMiAgOiAoY3krKHIvMikpK3VuaXRzXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgY2xvc2VfZ3JvdXAgPSB0aGlzLmdyb3VwKCk7XG5cbiAgICAgICAgICAgIHZhciBjbG9zZV9idXR0b24gPSB0aGlzLmNpcmNsZShkaW0uQ1gsZGltLkNZLGRpbS5SKTtcbiAgICAgICAgICAgIGNsb3NlX2J1dHRvbi5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLCcjMDAwMDAwJyk7XG4gICAgICAgICAgICBjbG9zZV9idXR0b24uc2V0QXR0cmlidXRlKCdzdHJva2UnLCAnI2ZmZmZmZicpO1xuICAgICAgICAgICAgY2xvc2VfYnV0dG9uLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLXdpZHRoJywgJzInKTtcblxuICAgICAgICAgICAgY2xvc2VfZ3JvdXAuX2J1dHRvbiA9IGNsb3NlX2J1dHRvbjtcblxuICAgICAgICAgICAgY2xvc2VfZ3JvdXAucHVzaChjbG9zZV9idXR0b24pO1xuXG4gICAgICAgICAgICB2YXIgYV9saW5lID0gdGhpcy5saW5lKGRpbS5NSURfWDEsZGltLk1JRF9ZMSxkaW0uTUlEX1gyLGRpbS5NSURfWTIpO1xuICAgICAgICAgICAgYV9saW5lLnNldEF0dHJpYnV0ZSgnc3Ryb2tlJywgJyNmZmZmZmYnKTtcbiAgICAgICAgICAgIGFfbGluZS5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS13aWR0aCcsICcyJyk7XG5cbiAgICAgICAgICAgIGNsb3NlX2dyb3VwLnB1c2goYV9saW5lKTtcblxuICAgICAgICAgICAgdmFyIGZpcnN0X2xpbmUgPSBhX2xpbmU7XG5cbiAgICAgICAgICAgIHZhciBhX2xpbmUgPSB0aGlzLmxpbmUoZGltLk1JRF9YMSxkaW0uTUlEX1kyLGRpbS5NSURfWDIsZGltLk1JRF9ZMSk7XG4gICAgICAgICAgICBhX2xpbmUuc2V0QXR0cmlidXRlKCdzdHJva2UnLCAnI2ZmZmZmZicpO1xuICAgICAgICAgICAgYV9saW5lLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLXdpZHRoJywgJzInKTtcblxuICAgICAgICAgICAgY2xvc2VfZ3JvdXAucHVzaChhX2xpbmUpO1xuXG4gICAgICAgICAgICBjbG9zZV9ncm91cC5tb3ZlID0gZnVuY3Rpb24oY3gsY3kpIHtcbiAgICAgICAgICAgICAgICBjbG9zZV9idXR0b24uc2V0QXR0cmlidXRlKCdjeCcsY3gpO1xuICAgICAgICAgICAgICAgIGRpbS5NSURfWDEgPSAoY3gtKHIvMikpO1xuICAgICAgICAgICAgICAgIGRpbS5NSURfWDIgPSAoY3grKHIvMikpO1xuICAgICAgICAgICAgICAgIGRpbS5NSURfWTEgPSAoY3ktKHIvMikpO1xuICAgICAgICAgICAgICAgIGRpbS5NSURfWTIgPSAoY3krKHIvMikpO1xuICAgICAgICAgICAgICAgIGZpcnN0X2xpbmUuc2V0QXR0cmlidXRlKCd4MScsZGltLk1JRF9YMSk7XG4gICAgICAgICAgICAgICAgZmlyc3RfbGluZS5zZXRBdHRyaWJ1dGUoJ3kxJyxkaW0uTUlEX1kxKTtcbiAgICAgICAgICAgICAgICBmaXJzdF9saW5lLnNldEF0dHJpYnV0ZSgneDInLGRpbS5NSURfWDIpO1xuICAgICAgICAgICAgICAgIGZpcnN0X2xpbmUuc2V0QXR0cmlidXRlKCd5MicsZGltLk1JRF9ZMik7XG4gICAgICAgICAgICAgICAgYV9saW5lLnNldEF0dHJpYnV0ZSgneDEnLGRpbS5NSURfWDEpO1xuICAgICAgICAgICAgICAgIGFfbGluZS5zZXRBdHRyaWJ1dGUoJ3kxJyxkaW0uTUlEX1kyKTtcbiAgICAgICAgICAgICAgICBhX2xpbmUuc2V0QXR0cmlidXRlKCd4MicsZGltLk1JRF9YMik7XG4gICAgICAgICAgICAgICAgYV9saW5lLnNldEF0dHJpYnV0ZSgneTInLGRpbS5NSURfWTEpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBjbG9zZV9ncm91cDsgICAgICAgIFxuICAgICAgICB9O1xuICAgICAgICBjYW52YXMudGV4dCA9IGZ1bmN0aW9uKHgseSx0ZXh0KSB7XG4gICAgICAgICAgICB2YXIgYV90ZXh0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHN2Z25zLCd0ZXh0Jyk7XG4gICAgICAgICAgICB2YXIgYV90c3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhzdmducywgJ3RzcGFuJyk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHRleHQgIT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBhX3RleHQuYXBwZW5kQ2hpbGQodGV4dCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFfdGV4dC5hcHBlbmRDaGlsZChhX3RzcGFuKTtcbiAgICAgICAgICAgICAgICBhX3RzcGFuLnRleHRDb250ZW50ID0gdGV4dDtcbiAgICAgICAgICAgICAgICBhX3RzcGFuLnNldEF0dHJpYnV0ZSgnZHknLCcwJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhX3RleHQuc3R5bGUuZm9udEZhbWlseSA9IHRoaXMuZm9udF9vcmRlciB8fCAnSGVsdmV0aWNhLCBWZXJkYW5hLCBBcmlhbCwgU2Fucy1zZXJpZic7XG4gICAgICAgICAgICBhX3RleHQuc2V0QXR0cmlidXRlKCd4Jyx0eXBlb2YgeCA9PSAnc3RyaW5nJyA/IHggOiB4ICogUlMpO1xuICAgICAgICAgICAgYV90ZXh0LnNldEF0dHJpYnV0ZSgneScsdHlwZW9mIHkgPT0gJ3N0cmluZycgPyB5IDogeSAqIFJTKTsgICAgICAgIFxuICAgICAgICAgICAgYV90ZXh0Lm1vdmUgPSBmdW5jdGlvbihuZXdfeCxuZXdfd2lkdGgpIHtcbiAgICAgICAgICAgICAgICBpZiAoKHR5cGVvZih0aGlzLm9mZnNldCkgIT09IFwidW5kZWZpbmVkXCIpICYmIHRoaXMuZ2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHJhbnNmb3JtX2F0dHIgPSB0aGlzLmdldEF0dHJpYnV0ZSgndHJhbnNmb3JtJyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXRjaGVzID0gL3RyYW5zbGF0ZVxcKC4qWyxcXHNdKC4qKVxcKS8uZXhlYyh0cmFuc2Zvcm1fYXR0cik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaGVzWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsJ3RyYW5zbGF0ZSgnKyhuZXdfeCpSUykrJywnK21hdGNoZXNbMV0rJyknKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCd4JyxuZXdfeCpSUyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdGhpcy5hcHBlbmRDaGlsZChhX3RleHQpO1xuICAgICAgICAgICAgcmV0dXJuIGFfdGV4dDtcbiAgICAgICAgfTtcbiAgICAgICAgY2FudmFzLnBsdXMgPSBmdW5jdGlvbih4LHksaGVpZ2h0KSB7XG4gICAgICAgICAgICB2YXIgZyA9IHRoaXMuZ3JvdXAoKTtcbiAgICAgICAgICAgIGcuYXBwZW5kQ2hpbGQodGhpcy5tYWtlRWwoJ3JlY3QnLCB7XG4gICAgICAgICAgICAgICAgJ3gnIDogTWF0aC5yb3VuZCgoMC40KSpoZWlnaHQqUlMpLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgJ3knIDogTWF0aC5yb3VuZCgoMC4xKSpoZWlnaHQqUlMpLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgJ3N0cm9rZS13aWR0aCcgOiAnMScsXG4gICAgICAgICAgICAgICAgJ3dpZHRoJyA6IE1hdGgucm91bmQoKDAuMikqaGVpZ2h0KlJTKS50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgICdoZWlnaHQnOiBNYXRoLnJvdW5kKCgwLjgpKmhlaWdodCpSUykudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAnc3Ryb2tlJzogJyNmZmZmZmYnLFxuICAgICAgICAgICAgICAgICdmaWxsJyAgOiAnI2ZmZmZmZicgICAgICAgICAgICBcbiAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgZy5hcHBlbmRDaGlsZCh0aGlzLm1ha2VFbCgncmVjdCcsIHtcbiAgICAgICAgICAgICAgICAneCcgOiBNYXRoLnJvdW5kKCgwLjEpKmhlaWdodCpSUykudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAneScgOiBNYXRoLnJvdW5kKCgwLjQpKmhlaWdodCpSUykudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAnc3Ryb2tlLXdpZHRoJyA6ICcxJyxcbiAgICAgICAgICAgICAgICAnd2lkdGgnIDogTWF0aC5yb3VuZCgoMC44KSpoZWlnaHQqUlMpLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgJ2hlaWdodCc6IE1hdGgucm91bmQoKDAuMikqaGVpZ2h0KlJTKS50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgICdzdHJva2UnOiAnI2ZmZmZmZicsXG4gICAgICAgICAgICAgICAgJ2ZpbGwnICA6ICcjZmZmZmZmJyAgICAgICAgICAgIFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgZy5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsJ3RyYW5zbGF0ZSgnK3gqUlMrJywnK3kqUlMrJyknKTtcbiAgICAgICAgICAgIHJldHVybiBnO1xuICAgICAgICB9O1xuICAgICAgICBjYW52YXMubWludXMgPSBmdW5jdGlvbih4LHksaGVpZ2h0KSB7XG4gICAgICAgICAgICB2YXIgZyA9IHRoaXMuZ3JvdXAoKTtcblxuICAgICAgICAgICAgZy5hcHBlbmRDaGlsZCh0aGlzLm1ha2VFbCgncmVjdCcsIHtcbiAgICAgICAgICAgICAgICAneCcgOiBNYXRoLnJvdW5kKCgwLjEpKmhlaWdodCpSUykudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAneScgOiBNYXRoLnJvdW5kKCgwLjQpKmhlaWdodCpSUykudG9TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAnc3Ryb2tlLXdpZHRoJyA6ICcxJyxcbiAgICAgICAgICAgICAgICAnd2lkdGgnIDogTWF0aC5yb3VuZCgoMC44KSpoZWlnaHQqUlMpLnRvU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgJ2hlaWdodCc6IE1hdGgucm91bmQoKDAuMikqaGVpZ2h0KlJTKS50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgICdzdHJva2UnOiAnI2ZmZmZmZicsXG4gICAgICAgICAgICAgICAgJ2ZpbGwnICA6ICcjZmZmZmZmJyAgICAgICAgICAgIFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgZy5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsJ3RyYW5zbGF0ZSgnK3gqUlMrJywnK3kqUlMrJyknKTtcbiAgICAgICAgICAgIHJldHVybiBnO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgYm91bmRpbmcgYm94IG9mIGFuIGVsZW1lbnQgd2l0aCByZXNwZWN0IHRvIGl0cyBwYXJlbnQgZWxlbWVudFxuICAgICAgICAvLyBUaGFua3MgdG8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMDYyMzgwOS9nZXQtYm91bmRpbmctYm94LW9mLWVsZW1lbnQtYWNjb3VudGluZy1mb3ItaXRzLXRyYW5zZm9ybVxuICAgICAgICBjYW52YXMudHJhbnNmb3JtZWRCb3VuZGluZ0JveCA9IGZ1bmN0aW9uKGVsKXtcbiAgICAgICAgICAgIHZhciBiYiAgPSBlbC5nZXRCQm94KCksXG4gICAgICAgICAgICAgICAgc3ZnID0gZWwub3duZXJTVkdFbGVtZW50LFxuICAgICAgICAgICAgICAgIG0gICA9IGVsLnBhcmVudE5vZGUuZ2V0U2NyZWVuQ1RNKCkuaW52ZXJzZSgpLm11bHRpcGx5KGVsLmdldFNjcmVlbkNUTSgpKS5pbnZlcnNlKCk7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYW4gYXJyYXkgb2YgYWxsIGZvdXIgcG9pbnRzIGZvciB0aGUgb3JpZ2luYWwgYm91bmRpbmcgYm94XG4gICAgICAgICAgICB2YXIgcHRzID0gW1xuICAgICAgICAgICAgICAgIHN2Zy5jcmVhdGVTVkdQb2ludCgpLCBzdmcuY3JlYXRlU1ZHUG9pbnQoKSxcbiAgICAgICAgICAgICAgICBzdmcuY3JlYXRlU1ZHUG9pbnQoKSwgc3ZnLmNyZWF0ZVNWR1BvaW50KClcbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBwdHNbMF0ueD1iYi54OyAgICAgICAgICBwdHNbMF0ueT1iYi55O1xuICAgICAgICAgICAgcHRzWzFdLng9YmIueCtiYi53aWR0aDsgcHRzWzFdLnk9YmIueTtcbiAgICAgICAgICAgIHB0c1syXS54PWJiLngrYmIud2lkdGg7IHB0c1syXS55PWJiLnkrYmIuaGVpZ2h0O1xuICAgICAgICAgICAgcHRzWzNdLng9YmIueDsgICAgICAgICAgcHRzWzNdLnk9YmIueStiYi5oZWlnaHQ7XG5cbiAgICAgICAgICAgIC8vIFRyYW5zZm9ybSBlYWNoIGludG8gdGhlIHNwYWNlIG9mIHRoZSBwYXJlbnQsXG4gICAgICAgICAgICAvLyBhbmQgY2FsY3VsYXRlIHRoZSBtaW4vbWF4IHBvaW50cyBmcm9tIHRoYXQuXG4gICAgICAgICAgICB2YXIgeE1pbj1JbmZpbml0eSx4TWF4PS1JbmZpbml0eSx5TWluPUluZmluaXR5LHlNYXg9LUluZmluaXR5O1xuICAgICAgICAgICAgcHRzLmZvckVhY2goZnVuY3Rpb24ocHQpe1xuICAgICAgICAgICAgICAgIHB0ID0gcHQubWF0cml4VHJhbnNmb3JtKG0pO1xuICAgICAgICAgICAgICAgIHhNaW4gPSBNYXRoLm1pbih4TWluLHB0LngpO1xuICAgICAgICAgICAgICAgIHhNYXggPSBNYXRoLm1heCh4TWF4LHB0LngpO1xuICAgICAgICAgICAgICAgIHlNaW4gPSBNYXRoLm1pbih5TWluLHB0LnkpO1xuICAgICAgICAgICAgICAgIHlNYXggPSBNYXRoLm1heCh5TWF4LHB0LnkpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgYm91bmRpbmcgYm94IHdpdGggdGhlIG5ldyB2YWx1ZXNcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYmIueCA9IHhNaW47IGJiLndpZHRoICA9IHhNYXgteE1pbjtcbiAgICAgICAgICAgICAgICBiYi55ID0geU1pbjsgYmIuaGVpZ2h0ID0geU1heC15TWluO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGJiID0geyAneCcgOiB4TWluLCAneScgOiB5TWluLCAnd2lkdGgnIDogeE1heC14TWluLCAnaGVpZ2h0JyA6IHlNYXgteU1pbiB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGJiO1xuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgY2FudmFzLnNldCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGFuX2FycmF5ID0gW107XG4gICAgICAgICAgICBleHRlbmRfYXJyYXkoYW5fYXJyYXksUlMpO1xuICAgICAgICAgICAgcmV0dXJuIGFuX2FycmF5O1xuICAgICAgICB9O1xuICAgICAgICBjYW52YXMuaGlkZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2Rpc3BsYXknLCdub25lJyk7XG4gICAgICAgIH07XG4gICAgICAgIGNhbnZhcy5zaG93ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnZGlzcGxheScsJ2lubGluZScpO1xuICAgICAgICB9O1xuICAgIH0pO1xuXG59KSgpO1xuXG5cbmV4cG9ydCBkZWZhdWx0IFNWR0NhbnZhczsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRkE7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBWEE7QUFDQTtBQWFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFYQTtBQUNBO0FBYUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFYQTtBQUNBO0FBYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQVBBO0FBQ0E7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBUEE7QUFTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUdBO0FBQ0E7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./js/lib/SVGCanvas.js\n");

/***/ }),

/***/ "./js/lib/SequenceRenderer.js":
/*!************************************!*\
  !*** ./js/lib/SequenceRenderer.js ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _MASCP__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MASCP */ \"./js/lib/MASCP.js\");\n/* harmony import */ var _bean__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../bean */ \"./js/bean.js\");\n/**\n * @fileOverview    Read in sequences to be re-rendered in a block that can be easily annotated.\n */\n\n\n\n\n/**\n * @class   Reformatter for sequences in html pages. The object retrieves the amino acid sequence from the \n *          given element, and then reformats the display of the sequence so that rendering layers can be\n *          applied to it. \n * @author  hjjoshi\n * @param   {Element} sequenceContainer Container element that the sequence currently is found in, and also \n *                                      the container that data will be re-inserted into.\n */\nconst SequenceRenderer = function () {\n\n    /**\n     *  @lends SequenceRenderer.prototype\n     *  @property   {Array}     trackOrder  The order of tracks on the renderer, an array of layer/group names.\n     */\n    var setupTrackOrder = function setupTrackOrder(renderer) {\n        var renderer_track_order = [];\n\n        var accessors = {\n\n            getTrackOrder: function getTrackOrder() {\n                return renderer_track_order;\n            },\n\n            setTrackOrder: function setTrackOrder(in_order) {\n                var track_order = [];\n                var order = in_order;\n                if (!order instanceof Array) {\n                    order = [in_order];\n                }\n                for (var i = 0; i < order.length; i++) {\n                    var a_track = order[i];\n                    if (_MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getLayer(a_track)) {\n                        while (track_order.indexOf(a_track) >= 0) {\n                            track_order.splice(track_order.indexOf(a_track), 1);\n                        }\n                        track_order.push(a_track);\n                    }\n                    if (_MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getGroup(a_track)) {\n                        let insert_idx = i + 1;\n                        _MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getGroup(order[i]).eachLayer(function (grp_lay) {\n                            while (track_order.indexOf(grp_lay.name) >= 0) {\n                                track_order.splice(track_order.indexOf(grp_lay.name), 1);\n                            }\n                            order.splice(insert_idx, 0, grp_lay.name);\n                            insert_idx += 1;\n                        });\n                    }\n                }\n                for (i = (renderer_track_order || []).length - 1; i >= 0; i--) {\n                    if (track_order.indexOf(renderer_track_order[i]) < 0) {\n                        this.hideLayer(renderer_track_order[i]);\n                        this.hideGroup(renderer_track_order[i]);\n                        if (_MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getLayer(renderer_track_order[i])) {\n                            _bean__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fire(_MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getLayer(renderer_track_order[i]), 'removed', [renderer]);\n                        }\n                        if (_MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getGroup(renderer_track_order[i])) {\n                            _bean__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fire(_MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getGroup(renderer_track_order[i]), 'removed', [renderer]);\n                        }\n                    }\n                }\n                renderer_track_order = track_order;\n\n                if (this.refresh) {\n                    this.refresh(true);\n                }\n                _bean__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fire(renderer, 'orderChanged', [track_order]);\n            }\n        };\n\n        if (_MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"].IE) {\n            renderer.setTrackOrder = accessors.setTrackOrder;\n        }\n\n        if (typeof Object.defineProperty == 'function' && !_MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"].IE8) {\n            Object.defineProperty(renderer, \"trackOrder\", {\n                get: accessors.getTrackOrder,\n                set: accessors.setTrackOrder\n            });\n        }\n    };\n\n    return function (sequenceContainer) {\n        if (!sequenceContainer) {\n            return this;\n        }\n        if (typeof sequenceContainer !== 'undefined') {\n            this._container = sequenceContainer;\n            if (!this._container.style.position) {\n                this._container.style.position = 'relative';\n            }\n            //        this._container.style.width = '100%';\n\n            _bean__WEBPACK_IMPORTED_MODULE_1__[\"default\"].add(this, 'sequenceChange', function (e) {\n                while (sequenceContainer.firstChild) {\n                    sequenceContainer.removeChild(sequenceContainer.firstChild);\n                }\n                this._sequence_els.forEach(function (el) {\n                    sequenceContainer.appendChild(el);\n                });\n                var float_clear = document.createElement('div');\n                float_clear.setAttribute('style', 'clear: both; float: none; height: 0px; width: 100%;');\n                sequenceContainer.appendChild(float_clear);\n                sequenceContainer.style.width = this._sequence_els.length + 'em';\n                //            this.showRowNumbers();            \n            });\n\n            this.setSequence(sequenceContainer.textContent || '');\n        }\n\n        setupTrackOrder(this);\n\n        return this;\n    };\n}();\n\n/**\n * Event fired when a layer is registered with the global layer registry\n * @name    MASCP.layerRegistered\n * @event\n * @param   {Object}    e\n * @param   {Object}    layer Layer just registered\n */\n\n/**\n * Event fired when a group is registered with the global group registry\n * @name    MASCP.groupRegistered\n * @event\n * @param   {Object}    e\n * @param   {Object}    group Group just registered\n */\n\n/**\n * Event fired when the sequence is changed in a sequence renderer\n * @name    SequenceRenderer#sequenceChange\n * @event\n * @param   {Object}    e\n */\n\n/**\n * Event fired when a result is rendered on this renderer\n * @name    SequenceRenderer#resultsRendered\n * @event\n * @param   {Object}    e\n * @param   {MASCP.Service} reader  Reader that rendered the result.\n */\n\n/**\n * @name    MASCP.Group#visibilityChange\n * @event\n * @param   {Object}    e\n * @param   {Object}    renderer\n * @param   {Boolean}   visibility\n */\n\n/**\n * @name    MASCP.Layer#visibilityChange\n * @event\n * @param   {Object}    e\n * @param   {Object}    renderer\n * @param   {Boolean}   visibility\n */\n\n/**\n *  @lends SequenceRenderer.prototype\n *  @property   {String}  sequence  Sequence to mark up.\n */\nSequenceRenderer.prototype = {\n    sequence: null\n};\n\nif (_MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"].IE) {\n    SequenceRenderer.prototype.prototype = document.createElement('div');\n}\n\n/**\n * Set the sequence for this renderer. Fires the sequenceChange event when the sequence is set.\n * @param {String} sequence Sequence to render\n * @see SequenceRenderer#event:sequenceChange\n */\nSequenceRenderer.prototype.setSequence = function (sequence) {\n    this.sequence = this._cleanSequence(sequence);\n    var sequence_els = [];\n    var renderer = this;\n    if (!this.sequence) {\n        return;\n    }\n    var seq_chars = this.sequence.split('');\n    for (var i = 0; i < seq_chars.length; i++) {\n        var aa = seq_chars[i];\n        if (aa.match(/[A-Za-z]/)) {\n            var span_el = document.createElement('span');\n            span_el.textContent = aa;\n            sequence_els.push(span_el);\n        }\n    }\n\n    sequence_els.forEach(function (el, i) {\n        // if ( (i % 10) == 0 && i > 0 && ((i % 50) != 0)) {\n        //     this.style.margin = '0px 0px 0px 1em';\n        // }\n        // if ( (i % 50) == 0 && i > 0 ) {\n        //     if (MASCP.IE7) {\n        //         sequence_els[i-1].style.styleFloat = 'none';\n        //         sequence_els[i-1].style.width = '1em';\n        //     }\n        //     this.style.clear = 'both';\n        // }\n\n        el._index = i;\n\n        el.style.display = 'block';\n        el.style.cssFloat = 'left';\n        el.style.styleFloat = 'left';\n        el.style.height = '1.1em';\n        el.style.position = 'relative';\n\n        el.addToLayer = SequenceRenderer.addElementToLayer;\n        el.addBoxOverlay = SequenceRenderer.addBoxOverlayToElement;\n        el.addToLayerWithLink = SequenceRenderer.addElementToLayerWithLink;\n        el._renderer = renderer;\n    });\n    this._sequence_els = sequence_els;\n    _bean__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fire(this, 'sequenceChange');\n};\n\n/**\n * Color some residues on this residue\n * @param {Array} indexes Indexes to apply the given color to\n * @param {String} color Color to use to highlight the residues\n * @returns ID for the layer that is created\n * @type String\n */\nSequenceRenderer.prototype.colorResidues = function (indexes, color) {\n    var layer_id = Math.floor(Math.random() * 1000).toString();\n    _MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"].registerLayer(layer_id, { 'color': color || '#ff0000' });\n    var aas = this.getAminoAcidsByPosition(indexes);\n    for (var i = 0; i < aas.length; i++) {\n        aas[i].addToLayer(layer_id);\n    }\n    return _MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getLayer(layer_id);\n};\n\nSequenceRenderer.prototype._cleanSequence = function (sequence) {\n    if (!sequence) {\n        return sequence;\n    }\n    var cleaned_sequence = sequence;\n    cleaned_sequence = cleaned_sequence.replace(new RegExp(String.fromCharCode(160), \"g\"), '');\n    cleaned_sequence = cleaned_sequence.replace(/[\\n\\t\\s\\d]+/mgi, '');\n    cleaned_sequence = cleaned_sequence.replace(/\\(.*\\)/g, '');\n    return cleaned_sequence;\n};\n\n/**\n * Retrieve the HTML Elements that contain the amino acids at the given positions. The first amino acid is found at position 1.\n * @param {Array} indexes Indexes to retrieve elements for\n * @returns Elements representing each amino acid at the given positions\n * @type Array\n */\nSequenceRenderer.prototype.getAminoAcidsByPosition = function (indexes) {\n    var sequence_els = this._sequence_els;\n    return indexes.map(function (index) {\n        if (index < 0) {\n            return null;\n        }\n        return sequence_els[index - 1];\n    });\n};\n\nSequenceRenderer.prototype.getAA = function (index) {\n    return this.getAminoAcidsByPosition([index]).shift();\n};\n\n/**\n * Retrieve the HTML Elements that contain the amino acids contained in the given peptide sequence.\n * @param {String} peptideSequence Peptide sequence used to look up the amino acids\n * @returns Elements representing each amino acid at the given positions\n * @type Array\n */\nSequenceRenderer.prototype.getAminoAcidsByPeptide = function (peptideSequence) {\n    var start = this.sequence.indexOf(peptideSequence);\n    var results = [];\n\n    if (start < 0) {\n        results.addToLayer = function () {};\n        return results;\n    }\n    results = results.concat(this._sequence_els.slice(start, start + peptideSequence.length));\n    if (results.length) {\n        results.addToLayer = function (layername, fraction, options) {\n            return results[0].addBoxOverlay(layername, results.length, fraction, options);\n        };\n    } else {\n        results.addToLayer = function () {};\n    }\n\n    return results;\n};\n\n/**\n * Toggle the display of the given layer\n * @param {String|Object} layer Layer name, or layer object\n * @see MASCP.Layer#event:visibilityChange\n */\nSequenceRenderer.prototype.toggleLayer = function (layer, consumeChange) {\n    var layerName = layer;\n    if (typeof layer != 'string') {\n        layerName = layer.name;\n    } else {\n        layer = _MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"].layers[layer];\n    }\n    this._container.classList.toggle(layerName + '_active');\n    this._container.classList.toggle(layerName + '_inactive');\n    if (!consumeChange) {\n        _bean__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fire(layer, 'visibilityChange', [this, this.isLayerActive(layer)]);\n    }\n    return this;\n};\n\n/**\n * Show the given layer\n * @param {String|Object} layer Layer name, or layer object\n * @see MASCP.Layer#event:visibilityChange\n */\nSequenceRenderer.prototype.showLayer = function (lay, consumeChange) {\n    var layer = _MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getLayer(lay);\n\n    if (!layer || layer.disabled) {\n        return;\n    }\n    this._container.classList.add(layer.name + '_active');\n    this._container.classList.add('active_layer');\n    this._container.classList.remove(layer.name + '_inactive');\n    if (!consumeChange) {\n        _bean__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fire(layer, 'visibilityChange', [this, true]);\n    }\n    return this;\n};\n\n/**\n * Hide the given layer\n * @param {String|Object} layer Layer name, or layer object\n * @see MASCP.Layer#event:visibilityChange\n */\nSequenceRenderer.prototype.hideLayer = function (lay, consumeChange) {\n    var layer = _MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getLayer(lay);\n\n    if (!layer || layer.disabled) {\n        return;\n    }\n\n    this._container.classList.remove(layer.name + '_active');\n    this._container.classList.remove('active_layer');\n    this._container.classList.add(layer.name + '_inactive');\n    if (!consumeChange) {\n        _bean__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fire(layer, 'visibilityChange', [this, false]);\n    }\n    return this;\n};\n\n/**\n * Register a layer with this renderer. Actually is a proxy on to the global registry method\n * @see MASCP#registerLayer\n */\nSequenceRenderer.prototype.registerLayer = function (layer, options) {\n    return _MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"].registerLayer(layer, options);\n};\n\n/**\n * Hide or show a group. Fires an event when this method is called.\n * @param {Object} grp Group to set the visibility for\n * @param {Boolean} visibility True for visible, false for hidden\n * @see MASCP.Group#event:visibilityChange\n */\nSequenceRenderer.prototype.setGroupVisibility = function (grp, visibility, consumeChange) {\n    var group = _MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getGroup(grp);\n    if (!group) {\n        return;\n    }\n    var groupName = group.name;\n\n    var renderer = this;\n\n    group.eachLayer(function (layer) {\n        if (_MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getGroup(layer) === layer) {\n            // We can skip explicitly setting the visibility of groups here, since\n            // any sub-groups should have a controller.\n            return;\n        }\n        if (this.disabled && visibility) {\n            renderer.hideLayer(layer.name);\n            return;\n        }\n        if (visibility === true) {\n            renderer.showLayer(layer.name);\n        } else if (visibility === false) {\n            renderer.hideLayer(layer.name);\n        } else {\n            renderer.toggleLayer(layer.name);\n        }\n    });\n    if (visibility !== null && !consumeChange) {\n        _bean__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fire(group, 'visibilityChange', [renderer, visibility]);\n    }\n};\n\n/**\n * Hide a group. Fires an event when this method is called.\n * @param {Object} grp Group to set the visibility for\n * @see MASCP.Group#event:visibilityChange\n */\nSequenceRenderer.prototype.hideGroup = function (group, consumeChange) {\n    this.setGroupVisibility(group, false, consumeChange);\n};\n\n/**\n * Show a group. Fires an event when this method is called.\n * @param {Object} grp Group to set the visibility for\n * @see MASCP.Group#event:visibilityChange\n */\nSequenceRenderer.prototype.showGroup = function (group, consumeChange) {\n    this.setGroupVisibility(group, true, consumeChange);\n};\n\n/**\n * Toggle the visibility for a group. Fires an event when this method is called.\n * @param {Object} grp Group to set the visibility for\n * @see MASCP.Group#event:visibilityChange\n */\nSequenceRenderer.prototype.toggleGroup = function (group, consumeChange) {\n    this.setGroupVisibility(group, consumeChange);\n};\n\n/**\n * Check if the given layer is active\n * @param {String|Object} layer Layer name, or layer object\n * @returns Whether this layer is active on this renderer\n * @type Boolean\n */\nSequenceRenderer.prototype.isLayerActive = function (layer) {\n    var layerName = layer;\n    if (typeof layer != 'string') {\n        layerName = layer.name;\n    }\n    return !layer.disabled && this._container.classList.contains(layerName + '_active');\n};\n\n/**\n * Deprecated until there's a better implementation for the CondensedSequenceRenderer\n * @private\n */\n\nSequenceRenderer.prototype._setHighlight = function (layer, isHighlighted) {\n    return;\n};\n\n/**\n * Create a layer controller for this sequence renderer. Attach the controller to the containing box, and shift the box across 20px.\n */\nSequenceRenderer.prototype.createLayerController = function () {\n    console.log(\"createLayerController is deprected\");\n    return;\n};\n\n/**\n * Create a checkbox that is used to control the given layer\n * @param {String|Object} layer Layer name or layer object that a controller should be generated for\n * @param {Object} inputElement Optional input element to bind events to. If no element is given, a new one is created.\n * @returns Checkbox element that when checked will toggle on the layer, and toggle it off when unchecked\n * @type Object\n */\nSequenceRenderer.prototype.createLayerCheckbox = function (layer, inputElement, exclusive) {\n    console.log(\"createLayerCheckbox is deprecated\");\n    return;\n};\n\nSequenceRenderer.prototype._removeOtherBindings = function (object, inputElement) {\n    var renderer = this;\n\n    for (var i = 0; i < inputElement._current_bindings.length; i++) {\n        if (inputElement._current_bindings[i].renderer != renderer) {\n            continue;\n        }\n        var cb = inputElement._current_bindings[i];\n\n        if (cb.layer && cb.layer != object.name) {\n            _bean__WEBPACK_IMPORTED_MODULE_1__[\"default\"].remove(_MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getLayer(cb.layer), 'visibilityChange', cb.object_function);\n            _bean__WEBPACK_IMPORTED_MODULE_1__[\"default\"].remove(inputElement, 'change', cb.input_function);\n        }\n\n        if (cb.group && cb.group != object.name) {\n            _bean__WEBPACK_IMPORTED_MODULE_1__[\"default\"].remove(_MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getGroup(cb.group), 'visibilityChange', cb.object_function);\n            _bean__WEBPACK_IMPORTED_MODULE_1__[\"default\"].remove(inputElement, 'change', cb.input_function);\n        }\n        cb.group = null;\n        cb.layer = null;\n    }\n};\n\n/**\n * Create a layer based controller for a group. This layer can act as a proxy for the other layers\n * @param {Object} lay Layer to turn into a group controller\n * @param {Object} grp Group to be controlled by this layer.\n */\n\nSequenceRenderer.prototype.createGroupController = function (lay, grp) {\n    var layer = _MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getLayer(lay);\n    var group = _MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getGroup(grp);\n\n    var self = this;\n    _bean__WEBPACK_IMPORTED_MODULE_1__[\"default\"].add(layer, 'visibilityChange', function (rend, visible) {\n        if (rend == self) {\n            self.setGroupVisibility(group, visible);\n            self.refresh();\n        }\n    });\n};\n\n/**\n * Function to be added to Amino acid elements to facilitate adding elements to layers\n * @private\n * @param {String} layerName The layer that this amino acid should be added to\n * @returns Itself\n * @type Element\n */\nSequenceRenderer.addElementToLayer = function (layerName) {\n    this.addBoxOverlay(layerName, 1);\n    return this;\n};\n\n/**\n * Function to be added to Amino acid elements to facilitate adding elements to layers with a link\n * @private\n * @param {String} layerName The layer that this amino acid should be added to\n * @param {String} url URL to link to\n * @returns Itself\n * @type Element\n */\nSequenceRenderer.addElementToLayerWithLink = function (layerName, url, width) {\n    this.classList.add(layerName);\n    var anchor = document.createElement('a');\n    anchor.setAttribute('href', url);\n    anchor.classList.add(layerName + '_overlay');\n    anchor.setAttribute('style', 'display: box; left: 0px; top: 0px; width: 100%; position: absolute; height: 100%;');\n    anchor.textContent = '&nbsp;';\n    this.appendChild(anchor);\n    while (width && width > 0) {\n        this._renderer._sequence_els[this._index + width].addToLayerWithLink(layerName, url);\n        width -= 1;\n    }\n    if (this._z_indexes && this._z_indexes[layerName]) {\n        anchor.style.zIndex = this._z_indexes[layerName];\n    }\n    return this;\n};\n\n/**\n * Function to be added to Amino acid elements to facilitate adding box overlays to elements\n * @private\n * @param {String} layerName The layer that this amino acid should be added to, as well as the fraction opacity to use for this overlay\n * @returns Itself\n * @type Element\n */\nSequenceRenderer.addBoxOverlayToElement = function (layerName, width, fraction) {\n    if (typeof fraction == 'undefined') {\n        fraction = 1;\n    }\n\n    this.classList.add(layerName);\n    var new_el = document.createElement('div');\n    new_el.classList.add(layerName + '_overlay');\n    new_el.setAttribute('style', 'top: 0px; width: 100%; position: absolute; height: 100%; opacity:' + fraction + ';');\n    this.appendChild(new_el);\n    while (width && width > 1) {\n        this._renderer._sequence_els[this._index + width - 1].addBoxOverlay(layerName, 0, fraction);\n        width -= 1;\n    }\n    if (this._z_indexes && this._z_indexes[layerName]) {\n        new_el.style.zIndex = this._z_indexes[layerName];\n    }\n    var event_names = ['mouseover', 'mousedown', 'mousemove', 'mouseout', 'click', 'dblclick', 'mouseup', 'mouseenter', 'mouseleave'];\n    for (var i = 0; i < event_names.length; i++) {\n        _bean__WEBPACK_IMPORTED_MODULE_1__[\"default\"].add(new_el, event_names[i], function () {\n            return function (e) {\n                _bean__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fire(_MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getLayer(layerName), e.type, [e, 'SequenceRenderer']);\n            };\n        }(i));\n    }\n    return this;\n};\n\n/**\n * Reset this renderer. Hide all groups and layers, disabling them in the registry.\n */\nSequenceRenderer.prototype.reset = function () {\n    while (this._container.classList.length > 0) {\n        this._container.classList.remove(this._container.classList.item(0));\n    }\n    for (var group in _MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"].groups) {\n        if (_MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"].groups.hasOwnProperty(group)) {\n            this.hideGroup(group);\n        }\n    }\n    for (var layer in _MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"].layers) {\n        if (_MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"].layers.hasOwnProperty(layer)) {\n            if (!this.keeptracks) {\n                this.hideLayer(layer, true);\n                _MASCP__WEBPACK_IMPORTED_MODULE_0__[\"default\"].layers[layer].disabled = true;\n            }\n        }\n    }\n\n    if (this.resetAnnotations) {\n        this.resetAnnotations();\n    }\n};\n\n/**\n * Execute the given block of code (in the renderer context) moving the refresh method away so that it is not called\n * @param {Function} func Function that contains operations to run without refreshing the renderer\n */\nSequenceRenderer.prototype.withoutRefresh = function (func) {\n    var curr_refresh = this.refresh;\n    this.refresh = function () {};\n    this.refresh.suspended = true;\n    func.apply(this);\n    this.refresh = curr_refresh;\n};\n\n/**\n * Refresh the display for this sequence renderer\n */\nSequenceRenderer.prototype.refresh = function () {\n    var z_index = -2;\n    if (!this._z_indexes) {\n        this._z_indexes = {};\n    }\n    for (var i = 0; i < (this.trackOrder || []).length; i++) {\n        if (!this.isLayerActive(this.trackOrder[i])) {\n            continue;\n        }\n        Array.prototype.slice.call(document.querySelectorAll('.' + this.trackOrder[i] + '_overlay')).forEach(function (el) {\n            el.style.zIndex = z_index;\n        });\n        this._z_indexes[this.trackOrder[i]] = z_index;\n        z_index -= 1;\n    }\n};\n\n/**\n * Bind a function to execute on a particular event for this object\n * @param {String} ev Event name\n * @param {Function} func Function to execute\n */\n\nSequenceRenderer.prototype.bind = function (ev, func) {\n    _bean__WEBPACK_IMPORTED_MODULE_1__[\"default\"].add(this, ev, func);\n};\n\nSequenceRenderer.prototype.unbind = function (ev, func) {\n    _bean__WEBPACK_IMPORTED_MODULE_1__[\"default\"].remove(this, ev, func);\n};\n\nSequenceRenderer.prototype.trigger = function (ev, args) {\n    _bean__WEBPACK_IMPORTED_MODULE_1__[\"default\"].fire(this, ev, args);\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (SequenceRenderer);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9qcy9saWIvU2VxdWVuY2VSZW5kZXJlci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9qcy9saWIvU2VxdWVuY2VSZW5kZXJlci5qcz9lN2ZmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGZpbGVPdmVydmlldyAgICBSZWFkIGluIHNlcXVlbmNlcyB0byBiZSByZS1yZW5kZXJlZCBpbiBhIGJsb2NrIHRoYXQgY2FuIGJlIGVhc2lseSBhbm5vdGF0ZWQuXG4gKi9cblxuaW1wb3J0IE1BU0NQIGZyb20gJy4vTUFTQ1AnO1xuaW1wb3J0IGJlYW4gZnJvbSAnLi4vYmVhbic7XG5cblxuLyoqXG4gKiBAY2xhc3MgICBSZWZvcm1hdHRlciBmb3Igc2VxdWVuY2VzIGluIGh0bWwgcGFnZXMuIFRoZSBvYmplY3QgcmV0cmlldmVzIHRoZSBhbWlubyBhY2lkIHNlcXVlbmNlIGZyb20gdGhlIFxuICogICAgICAgICAgZ2l2ZW4gZWxlbWVudCwgYW5kIHRoZW4gcmVmb3JtYXRzIHRoZSBkaXNwbGF5IG9mIHRoZSBzZXF1ZW5jZSBzbyB0aGF0IHJlbmRlcmluZyBsYXllcnMgY2FuIGJlXG4gKiAgICAgICAgICBhcHBsaWVkIHRvIGl0LiBcbiAqIEBhdXRob3IgIGhqam9zaGlcbiAqIEBwYXJhbSAgIHtFbGVtZW50fSBzZXF1ZW5jZUNvbnRhaW5lciBDb250YWluZXIgZWxlbWVudCB0aGF0IHRoZSBzZXF1ZW5jZSBjdXJyZW50bHkgaXMgZm91bmQgaW4sIGFuZCBhbHNvIFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZSBjb250YWluZXIgdGhhdCBkYXRhIHdpbGwgYmUgcmUtaW5zZXJ0ZWQgaW50by5cbiAqL1xuY29uc3QgU2VxdWVuY2VSZW5kZXJlciA9IChmdW5jdGlvbigpIHtcblxuICAgIC8qKlxuICAgICAqICBAbGVuZHMgU2VxdWVuY2VSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiAgQHByb3BlcnR5ICAge0FycmF5fSAgICAgdHJhY2tPcmRlciAgVGhlIG9yZGVyIG9mIHRyYWNrcyBvbiB0aGUgcmVuZGVyZXIsIGFuIGFycmF5IG9mIGxheWVyL2dyb3VwIG5hbWVzLlxuICAgICAqL1xuICAgIHZhciBzZXR1cFRyYWNrT3JkZXIgPSBmdW5jdGlvbihyZW5kZXJlcikge1xuICAgICAgICB2YXIgcmVuZGVyZXJfdHJhY2tfb3JkZXIgPSBbXTtcblxuICAgICAgICB2YXIgYWNjZXNzb3JzID0ge1xuXG4gICAgICAgICAgICBnZXRUcmFja09yZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVuZGVyZXJfdHJhY2tfb3JkZXI7XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICBzZXRUcmFja09yZGVyOiBmdW5jdGlvbihpbl9vcmRlcikge1xuICAgICAgICAgICAgICAgIHZhciB0cmFja19vcmRlciA9IFtdO1xuICAgICAgICAgICAgICAgIHZhciBvcmRlciA9IGluX29yZGVyO1xuICAgICAgICAgICAgICAgIGlmICggISBvcmRlciBpbnN0YW5jZW9mIEFycmF5ICkge1xuICAgICAgICAgICAgICAgICAgICBvcmRlciA9IFsgaW5fb3JkZXIgXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvcmRlci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYV90cmFjayA9IG9yZGVyW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoTUFTQ1AuZ2V0TGF5ZXIoYV90cmFjaykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICh0cmFja19vcmRlci5pbmRleE9mKGFfdHJhY2spID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFja19vcmRlci5zcGxpY2UodHJhY2tfb3JkZXIuaW5kZXhPZihhX3RyYWNrKSwxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNrX29yZGVyLnB1c2goYV90cmFjayk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKE1BU0NQLmdldEdyb3VwKGFfdHJhY2spKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgaW5zZXJ0X2lkeD0gaSsxO1xuICAgICAgICAgICAgICAgICAgICAgICAgTUFTQ1AuZ2V0R3JvdXAob3JkZXJbaV0pLmVhY2hMYXllcihmdW5jdGlvbihncnBfbGF5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHRyYWNrX29yZGVyLmluZGV4T2YoZ3JwX2xheS5uYW1lKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNrX29yZGVyLnNwbGljZSh0cmFja19vcmRlci5pbmRleE9mKGdycF9sYXkubmFtZSksMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yZGVyLnNwbGljZShpbnNlcnRfaWR4LDAsZ3JwX2xheS5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnNlcnRfaWR4ICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAoKHJlbmRlcmVyX3RyYWNrX29yZGVyIHx8IFtdKS5sZW5ndGggLSAxKTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRyYWNrX29yZGVyLmluZGV4T2YocmVuZGVyZXJfdHJhY2tfb3JkZXJbaV0pIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oaWRlTGF5ZXIocmVuZGVyZXJfdHJhY2tfb3JkZXJbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oaWRlR3JvdXAocmVuZGVyZXJfdHJhY2tfb3JkZXJbaV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE1BU0NQLmdldExheWVyKHJlbmRlcmVyX3RyYWNrX29yZGVyW2ldKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlYW4uZmlyZShNQVNDUC5nZXRMYXllcihyZW5kZXJlcl90cmFja19vcmRlcltpXSksJ3JlbW92ZWQnLFtyZW5kZXJlcl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE1BU0NQLmdldEdyb3VwKHJlbmRlcmVyX3RyYWNrX29yZGVyW2ldKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlYW4uZmlyZShNQVNDUC5nZXRHcm91cChyZW5kZXJlcl90cmFja19vcmRlcltpXSksJ3JlbW92ZWQnLFtyZW5kZXJlcl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlbmRlcmVyX3RyYWNrX29yZGVyID0gdHJhY2tfb3JkZXI7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZWZyZXNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVmcmVzaCh0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYmVhbi5maXJlKHJlbmRlcmVyLCdvcmRlckNoYW5nZWQnLCBbIHRyYWNrX29yZGVyIF0gKTtcblxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChNQVNDUC5JRSkge1xuICAgICAgICAgICAgcmVuZGVyZXIuc2V0VHJhY2tPcmRlciA9IGFjY2Vzc29ycy5zZXRUcmFja09yZGVyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCh0eXBlb2YgT2JqZWN0LmRlZmluZVByb3BlcnR5ID09ICdmdW5jdGlvbicpICYmICEgTUFTQ1AuSUU4ICkge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlbmRlcmVyLFwidHJhY2tPcmRlclwiLCB7XG4gICAgICAgICAgICAgICAgZ2V0IDogYWNjZXNzb3JzLmdldFRyYWNrT3JkZXIsXG4gICAgICAgICAgICAgICAgc2V0IDogYWNjZXNzb3JzLnNldFRyYWNrT3JkZXJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBmdW5jdGlvbihzZXF1ZW5jZUNvbnRhaW5lcikge1xuICAgICAgICBpZiAoISBzZXF1ZW5jZUNvbnRhaW5lcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBzZXF1ZW5jZUNvbnRhaW5lciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRhaW5lciA9IHNlcXVlbmNlQ29udGFpbmVyO1xuICAgICAgICAgICAgaWYgKCAhIHRoaXMuX2NvbnRhaW5lci5zdHlsZS5wb3NpdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRhaW5lci5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG4gICAgICAgICAgICB9XG4gICAgLy8gICAgICAgIHRoaXMuX2NvbnRhaW5lci5zdHlsZS53aWR0aCA9ICcxMDAlJztcblxuICAgICAgICAgICAgYmVhbi5hZGQodGhpcywnc2VxdWVuY2VDaGFuZ2UnLCBmdW5jdGlvbihlKXtcbiAgICAgICAgICAgICAgICB3aGlsZSAoc2VxdWVuY2VDb250YWluZXIuZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICBzZXF1ZW5jZUNvbnRhaW5lci5yZW1vdmVDaGlsZChzZXF1ZW5jZUNvbnRhaW5lci5maXJzdENoaWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fc2VxdWVuY2VfZWxzLmZvckVhY2goZnVuY3Rpb24oZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VxdWVuY2VDb250YWluZXIuYXBwZW5kQ2hpbGQoZWwpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHZhciBmbG9hdF9jbGVhciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgICAgIGZsb2F0X2NsZWFyLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCdjbGVhcjogYm90aDsgZmxvYXQ6IG5vbmU7IGhlaWdodDogMHB4OyB3aWR0aDogMTAwJTsnKTtcbiAgICAgICAgICAgICAgICBzZXF1ZW5jZUNvbnRhaW5lci5hcHBlbmRDaGlsZChmbG9hdF9jbGVhcik7XG4gICAgICAgICAgICAgICAgc2VxdWVuY2VDb250YWluZXIuc3R5bGUud2lkdGggPSAodGhpcy5fc2VxdWVuY2VfZWxzLmxlbmd0aCkrJ2VtJztcbiAgICAvLyAgICAgICAgICAgIHRoaXMuc2hvd1Jvd051bWJlcnMoKTsgICAgICAgICAgICBcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB0aGlzLnNldFNlcXVlbmNlKHNlcXVlbmNlQ29udGFpbmVyLnRleHRDb250ZW50IHx8ICcnKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgc2V0dXBUcmFja09yZGVyKHRoaXMpO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbn0pKCk7XG5cbi8qKlxuICogRXZlbnQgZmlyZWQgd2hlbiBhIGxheWVyIGlzIHJlZ2lzdGVyZWQgd2l0aCB0aGUgZ2xvYmFsIGxheWVyIHJlZ2lzdHJ5XG4gKiBAbmFtZSAgICBNQVNDUC5sYXllclJlZ2lzdGVyZWRcbiAqIEBldmVudFxuICogQHBhcmFtICAge09iamVjdH0gICAgZVxuICogQHBhcmFtICAge09iamVjdH0gICAgbGF5ZXIgTGF5ZXIganVzdCByZWdpc3RlcmVkXG4gKi9cblxuLyoqXG4gKiBFdmVudCBmaXJlZCB3aGVuIGEgZ3JvdXAgaXMgcmVnaXN0ZXJlZCB3aXRoIHRoZSBnbG9iYWwgZ3JvdXAgcmVnaXN0cnlcbiAqIEBuYW1lICAgIE1BU0NQLmdyb3VwUmVnaXN0ZXJlZFxuICogQGV2ZW50XG4gKiBAcGFyYW0gICB7T2JqZWN0fSAgICBlXG4gKiBAcGFyYW0gICB7T2JqZWN0fSAgICBncm91cCBHcm91cCBqdXN0IHJlZ2lzdGVyZWRcbiAqL1xuXG4vKipcbiAqIEV2ZW50IGZpcmVkIHdoZW4gdGhlIHNlcXVlbmNlIGlzIGNoYW5nZWQgaW4gYSBzZXF1ZW5jZSByZW5kZXJlclxuICogQG5hbWUgICAgU2VxdWVuY2VSZW5kZXJlciNzZXF1ZW5jZUNoYW5nZVxuICogQGV2ZW50XG4gKiBAcGFyYW0gICB7T2JqZWN0fSAgICBlXG4gKi9cblxuLyoqXG4gKiBFdmVudCBmaXJlZCB3aGVuIGEgcmVzdWx0IGlzIHJlbmRlcmVkIG9uIHRoaXMgcmVuZGVyZXJcbiAqIEBuYW1lICAgIFNlcXVlbmNlUmVuZGVyZXIjcmVzdWx0c1JlbmRlcmVkXG4gKiBAZXZlbnRcbiAqIEBwYXJhbSAgIHtPYmplY3R9ICAgIGVcbiAqIEBwYXJhbSAgIHtNQVNDUC5TZXJ2aWNlfSByZWFkZXIgIFJlYWRlciB0aGF0IHJlbmRlcmVkIHRoZSByZXN1bHQuXG4gKi9cblxuLyoqXG4gKiBAbmFtZSAgICBNQVNDUC5Hcm91cCN2aXNpYmlsaXR5Q2hhbmdlXG4gKiBAZXZlbnRcbiAqIEBwYXJhbSAgIHtPYmplY3R9ICAgIGVcbiAqIEBwYXJhbSAgIHtPYmplY3R9ICAgIHJlbmRlcmVyXG4gKiBAcGFyYW0gICB7Qm9vbGVhbn0gICB2aXNpYmlsaXR5XG4gKi9cblxuLyoqXG4gKiBAbmFtZSAgICBNQVNDUC5MYXllciN2aXNpYmlsaXR5Q2hhbmdlXG4gKiBAZXZlbnRcbiAqIEBwYXJhbSAgIHtPYmplY3R9ICAgIGVcbiAqIEBwYXJhbSAgIHtPYmplY3R9ICAgIHJlbmRlcmVyXG4gKiBAcGFyYW0gICB7Qm9vbGVhbn0gICB2aXNpYmlsaXR5XG4gKi9cblxuXG5cbi8qKlxuICogIEBsZW5kcyBTZXF1ZW5jZVJlbmRlcmVyLnByb3RvdHlwZVxuICogIEBwcm9wZXJ0eSAgIHtTdHJpbmd9ICBzZXF1ZW5jZSAgU2VxdWVuY2UgdG8gbWFyayB1cC5cbiAqL1xuU2VxdWVuY2VSZW5kZXJlci5wcm90b3R5cGUgPSB7XG4gICAgc2VxdWVuY2U6IG51bGwgXG59O1xuIFxuaWYgKCBNQVNDUC5JRSApIHtcbiAgICBTZXF1ZW5jZVJlbmRlcmVyLnByb3RvdHlwZS5wcm90b3R5cGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbn1cblxuXG4vKipcbiAqIFNldCB0aGUgc2VxdWVuY2UgZm9yIHRoaXMgcmVuZGVyZXIuIEZpcmVzIHRoZSBzZXF1ZW5jZUNoYW5nZSBldmVudCB3aGVuIHRoZSBzZXF1ZW5jZSBpcyBzZXQuXG4gKiBAcGFyYW0ge1N0cmluZ30gc2VxdWVuY2UgU2VxdWVuY2UgdG8gcmVuZGVyXG4gKiBAc2VlIFNlcXVlbmNlUmVuZGVyZXIjZXZlbnQ6c2VxdWVuY2VDaGFuZ2VcbiAqL1xuU2VxdWVuY2VSZW5kZXJlci5wcm90b3R5cGUuc2V0U2VxdWVuY2UgPSBmdW5jdGlvbihzZXF1ZW5jZSlcbntcbiAgICB0aGlzLnNlcXVlbmNlID0gdGhpcy5fY2xlYW5TZXF1ZW5jZShzZXF1ZW5jZSk7XG4gICAgdmFyIHNlcXVlbmNlX2VscyA9IFtdO1xuICAgIHZhciByZW5kZXJlciA9IHRoaXM7XG4gICAgaWYgKCAhIHRoaXMuc2VxdWVuY2UgKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHNlcV9jaGFycyA9IHRoaXMuc2VxdWVuY2Uuc3BsaXQoJycpO1xuICAgIGZvciAodmFyIGkgPTA7IGkgPCBzZXFfY2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGFhID0gc2VxX2NoYXJzW2ldO1xuICAgICAgICBpZiAoYWEubWF0Y2goL1tBLVphLXpdLykpIHtcbiAgICAgICAgICAgIHZhciBzcGFuX2VsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgICAgICAgc3Bhbl9lbC50ZXh0Q29udGVudCA9IGFhO1xuICAgICAgICAgICAgc2VxdWVuY2VfZWxzLnB1c2goc3Bhbl9lbCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXF1ZW5jZV9lbHMuZm9yRWFjaCggZnVuY3Rpb24oZWwsaSkge1xuICAgICAgICAvLyBpZiAoIChpICUgMTApID09IDAgJiYgaSA+IDAgJiYgKChpICUgNTApICE9IDApKSB7XG4gICAgICAgIC8vICAgICB0aGlzLnN0eWxlLm1hcmdpbiA9ICcwcHggMHB4IDBweCAxZW0nO1xuICAgICAgICAvLyB9XG4gICAgICAgIC8vIGlmICggKGkgJSA1MCkgPT0gMCAmJiBpID4gMCApIHtcbiAgICAgICAgLy8gICAgIGlmIChNQVNDUC5JRTcpIHtcbiAgICAgICAgLy8gICAgICAgICBzZXF1ZW5jZV9lbHNbaS0xXS5zdHlsZS5zdHlsZUZsb2F0ID0gJ25vbmUnO1xuICAgICAgICAvLyAgICAgICAgIHNlcXVlbmNlX2Vsc1tpLTFdLnN0eWxlLndpZHRoID0gJzFlbSc7XG4gICAgICAgIC8vICAgICB9XG4gICAgICAgIC8vICAgICB0aGlzLnN0eWxlLmNsZWFyID0gJ2JvdGgnO1xuICAgICAgICAvLyB9XG4gICAgICAgIFxuICAgICAgICBlbC5faW5kZXggPSBpO1xuICAgICAgICBcbiAgICAgICAgZWwuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgIGVsLnN0eWxlLmNzc0Zsb2F0ID0gJ2xlZnQnO1xuICAgICAgICBlbC5zdHlsZS5zdHlsZUZsb2F0ID0gJ2xlZnQnO1xuICAgICAgICBlbC5zdHlsZS5oZWlnaHQgPSAnMS4xZW0nO1xuICAgICAgICBlbC5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG5cbiAgICAgICAgZWwuYWRkVG9MYXllciA9IFNlcXVlbmNlUmVuZGVyZXIuYWRkRWxlbWVudFRvTGF5ZXI7XG4gICAgICAgIGVsLmFkZEJveE92ZXJsYXkgPSBTZXF1ZW5jZVJlbmRlcmVyLmFkZEJveE92ZXJsYXlUb0VsZW1lbnQ7XG4gICAgICAgIGVsLmFkZFRvTGF5ZXJXaXRoTGluayA9IFNlcXVlbmNlUmVuZGVyZXIuYWRkRWxlbWVudFRvTGF5ZXJXaXRoTGluaztcbiAgICAgICAgZWwuX3JlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgfSk7XG4gICAgdGhpcy5fc2VxdWVuY2VfZWxzID0gc2VxdWVuY2VfZWxzOyAgIFxuICAgIGJlYW4uZmlyZSh0aGlzLCdzZXF1ZW5jZUNoYW5nZScpO1xufTtcblxuLyoqXG4gKiBDb2xvciBzb21lIHJlc2lkdWVzIG9uIHRoaXMgcmVzaWR1ZVxuICogQHBhcmFtIHtBcnJheX0gaW5kZXhlcyBJbmRleGVzIHRvIGFwcGx5IHRoZSBnaXZlbiBjb2xvciB0b1xuICogQHBhcmFtIHtTdHJpbmd9IGNvbG9yIENvbG9yIHRvIHVzZSB0byBoaWdobGlnaHQgdGhlIHJlc2lkdWVzXG4gKiBAcmV0dXJucyBJRCBmb3IgdGhlIGxheWVyIHRoYXQgaXMgY3JlYXRlZFxuICogQHR5cGUgU3RyaW5nXG4gKi9cblNlcXVlbmNlUmVuZGVyZXIucHJvdG90eXBlLmNvbG9yUmVzaWR1ZXMgPSBmdW5jdGlvbihpbmRleGVzLCBjb2xvcikge1xuICAgIHZhciBsYXllcl9pZCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSoxMDAwKS50b1N0cmluZygpO1xuICAgIE1BU0NQLnJlZ2lzdGVyTGF5ZXIobGF5ZXJfaWQsIHsgJ2NvbG9yJyA6IChjb2xvciB8fCAnI2ZmMDAwMCcpIH0pO1xuICAgIHZhciBhYXMgPSB0aGlzLmdldEFtaW5vQWNpZHNCeVBvc2l0aW9uKGluZGV4ZXMpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYWFzLmxlbmd0aDsgaSsrICkge1xuICAgICAgICBhYXNbaV0uYWRkVG9MYXllcihsYXllcl9pZCk7XG4gICAgfVxuICAgIHJldHVybiBNQVNDUC5nZXRMYXllcihsYXllcl9pZCk7XG59O1xuXG5cblNlcXVlbmNlUmVuZGVyZXIucHJvdG90eXBlLl9jbGVhblNlcXVlbmNlID0gZnVuY3Rpb24oc2VxdWVuY2UpIHtcbiAgICBpZiAoICEgc2VxdWVuY2UgKSB7XG4gICAgICAgIHJldHVybiBzZXF1ZW5jZTtcbiAgICB9XG4gICAgdmFyIGNsZWFuZWRfc2VxdWVuY2UgPSBzZXF1ZW5jZTtcbiAgICBjbGVhbmVkX3NlcXVlbmNlID0gY2xlYW5lZF9zZXF1ZW5jZS5yZXBsYWNlKG5ldyBSZWdFeHAoU3RyaW5nLmZyb21DaGFyQ29kZSgxNjApLFwiZ1wiKSwnJyk7XG4gICAgY2xlYW5lZF9zZXF1ZW5jZSA9IGNsZWFuZWRfc2VxdWVuY2UucmVwbGFjZSgvW1xcblxcdFxcc1xcZF0rL21naSwnJyk7XG4gICAgY2xlYW5lZF9zZXF1ZW5jZSA9IGNsZWFuZWRfc2VxdWVuY2UucmVwbGFjZSgvXFwoLipcXCkvZywnJyk7XG4gICAgcmV0dXJuIGNsZWFuZWRfc2VxdWVuY2U7XG59O1xuXG4vKipcbiAqIFJldHJpZXZlIHRoZSBIVE1MIEVsZW1lbnRzIHRoYXQgY29udGFpbiB0aGUgYW1pbm8gYWNpZHMgYXQgdGhlIGdpdmVuIHBvc2l0aW9ucy4gVGhlIGZpcnN0IGFtaW5vIGFjaWQgaXMgZm91bmQgYXQgcG9zaXRpb24gMS5cbiAqIEBwYXJhbSB7QXJyYXl9IGluZGV4ZXMgSW5kZXhlcyB0byByZXRyaWV2ZSBlbGVtZW50cyBmb3JcbiAqIEByZXR1cm5zIEVsZW1lbnRzIHJlcHJlc2VudGluZyBlYWNoIGFtaW5vIGFjaWQgYXQgdGhlIGdpdmVuIHBvc2l0aW9uc1xuICogQHR5cGUgQXJyYXlcbiAqL1xuU2VxdWVuY2VSZW5kZXJlci5wcm90b3R5cGUuZ2V0QW1pbm9BY2lkc0J5UG9zaXRpb24gPSBmdW5jdGlvbihpbmRleGVzKSB7XG4gICAgdmFyIHNlcXVlbmNlX2VscyA9IHRoaXMuX3NlcXVlbmNlX2VscztcbiAgICByZXR1cm4gaW5kZXhlcy5tYXAoZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlcXVlbmNlX2Vsc1tpbmRleC0xXTtcbiAgICB9KTtcbn07XG5cblNlcXVlbmNlUmVuZGVyZXIucHJvdG90eXBlLmdldEFBID0gZnVuY3Rpb24oaW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRBbWlub0FjaWRzQnlQb3NpdGlvbihbaW5kZXhdKS5zaGlmdCgpO1xufTtcblxuXG4vKipcbiAqIFJldHJpZXZlIHRoZSBIVE1MIEVsZW1lbnRzIHRoYXQgY29udGFpbiB0aGUgYW1pbm8gYWNpZHMgY29udGFpbmVkIGluIHRoZSBnaXZlbiBwZXB0aWRlIHNlcXVlbmNlLlxuICogQHBhcmFtIHtTdHJpbmd9IHBlcHRpZGVTZXF1ZW5jZSBQZXB0aWRlIHNlcXVlbmNlIHVzZWQgdG8gbG9vayB1cCB0aGUgYW1pbm8gYWNpZHNcbiAqIEByZXR1cm5zIEVsZW1lbnRzIHJlcHJlc2VudGluZyBlYWNoIGFtaW5vIGFjaWQgYXQgdGhlIGdpdmVuIHBvc2l0aW9uc1xuICogQHR5cGUgQXJyYXlcbiAqL1xuU2VxdWVuY2VSZW5kZXJlci5wcm90b3R5cGUuZ2V0QW1pbm9BY2lkc0J5UGVwdGlkZSA9IGZ1bmN0aW9uKHBlcHRpZGVTZXF1ZW5jZSkge1xuICAgIHZhciBzdGFydCA9IHRoaXMuc2VxdWVuY2UuaW5kZXhPZihwZXB0aWRlU2VxdWVuY2UpO1xuICAgIHZhciByZXN1bHRzID0gW107XG5cbiAgICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgICAgIHJlc3VsdHMuYWRkVG9MYXllciA9IGZ1bmN0aW9uKCkge307XG4gICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgIH1cbiAgICByZXN1bHRzID0gcmVzdWx0cy5jb25jYXQodGhpcy5fc2VxdWVuY2VfZWxzLnNsaWNlKHN0YXJ0LHN0YXJ0KyhwZXB0aWRlU2VxdWVuY2UubGVuZ3RoKSkpO1xuICAgIGlmIChyZXN1bHRzLmxlbmd0aCkge1xuICAgICAgICByZXN1bHRzLmFkZFRvTGF5ZXIgPSBmdW5jdGlvbihsYXllcm5hbWUsIGZyYWN0aW9uLCBvcHRpb25zKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0c1swXS5hZGRCb3hPdmVybGF5KGxheWVybmFtZSxyZXN1bHRzLmxlbmd0aCxmcmFjdGlvbixvcHRpb25zKTtcbiAgICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHRzLmFkZFRvTGF5ZXIgPSBmdW5jdGlvbigpIHt9O1xuICAgIH1cbiAgICAgICAgXG4gICAgcmV0dXJuIHJlc3VsdHM7XG59O1xuXG4vKipcbiAqIFRvZ2dsZSB0aGUgZGlzcGxheSBvZiB0aGUgZ2l2ZW4gbGF5ZXJcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gbGF5ZXIgTGF5ZXIgbmFtZSwgb3IgbGF5ZXIgb2JqZWN0XG4gKiBAc2VlIE1BU0NQLkxheWVyI2V2ZW50OnZpc2liaWxpdHlDaGFuZ2VcbiAqL1xuU2VxdWVuY2VSZW5kZXJlci5wcm90b3R5cGUudG9nZ2xlTGF5ZXIgPSBmdW5jdGlvbihsYXllcixjb25zdW1lQ2hhbmdlKSB7XG4gICAgdmFyIGxheWVyTmFtZSA9IGxheWVyO1xuICAgIGlmICh0eXBlb2YgbGF5ZXIgIT0gJ3N0cmluZycpIHtcbiAgICAgICAgbGF5ZXJOYW1lID0gbGF5ZXIubmFtZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBsYXllciA9IE1BU0NQLmxheWVyc1tsYXllcl07XG4gICAgfVxuICAgIHRoaXMuX2NvbnRhaW5lci5jbGFzc0xpc3QudG9nZ2xlKGxheWVyTmFtZSsnX2FjdGl2ZScpO1xuICAgIHRoaXMuX2NvbnRhaW5lci5jbGFzc0xpc3QudG9nZ2xlKGxheWVyTmFtZSsnX2luYWN0aXZlJyk7XG4gICAgaWYgKCAhIGNvbnN1bWVDaGFuZ2UgKSB7XG4gICAgICAgIGJlYW4uZmlyZShsYXllciwndmlzaWJpbGl0eUNoYW5nZScsW3RoaXMsdGhpcy5pc0xheWVyQWN0aXZlKGxheWVyKV0pO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2hvdyB0aGUgZ2l2ZW4gbGF5ZXJcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gbGF5ZXIgTGF5ZXIgbmFtZSwgb3IgbGF5ZXIgb2JqZWN0XG4gKiBAc2VlIE1BU0NQLkxheWVyI2V2ZW50OnZpc2liaWxpdHlDaGFuZ2VcbiAqL1xuU2VxdWVuY2VSZW5kZXJlci5wcm90b3R5cGUuc2hvd0xheWVyID0gZnVuY3Rpb24obGF5LGNvbnN1bWVDaGFuZ2UpIHtcbiAgICB2YXIgbGF5ZXIgPSBNQVNDUC5nZXRMYXllcihsYXkpO1xuXG4gICAgaWYgKCEgbGF5ZXIgfHwgbGF5ZXIuZGlzYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9jb250YWluZXIuY2xhc3NMaXN0LmFkZChsYXllci5uYW1lKydfYWN0aXZlJyk7XG4gICAgdGhpcy5fY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoJ2FjdGl2ZV9sYXllcicpOyAgICBcbiAgICB0aGlzLl9jb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZShsYXllci5uYW1lKydfaW5hY3RpdmUnKTtcbiAgICBpZiAoICEgY29uc3VtZUNoYW5nZSApIHtcbiAgICAgICAgYmVhbi5maXJlKGxheWVyLCd2aXNpYmlsaXR5Q2hhbmdlJyxbdGhpcyx0cnVlXSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBIaWRlIHRoZSBnaXZlbiBsYXllclxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBsYXllciBMYXllciBuYW1lLCBvciBsYXllciBvYmplY3RcbiAqIEBzZWUgTUFTQ1AuTGF5ZXIjZXZlbnQ6dmlzaWJpbGl0eUNoYW5nZVxuICovXG5TZXF1ZW5jZVJlbmRlcmVyLnByb3RvdHlwZS5oaWRlTGF5ZXIgPSBmdW5jdGlvbihsYXksY29uc3VtZUNoYW5nZSkge1xuICAgIHZhciBsYXllciA9IE1BU0NQLmdldExheWVyKGxheSk7XG5cbiAgICBpZiAoISBsYXllciB8fCBsYXllci5kaXNhYmxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgICAgICBcbiAgICB0aGlzLl9jb250YWluZXIuY2xhc3NMaXN0LnJlbW92ZShsYXllci5uYW1lKydfYWN0aXZlJyk7XG4gICAgdGhpcy5fY29udGFpbmVyLmNsYXNzTGlzdC5yZW1vdmUoJ2FjdGl2ZV9sYXllcicpO1xuICAgIHRoaXMuX2NvbnRhaW5lci5jbGFzc0xpc3QuYWRkKGxheWVyLm5hbWUrJ19pbmFjdGl2ZScpO1xuICAgIGlmICghIGNvbnN1bWVDaGFuZ2UgKSB7XG4gICAgICAgIGJlYW4uZmlyZShsYXllciwndmlzaWJpbGl0eUNoYW5nZScsW3RoaXMsZmFsc2VdKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlZ2lzdGVyIGEgbGF5ZXIgd2l0aCB0aGlzIHJlbmRlcmVyLiBBY3R1YWxseSBpcyBhIHByb3h5IG9uIHRvIHRoZSBnbG9iYWwgcmVnaXN0cnkgbWV0aG9kXG4gKiBAc2VlIE1BU0NQI3JlZ2lzdGVyTGF5ZXJcbiAqL1xuU2VxdWVuY2VSZW5kZXJlci5wcm90b3R5cGUucmVnaXN0ZXJMYXllciA9IGZ1bmN0aW9uKGxheWVyLG9wdGlvbnMpIHtcbiAgICByZXR1cm4gTUFTQ1AucmVnaXN0ZXJMYXllcihsYXllcixvcHRpb25zKTtcbn07XG5cbi8qKlxuICogSGlkZSBvciBzaG93IGEgZ3JvdXAuIEZpcmVzIGFuIGV2ZW50IHdoZW4gdGhpcyBtZXRob2QgaXMgY2FsbGVkLlxuICogQHBhcmFtIHtPYmplY3R9IGdycCBHcm91cCB0byBzZXQgdGhlIHZpc2liaWxpdHkgZm9yXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHZpc2liaWxpdHkgVHJ1ZSBmb3IgdmlzaWJsZSwgZmFsc2UgZm9yIGhpZGRlblxuICogQHNlZSBNQVNDUC5Hcm91cCNldmVudDp2aXNpYmlsaXR5Q2hhbmdlXG4gKi9cblNlcXVlbmNlUmVuZGVyZXIucHJvdG90eXBlLnNldEdyb3VwVmlzaWJpbGl0eSA9IGZ1bmN0aW9uKGdycCx2aXNpYmlsaXR5LGNvbnN1bWVDaGFuZ2UpIHtcbiAgICB2YXIgZ3JvdXAgPSBNQVNDUC5nZXRHcm91cChncnApO1xuICAgIGlmICggISBncm91cCApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgZ3JvdXBOYW1lID0gZ3JvdXAubmFtZTtcbiAgICBcbiAgICB2YXIgcmVuZGVyZXIgPSB0aGlzO1xuXG4gICAgZ3JvdXAuZWFjaExheWVyKGZ1bmN0aW9uKGxheWVyKSB7XG4gICAgICAgIGlmIChNQVNDUC5nZXRHcm91cChsYXllcikgPT09IGxheWVyKSB7XG4gICAgICAgICAgICAvLyBXZSBjYW4gc2tpcCBleHBsaWNpdGx5IHNldHRpbmcgdGhlIHZpc2liaWxpdHkgb2YgZ3JvdXBzIGhlcmUsIHNpbmNlXG4gICAgICAgICAgICAvLyBhbnkgc3ViLWdyb3VwcyBzaG91bGQgaGF2ZSBhIGNvbnRyb2xsZXIuXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZGlzYWJsZWQgJiYgdmlzaWJpbGl0eSkge1xuICAgICAgICAgICAgcmVuZGVyZXIuaGlkZUxheWVyKGxheWVyLm5hbWUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2aXNpYmlsaXR5ID09PSB0cnVlKSB7XG4gICAgICAgICAgICByZW5kZXJlci5zaG93TGF5ZXIobGF5ZXIubmFtZSk7XG4gICAgICAgIH0gZWxzZSBpZiAodmlzaWJpbGl0eSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIHJlbmRlcmVyLmhpZGVMYXllcihsYXllci5uYW1lKTsgICAgICAgICAgICAgICAgXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZW5kZXJlci50b2dnbGVMYXllcihsYXllci5uYW1lKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGlmICh2aXNpYmlsaXR5ICE9PSBudWxsICYmICEgY29uc3VtZUNoYW5nZSkge1xuICAgICAgICBiZWFuLmZpcmUoZ3JvdXAsJ3Zpc2liaWxpdHlDaGFuZ2UnLFtyZW5kZXJlcix2aXNpYmlsaXR5XSk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBIaWRlIGEgZ3JvdXAuIEZpcmVzIGFuIGV2ZW50IHdoZW4gdGhpcyBtZXRob2QgaXMgY2FsbGVkLlxuICogQHBhcmFtIHtPYmplY3R9IGdycCBHcm91cCB0byBzZXQgdGhlIHZpc2liaWxpdHkgZm9yXG4gKiBAc2VlIE1BU0NQLkdyb3VwI2V2ZW50OnZpc2liaWxpdHlDaGFuZ2VcbiAqL1xuU2VxdWVuY2VSZW5kZXJlci5wcm90b3R5cGUuaGlkZUdyb3VwID0gZnVuY3Rpb24oZ3JvdXAsY29uc3VtZUNoYW5nZSkge1xuICAgIHRoaXMuc2V0R3JvdXBWaXNpYmlsaXR5KGdyb3VwLGZhbHNlLGNvbnN1bWVDaGFuZ2UpO1xufTtcblxuLyoqXG4gKiBTaG93IGEgZ3JvdXAuIEZpcmVzIGFuIGV2ZW50IHdoZW4gdGhpcyBtZXRob2QgaXMgY2FsbGVkLlxuICogQHBhcmFtIHtPYmplY3R9IGdycCBHcm91cCB0byBzZXQgdGhlIHZpc2liaWxpdHkgZm9yXG4gKiBAc2VlIE1BU0NQLkdyb3VwI2V2ZW50OnZpc2liaWxpdHlDaGFuZ2VcbiAqL1xuU2VxdWVuY2VSZW5kZXJlci5wcm90b3R5cGUuc2hvd0dyb3VwID0gZnVuY3Rpb24oZ3JvdXAsY29uc3VtZUNoYW5nZSkge1xuICAgIHRoaXMuc2V0R3JvdXBWaXNpYmlsaXR5KGdyb3VwLHRydWUsY29uc3VtZUNoYW5nZSk7XG59O1xuXG4vKipcbiAqIFRvZ2dsZSB0aGUgdmlzaWJpbGl0eSBmb3IgYSBncm91cC4gRmlyZXMgYW4gZXZlbnQgd2hlbiB0aGlzIG1ldGhvZCBpcyBjYWxsZWQuXG4gKiBAcGFyYW0ge09iamVjdH0gZ3JwIEdyb3VwIHRvIHNldCB0aGUgdmlzaWJpbGl0eSBmb3JcbiAqIEBzZWUgTUFTQ1AuR3JvdXAjZXZlbnQ6dmlzaWJpbGl0eUNoYW5nZVxuICovXG5TZXF1ZW5jZVJlbmRlcmVyLnByb3RvdHlwZS50b2dnbGVHcm91cCA9IGZ1bmN0aW9uKGdyb3VwLGNvbnN1bWVDaGFuZ2UpIHtcbiAgICB0aGlzLnNldEdyb3VwVmlzaWJpbGl0eShncm91cCxjb25zdW1lQ2hhbmdlKTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIGxheWVyIGlzIGFjdGl2ZVxuICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBsYXllciBMYXllciBuYW1lLCBvciBsYXllciBvYmplY3RcbiAqIEByZXR1cm5zIFdoZXRoZXIgdGhpcyBsYXllciBpcyBhY3RpdmUgb24gdGhpcyByZW5kZXJlclxuICogQHR5cGUgQm9vbGVhblxuICovXG5TZXF1ZW5jZVJlbmRlcmVyLnByb3RvdHlwZS5pc0xheWVyQWN0aXZlID0gZnVuY3Rpb24obGF5ZXIpIHtcbiAgICB2YXIgbGF5ZXJOYW1lID0gbGF5ZXI7XG4gICAgaWYgKHR5cGVvZiBsYXllciAhPSAnc3RyaW5nJykge1xuICAgICAgICBsYXllck5hbWUgPSBsYXllci5uYW1lO1xuICAgIH1cbiAgICByZXR1cm4gKCEgbGF5ZXIuZGlzYWJsZWQpICYmIHRoaXMuX2NvbnRhaW5lci5jbGFzc0xpc3QuY29udGFpbnMobGF5ZXJOYW1lKydfYWN0aXZlJyk7XG59O1xuXG4vKipcbiAqIERlcHJlY2F0ZWQgdW50aWwgdGhlcmUncyBhIGJldHRlciBpbXBsZW1lbnRhdGlvbiBmb3IgdGhlIENvbmRlbnNlZFNlcXVlbmNlUmVuZGVyZXJcbiAqIEBwcml2YXRlXG4gKi9cblxuU2VxdWVuY2VSZW5kZXJlci5wcm90b3R5cGUuX3NldEhpZ2hsaWdodCA9IGZ1bmN0aW9uKGxheWVyLGlzSGlnaGxpZ2h0ZWQpIHtcbiAgICByZXR1cm47XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIGxheWVyIGNvbnRyb2xsZXIgZm9yIHRoaXMgc2VxdWVuY2UgcmVuZGVyZXIuIEF0dGFjaCB0aGUgY29udHJvbGxlciB0byB0aGUgY29udGFpbmluZyBib3gsIGFuZCBzaGlmdCB0aGUgYm94IGFjcm9zcyAyMHB4LlxuICovXG5TZXF1ZW5jZVJlbmRlcmVyLnByb3RvdHlwZS5jcmVhdGVMYXllckNvbnRyb2xsZXIgPSBmdW5jdGlvbigpIHtcbiAgICBjb25zb2xlLmxvZyhcImNyZWF0ZUxheWVyQ29udHJvbGxlciBpcyBkZXByZWN0ZWRcIik7XG4gICAgcmV0dXJuO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgYSBjaGVja2JveCB0aGF0IGlzIHVzZWQgdG8gY29udHJvbCB0aGUgZ2l2ZW4gbGF5ZXJcbiAqIEBwYXJhbSB7U3RyaW5nfE9iamVjdH0gbGF5ZXIgTGF5ZXIgbmFtZSBvciBsYXllciBvYmplY3QgdGhhdCBhIGNvbnRyb2xsZXIgc2hvdWxkIGJlIGdlbmVyYXRlZCBmb3JcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dEVsZW1lbnQgT3B0aW9uYWwgaW5wdXQgZWxlbWVudCB0byBiaW5kIGV2ZW50cyB0by4gSWYgbm8gZWxlbWVudCBpcyBnaXZlbiwgYSBuZXcgb25lIGlzIGNyZWF0ZWQuXG4gKiBAcmV0dXJucyBDaGVja2JveCBlbGVtZW50IHRoYXQgd2hlbiBjaGVja2VkIHdpbGwgdG9nZ2xlIG9uIHRoZSBsYXllciwgYW5kIHRvZ2dsZSBpdCBvZmYgd2hlbiB1bmNoZWNrZWRcbiAqIEB0eXBlIE9iamVjdFxuICovXG5TZXF1ZW5jZVJlbmRlcmVyLnByb3RvdHlwZS5jcmVhdGVMYXllckNoZWNrYm94ID0gZnVuY3Rpb24obGF5ZXIsaW5wdXRFbGVtZW50LGV4Y2x1c2l2ZSkge1xuICAgIGNvbnNvbGUubG9nKFwiY3JlYXRlTGF5ZXJDaGVja2JveCBpcyBkZXByZWNhdGVkXCIpO1xuICAgIHJldHVybjtcbn07XG5cblxuU2VxdWVuY2VSZW5kZXJlci5wcm90b3R5cGUuX3JlbW92ZU90aGVyQmluZGluZ3MgPSBmdW5jdGlvbihvYmplY3QsaW5wdXRFbGVtZW50KSB7XG4gICAgdmFyIHJlbmRlcmVyID0gdGhpcztcbiAgICBcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGlucHV0RWxlbWVudC5fY3VycmVudF9iaW5kaW5ncy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoIGlucHV0RWxlbWVudC5fY3VycmVudF9iaW5kaW5nc1tpXS5yZW5kZXJlciAhPSByZW5kZXJlciApIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjYiA9IGlucHV0RWxlbWVudC5fY3VycmVudF9iaW5kaW5nc1tpXTtcbiAgICAgICAgXG4gICAgICAgIGlmICggY2IubGF5ZXIgJiYgY2IubGF5ZXIgIT0gb2JqZWN0Lm5hbWUgKSB7XG4gICAgICAgICAgICBiZWFuLnJlbW92ZShNQVNDUC5nZXRMYXllcihjYi5sYXllciksJ3Zpc2liaWxpdHlDaGFuZ2UnLGNiLm9iamVjdF9mdW5jdGlvbik7XG4gICAgICAgICAgICBiZWFuLnJlbW92ZShpbnB1dEVsZW1lbnQsJ2NoYW5nZScsY2IuaW5wdXRfZnVuY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAoIGNiLmdyb3VwICYmIGNiLmdyb3VwICE9IG9iamVjdC5uYW1lICkge1xuICAgICAgICAgICAgYmVhbi5yZW1vdmUoTUFTQ1AuZ2V0R3JvdXAoY2IuZ3JvdXApLCd2aXNpYmlsaXR5Q2hhbmdlJyxjYi5vYmplY3RfZnVuY3Rpb24pO1xuICAgICAgICAgICAgYmVhbi5yZW1vdmUoaW5wdXRFbGVtZW50LCdjaGFuZ2UnLGNiLmlucHV0X2Z1bmN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBjYi5ncm91cCA9IG51bGw7XG4gICAgICAgIGNiLmxheWVyID0gbnVsbDtcbiAgICB9XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIGxheWVyIGJhc2VkIGNvbnRyb2xsZXIgZm9yIGEgZ3JvdXAuIFRoaXMgbGF5ZXIgY2FuIGFjdCBhcyBhIHByb3h5IGZvciB0aGUgb3RoZXIgbGF5ZXJzXG4gKiBAcGFyYW0ge09iamVjdH0gbGF5IExheWVyIHRvIHR1cm4gaW50byBhIGdyb3VwIGNvbnRyb2xsZXJcbiAqIEBwYXJhbSB7T2JqZWN0fSBncnAgR3JvdXAgdG8gYmUgY29udHJvbGxlZCBieSB0aGlzIGxheWVyLlxuICovXG5cblNlcXVlbmNlUmVuZGVyZXIucHJvdG90eXBlLmNyZWF0ZUdyb3VwQ29udHJvbGxlciA9IGZ1bmN0aW9uKGxheSxncnApIHtcbiAgICB2YXIgbGF5ZXIgPSBNQVNDUC5nZXRMYXllcihsYXkpO1xuICAgIHZhciBncm91cCA9IE1BU0NQLmdldEdyb3VwKGdycCk7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgYmVhbi5hZGQobGF5ZXIsJ3Zpc2liaWxpdHlDaGFuZ2UnLGZ1bmN0aW9uKHJlbmQsdmlzaWJsZSkge1xuICAgICAgICBpZiAocmVuZCA9PSBzZWxmKSB7XG4gICAgICAgICAgICBzZWxmLnNldEdyb3VwVmlzaWJpbGl0eShncm91cCwgdmlzaWJsZSk7XG4gICAgICAgICAgICBzZWxmLnJlZnJlc2goKTtcbiAgICAgICAgfVxuICAgIH0pO1xufTtcblxuLyoqXG4gKiBGdW5jdGlvbiB0byBiZSBhZGRlZCB0byBBbWlubyBhY2lkIGVsZW1lbnRzIHRvIGZhY2lsaXRhdGUgYWRkaW5nIGVsZW1lbnRzIHRvIGxheWVyc1xuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBsYXllck5hbWUgVGhlIGxheWVyIHRoYXQgdGhpcyBhbWlubyBhY2lkIHNob3VsZCBiZSBhZGRlZCB0b1xuICogQHJldHVybnMgSXRzZWxmXG4gKiBAdHlwZSBFbGVtZW50XG4gKi9cblNlcXVlbmNlUmVuZGVyZXIuYWRkRWxlbWVudFRvTGF5ZXIgPSBmdW5jdGlvbihsYXllck5hbWUpXG57XG4gICAgdGhpcy5hZGRCb3hPdmVybGF5KGxheWVyTmFtZSwxKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRnVuY3Rpb24gdG8gYmUgYWRkZWQgdG8gQW1pbm8gYWNpZCBlbGVtZW50cyB0byBmYWNpbGl0YXRlIGFkZGluZyBlbGVtZW50cyB0byBsYXllcnMgd2l0aCBhIGxpbmtcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gbGF5ZXJOYW1lIFRoZSBsYXllciB0aGF0IHRoaXMgYW1pbm8gYWNpZCBzaG91bGQgYmUgYWRkZWQgdG9cbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgVVJMIHRvIGxpbmsgdG9cbiAqIEByZXR1cm5zIEl0c2VsZlxuICogQHR5cGUgRWxlbWVudFxuICovXG5TZXF1ZW5jZVJlbmRlcmVyLmFkZEVsZW1lbnRUb0xheWVyV2l0aExpbmsgPSBmdW5jdGlvbihsYXllck5hbWUsIHVybCwgd2lkdGgpXG57XG4gICAgdGhpcy5jbGFzc0xpc3QuYWRkKGxheWVyTmFtZSk7XG4gICAgdmFyIGFuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgICBhbmNob3Iuc2V0QXR0cmlidXRlKCdocmVmJyx1cmwpO1xuICAgIGFuY2hvci5jbGFzc0xpc3QuYWRkKGxheWVyTmFtZSsnX292ZXJsYXknKTtcbiAgICBhbmNob3Iuc2V0QXR0cmlidXRlKCdzdHlsZScsJ2Rpc3BsYXk6IGJveDsgbGVmdDogMHB4OyB0b3A6IDBweDsgd2lkdGg6IDEwMCU7IHBvc2l0aW9uOiBhYnNvbHV0ZTsgaGVpZ2h0OiAxMDAlOycpO1xuICAgIGFuY2hvci50ZXh0Q29udGVudCA9ICcmbmJzcDsnO1xuICAgIHRoaXMuYXBwZW5kQ2hpbGQoYW5jaG9yKTtcbiAgICB3aGlsZSAod2lkdGggJiYgd2lkdGggPiAwKSB7XG4gICAgICAgIHRoaXMuX3JlbmRlcmVyLl9zZXF1ZW5jZV9lbHNbdGhpcy5faW5kZXggKyB3aWR0aF0uYWRkVG9MYXllcldpdGhMaW5rKGxheWVyTmFtZSx1cmwpO1xuICAgICAgICB3aWR0aCAtPSAxO1xuICAgIH1cbiAgICBpZiAodGhpcy5fel9pbmRleGVzICYmIHRoaXMuX3pfaW5kZXhlc1tsYXllck5hbWVdKSB7XG4gICAgICAgIGFuY2hvci5zdHlsZS56SW5kZXggPSB0aGlzLl96X2luZGV4ZXNbbGF5ZXJOYW1lXTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7ICAgIFxufTtcblxuLyoqXG4gKiBGdW5jdGlvbiB0byBiZSBhZGRlZCB0byBBbWlubyBhY2lkIGVsZW1lbnRzIHRvIGZhY2lsaXRhdGUgYWRkaW5nIGJveCBvdmVybGF5cyB0byBlbGVtZW50c1xuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBsYXllck5hbWUgVGhlIGxheWVyIHRoYXQgdGhpcyBhbWlubyBhY2lkIHNob3VsZCBiZSBhZGRlZCB0bywgYXMgd2VsbCBhcyB0aGUgZnJhY3Rpb24gb3BhY2l0eSB0byB1c2UgZm9yIHRoaXMgb3ZlcmxheVxuICogQHJldHVybnMgSXRzZWxmXG4gKiBAdHlwZSBFbGVtZW50XG4gKi9cblNlcXVlbmNlUmVuZGVyZXIuYWRkQm94T3ZlcmxheVRvRWxlbWVudCA9IGZ1bmN0aW9uKGxheWVyTmFtZSwgd2lkdGgsIGZyYWN0aW9uKVxue1xuICAgIGlmICh0eXBlb2YgZnJhY3Rpb24gPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgZnJhY3Rpb24gPSAxO1xuICAgIH1cblxuICAgIHRoaXMuY2xhc3NMaXN0LmFkZChsYXllck5hbWUpO1xuICAgIHZhciBuZXdfZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBuZXdfZWwuY2xhc3NMaXN0LmFkZChsYXllck5hbWUrJ19vdmVybGF5Jyk7XG4gICAgbmV3X2VsLnNldEF0dHJpYnV0ZSgnc3R5bGUnLCd0b3A6IDBweDsgd2lkdGg6IDEwMCU7IHBvc2l0aW9uOiBhYnNvbHV0ZTsgaGVpZ2h0OiAxMDAlOyBvcGFjaXR5OicrZnJhY3Rpb24rJzsnKTtcbiAgICB0aGlzLmFwcGVuZENoaWxkKG5ld19lbCk7XG4gICAgd2hpbGUgKHdpZHRoICYmIHdpZHRoID4gMSkge1xuICAgICAgICB0aGlzLl9yZW5kZXJlci5fc2VxdWVuY2VfZWxzW3RoaXMuX2luZGV4ICsgd2lkdGggLSAxXS5hZGRCb3hPdmVybGF5KGxheWVyTmFtZSwwLGZyYWN0aW9uKTtcbiAgICAgICAgd2lkdGggLT0gMTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3pfaW5kZXhlcyAmJiB0aGlzLl96X2luZGV4ZXNbbGF5ZXJOYW1lXSkge1xuICAgICAgICBuZXdfZWwuc3R5bGUuekluZGV4ID0gdGhpcy5fel9pbmRleGVzW2xheWVyTmFtZV07XG4gICAgfVxuICAgIHZhciBldmVudF9uYW1lcyA9IFsnbW91c2VvdmVyJywnbW91c2Vkb3duJywnbW91c2Vtb3ZlJywnbW91c2VvdXQnLCdjbGljaycsJ2RibGNsaWNrJywnbW91c2V1cCcsJ21vdXNlZW50ZXInLCdtb3VzZWxlYXZlJ107XG4gICAgZm9yICh2YXIgaSA9IDAgOyBpIDwgZXZlbnRfbmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYmVhbi5hZGQobmV3X2VsLGV2ZW50X25hbWVzW2ldLGZ1bmN0aW9uKCkgeyByZXR1cm4gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgYmVhbi5maXJlKE1BU0NQLmdldExheWVyKGxheWVyTmFtZSksZS50eXBlLFtlLCdTZXF1ZW5jZVJlbmRlcmVyJ10pO1xuICAgICAgICB9O30oaSkpO1xuICAgIH0gICAgXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbi8qKlxuICogUmVzZXQgdGhpcyByZW5kZXJlci4gSGlkZSBhbGwgZ3JvdXBzIGFuZCBsYXllcnMsIGRpc2FibGluZyB0aGVtIGluIHRoZSByZWdpc3RyeS5cbiAqL1xuU2VxdWVuY2VSZW5kZXJlci5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbigpXG57XG4gICAgd2hpbGUodGhpcy5fY29udGFpbmVyLmNsYXNzTGlzdC5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMuX2NvbnRhaW5lci5jbGFzc0xpc3QucmVtb3ZlKHRoaXMuX2NvbnRhaW5lci5jbGFzc0xpc3QuaXRlbSgwKSk7XG4gICAgfVxuICAgIGZvciAoIHZhciBncm91cCBpbiBNQVNDUC5ncm91cHMpIHtcbiAgICAgICAgaWYgKE1BU0NQLmdyb3Vwcy5oYXNPd25Qcm9wZXJ0eShncm91cCkpIHtcbiAgICAgICAgICAgIHRoaXMuaGlkZUdyb3VwKGdyb3VwKTtcbiAgICAgICAgfVxuICAgIH0gICAgXG4gICAgZm9yICggdmFyIGxheWVyIGluIE1BU0NQLmxheWVycykge1xuICAgICAgICBpZiAoTUFTQ1AubGF5ZXJzLmhhc093blByb3BlcnR5KGxheWVyKSkge1xuICAgICAgICAgICAgaWYgKCAhIHRoaXMua2VlcHRyYWNrcyApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhpZGVMYXllcihsYXllcix0cnVlKTtcbiAgICAgICAgICAgICAgICBNQVNDUC5sYXllcnNbbGF5ZXJdLmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLnJlc2V0QW5ub3RhdGlvbnMpIHtcbiAgICAgICAgdGhpcy5yZXNldEFubm90YXRpb25zKCk7XG4gICAgfVxuICAgIFxufTtcblxuLyoqXG4gKiBFeGVjdXRlIHRoZSBnaXZlbiBibG9jayBvZiBjb2RlIChpbiB0aGUgcmVuZGVyZXIgY29udGV4dCkgbW92aW5nIHRoZSByZWZyZXNoIG1ldGhvZCBhd2F5IHNvIHRoYXQgaXQgaXMgbm90IGNhbGxlZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBGdW5jdGlvbiB0aGF0IGNvbnRhaW5zIG9wZXJhdGlvbnMgdG8gcnVuIHdpdGhvdXQgcmVmcmVzaGluZyB0aGUgcmVuZGVyZXJcbiAqL1xuU2VxdWVuY2VSZW5kZXJlci5wcm90b3R5cGUud2l0aG91dFJlZnJlc2ggPSBmdW5jdGlvbihmdW5jKVxue1xuICAgIHZhciBjdXJyX3JlZnJlc2ggPSB0aGlzLnJlZnJlc2g7XG4gICAgdGhpcy5yZWZyZXNoID0gZnVuY3Rpb24oKSB7fTtcbiAgICB0aGlzLnJlZnJlc2guc3VzcGVuZGVkID0gdHJ1ZTtcbiAgICBmdW5jLmFwcGx5KHRoaXMpO1xuICAgIHRoaXMucmVmcmVzaCA9IGN1cnJfcmVmcmVzaDtcbn07XG5cbi8qKlxuICogUmVmcmVzaCB0aGUgZGlzcGxheSBmb3IgdGhpcyBzZXF1ZW5jZSByZW5kZXJlclxuICovXG5TZXF1ZW5jZVJlbmRlcmVyLnByb3RvdHlwZS5yZWZyZXNoID0gZnVuY3Rpb24oKVxue1xuICAgIHZhciB6X2luZGV4ID0gLTI7XG4gICAgaWYgKCAhIHRoaXMuX3pfaW5kZXhlcykge1xuICAgICAgICB0aGlzLl96X2luZGV4ZXMgPSB7fTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAodGhpcy50cmFja09yZGVyIHx8IFtdKS5sZW5ndGg7IGkrKyApIHtcbiAgICAgICAgaWYgKCEgdGhpcy5pc0xheWVyQWN0aXZlKHRoaXMudHJhY2tPcmRlcltpXSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy4nK3RoaXMudHJhY2tPcmRlcltpXSsnX292ZXJsYXknKSkuZm9yRWFjaChmdW5jdGlvbihlbCkge1xuICAgICAgICAgICAgZWwuc3R5bGUuekluZGV4ID0gel9pbmRleDtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3pfaW5kZXhlc1t0aGlzLnRyYWNrT3JkZXJbaV1dID0gel9pbmRleDtcbiAgICAgICAgel9pbmRleCAtPSAxO1xuICAgIH1cbn07XG5cbi8qKlxuICogQmluZCBhIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgb24gYSBwYXJ0aWN1bGFyIGV2ZW50IGZvciB0aGlzIG9iamVjdFxuICogQHBhcmFtIHtTdHJpbmd9IGV2IEV2ZW50IG5hbWVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgRnVuY3Rpb24gdG8gZXhlY3V0ZVxuICovXG5cblNlcXVlbmNlUmVuZGVyZXIucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbihldixmdW5jKVxue1xuICAgIGJlYW4uYWRkKHRoaXMsZXYsZnVuYyk7XG59O1xuXG5TZXF1ZW5jZVJlbmRlcmVyLnByb3RvdHlwZS51bmJpbmQgPSBmdW5jdGlvbihldixmdW5jKVxue1xuICAgIGJlYW4ucmVtb3ZlKHRoaXMsZXYsZnVuYyk7XG59O1xuXG5cblNlcXVlbmNlUmVuZGVyZXIucHJvdG90eXBlLnRyaWdnZXIgPSBmdW5jdGlvbihldixhcmdzKVxue1xuICAgIGJlYW4uZmlyZSh0aGlzLGV2LGFyZ3MpO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgU2VxdWVuY2VSZW5kZXJlcjtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFFQTs7Ozs7Ozs7QUFRQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBbERBO0FBQ0E7QUFvREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUZBO0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7QUFRQTs7Ozs7Ozs7QUFRQTs7Ozs7OztBQU9BOzs7Ozs7OztBQVFBOzs7Ozs7OztBQVFBOzs7Ozs7OztBQVVBOzs7O0FBSUE7QUFDQTtBQURBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7OztBQUtBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQU9BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFPQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7O0FBUUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7QUFPQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7QUFHQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7Ozs7QUFJQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUVBO0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./js/lib/SequenceRenderer.js\n");

/***/ }),

/***/ "./js/lib/Service.js":
/*!***************************!*\
  !*** ./js/lib/Service.js ***!
  \***************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _bean__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../bean */ \"./js/bean.js\");\n/* harmony import */ var _jsandbox__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../jsandbox */ \"./js/jsandbox.js\");\n/* harmony import */ var _MASCP__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./MASCP */ \"./js/lib/MASCP.js\");\n//\"use strict\";\n\n\n\n\n\n\n/** Default constructor for Services\n *  @class      Super-class for all MASCP services to retrieve data from\n *              proteomic databases. Sub-classes of this class override methods\n *              to change how requests are built, and how the data is parsed.\n *  @param      {String}    agi             AGI to retrieve data for\n *  @param      {String}    endpointURL     Endpoint for the service\n */\nconst Service = function Service(agi, endpointURL) {};\n\n/** Build a data retrieval class that uses the given function to extract result data.\n *  @static\n *  @param  {Function}  dataExtractor   Function to extract data from the resultant data (passed as an argument\n *                                      to the function), and then populate the result object. The function is\n *                                      bound to a hash to populate data in to. When no data is passed to the\n *                                      function, the hash should be populated with default values.\n */\n\nlet resultsymb = Symbol('resultclass');\n\nService.buildService = function (dataExtractor) {\n\n    let clazz = class extends Service {\n        constructor(agi, endpointURL) {\n            super();\n            if (typeof endpointURL != 'undefined') {\n                this._endpointURL = endpointURL;\n            } else {\n                this._endpointURL = clazz.SERVICE_URL;\n            }\n            this.agi = agi;\n            return this;\n        }\n\n        toString() {\n            for (var serv in _MASCP__WEBPACK_IMPORTED_MODULE_2__[\"default\"]) {\n                if (this === _MASCP__WEBPACK_IMPORTED_MODULE_2__[\"default\"][serv]) {\n                    return \"MASCP.\" + serv;\n                }\n            }\n        }\n\n        get Result() {\n            return this[resultsymb] || this.constructor.Result;\n        }\n\n        set Result(resultclass) {\n            this[resultsymb] = resultclass;\n        }\n    };\n\n    clazz.Result = class {\n        constructor(data) {\n            dataExtractor.apply(this, [data]);\n            return this;\n        }\n    };\n\n    Object.assign(dataExtractor.apply({}, []), clazz.Result.prototype);\n\n    return clazz;\n};\n\nService.clone = function (service, name) {\n    var new_service = Service.buildService(function () {\n        return this;\n    });\n    new_service.Result = service.Result;\n    new_service.prototype = new service();\n    _MASCP__WEBPACK_IMPORTED_MODULE_2__[\"default\"][name] = new_service;\n    new_service.prototype['__class__'] = new_service;\n    return new_service;\n};\n\n/**\n *  @lends Service.prototype\n *  @property   {String}  agi               AGI to retrieve data for\n *  @property   {Service.Result}  result  Result from the query\n *  @property   {Boolean} async             Flag for using asynchronous requests - defaults to true\n */\nService.prototype = Object.assign({\n    'agi': null,\n    'result': null,\n    'async': true\n}, Service.prototype);\n\n/*\n * Internal callback for new data coming in from a XHR\n * @private\n */\n\nService.prototype._dataReceived = function (data, status) {\n    if (!data) {\n        return false;\n    }\n    var clazz = this.Result;\n    if (data && data.error && data.error != '' && data.error !== null) {\n        _bean__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fire(this, 'error', [data.error]);\n        return false;\n    }\n    if (Object.prototype.toString.call(data) === '[object Array]') {\n        for (var i = 0; i < data.length; i++) {\n            arguments.callee.call(this, data[i], status);\n        }\n        if (i === 0) {\n            this.result = new clazz();\n        }\n        this.result._raw_data = { 'data': data };\n    } else if (!this.result) {\n        var result;\n        try {\n            result = new clazz(data);\n        } catch (err2) {\n            _bean__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fire(this, 'error', [err2]);\n            return false;\n        }\n        if (!result._raw_data) {\n            result._raw_data = data;\n        }\n        this.result = result;\n    } else {\n        // var new_result = {};\n        try {\n            clazz.call(this.result, data);\n        } catch (err3) {\n            _bean__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fire(this, 'error', [err3]);\n            return false;\n        }\n        // for(var field in new_result) {\n        //     if (true && new_result.hasOwnProperty(field)) {\n        //         this.result[field] = new_result[field];\n        //     }\n        // }\n        if (!this.result._raw_data) {\n            this.result._raw_data = data;\n        }\n        // this.result._raw_data = data;\n    }\n\n    if (data && data.retrieved) {\n        this.result.retrieved = data.retrieved;\n        this.result._raw_data.retrieved = data.retrieved;\n    }\n\n    this.result.agi = this.agi;\n\n    return true;\n};\n\nService.prototype.gotResult = function () {\n    var self = this;\n\n    var reader_cache = function reader_cache(thing) {\n        if (!thing.readers) {\n            thing.readers = [];\n        }\n        thing.readers.push(self.toString());\n    };\n\n    _bean__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(_MASCP__WEBPACK_IMPORTED_MODULE_2__[\"default\"], 'layerRegistered', reader_cache);\n    _bean__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(_MASCP__WEBPACK_IMPORTED_MODULE_2__[\"default\"], 'groupRegistered', reader_cache);\n    _bean__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fire(self, \"resultReceived\");\n    try {\n        _bean__WEBPACK_IMPORTED_MODULE_0__[\"default\"].remove(_MASCP__WEBPACK_IMPORTED_MODULE_2__[\"default\"], 'layerRegistered', reader_cache);\n        _bean__WEBPACK_IMPORTED_MODULE_0__[\"default\"].remove(_MASCP__WEBPACK_IMPORTED_MODULE_2__[\"default\"], 'groupRegistered', reader_cache);\n    } catch (e) {}\n\n    _bean__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fire(Service, \"resultReceived\");\n};\n\nService.prototype.requestComplete = function () {\n    _bean__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fire(this, 'requestComplete');\n    _bean__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fire(Service, 'requestComplete', [this]);\n};\n\nService.prototype.requestIncomplete = function () {\n    _bean__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fire(this, 'requestIncomplete');\n    _bean__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fire(Service, 'requestIncomplete', [this]);\n};\n\nService.registeredLayers = function (service) {\n    var result = [];\n    for (var layname in _MASCP__WEBPACK_IMPORTED_MODULE_2__[\"default\"].layers) {\n        if (_MASCP__WEBPACK_IMPORTED_MODULE_2__[\"default\"].layers.hasOwnProperty(layname)) {\n            var layer = _MASCP__WEBPACK_IMPORTED_MODULE_2__[\"default\"].layers[layname];\n            if (layer.readers && layer.readers.indexOf(service.toString()) >= 0) {\n                result.push(layer);\n            }\n        }\n    }\n    return result;\n};\n\nService.registeredGroups = function (service) {\n    var result = [];\n    for (var nm in _MASCP__WEBPACK_IMPORTED_MODULE_2__[\"default\"].groups) {\n        if (_MASCP__WEBPACK_IMPORTED_MODULE_2__[\"default\"].groups.hasOwnProperty(nm)) {\n            var group = _MASCP__WEBPACK_IMPORTED_MODULE_2__[\"default\"].groups[nm];\n            if (group.readers && group.readers.indexOf(service.toString()) >= 0) {\n                result.push(group);\n            }\n        }\n    }\n    return result;\n};\n\n/**\n *  Binds a handler to one or more events. Returns a reference to self, so this method\n *  can be chained.\n *\n *  @param  {String}    type        Event type to bind\n *  @param  {Function}  function    Handler to execute on event\n */\n\nService.prototype.bind = function (type, func) {\n    _bean__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this, type, func);\n    return this;\n};\n\nService.prototype.once = function (type, func) {\n    var self = this;\n    var wrapped_func = function wrapped_func() {\n        _bean__WEBPACK_IMPORTED_MODULE_0__[\"default\"].remove(self, type, wrapped_func);\n        func.apply(self, [].slice.call(arguments));\n    };\n    self.bind(type, wrapped_func);\n};\n\n/**\n *  Unbinds a handler from one or more events. Returns a reference to self, so this method\n *  can be chained.\n *\n *  @param  {String}    type        Event type to unbind\n *  @param  {Function}  function    Handler to unbind from event\n */\nService.prototype.unbind = function (type, func) {\n    _bean__WEBPACK_IMPORTED_MODULE_0__[\"default\"].remove(this, type, func);\n    return this;\n};\n\n/**\n * @name    Service#resultReceived\n * @event\n * @param   {Object}    e\n */\n\n/**\n * @name    Service#error\n * @event\n * @param   {Object}    e\n */\n\n/**\n *  Asynchronously retrieves data from the remote source. When data is received, a \n *  resultReceived.mascp event is triggered upon this service, while an error.mascp\n *  event is triggered when an error occurs. This method returns a reference to self\n *  so it can be chained.\n */\n(function (base) {\n\n    var make_params = function make_params(params) {\n        var qpoints = [];\n        for (var fieldname in params) {\n            if (params.hasOwnProperty(fieldname)) {\n                qpoints.push(fieldname + '=' + params[fieldname]);\n            }\n        }\n        return qpoints.join('&');\n    };\n\n    var cached_requests = {};\n\n    var do_request = function do_request(request_data) {\n\n        request_data.async = true;\n\n        var datablock = null;\n\n        if (!request_data.url) {\n            request_data.success.call(null, null);\n            return;\n        }\n\n        var request = new XMLHttpRequest();\n\n        if (request_data.type == 'GET' && request_data.data) {\n            var index_of_quest = request_data.url.indexOf('?');\n\n            if (index_of_quest == request_data.url.length - 1) {\n                request_data.url = request_data.url.slice(0, -1);\n                index_of_quest = -1;\n            }\n            var has_question = index_of_quest >= 0 ? '&' : '?';\n            request_data.url = request_data.url.replace(/\\?$/, '') + has_question + make_params(request_data.data);\n        }\n        if (request_data.type == 'GET' && request_data.session_cache) {\n            if (cached_requests[request_data.url]) {\n                cached_requests[request_data.url].then(function (data) {\n                    request_data.success.call(null, data);\n                }).catch(function (error_args) {\n                    request_data.error.apply(null, [null, request, error_args]);\n                });\n                return;\n            } else {\n                var success_callback = request_data.success;\n                var error_callback = request_data.error;\n                cached_requests[request_data.url] = new Promise(function (resolve, reject) {\n                    request_data.success = function (data) {\n                        resolve(data);\n                    };\n                    request_data.error = function (message, req, error_obj) {\n                        reject([message, req, error_obj]);\n                        delete cached_requests[request_data.url];\n                    };\n                });\n                cached_requests[request_data.url].catch(function (error_args) {\n                    error_callback.apply(null, error_args);\n                }).then(function (data) {\n                    success_callback.call(null, data);\n                });\n            }\n        }\n\n        request.open(request_data.type, request_data.url, request_data.async);\n\n        if (request_data.type == 'POST') {\n            request.setRequestHeader(\"Content-Type\", request_data.content ? request_data.content : \"application/x-www-form-urlencoded\");\n            datablock = request_data.content ? request_data.data : make_params(request_data.data);\n        }\n\n        if (request.customUA) {\n            request.setRequestHeader('User-Agent', request.customUA);\n        }\n\n        if (request_data.auth) {\n            request.setRequestHeader('Authorization', 'Bearer ' + request_data.auth);\n        }\n\n        if (request_data.api_key) {\n            request.setRequestHeader('x-api-key', request_data.api_key);\n        }\n\n        var redirect_counts = 5;\n\n        request.onreadystatechange = function (evt) {\n            if (request.readyState == 4) {\n                if (request.status >= 300 && request.status < 400 && redirect_counts > 0) {\n                    var loc = request.getResponseHeader('location').replace(/location:\\s+/, '');\n                    redirect_counts = redirect_counts - 1;\n                    request.open('GET', loc, request_data.async);\n                    request.send();\n                    return;\n                }\n                if (request.status == 503) {\n                    // Let's encode an exponential backoff\n                    request.last_wait = (request_data.last_wait || 500) * 2;\n                    setTimeout(function () {\n                        request.open(request_data.type, request_data.url, request_data.async);\n                        if (request_data.type == 'POST') {\n                            request.setRequestHeader(\"Content-Type\", request_data.content ? request_data.content : \"application/x-www-form-urlencoded\");\n                        }\n                        if (request.customUA) {\n                            request.setRequestHeader('User-Agent', request.customUA);\n                        }\n                        request.send(datablock);\n                    }, request_data.last_wait);\n                    return;\n                }\n                if (request.status == 403) {\n                    // Make sure our S3 buckets expose the Server header cross-origin\n                    var server = request.getResponseHeader('Server');\n                    if (server === 'AmazonS3') {\n                        request_data.success.call(null, { \"error\": \"No data\" }, 403, request);\n                        return;\n                    }\n                }\n                if (request.status >= 200 && request.status < 300) {\n                    var data_block;\n                    if (request_data.dataType == 'xml') {\n                        data_block = typeof document !== 'undefined' ? document.implementation.createDocument(null, \"nodata\", null) : { 'getElementsByTagName': function getElementsByTagName() {\n                                return [];\n                            } };\n                    } else {\n                        data_block = {};\n                    }\n                    try {\n                        var text = request.responseText;\n                        data_block = request_data.dataType == 'xml' ? request.responseXML : request_data.dataType == 'txt' ? request.responseText : JSON.parse(request.responseText);\n                    } catch (e) {\n                        if (e.type == 'unexpected_eos') {\n                            request_data.success.call(null, {}, request.status, request);\n                            return;\n                        } else {\n                            request_data.error.call(null, request.responseText, request, { 'error': e.type || e.message, 'stack': e });\n                            return;\n                        }\n                    }\n                    if (request.status == 202 && data_block.status == \"RUNNING\") {\n                        setTimeout(function () {\n                            request.open(request_data.type, request_data.url, request_data.async);\n                            if (request_data.type == 'POST') {\n                                request.setRequestHeader(\"Content-Type\", \"application/x-www-form-urlencoded\");\n                            }\n                            if (request.customUA) {\n                                request.setRequestHeader('User-Agent', request.customUA);\n                            }\n                            request.send(datablock);\n                        }, 5000);\n                        return;\n                    }\n                    request_data.success.call(null, data_block, request.status, request);\n                    data_block = null;\n                } else {\n                    request_data.error.call(null, request.responseText, request, request.status);\n                }\n            }\n        };\n        if (_MASCP__WEBPACK_IMPORTED_MODULE_2__[\"default\"].NETWORK_FAIL && _MASCP__WEBPACK_IMPORTED_MODULE_2__[\"default\"].NETWORK_FAIL.enabled) {\n            setTimeout(function () {\n                console.log(\"Causing network failure\");\n                request = { 'onreadystatechange': request.onreadystatechange };\n                request.readyState = 4;\n                request.status = _MASCP__WEBPACK_IMPORTED_MODULE_2__[\"default\"].NETWORK_FAIL.status || 500;\n                request.responseText = \"Intercepted by Network Failure simulator\";\n                request.onreadystatechange();\n            }, 1000);\n            return;\n        }\n\n        request.send(datablock);\n    };\n\n    Service.request = function (url, callback, noparse) {\n        var method = _MASCP__WEBPACK_IMPORTED_MODULE_2__[\"default\"].IE ? do_request_ie : do_request;\n        if (_MASCP__WEBPACK_IMPORTED_MODULE_2__[\"default\"].IE && !url.match(/^https?\\:/)) {\n            method = do_request;\n        }\n        var params;\n        if (!url) {\n            callback(null);\n            return;\n        }\n        if (typeof url == 'string') {\n            params = { async: true, url: url, timeout: 5000, type: \"GET\",\n                error: function error(response, req, status) {\n                    callback.call(null, { \"status\": status });\n                },\n                success: function success(data, status, xhr) {\n                    callback.call(null, null, data);\n                }\n            };\n        } else if (url.hasOwnProperty('url')) {\n            params = url;\n            params.success = function (data) {\n                callback.call(null, null, data);\n            };\n            params.error = function (resp, req, status) {\n                callback.call(null, { \"status\": status });\n            };\n        }\n        if (noparse) {\n            params.dataType = 'txt';\n            if (noparse === \"xml\") {\n                params.dataType = 'xml';\n            }\n        }\n        method.call(null, params);\n    };\n\n    /**\n     * Private method for performing a cross-domain request using Internet Explorer 8 and up. Adapts the \n     * parameters passed, and builds an XDR object. There is no support for a locking\n     * synchronous method to do these requests (that is required for Unit testing) so an alert box is used\n     * to provide the locking.\n     * @private\n     * @param {Object} dataHash Hash with the data and settings used to build the query.\n     */\n\n    var do_request_ie = function do_request_ie(dataHash) {\n        // Use XDR\n        var xdr = new XDomainRequest();\n        var loaded = false;\n        var counter = 0;\n        xdr.onerror = function (ev) {\n            dataHash.error(xdr, xdr, { \"message\": \"XDomainRequest error\" });\n        };\n        xdr.onprogress = function () {};\n        xdr.open(\"GET\", dataHash.url + \"?\" + make_params(dataHash.data));\n        xdr.onload = function () {\n            loaded = true;\n            if (dataHash.dataType == 'xml') {\n                var dom = new ActiveXObject(\"Microsoft.XMLDOM\");\n                dom.async = false;\n                dom.loadXML(xdr.responseText);\n                dataHash.success(dom, 'success', xdr);\n            } else if (dataHash.dataType == 'json') {\n                var parsed = null;\n                try {\n                    parsed = JSON.parse(xdr.responseText);\n                } catch (err) {\n                    dataHash.error(xdr, xdr, { \"message\": \"JSON parsing error\" });\n                }\n                if (parsed) {\n                    dataHash.success(parsed, 'success', xdr);\n                }\n            } else {\n                dataHash.success(xdr.responseText, 'success', xdr);\n            }\n        };\n        // We can't set the content-type on the parameters here to url-encoded form data.\n        setTimeout(function () {\n            xdr.send();\n        }, 0);\n        while (!dataHash.async && !loaded && counter < 3) {\n            alert(\"This browser does not support synchronous requests, click OK while we're waiting for data\");\n            counter += 1;\n        }\n        if (!dataHash.async && !loaded) {\n            alert(\"No data\");\n        }\n    };\n\n    base.retrieve = function (agi, callback) {\n        var self = this;\n\n        Service._current_reqs = Service._current_reqs || 0;\n        Service._waiting_reqs = Service._waiting_reqs || 0;\n\n        if (Service.MAX_REQUESTS) {\n            var my_func = arguments.callee;\n            if (Service._current_reqs > Service.MAX_REQUESTS) {\n                Service._waiting_reqs += 1;\n                _bean__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(Service, 'requestComplete', function () {\n                    _bean__WEBPACK_IMPORTED_MODULE_0__[\"default\"].remove(this, 'requestComplete', arguments.callee);\n                    setTimeout(function () {\n                        Service._waiting_reqs -= 1;\n                        my_func.call(self, agi, callback);\n                    }, 0);\n                });\n                return this;\n            }\n        }\n        if (agi) {\n            this.agi = agi;\n        }\n\n        if (agi && callback) {\n            this.agi = agi;\n\n            this.result = null;\n\n            var done_result = false;\n            var done_func = function done_func(err, obj) {\n                _bean__WEBPACK_IMPORTED_MODULE_0__[\"default\"].remove(self, \"resultReceived\", done_func);\n                _bean__WEBPACK_IMPORTED_MODULE_0__[\"default\"].remove(self, \"error\", done_func);\n                _bean__WEBPACK_IMPORTED_MODULE_0__[\"default\"].remove(self, \"requestComplete\", done_func);\n                if (!done_result) {\n                    if (err) {\n                        callback.call(self, err);\n                    } else {\n                        callback.call(self);\n                    }\n                }\n                done_result = true;\n            };\n            _bean__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(self, \"resultReceived\", done_func);\n            _bean__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(self, \"error\", done_func);\n            _bean__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(self, \"requestComplete\", done_func);\n        }\n        var request_data = this.requestData();\n\n        if (request_data === false) {\n            return;\n        }\n\n        if (!request_data) {\n            _bean__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fire(self, \"error\", [\"No request data\"]);\n            _bean__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fire(Service, \"requestComplete\", [self]);\n            this.requestComplete();\n            return this;\n        }\n\n        var default_params = {\n            async: this.async,\n            url: request_data.url || this._endpointURL,\n            timeout: 5000,\n            error: function error(response, req, status) {\n                Service._current_reqs -= 1;\n                if (typeof status == 'string') {\n                    status = { 'error': status, 'request': req };\n                }\n                if (!isNaN(status)) {\n                    status = { \"error\": \"Reqeust error\", \"status\": status, 'request': req };\n                }\n                _bean__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fire(self, \"error\", [status]);\n                _bean__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fire(Service, 'requestComplete');\n                self.requestComplete();\n                //throw \"Error occurred retrieving data for service \"+self._endpointURL;\n            },\n            success: function success(data, status, xhr) {\n                Service._current_reqs -= 1;\n                if (xhr && xhr.status !== null && xhr.status === 0) {\n                    _bean__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fire(self, \"error\", [{ \"error\": \"Zero return status from request \" }]);\n                    self.requestComplete();\n                    return;\n                }\n                var received_flag = self._dataReceived(data, status);\n\n                if (received_flag) {\n                    self.gotResult();\n                }\n\n                if (received_flag !== null && typeof received_flag !== 'undefined') {\n                    self.requestComplete();\n                } else {\n                    self.requestIncomplete();\n                }\n            }\n        };\n        default_params = Object.assign(request_data, default_params);\n        if (_MASCP__WEBPACK_IMPORTED_MODULE_2__[\"default\"].IE) {\n            do_request_ie(default_params);\n        } else {\n            do_request(default_params);\n        }\n\n        Service._current_reqs += 1;\n\n        return this;\n    };\n})(Service.prototype);\n\n/**\n *  Get the parameters that will be used to build this request. Implementations of services will\n *  override this method, returning the parameters to be used to build the XHR.\n */\n\nService.prototype.requestData = function () {};\n\nService.prototype.toString = function () {\n    for (var clazz in _MASCP__WEBPACK_IMPORTED_MODULE_2__[\"default\"]) {\n        if (this.__class__ == _MASCP__WEBPACK_IMPORTED_MODULE_2__[\"default\"][clazz]) {\n            return \"MASCP.\" + clazz;\n        }\n    }\n};\n\n/**\n * For this service, register a sequence rendering view so that the results can be marked up directly\n * on to a sequence. This method will do nothing if the service does not know how to render the \n * results onto the sequence.\n * @param {MASCP.SequenceRenderer} sequenceRenderer Sequence renderer object to render results upon\n */\nService.prototype.registerSequenceRenderer = function (sequenceRenderer, options) {\n    if (this.setupSequenceRenderer) {\n        this.renderers = this.renderers || [];\n        this.setupSequenceRenderer(sequenceRenderer, options);\n        this.renderers.push(sequenceRenderer);\n    }\n    sequenceRenderer.trigger('readerRegistered', [this]);\n    return this;\n};\n\nService.prototype.resetOnResult = function (sequenceRenderer, rendered, track) {\n    var self = this;\n    var result_func = function result_func() {\n        self.unbind('resultReceived', result_func);\n        sequenceRenderer.bind('resultsRendered', clear_func);\n    };\n\n    var clear_func = function clear_func(reader) {\n        if (reader !== self) {\n            return;\n        }\n        sequenceRenderer.unbind('resultsRendered', clear_func);\n        rendered.forEach(function (obj) {\n            sequenceRenderer.remove(track, obj);\n        });\n    };\n    this.bind('resultReceived', result_func);\n};\n\n/**\n * For this service, set up a sequence renderer so that the events are connected up with receiving data.\n * This method should be overridden to wire up the sequence renderer to the service.\n * @param {MASCP.SequenceRenderer} sequenceRenderer Sequence renderer object to render results upon\n */\nService.prototype.setupSequenceRenderer = function (sequenceRenderer) {\n    return this;\n};\n\n/** Default constructor\n *  @class  Super-class for all results from MASCP services.\n */\nService.Result = function () {};\n\nService.Result.prototype = {\n    agi: null,\n    reader: null\n};\n\nService.Result.prototype.render = function () {};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (Service);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9qcy9saWIvU2VydmljZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9qcy9saWIvU2VydmljZS5qcz9kYWJmIl0sInNvdXJjZXNDb250ZW50IjpbIi8vXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCBiZWFuIGZyb20gJy4uL2JlYW4nO1xuaW1wb3J0IEpTYW5kYm94IGZyb20gJy4uL2pzYW5kYm94JztcblxuaW1wb3J0IE1BU0NQIGZyb20gJy4vTUFTQ1AnO1xuXG4vKiogRGVmYXVsdCBjb25zdHJ1Y3RvciBmb3IgU2VydmljZXNcbiAqICBAY2xhc3MgICAgICBTdXBlci1jbGFzcyBmb3IgYWxsIE1BU0NQIHNlcnZpY2VzIHRvIHJldHJpZXZlIGRhdGEgZnJvbVxuICogICAgICAgICAgICAgIHByb3Rlb21pYyBkYXRhYmFzZXMuIFN1Yi1jbGFzc2VzIG9mIHRoaXMgY2xhc3Mgb3ZlcnJpZGUgbWV0aG9kc1xuICogICAgICAgICAgICAgIHRvIGNoYW5nZSBob3cgcmVxdWVzdHMgYXJlIGJ1aWx0LCBhbmQgaG93IHRoZSBkYXRhIGlzIHBhcnNlZC5cbiAqICBAcGFyYW0gICAgICB7U3RyaW5nfSAgICBhZ2kgICAgICAgICAgICAgQUdJIHRvIHJldHJpZXZlIGRhdGEgZm9yXG4gKiAgQHBhcmFtICAgICAge1N0cmluZ30gICAgZW5kcG9pbnRVUkwgICAgIEVuZHBvaW50IGZvciB0aGUgc2VydmljZVxuICovXG5jb25zdCBTZXJ2aWNlID0gZnVuY3Rpb24oYWdpLGVuZHBvaW50VVJMKSB7fTtcblxuLyoqIEJ1aWxkIGEgZGF0YSByZXRyaWV2YWwgY2xhc3MgdGhhdCB1c2VzIHRoZSBnaXZlbiBmdW5jdGlvbiB0byBleHRyYWN0IHJlc3VsdCBkYXRhLlxuICogIEBzdGF0aWNcbiAqICBAcGFyYW0gIHtGdW5jdGlvbn0gIGRhdGFFeHRyYWN0b3IgICBGdW5jdGlvbiB0byBleHRyYWN0IGRhdGEgZnJvbSB0aGUgcmVzdWx0YW50IGRhdGEgKHBhc3NlZCBhcyBhbiBhcmd1bWVudFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvIHRoZSBmdW5jdGlvbiksIGFuZCB0aGVuIHBvcHVsYXRlIHRoZSByZXN1bHQgb2JqZWN0LiBUaGUgZnVuY3Rpb24gaXNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3VuZCB0byBhIGhhc2ggdG8gcG9wdWxhdGUgZGF0YSBpbiB0by4gV2hlbiBubyBkYXRhIGlzIHBhc3NlZCB0byB0aGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiwgdGhlIGhhc2ggc2hvdWxkIGJlIHBvcHVsYXRlZCB3aXRoIGRlZmF1bHQgdmFsdWVzLlxuICovXG5cbmxldCByZXN1bHRzeW1iID0gU3ltYm9sKCdyZXN1bHRjbGFzcycpO1xuXG5TZXJ2aWNlLmJ1aWxkU2VydmljZSA9IGZ1bmN0aW9uKGRhdGFFeHRyYWN0b3IpXG57XG5cbiAgICBsZXQgY2xhenogPSBjbGFzcyBleHRlbmRzIFNlcnZpY2Uge1xuICAgICAgICBjb25zdHJ1Y3RvcihhZ2ksZW5kcG9pbnRVUkwpIHtcbiAgICAgICAgICAgIHN1cGVyKCk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGVuZHBvaW50VVJMICE9ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZW5kcG9pbnRVUkwgPSBlbmRwb2ludFVSTDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZW5kcG9pbnRVUkwgPSBjbGF6ei5TRVJWSUNFX1VSTDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYWdpID0gYWdpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICB0b1N0cmluZygpIHtcbiAgICAgICAgICAgIGZvciAodmFyIHNlcnYgaW4gTUFTQ1ApIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcyA9PT0gTUFTQ1Bbc2Vydl0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiTUFTQ1AuXCIrc2VydjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBnZXQgUmVzdWx0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbcmVzdWx0c3ltYl0gfHwgdGhpcy5jb25zdHJ1Y3Rvci5SZXN1bHQ7XG4gICAgICAgIH1cblxuICAgICAgICBzZXQgUmVzdWx0KHJlc3VsdGNsYXNzKSB7XG4gICAgICAgICAgICB0aGlzW3Jlc3VsdHN5bWJdID0gcmVzdWx0Y2xhc3M7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgY2xhenouUmVzdWx0ID0gY2xhc3Mge1xuICAgICAgICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgICAgICAgICBkYXRhRXh0cmFjdG9yLmFwcGx5KHRoaXMsW2RhdGFdKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIE9iamVjdC5hc3NpZ24oZGF0YUV4dHJhY3Rvci5hcHBseSh7fSxbXSksY2xhenouUmVzdWx0LnByb3RvdHlwZSk7XG5cbiAgICByZXR1cm4gY2xheno7XG59O1xuXG5TZXJ2aWNlLmNsb25lID0gZnVuY3Rpb24oc2VydmljZSxuYW1lKSB7XG4gICAgdmFyIG5ld19zZXJ2aWNlID0gU2VydmljZS5idWlsZFNlcnZpY2UoZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KTtcbiAgICBuZXdfc2VydmljZS5SZXN1bHQgPSBzZXJ2aWNlLlJlc3VsdDtcbiAgICBuZXdfc2VydmljZS5wcm90b3R5cGUgPSBuZXcgc2VydmljZSgpO1xuICAgIE1BU0NQW25hbWVdID0gbmV3X3NlcnZpY2U7XG4gICAgbmV3X3NlcnZpY2UucHJvdG90eXBlWydfX2NsYXNzX18nXSA9IG5ld19zZXJ2aWNlO1xuICAgIHJldHVybiBuZXdfc2VydmljZTtcbn07XG5cblxuLyoqXG4gKiAgQGxlbmRzIFNlcnZpY2UucHJvdG90eXBlXG4gKiAgQHByb3BlcnR5ICAge1N0cmluZ30gIGFnaSAgICAgICAgICAgICAgIEFHSSB0byByZXRyaWV2ZSBkYXRhIGZvclxuICogIEBwcm9wZXJ0eSAgIHtTZXJ2aWNlLlJlc3VsdH0gIHJlc3VsdCAgUmVzdWx0IGZyb20gdGhlIHF1ZXJ5XG4gKiAgQHByb3BlcnR5ICAge0Jvb2xlYW59IGFzeW5jICAgICAgICAgICAgIEZsYWcgZm9yIHVzaW5nIGFzeW5jaHJvbm91cyByZXF1ZXN0cyAtIGRlZmF1bHRzIHRvIHRydWVcbiAqL1xuU2VydmljZS5wcm90b3R5cGUgPSBPYmplY3QuYXNzaWduKHtcbiAgJ2FnaScgICAgIDogbnVsbCxcbiAgJ3Jlc3VsdCcgIDogbnVsbCwgXG4gICdhc3luYycgICA6IHRydWVcbn0sU2VydmljZS5wcm90b3R5cGUpO1xuXG5cbi8qXG4gKiBJbnRlcm5hbCBjYWxsYmFjayBmb3IgbmV3IGRhdGEgY29taW5nIGluIGZyb20gYSBYSFJcbiAqIEBwcml2YXRlXG4gKi9cblxuU2VydmljZS5wcm90b3R5cGUuX2RhdGFSZWNlaXZlZCA9IGZ1bmN0aW9uKGRhdGEsc3RhdHVzKVxue1xuICAgIGlmICghIGRhdGEgKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIGNsYXp6ID0gdGhpcy5SZXN1bHQ7XG4gICAgaWYgKGRhdGEgJiYgZGF0YS5lcnJvciAmJiBkYXRhLmVycm9yICE9ICcnICYmIGRhdGEuZXJyb3IgIT09IG51bGwgKSB7XG4gICAgICAgIGJlYW4uZmlyZSh0aGlzLCdlcnJvcicsW2RhdGEuZXJyb3JdKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGRhdGEpID09PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKyApIHtcbiAgICAgICAgICAgIGFyZ3VtZW50cy5jYWxsZWUuY2FsbCh0aGlzLGRhdGFbaV0sc3RhdHVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5yZXN1bHQgPSBuZXcgY2xhenooKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlc3VsdC5fcmF3X2RhdGEgPSB7ICdkYXRhJyA6IGRhdGEgfTtcbiAgICB9IGVsc2UgaWYgKCAhIHRoaXMucmVzdWx0ICkge1xuICAgICAgICB2YXIgcmVzdWx0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmVzdWx0ID0gbmV3IGNsYXp6KGRhdGEpO1xuICAgICAgICB9IGNhdGNoKGVycjIpIHtcbiAgICAgICAgICAgIGJlYW4uZmlyZSh0aGlzLCdlcnJvcicsW2VycjJdKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoICEgcmVzdWx0Ll9yYXdfZGF0YSApIHtcbiAgICAgICAgICAgIHJlc3VsdC5fcmF3X2RhdGEgPSBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVzdWx0ID0gcmVzdWx0O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHZhciBuZXdfcmVzdWx0ID0ge307XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjbGF6ei5jYWxsKHRoaXMucmVzdWx0LGRhdGEpO1xuICAgICAgICB9IGNhdGNoKGVycjMpIHtcbiAgICAgICAgICAgIGJlYW4uZmlyZSh0aGlzLCdlcnJvcicsW2VycjNdKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBmb3IodmFyIGZpZWxkIGluIG5ld19yZXN1bHQpIHtcbiAgICAgICAgLy8gICAgIGlmICh0cnVlICYmIG5ld19yZXN1bHQuaGFzT3duUHJvcGVydHkoZmllbGQpKSB7XG4gICAgICAgIC8vICAgICAgICAgdGhpcy5yZXN1bHRbZmllbGRdID0gbmV3X3Jlc3VsdFtmaWVsZF07XG4gICAgICAgIC8vICAgICB9XG4gICAgICAgIC8vIH1cbiAgICAgICAgaWYgKCEgdGhpcy5yZXN1bHQuX3Jhd19kYXRhKSB7XG4gICAgICAgICAgICB0aGlzLnJlc3VsdC5fcmF3X2RhdGEgPSBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRoaXMucmVzdWx0Ll9yYXdfZGF0YSA9IGRhdGE7XG4gICAgfVxuXG4gICAgaWYgKGRhdGEgJiYgZGF0YS5yZXRyaWV2ZWQpIHtcbiAgICAgICAgdGhpcy5yZXN1bHQucmV0cmlldmVkID0gZGF0YS5yZXRyaWV2ZWQ7XG4gICAgICAgIHRoaXMucmVzdWx0Ll9yYXdfZGF0YS5yZXRyaWV2ZWQgPSBkYXRhLnJldHJpZXZlZDtcbiAgICB9XG5cbiAgICB0aGlzLnJlc3VsdC5hZ2kgPSB0aGlzLmFnaTtcbiAgICBcbiAgICBcbiAgICBcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cblNlcnZpY2UucHJvdG90eXBlLmdvdFJlc3VsdCA9IGZ1bmN0aW9uKClcbntcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgXG4gICAgdmFyIHJlYWRlcl9jYWNoZSA9IGZ1bmN0aW9uKHRoaW5nKSB7XG4gICAgICAgIGlmICggISB0aGluZy5yZWFkZXJzICkge1xuICAgICAgICAgICAgdGhpbmcucmVhZGVycyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHRoaW5nLnJlYWRlcnMucHVzaChzZWxmLnRvU3RyaW5nKCkpO1xuICAgIH07XG4gICAgXG4gICAgYmVhbi5hZGQoTUFTQ1AsJ2xheWVyUmVnaXN0ZXJlZCcsIHJlYWRlcl9jYWNoZSk7XG4gICAgYmVhbi5hZGQoTUFTQ1AsJ2dyb3VwUmVnaXN0ZXJlZCcsIHJlYWRlcl9jYWNoZSk7XG4gICAgYmVhbi5maXJlKHNlbGYsXCJyZXN1bHRSZWNlaXZlZFwiKTtcbiAgICB0cnkge1xuICAgICAgICBiZWFuLnJlbW92ZShNQVNDUCwnbGF5ZXJSZWdpc3RlcmVkJyxyZWFkZXJfY2FjaGUpO1xuICAgICAgICBiZWFuLnJlbW92ZShNQVNDUCwnZ3JvdXBSZWdpc3RlcmVkJyxyZWFkZXJfY2FjaGUpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICB9XG5cbiAgICBiZWFuLmZpcmUoU2VydmljZSxcInJlc3VsdFJlY2VpdmVkXCIpO1xufTtcblxuU2VydmljZS5wcm90b3R5cGUucmVxdWVzdENvbXBsZXRlID0gZnVuY3Rpb24oKVxue1xuICAgIGJlYW4uZmlyZSh0aGlzLCdyZXF1ZXN0Q29tcGxldGUnKTtcbiAgICBiZWFuLmZpcmUoU2VydmljZSwncmVxdWVzdENvbXBsZXRlJyxbdGhpc10pO1xufTtcblxuU2VydmljZS5wcm90b3R5cGUucmVxdWVzdEluY29tcGxldGUgPSBmdW5jdGlvbigpXG57XG4gICAgYmVhbi5maXJlKHRoaXMsJ3JlcXVlc3RJbmNvbXBsZXRlJyk7XG4gICAgYmVhbi5maXJlKFNlcnZpY2UsJ3JlcXVlc3RJbmNvbXBsZXRlJyxbdGhpc10pO1xufTtcblxuXG5TZXJ2aWNlLnJlZ2lzdGVyZWRMYXllcnMgPSBmdW5jdGlvbihzZXJ2aWNlKSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIGZvciAodmFyIGxheW5hbWUgaW4gTUFTQ1AubGF5ZXJzKSB7XG4gICAgICAgIGlmIChNQVNDUC5sYXllcnMuaGFzT3duUHJvcGVydHkobGF5bmFtZSkpIHtcbiAgICAgICAgICAgIHZhciBsYXllciA9IE1BU0NQLmxheWVyc1tsYXluYW1lXTtcbiAgICAgICAgICAgIGlmIChsYXllci5yZWFkZXJzICYmIGxheWVyLnJlYWRlcnMuaW5kZXhPZihzZXJ2aWNlLnRvU3RyaW5nKCkpID49IDApIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChsYXllcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblNlcnZpY2UucmVnaXN0ZXJlZEdyb3VwcyA9IGZ1bmN0aW9uKHNlcnZpY2UpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgZm9yICh2YXIgbm0gaW4gTUFTQ1AuZ3JvdXBzKSB7XG4gICAgICAgIGlmIChNQVNDUC5ncm91cHMuaGFzT3duUHJvcGVydHkobm0pKSB7XG4gICAgICAgICAgICB2YXIgZ3JvdXAgPSBNQVNDUC5ncm91cHNbbm1dO1xuICAgICAgICAgICAgaWYgKGdyb3VwLnJlYWRlcnMgJiYgZ3JvdXAucmVhZGVycy5pbmRleE9mKHNlcnZpY2UudG9TdHJpbmcoKSkgPj0gMCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGdyb3VwKTtcbiAgICAgICAgICAgIH0gICAgICAgICAgICBcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0OyAgXG59O1xuXG4vKipcbiAqICBCaW5kcyBhIGhhbmRsZXIgdG8gb25lIG9yIG1vcmUgZXZlbnRzLiBSZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHNlbGYsIHNvIHRoaXMgbWV0aG9kXG4gKiAgY2FuIGJlIGNoYWluZWQuXG4gKlxuICogIEBwYXJhbSAge1N0cmluZ30gICAgdHlwZSAgICAgICAgRXZlbnQgdHlwZSB0byBiaW5kXG4gKiAgQHBhcmFtICB7RnVuY3Rpb259ICBmdW5jdGlvbiAgICBIYW5kbGVyIHRvIGV4ZWN1dGUgb24gZXZlbnRcbiAqL1xuXG5TZXJ2aWNlLnByb3RvdHlwZS5iaW5kID0gZnVuY3Rpb24odHlwZSxmdW5jKVxue1xuICAgIGJlYW4uYWRkKHRoaXMsdHlwZSxmdW5jKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cblNlcnZpY2UucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbih0eXBlLGZ1bmMpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHdyYXBwZWRfZnVuYyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBiZWFuLnJlbW92ZShzZWxmLHR5cGUsd3JhcHBlZF9mdW5jKTtcbiAgICAgICAgZnVuYy5hcHBseShzZWxmLFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgfTtcbiAgICBzZWxmLmJpbmQodHlwZSx3cmFwcGVkX2Z1bmMpO1xufTtcblxuLyoqXG4gKiAgVW5iaW5kcyBhIGhhbmRsZXIgZnJvbSBvbmUgb3IgbW9yZSBldmVudHMuIFJldHVybnMgYSByZWZlcmVuY2UgdG8gc2VsZiwgc28gdGhpcyBtZXRob2RcbiAqICBjYW4gYmUgY2hhaW5lZC5cbiAqXG4gKiAgQHBhcmFtICB7U3RyaW5nfSAgICB0eXBlICAgICAgICBFdmVudCB0eXBlIHRvIHVuYmluZFxuICogIEBwYXJhbSAge0Z1bmN0aW9ufSAgZnVuY3Rpb24gICAgSGFuZGxlciB0byB1bmJpbmQgZnJvbSBldmVudFxuICovXG5TZXJ2aWNlLnByb3RvdHlwZS51bmJpbmQgPSBmdW5jdGlvbih0eXBlLGZ1bmMpXG57XG4gICAgYmVhbi5yZW1vdmUodGhpcyx0eXBlLGZ1bmMpO1xuICAgIHJldHVybiB0aGlzOyAgICBcbn07XG5cbi8qKlxuICogQG5hbWUgICAgU2VydmljZSNyZXN1bHRSZWNlaXZlZFxuICogQGV2ZW50XG4gKiBAcGFyYW0gICB7T2JqZWN0fSAgICBlXG4gKi9cblxuLyoqXG4gKiBAbmFtZSAgICBTZXJ2aWNlI2Vycm9yXG4gKiBAZXZlbnRcbiAqIEBwYXJhbSAgIHtPYmplY3R9ICAgIGVcbiAqL1xuXG4vKipcbiAqICBBc3luY2hyb25vdXNseSByZXRyaWV2ZXMgZGF0YSBmcm9tIHRoZSByZW1vdGUgc291cmNlLiBXaGVuIGRhdGEgaXMgcmVjZWl2ZWQsIGEgXG4gKiAgcmVzdWx0UmVjZWl2ZWQubWFzY3AgZXZlbnQgaXMgdHJpZ2dlcmVkIHVwb24gdGhpcyBzZXJ2aWNlLCB3aGlsZSBhbiBlcnJvci5tYXNjcFxuICogIGV2ZW50IGlzIHRyaWdnZXJlZCB3aGVuIGFuIGVycm9yIG9jY3Vycy4gVGhpcyBtZXRob2QgcmV0dXJucyBhIHJlZmVyZW5jZSB0byBzZWxmXG4gKiAgc28gaXQgY2FuIGJlIGNoYWluZWQuXG4gKi9cbihmdW5jdGlvbihiYXNlKSB7XG5cbnZhciBtYWtlX3BhcmFtcyA9IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgIHZhciBxcG9pbnRzID0gW107XG4gICAgZm9yKHZhciBmaWVsZG5hbWUgaW4gcGFyYW1zKSB7XG4gICAgICAgIGlmIChwYXJhbXMuaGFzT3duUHJvcGVydHkoZmllbGRuYW1lKSkge1xuICAgICAgICAgICAgcXBvaW50cy5wdXNoKGZpZWxkbmFtZSArJz0nK3BhcmFtc1tmaWVsZG5hbWVdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcXBvaW50cy5qb2luKCcmJyk7XG59O1xuXG52YXIgY2FjaGVkX3JlcXVlc3RzID0ge307XG5cbnZhciBkb19yZXF1ZXN0ID0gZnVuY3Rpb24ocmVxdWVzdF9kYXRhKSB7XG4gICAgXG4gICAgcmVxdWVzdF9kYXRhLmFzeW5jID0gdHJ1ZTtcblxuICAgIHZhciBkYXRhYmxvY2sgPSBudWxsO1xuICAgIFxuICAgIGlmICggISByZXF1ZXN0X2RhdGEudXJsICkge1xuICAgICAgICByZXF1ZXN0X2RhdGEuc3VjY2Vzcy5jYWxsKG51bGwsbnVsbCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIFxuICAgIGlmIChyZXF1ZXN0X2RhdGEudHlwZSA9PSAnR0VUJyAmJiByZXF1ZXN0X2RhdGEuZGF0YSkge1xuICAgICAgICB2YXIgaW5kZXhfb2ZfcXVlc3QgPSByZXF1ZXN0X2RhdGEudXJsLmluZGV4T2YoJz8nKTtcblxuICAgICAgICBpZiAoaW5kZXhfb2ZfcXVlc3QgPT0gKHJlcXVlc3RfZGF0YS51cmwubGVuZ3RoIC0gMSkpIHtcbiAgICAgICAgICAgIHJlcXVlc3RfZGF0YS51cmwgPSByZXF1ZXN0X2RhdGEudXJsLnNsaWNlKDAsLTEpO1xuICAgICAgICAgICAgaW5kZXhfb2ZfcXVlc3QgPSAtMTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaGFzX3F1ZXN0aW9uID0gIChpbmRleF9vZl9xdWVzdCA+PSAwKSA/ICcmJyA6ICc/JztcbiAgICAgICAgcmVxdWVzdF9kYXRhLnVybCA9IHJlcXVlc3RfZGF0YS51cmwucmVwbGFjZSgvXFw/JC8sJycpICsgaGFzX3F1ZXN0aW9uICsgbWFrZV9wYXJhbXMocmVxdWVzdF9kYXRhLmRhdGEpO1xuICAgIH1cbiAgICBpZiAocmVxdWVzdF9kYXRhLnR5cGUgPT0gJ0dFVCcgJiYgcmVxdWVzdF9kYXRhLnNlc3Npb25fY2FjaGUpIHtcbiAgICAgICAgaWYgKGNhY2hlZF9yZXF1ZXN0c1tyZXF1ZXN0X2RhdGEudXJsXSkge1xuICAgICAgICAgICAgY2FjaGVkX3JlcXVlc3RzW3JlcXVlc3RfZGF0YS51cmxdLnRoZW4oIGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0X2RhdGEuc3VjY2Vzcy5jYWxsKG51bGwsZGF0YSk7XG4gICAgICAgICAgICB9KS5jYXRjaChmdW5jdGlvbihlcnJvcl9hcmdzKSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdF9kYXRhLmVycm9yLmFwcGx5KG51bGwsW251bGwscmVxdWVzdCxlcnJvcl9hcmdzXSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBzdWNjZXNzX2NhbGxiYWNrID0gcmVxdWVzdF9kYXRhLnN1Y2Nlc3M7XG4gICAgICAgICAgICB2YXIgZXJyb3JfY2FsbGJhY2sgPSByZXF1ZXN0X2RhdGEuZXJyb3I7XG4gICAgICAgICAgICBjYWNoZWRfcmVxdWVzdHNbcmVxdWVzdF9kYXRhLnVybF0gPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLHJlamVjdCkge1xuICAgICAgICAgICAgICAgIHJlcXVlc3RfZGF0YS5zdWNjZXNzID0gZnVuY3Rpb24oZGF0YSl7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoZGF0YSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICByZXF1ZXN0X2RhdGEuZXJyb3IgPSBmdW5jdGlvbihtZXNzYWdlLHJlcSxlcnJvcl9vYmopIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KFttZXNzYWdlLHJlcSxlcnJvcl9vYmpdKTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGNhY2hlZF9yZXF1ZXN0c1tyZXF1ZXN0X2RhdGEudXJsXTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjYWNoZWRfcmVxdWVzdHNbcmVxdWVzdF9kYXRhLnVybF0uY2F0Y2goZnVuY3Rpb24oZXJyb3JfYXJncykge1xuICAgICAgICAgICAgICAgIGVycm9yX2NhbGxiYWNrLmFwcGx5KG51bGwsZXJyb3JfYXJncyk7XG4gICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzX2NhbGxiYWNrLmNhbGwobnVsbCxkYXRhKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVxdWVzdC5vcGVuKHJlcXVlc3RfZGF0YS50eXBlLHJlcXVlc3RfZGF0YS51cmwscmVxdWVzdF9kYXRhLmFzeW5jKTtcblxuICAgIGlmIChyZXF1ZXN0X2RhdGEudHlwZSA9PSAnUE9TVCcpIHtcbiAgICAgICAgcmVxdWVzdC5zZXRSZXF1ZXN0SGVhZGVyKFwiQ29udGVudC1UeXBlXCIscmVxdWVzdF9kYXRhLmNvbnRlbnQgPyByZXF1ZXN0X2RhdGEuY29udGVudCA6IFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIpO1xuICAgICAgICBkYXRhYmxvY2sgPSByZXF1ZXN0X2RhdGEuY29udGVudCA/IHJlcXVlc3RfZGF0YS5kYXRhIDogbWFrZV9wYXJhbXMocmVxdWVzdF9kYXRhLmRhdGEpO1xuICAgIH1cblxuICAgIGlmIChyZXF1ZXN0LmN1c3RvbVVBKSB7XG4gICAgICAgIHJlcXVlc3Quc2V0UmVxdWVzdEhlYWRlcignVXNlci1BZ2VudCcscmVxdWVzdC5jdXN0b21VQSk7XG4gICAgfVxuXG4gICAgaWYgKHJlcXVlc3RfZGF0YS5hdXRoKSB7XG4gICAgICAgIHJlcXVlc3Quc2V0UmVxdWVzdEhlYWRlcignQXV0aG9yaXphdGlvbicsJ0JlYXJlciAnK3JlcXVlc3RfZGF0YS5hdXRoKTtcbiAgICB9XG5cbiAgICBpZiAocmVxdWVzdF9kYXRhLmFwaV9rZXkpIHtcbiAgICAgICAgcmVxdWVzdC5zZXRSZXF1ZXN0SGVhZGVyKCd4LWFwaS1rZXknLHJlcXVlc3RfZGF0YS5hcGlfa2V5KTtcbiAgICB9XG5cbiAgICB2YXIgcmVkaXJlY3RfY291bnRzID0gNTtcblxuICAgIHJlcXVlc3Qub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgIGlmIChyZXF1ZXN0LnJlYWR5U3RhdGUgPT0gNCkge1xuICAgICAgICAgICAgaWYgKHJlcXVlc3Quc3RhdHVzID49IDMwMCAmJiByZXF1ZXN0LnN0YXR1cyA8IDQwMCAmJiByZWRpcmVjdF9jb3VudHMgPiAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxvYyA9IChyZXF1ZXN0LmdldFJlc3BvbnNlSGVhZGVyKCdsb2NhdGlvbicpKS5yZXBsYWNlKC9sb2NhdGlvbjpcXHMrLywnJyk7XG4gICAgICAgICAgICAgICAgcmVkaXJlY3RfY291bnRzID0gcmVkaXJlY3RfY291bnRzIC0gMTtcbiAgICAgICAgICAgICAgICByZXF1ZXN0Lm9wZW4oJ0dFVCcsbG9jLHJlcXVlc3RfZGF0YS5hc3luYyk7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC5zZW5kKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcXVlc3Quc3RhdHVzID09IDUwMykge1xuICAgICAgICAgICAgICAgIC8vIExldCdzIGVuY29kZSBhbiBleHBvbmVudGlhbCBiYWNrb2ZmXG4gICAgICAgICAgICAgICAgcmVxdWVzdC5sYXN0X3dhaXQgPSAocmVxdWVzdF9kYXRhLmxhc3Rfd2FpdCB8fCA1MDApICogMjtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3Qub3BlbihyZXF1ZXN0X2RhdGEudHlwZSxyZXF1ZXN0X2RhdGEudXJsLHJlcXVlc3RfZGF0YS5hc3luYyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0X2RhdGEudHlwZSA9PSAnUE9TVCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3Quc2V0UmVxdWVzdEhlYWRlcihcIkNvbnRlbnQtVHlwZVwiLHJlcXVlc3RfZGF0YS5jb250ZW50ID8gcmVxdWVzdF9kYXRhLmNvbnRlbnQgOiBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocmVxdWVzdC5jdXN0b21VQSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5zZXRSZXF1ZXN0SGVhZGVyKCdVc2VyLUFnZW50JyxyZXF1ZXN0LmN1c3RvbVVBKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LnNlbmQoZGF0YWJsb2NrKTtcbiAgICAgICAgICAgICAgICB9LHJlcXVlc3RfZGF0YS5sYXN0X3dhaXQpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0LnN0YXR1cyA9PSA0MDMpIHtcbiAgICAgICAgICAgICAgICAvLyBNYWtlIHN1cmUgb3VyIFMzIGJ1Y2tldHMgZXhwb3NlIHRoZSBTZXJ2ZXIgaGVhZGVyIGNyb3NzLW9yaWdpblxuICAgICAgICAgICAgICAgIHZhciBzZXJ2ZXIgPSByZXF1ZXN0LmdldFJlc3BvbnNlSGVhZGVyKCdTZXJ2ZXInKTtcbiAgICAgICAgICAgICAgICBpZiAoc2VydmVyID09PSAnQW1hem9uUzMnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RfZGF0YS5zdWNjZXNzLmNhbGwobnVsbCx7XCJlcnJvclwiIDogXCJObyBkYXRhXCJ9LDQwMyxyZXF1ZXN0KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXF1ZXN0LnN0YXR1cyA+PSAyMDAgJiYgcmVxdWVzdC5zdGF0dXMgPCAzMDApIHtcbiAgICAgICAgICAgICAgICB2YXIgZGF0YV9ibG9jaztcbiAgICAgICAgICAgICAgICBpZiAocmVxdWVzdF9kYXRhLmRhdGFUeXBlID09ICd4bWwnKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFfYmxvY2sgPSB0eXBlb2YoZG9jdW1lbnQpICE9PSAndW5kZWZpbmVkJyA/IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZURvY3VtZW50KG51bGwsIFwibm9kYXRhXCIsIG51bGwpIDogeyAnZ2V0RWxlbWVudHNCeVRhZ05hbWUnIDogZnVuY3Rpb24oKSB7IHJldHVybiBbXTsgfSB9O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFfYmxvY2sgPSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRleHQgPSByZXF1ZXN0LnJlc3BvbnNlVGV4dDtcbiAgICAgICAgICAgICAgICAgICAgZGF0YV9ibG9jayA9IHJlcXVlc3RfZGF0YS5kYXRhVHlwZSA9PSAneG1sJyA/IHJlcXVlc3QucmVzcG9uc2VYTUwgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdF9kYXRhLmRhdGFUeXBlID09ICd0eHQnID8gcmVxdWVzdC5yZXNwb25zZVRleHQgOiBKU09OLnBhcnNlKHJlcXVlc3QucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlLnR5cGUgPT0gJ3VuZXhwZWN0ZWRfZW9zJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdF9kYXRhLnN1Y2Nlc3MuY2FsbChudWxsLHt9LHJlcXVlc3Quc3RhdHVzLHJlcXVlc3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdF9kYXRhLmVycm9yLmNhbGwobnVsbCxyZXF1ZXN0LnJlc3BvbnNlVGV4dCxyZXF1ZXN0LHsnZXJyb3InIDogZS50eXBlIHx8IGUubWVzc2FnZSwgJ3N0YWNrJyA6IGUgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlcXVlc3Quc3RhdHVzID09IDIwMiAmJiBkYXRhX2Jsb2NrLnN0YXR1cyA9PSBcIlJVTk5JTkdcIikge1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0Lm9wZW4ocmVxdWVzdF9kYXRhLnR5cGUscmVxdWVzdF9kYXRhLnVybCxyZXF1ZXN0X2RhdGEuYXN5bmMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlcXVlc3RfZGF0YS50eXBlID09ICdQT1NUJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3Quc2V0UmVxdWVzdEhlYWRlcihcIkNvbnRlbnQtVHlwZVwiLFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlcXVlc3QuY3VzdG9tVUEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LnNldFJlcXVlc3RIZWFkZXIoJ1VzZXItQWdlbnQnLHJlcXVlc3QuY3VzdG9tVUEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5zZW5kKGRhdGFibG9jayk7XG4gICAgICAgICAgICAgICAgICAgIH0sNTAwMCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVxdWVzdF9kYXRhLnN1Y2Nlc3MuY2FsbChudWxsLGRhdGFfYmxvY2sscmVxdWVzdC5zdGF0dXMscmVxdWVzdCk7XG4gICAgICAgICAgICAgICAgZGF0YV9ibG9jayA9IG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlcXVlc3RfZGF0YS5lcnJvci5jYWxsKG51bGwscmVxdWVzdC5yZXNwb25zZVRleHQscmVxdWVzdCxyZXF1ZXN0LnN0YXR1cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGlmIChNQVNDUC5ORVRXT1JLX0ZBSUwgJiYgTUFTQ1AuTkVUV09SS19GQUlMLmVuYWJsZWQpIHtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiQ2F1c2luZyBuZXR3b3JrIGZhaWx1cmVcIik7XG4gICAgICAgICAgICByZXF1ZXN0ID0geyAnb25yZWFkeXN0YXRlY2hhbmdlJyA6IHJlcXVlc3Qub25yZWFkeXN0YXRlY2hhbmdlfTtcbiAgICAgICAgICAgIHJlcXVlc3QucmVhZHlTdGF0ZSA9IDQ7XG4gICAgICAgICAgICByZXF1ZXN0LnN0YXR1cyA9IE1BU0NQLk5FVFdPUktfRkFJTC5zdGF0dXMgfHwgNTAwO1xuICAgICAgICAgICAgcmVxdWVzdC5yZXNwb25zZVRleHQgPSBcIkludGVyY2VwdGVkIGJ5IE5ldHdvcmsgRmFpbHVyZSBzaW11bGF0b3JcIjtcbiAgICAgICAgICAgIHJlcXVlc3Qub25yZWFkeXN0YXRlY2hhbmdlKCk7XG4gICAgICAgIH0sMTAwMCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICByZXF1ZXN0LnNlbmQoZGF0YWJsb2NrKTtcbn07XG5cblNlcnZpY2UucmVxdWVzdCA9IGZ1bmN0aW9uKHVybCxjYWxsYmFjayxub3BhcnNlKSB7XG4gICAgdmFyIG1ldGhvZCA9ICBNQVNDUC5JRSA/IGRvX3JlcXVlc3RfaWUgOiBkb19yZXF1ZXN0O1xuICAgIGlmIChNQVNDUC5JRSAmJiAhIHVybC5tYXRjaCgvXmh0dHBzP1xcOi8pKSB7XG4gICAgICAgIG1ldGhvZCA9IGRvX3JlcXVlc3Q7XG4gICAgfVxuICAgIHZhciBwYXJhbXM7XG4gICAgaWYgKCAhIHVybCApIHtcbiAgICAgICAgY2FsbGJhY2sobnVsbCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB1cmwgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgcGFyYW1zID0gIHsgYXN5bmM6IHRydWUsIHVybDogdXJsLCB0aW1lb3V0OiA1MDAwLCB0eXBlIDogXCJHRVRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yOiBmdW5jdGlvbihyZXNwb25zZSxyZXEsc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suY2FsbChudWxsLHtcInN0YXR1c1wiIDogc3RhdHVzIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6ZnVuY3Rpb24oZGF0YSxzdGF0dXMseGhyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suY2FsbChudWxsLG51bGwsZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgfSBlbHNlIGlmICh1cmwuaGFzT3duUHJvcGVydHkoJ3VybCcpKSB7XG4gICAgICAgIHBhcmFtcyA9IHVybDtcbiAgICAgICAgcGFyYW1zLnN1Y2Nlc3MgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICBjYWxsYmFjay5jYWxsKG51bGwsbnVsbCxkYXRhKTtcbiAgICAgICAgfTtcbiAgICAgICAgcGFyYW1zLmVycm9yID0gZnVuY3Rpb24ocmVzcCxyZXEsc3RhdHVzKSB7XG4gICAgICAgICAgICBjYWxsYmFjay5jYWxsKG51bGwse1wic3RhdHVzXCI6IHN0YXR1c30pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAobm9wYXJzZSkge1xuICAgICAgICBwYXJhbXMuZGF0YVR5cGUgPSAndHh0JztcbiAgICAgICAgaWYgKG5vcGFyc2UgPT09IFwieG1sXCIpIHtcbiAgICAgICAgICAgIHBhcmFtcy5kYXRhVHlwZSA9ICd4bWwnO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1ldGhvZC5jYWxsKG51bGwscGFyYW1zKTtcbn07XG5cbi8qKlxuICogUHJpdmF0ZSBtZXRob2QgZm9yIHBlcmZvcm1pbmcgYSBjcm9zcy1kb21haW4gcmVxdWVzdCB1c2luZyBJbnRlcm5ldCBFeHBsb3JlciA4IGFuZCB1cC4gQWRhcHRzIHRoZSBcbiAqIHBhcmFtZXRlcnMgcGFzc2VkLCBhbmQgYnVpbGRzIGFuIFhEUiBvYmplY3QuIFRoZXJlIGlzIG5vIHN1cHBvcnQgZm9yIGEgbG9ja2luZ1xuICogc3luY2hyb25vdXMgbWV0aG9kIHRvIGRvIHRoZXNlIHJlcXVlc3RzICh0aGF0IGlzIHJlcXVpcmVkIGZvciBVbml0IHRlc3RpbmcpIHNvIGFuIGFsZXJ0IGJveCBpcyB1c2VkXG4gKiB0byBwcm92aWRlIHRoZSBsb2NraW5nLlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhSGFzaCBIYXNoIHdpdGggdGhlIGRhdGEgYW5kIHNldHRpbmdzIHVzZWQgdG8gYnVpbGQgdGhlIHF1ZXJ5LlxuICovXG5cblxudmFyIGRvX3JlcXVlc3RfaWUgPSBmdW5jdGlvbihkYXRhSGFzaClcbntcbiAgICAvLyBVc2UgWERSXG4gICAgdmFyIHhkciA9IG5ldyBYRG9tYWluUmVxdWVzdCgpO1xuICAgIHZhciBsb2FkZWQgPSBmYWxzZTtcbiAgICB2YXIgY291bnRlciA9IDA7XG4gICAgeGRyLm9uZXJyb3IgPSBmdW5jdGlvbihldikge1xuICAgICAgICBkYXRhSGFzaC5lcnJvcih4ZHIseGRyLHtcIm1lc3NhZ2VcIiA6IFwiWERvbWFpblJlcXVlc3QgZXJyb3JcIn0pO1xuICAgIH07XG4gICAgeGRyLm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbigpIHsgfTtcbiAgICB4ZHIub3BlbihcIkdFVFwiLGRhdGFIYXNoLnVybCtcIj9cIittYWtlX3BhcmFtcyhkYXRhSGFzaC5kYXRhKSk7XG4gICAgeGRyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBsb2FkZWQgPSB0cnVlO1xuICAgICAgICBpZiAoZGF0YUhhc2guZGF0YVR5cGUgPT0gJ3htbCcpIHtcbiAgICAgICAgICAgIHZhciBkb20gPSBuZXcgQWN0aXZlWE9iamVjdChcIk1pY3Jvc29mdC5YTUxET01cIik7XG4gICAgICAgICAgICBkb20uYXN5bmMgPSBmYWxzZTtcbiAgICAgICAgICAgIGRvbS5sb2FkWE1MKHhkci5yZXNwb25zZVRleHQpO1xuICAgICAgICAgICAgZGF0YUhhc2guc3VjY2Vzcyhkb20sICdzdWNjZXNzJyx4ZHIpO1xuICAgICAgICB9IGVsc2UgaWYgKGRhdGFIYXNoLmRhdGFUeXBlID09ICdqc29uJykge1xuICAgICAgICAgICAgdmFyIHBhcnNlZCA9IG51bGw7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHBhcnNlZCA9IEpTT04ucGFyc2UoeGRyLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICB9IGNhdGNoKGVycikge1xuICAgICAgICAgICAgICAgIGRhdGFIYXNoLmVycm9yKHhkcix4ZHIse1wibWVzc2FnZVwiIDogXCJKU09OIHBhcnNpbmcgZXJyb3JcIn0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcnNlZCkge1xuICAgICAgICAgICAgICAgIGRhdGFIYXNoLnN1Y2Nlc3MocGFyc2VkLCdzdWNjZXNzJyx4ZHIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGF0YUhhc2guc3VjY2Vzcyh4ZHIucmVzcG9uc2VUZXh0LCAnc3VjY2VzcycsIHhkcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIFdlIGNhbid0IHNldCB0aGUgY29udGVudC10eXBlIG9uIHRoZSBwYXJhbWV0ZXJzIGhlcmUgdG8gdXJsLWVuY29kZWQgZm9ybSBkYXRhLlxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICB4ZHIuc2VuZCgpO1xuICAgIH0sIDApO1xuICAgIHdoaWxlICghIGRhdGFIYXNoLmFzeW5jICYmICEgbG9hZGVkICYmIGNvdW50ZXIgPCAzKSB7XG4gICAgICAgIGFsZXJ0KFwiVGhpcyBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgc3luY2hyb25vdXMgcmVxdWVzdHMsIGNsaWNrIE9LIHdoaWxlIHdlJ3JlIHdhaXRpbmcgZm9yIGRhdGFcIik7XG4gICAgICAgIGNvdW50ZXIgKz0gMTtcbiAgICB9XG4gICAgaWYgKCAhIGRhdGFIYXNoLmFzeW5jICYmICEgbG9hZGVkICkge1xuICAgICAgICBhbGVydChcIk5vIGRhdGFcIik7XG4gICAgfVxufTtcblxuYmFzZS5yZXRyaWV2ZSA9IGZ1bmN0aW9uKGFnaSxjYWxsYmFjaylcbntcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBTZXJ2aWNlLl9jdXJyZW50X3JlcXMgPSBTZXJ2aWNlLl9jdXJyZW50X3JlcXMgfHwgMDtcbiAgICBTZXJ2aWNlLl93YWl0aW5nX3JlcXMgPSBTZXJ2aWNlLl93YWl0aW5nX3JlcXMgfHwgMDtcbiAgICBcbiAgICBpZiAoU2VydmljZS5NQVhfUkVRVUVTVFMpIHtcbiAgICAgICAgdmFyIG15X2Z1bmMgPSBhcmd1bWVudHMuY2FsbGVlO1xuICAgICAgICBpZiAoU2VydmljZS5fY3VycmVudF9yZXFzID4gU2VydmljZS5NQVhfUkVRVUVTVFMpIHtcbiAgICAgICAgICAgIFNlcnZpY2UuX3dhaXRpbmdfcmVxcyArPSAxO1xuICAgICAgICAgICAgYmVhbi5hZGQoU2VydmljZSwncmVxdWVzdENvbXBsZXRlJyxmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBiZWFuLnJlbW92ZSh0aGlzLCdyZXF1ZXN0Q29tcGxldGUnLGFyZ3VtZW50cy5jYWxsZWUpO1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIFNlcnZpY2UuX3dhaXRpbmdfcmVxcyAtPSAxO1xuICAgICAgICAgICAgICAgICAgICBteV9mdW5jLmNhbGwoc2VsZixhZ2ksY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIH0sMCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChhZ2kpIHtcbiAgICAgICAgdGhpcy5hZ2kgPSBhZ2k7XG4gICAgfVxuXG4gICAgaWYgKGFnaSAmJiBjYWxsYmFjaykge1xuICAgICAgICB0aGlzLmFnaSA9IGFnaTtcblxuICAgICAgICB0aGlzLnJlc3VsdCA9IG51bGw7XG4gICAgICAgIFxuICAgICAgICB2YXIgZG9uZV9yZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgdmFyIGRvbmVfZnVuYyA9IGZ1bmN0aW9uKGVycixvYmopIHtcbiAgICAgICAgICAgIGJlYW4ucmVtb3ZlKHNlbGYsXCJyZXN1bHRSZWNlaXZlZFwiLGRvbmVfZnVuYyk7XG4gICAgICAgICAgICBiZWFuLnJlbW92ZShzZWxmLFwiZXJyb3JcIixkb25lX2Z1bmMpO1xuICAgICAgICAgICAgYmVhbi5yZW1vdmUoc2VsZixcInJlcXVlc3RDb21wbGV0ZVwiLGRvbmVfZnVuYyk7XG4gICAgICAgICAgICBpZiAoICEgZG9uZV9yZXN1bHQgKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKHNlbGYsZXJyKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKHNlbGYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvbmVfcmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgYmVhbi5hZGQoc2VsZixcInJlc3VsdFJlY2VpdmVkXCIsZG9uZV9mdW5jKTtcbiAgICAgICAgYmVhbi5hZGQoc2VsZixcImVycm9yXCIsZG9uZV9mdW5jKTtcbiAgICAgICAgYmVhbi5hZGQoc2VsZixcInJlcXVlc3RDb21wbGV0ZVwiLGRvbmVfZnVuYyk7XG4gICAgfVxuICAgIHZhciByZXF1ZXN0X2RhdGEgPSB0aGlzLnJlcXVlc3REYXRhKCk7XG5cbiAgICBpZiAocmVxdWVzdF9kYXRhID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCEgcmVxdWVzdF9kYXRhICkge1xuICAgICAgICBiZWFuLmZpcmUoc2VsZixcImVycm9yXCIsW1wiTm8gcmVxdWVzdCBkYXRhXCJdKTtcbiAgICAgICAgYmVhbi5maXJlKFNlcnZpY2UsXCJyZXF1ZXN0Q29tcGxldGVcIixbc2VsZl0pO1xuICAgICAgICB0aGlzLnJlcXVlc3RDb21wbGV0ZSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgICAgIFxuICAgIHZhciBkZWZhdWx0X3BhcmFtcyA9IHtcbiAgICBhc3luYzogICAgICB0aGlzLmFzeW5jLFxuICAgIHVybDogICAgICAgIHJlcXVlc3RfZGF0YS51cmwgfHwgdGhpcy5fZW5kcG9pbnRVUkwsXG4gICAgdGltZW91dDogICAgNTAwMCxcbiAgICBlcnJvcjogICAgICBmdW5jdGlvbihyZXNwb25zZSxyZXEsc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgIFNlcnZpY2UuX2N1cnJlbnRfcmVxcyAtPSAxO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHN0YXR1cyA9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzID0geyAnZXJyb3InIDogc3RhdHVzICwgJ3JlcXVlc3QnIDogcmVxIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCEgaXNOYU4oc3RhdHVzKSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1cyA9IHsgXCJlcnJvclwiIDogXCJSZXFldXN0IGVycm9yXCIsIFwic3RhdHVzXCIgOiBzdGF0dXMsICdyZXF1ZXN0JyA6IHJlcSB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJlYW4uZmlyZShzZWxmLFwiZXJyb3JcIixbc3RhdHVzXSk7XG4gICAgICAgICAgICAgICAgICAgIGJlYW4uZmlyZShTZXJ2aWNlLCdyZXF1ZXN0Q29tcGxldGUnKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5yZXF1ZXN0Q29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICAgICAgLy90aHJvdyBcIkVycm9yIG9jY3VycmVkIHJldHJpZXZpbmcgZGF0YSBmb3Igc2VydmljZSBcIitzZWxmLl9lbmRwb2ludFVSTDtcbiAgICAgICAgICAgICAgICB9LFxuICAgIHN1Y2Nlc3M6ICAgIGZ1bmN0aW9uKGRhdGEsc3RhdHVzLHhocikge1xuICAgICAgICAgICAgICAgICAgICBTZXJ2aWNlLl9jdXJyZW50X3JlcXMgLT0gMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCB4aHIgJiYgeGhyLnN0YXR1cyAhPT0gbnVsbCAmJiB4aHIuc3RhdHVzID09PSAwICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVhbi5maXJlKHNlbGYsXCJlcnJvclwiLFt7XCJlcnJvclwiOiBcIlplcm8gcmV0dXJuIHN0YXR1cyBmcm9tIHJlcXVlc3QgXCJ9XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnJlcXVlc3RDb21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciByZWNlaXZlZF9mbGFnID0gc2VsZi5fZGF0YVJlY2VpdmVkKGRhdGEsc3RhdHVzKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAocmVjZWl2ZWRfZmxhZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5nb3RSZXN1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWNlaXZlZF9mbGFnICE9PSBudWxsICYmIHR5cGVvZiByZWNlaXZlZF9mbGFnICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5yZXF1ZXN0Q29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYucmVxdWVzdEluY29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICB9O1xuICAgIGRlZmF1bHRfcGFyYW1zID0gT2JqZWN0LmFzc2lnbihyZXF1ZXN0X2RhdGEsZGVmYXVsdF9wYXJhbXMpO1xuICAgIGlmIChNQVNDUC5JRSkge1xuICAgICAgICBkb19yZXF1ZXN0X2llKGRlZmF1bHRfcGFyYW1zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBkb19yZXF1ZXN0KGRlZmF1bHRfcGFyYW1zKTtcbiAgICB9XG4gICAgXG4gICAgU2VydmljZS5fY3VycmVudF9yZXFzICs9IDE7XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbn0pKFNlcnZpY2UucHJvdG90eXBlKTtcblxuLyoqXG4gKiAgR2V0IHRoZSBwYXJhbWV0ZXJzIHRoYXQgd2lsbCBiZSB1c2VkIHRvIGJ1aWxkIHRoaXMgcmVxdWVzdC4gSW1wbGVtZW50YXRpb25zIG9mIHNlcnZpY2VzIHdpbGxcbiAqICBvdmVycmlkZSB0aGlzIG1ldGhvZCwgcmV0dXJuaW5nIHRoZSBwYXJhbWV0ZXJzIHRvIGJlIHVzZWQgdG8gYnVpbGQgdGhlIFhIUi5cbiAqL1xuXG5TZXJ2aWNlLnByb3RvdHlwZS5yZXF1ZXN0RGF0YSA9IGZ1bmN0aW9uKClcbntcbiAgICBcbn07XG5cblNlcnZpY2UucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKVxue1xuICAgIGZvciAodmFyIGNsYXp6IGluIE1BU0NQKSB7XG4gICAgICAgIGlmICh0aGlzLl9fY2xhc3NfXyA9PSBNQVNDUFtjbGF6el0pIHtcbiAgICAgICAgICAgIHJldHVybiBcIk1BU0NQLlwiK2NsYXp6O1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBGb3IgdGhpcyBzZXJ2aWNlLCByZWdpc3RlciBhIHNlcXVlbmNlIHJlbmRlcmluZyB2aWV3IHNvIHRoYXQgdGhlIHJlc3VsdHMgY2FuIGJlIG1hcmtlZCB1cCBkaXJlY3RseVxuICogb24gdG8gYSBzZXF1ZW5jZS4gVGhpcyBtZXRob2Qgd2lsbCBkbyBub3RoaW5nIGlmIHRoZSBzZXJ2aWNlIGRvZXMgbm90IGtub3cgaG93IHRvIHJlbmRlciB0aGUgXG4gKiByZXN1bHRzIG9udG8gdGhlIHNlcXVlbmNlLlxuICogQHBhcmFtIHtNQVNDUC5TZXF1ZW5jZVJlbmRlcmVyfSBzZXF1ZW5jZVJlbmRlcmVyIFNlcXVlbmNlIHJlbmRlcmVyIG9iamVjdCB0byByZW5kZXIgcmVzdWx0cyB1cG9uXG4gKi9cblNlcnZpY2UucHJvdG90eXBlLnJlZ2lzdGVyU2VxdWVuY2VSZW5kZXJlciA9IGZ1bmN0aW9uKHNlcXVlbmNlUmVuZGVyZXIsb3B0aW9ucylcbntcbiAgICBpZiAodGhpcy5zZXR1cFNlcXVlbmNlUmVuZGVyZXIpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlcnMgPSB0aGlzLnJlbmRlcmVycyB8fCBbXTtcbiAgICAgICAgdGhpcy5zZXR1cFNlcXVlbmNlUmVuZGVyZXIoc2VxdWVuY2VSZW5kZXJlcixvcHRpb25zKTtcbiAgICAgICAgdGhpcy5yZW5kZXJlcnMucHVzaChzZXF1ZW5jZVJlbmRlcmVyKTtcbiAgICB9XG4gICAgc2VxdWVuY2VSZW5kZXJlci50cmlnZ2VyKCdyZWFkZXJSZWdpc3RlcmVkJyxbdGhpc10pO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuU2VydmljZS5wcm90b3R5cGUucmVzZXRPblJlc3VsdCA9IGZ1bmN0aW9uKHNlcXVlbmNlUmVuZGVyZXIscmVuZGVyZWQsdHJhY2spIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHJlc3VsdF9mdW5jID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHNlbGYudW5iaW5kKCdyZXN1bHRSZWNlaXZlZCcscmVzdWx0X2Z1bmMpO1xuICAgICAgICBzZXF1ZW5jZVJlbmRlcmVyLmJpbmQoJ3Jlc3VsdHNSZW5kZXJlZCcsY2xlYXJfZnVuYyk7XG4gICAgfTtcblxuICAgIHZhciBjbGVhcl9mdW5jID0gZnVuY3Rpb24ocmVhZGVyKSB7XG4gICAgICAgIGlmIChyZWFkZXIgIT09IHNlbGYpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzZXF1ZW5jZVJlbmRlcmVyLnVuYmluZCgncmVzdWx0c1JlbmRlcmVkJyxjbGVhcl9mdW5jKTtcbiAgICAgICAgcmVuZGVyZWQuZm9yRWFjaChmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgIHNlcXVlbmNlUmVuZGVyZXIucmVtb3ZlKHRyYWNrLG9iaik7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgdGhpcy5iaW5kKCdyZXN1bHRSZWNlaXZlZCcscmVzdWx0X2Z1bmMpO1xufTtcblxuXG4vKipcbiAqIEZvciB0aGlzIHNlcnZpY2UsIHNldCB1cCBhIHNlcXVlbmNlIHJlbmRlcmVyIHNvIHRoYXQgdGhlIGV2ZW50cyBhcmUgY29ubmVjdGVkIHVwIHdpdGggcmVjZWl2aW5nIGRhdGEuXG4gKiBUaGlzIG1ldGhvZCBzaG91bGQgYmUgb3ZlcnJpZGRlbiB0byB3aXJlIHVwIHRoZSBzZXF1ZW5jZSByZW5kZXJlciB0byB0aGUgc2VydmljZS5cbiAqIEBwYXJhbSB7TUFTQ1AuU2VxdWVuY2VSZW5kZXJlcn0gc2VxdWVuY2VSZW5kZXJlciBTZXF1ZW5jZSByZW5kZXJlciBvYmplY3QgdG8gcmVuZGVyIHJlc3VsdHMgdXBvblxuICovXG5TZXJ2aWNlLnByb3RvdHlwZS5zZXR1cFNlcXVlbmNlUmVuZGVyZXIgPSBmdW5jdGlvbihzZXF1ZW5jZVJlbmRlcmVyKVxue1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqIERlZmF1bHQgY29uc3RydWN0b3JcbiAqICBAY2xhc3MgIFN1cGVyLWNsYXNzIGZvciBhbGwgcmVzdWx0cyBmcm9tIE1BU0NQIHNlcnZpY2VzLlxuICovXG5TZXJ2aWNlLlJlc3VsdCA9IGZ1bmN0aW9uKClcbnsgIFxufTtcblxuU2VydmljZS5SZXN1bHQucHJvdG90eXBlID0ge1xuICAgIGFnaSAgICAgOiAgIG51bGwsXG4gICAgcmVhZGVyICA6ICAgbnVsbFxufTtcblxuXG5TZXJ2aWNlLlJlc3VsdC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24oKSB7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBTZXJ2aWNlOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O0FBT0E7QUFDQTtBQUNBOzs7Ozs7OztBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBMUJBO0FBQ0E7QUE0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBQ0E7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBQ0E7QUFNQTs7Ozs7QUFLQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OztBQVFBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OztBQU9BO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7Ozs7OztBQU1BOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFOQTtBQVFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7QUFVQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBbkNBO0FBcUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUlBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7O0FBTUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7OztBQUtBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFHQTtBQUNBO0FBQ0E7QUFGQTtBQUNBO0FBS0E7QUFDQTtBQUVBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./js/lib/Service.js\n");

/***/ }),

/***/ "./js/lib/ServiceCaching.js":
/*!**********************************!*\
  !*** ./js/lib/ServiceCaching.js ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Service__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Service */ \"./js/lib/Service.js\");\n/* harmony import */ var _MASCP__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./MASCP */ \"./js/lib/MASCP.js\");\n\n\n\n\nvar get_db_data, store_db_data, search_service, clear_service, find_latest_data, data_timestamps, sweep_cache, cached_accessions, begin_transaction, end_transaction, first_accession;\n\nvar max_age = 0,\n    min_age = 0;\n\nclass CachingService extends _Service__WEBPACK_IMPORTED_MODULE_0__[\"default\"] {}\n\nCachingService.BeginCaching = function () {\n    CachingService.CacheService(CachingService.prototype);\n};\n\n// To do 7 days ago, you do\n// var date = new Date();\n// date.setDate(date.getDate() - 1);\n// Service.SetMinimumFreshnessAge(date);\n\n// Set the minimum age if you want nothing OLDER than this date\nCachingService.SetMinimumAge = function (date) {\n    if (date === 0) {\n        min_age = 0;\n    } else {\n        min_age = date.getTime();\n    }\n};\n\n// Set the maximum age if you want nothing NEWER than this date\nCachingService.SetMaximumAge = function (date) {\n    if (date === 0) {\n        max_age = 0;\n    } else {\n        max_age = date.getTime();\n    }\n};\n\nCachingService.SweepCache = function (date) {\n    if (!date) {\n        date = new Date();\n    }\n    sweep_cache(date.getTime());\n};\n\nCachingService.CacheService = function (reader) {\n    if (reader.prototype && reader.prototype.retrieve.caching || reader.retrieve.caching) {\n        return;\n    }\n    var _oldRetrieve = reader.retrieve;\n    var has_avoid;\n    reader.retrieve = function (agi, cback) {\n        var self = this;\n        var id = agi ? agi : self.agi;\n        if (!id) {\n            _oldRetrieve.call(self, id, cback);\n            return self;\n        }\n\n        id = id.toLowerCase();\n        self.agi = id;\n\n        if (self.avoid_database) {\n            if (has_avoid) {\n                return;\n            }\n            has_avoid = self._dataReceived;\n            self._dataReceived = function () {\n                return function (dat) {\n                    var res = has_avoid.call(this, dat);\n                    var id = self.agi;\n                    if (res && this.result && this.result._raw_data !== null) {\n                        store_db_data(id, this.toString(), this.result._raw_data || {});\n                    }\n                    dat = {};\n                    return res;\n                };\n            }();\n            cback.call(self);\n            return;\n        }\n        if (has_avoid && !self.avoid_database) {\n            self._dataReceived = has_avoid;\n            has_avoid = null;\n            cback.call(self);\n            return;\n        }\n\n        get_db_data(id, self.toString(), function (err, data) {\n            if (data) {\n                if (cback) {\n                    self.result = null;\n                    var done_func = function done_func(err) {\n                        bean.remove(self, \"resultReceived\", arguments.callee);\n                        bean.remove(self, \"error\", arguments.callee);\n                        cback.call(self, err);\n                    };\n                    bean.add(self, \"resultReceived\", done_func);\n                    bean.add(self, \"error\", done_func);\n                }\n\n                var received_flag = self._dataReceived(data, \"db\");\n\n                if (received_flag) {\n                    self.gotResult();\n                }\n\n                if (received_flag !== null) {\n                    self.requestComplete();\n                } else {\n                    self.requestIncomplete();\n                }\n            } else {\n                var old_received = self._dataReceived;\n                self._dataReceived = function () {\n                    return function (dat, source) {\n                        var res = old_received.call(this, dat, source);\n                        if (res && this.result && this.result._raw_data !== null) {\n                            store_db_data(id, this.toString(), this.result._raw_data || {});\n                        }\n                        this._dataReceived = null;\n                        this._dataReceived = old_received;\n                        dat = {};\n                        return res;\n                    };\n                }();\n                var old_url = self._endpointURL;\n                // If we have a maximum age, i.e. we don't want anything newer than a date\n                // we should not actually do a request that won't respect that.\n                // We can set a minimum age, since the latest data will be, by definition be the latest!\n                if (max_age !== 0) {\n                    self._endpointURL = null;\n                }\n                _oldRetrieve.call(self, id, cback);\n                self._endpointURL = old_url;\n            }\n        });\n        return self;\n    };\n    reader.retrieve.caching = true;\n};\n\nCachingService.FindCachedService = function (service, cback) {\n    var serviceString = service.toString();\n    search_service(serviceString, cback);\n    return true;\n};\n\nCachingService.CachedAgis = function (service, cback) {\n    var serviceString = service.toString();\n    cached_accessions(serviceString, cback);\n    return true;\n};\n\nCachingService.FirstAgi = function (service, cback) {\n    var serviceString = service.toString();\n    first_accession(serviceString, cback);\n    return true;\n};\n\nCachingService.ClearCache = function (service, agi, callback) {\n    var serviceString = service.toString();\n    if (!callback) {\n        callback = function callback() {};\n    }\n    clear_service(serviceString, agi, callback);\n    return true;\n};\n\nCachingService.HistoryForService = function (service, cback) {\n    var serviceString = service.toString();\n    data_timestamps(serviceString, null, cback);\n};\n\nCachingService.Snapshot = function (service, date, wanted, cback) {\n    var serviceString = service.toString();\n    get_snapshot(serviceString, null, wanted, cback);\n};\n\nvar transaction_ref_count = 0;\nvar waiting_callbacks = [];\nCachingService.BulkOperation = function (callback) {\n    transaction_ref_count++;\n    var trans = function trans(callback) {\n        if (!callback) {\n            callback = function callback() {};\n        }\n        transaction_ref_count--;\n        waiting_callbacks.push(callback);\n        if (transaction_ref_count == 0) {\n            end_transaction(function (err) {\n                waiting_callbacks.forEach(function (cback) {\n                    cback(err);\n                });\n                waiting_callbacks = [];\n            });\n        }\n    };\n    begin_transaction(callback, trans);\n    return trans;\n};\n\nvar setup_idb = function setup_idb(idb) {\n    var transaction_store_db;\n    var transaction_find_latest;\n    var transaction_data = [];\n    begin_transaction = function begin_transaction(callback, trans) {\n        if (transaction_store_db != null) {\n            setTimeout(function () {\n                callback.call({ \"transaction\": trans });\n            }, 0);\n            return false;\n        }\n        transaction_store_db = store_db_data;\n        store_db_data = function store_db_data(acc, service, data) {\n            transaction_data.push([acc, service, data]);\n        };\n        setTimeout(function () {\n            callback.call({ \"transaction\": trans });\n        }, 0);\n        return true;\n    };\n\n    end_transaction = function end_transaction(callback) {\n        if (transaction_store_db === null) {\n            callback(null);\n            return;\n        }\n        store_db_data = transaction_store_db;\n        transaction_store_db = null;\n        var trans = idb.transaction([\"cached\"], \"readwrite\");\n        var store = trans.objectStore(\"cached\");\n        trans.oncomplete = function (event) {\n            callback(null);\n        };\n        trans.onerror = function (event) {\n            callback(event.target.errorCode);\n        };\n        while (transaction_data.length > 0) {\n            var row = transaction_data.shift();\n            var acc = row[0];\n            var service = row[1];\n            var data = row[2];\n            if (typeof data != 'object' || data.constructor.name !== 'Object' || typeof Document != 'undefined' && data instanceof Document) {\n                continue;\n            }\n            var dateobj = data.retrieved ? data.retrieved : new Date();\n            if (typeof dateobj === 'string' || typeof dateobj === 'number') {\n                dateobj = new Date(dateobj);\n            }\n            dateobj.setUTCHours(0);\n            dateobj.setUTCMinutes(0);\n            dateobj.setUTCSeconds(0);\n            dateobj.setUTCMilliseconds(0);\n            var reporter = insert_report_func(acc, service);\n            var datetime = dateobj.getTime();\n            data.id = [acc, service, datetime];\n            data.acc = acc;\n            data.service = service;\n            if (window.msIndexedDB) {\n                data.serviceacc = service + acc;\n            }\n            data.retrieved = datetime;\n            var req = store.put(data);\n            req.onerror = reporter;\n        }\n    };\n\n    var insert_report_func = function insert_report_func(acc, service) {\n        return function (err, rows) {\n            if (!err && rows) {}\n        };\n    };\n\n    store_db_data = function store_db_data(acc, service, data) {\n        var trans = idb.transaction([\"cached\"], \"readwrite\");\n        var store = trans.objectStore(\"cached\");\n        if (typeof data != 'object' || typeof Document != 'undefined' && data instanceof Document) {\n            return;\n        }\n        var dateobj = data.retrieved ? data.retrieved : new Date();\n        if (typeof dateobj === 'string' || typeof dateobj === 'number') {\n            dateobj = new Date(dateobj);\n        }\n        dateobj.setUTCHours(0);\n        dateobj.setUTCMinutes(0);\n        dateobj.setUTCSeconds(0);\n        dateobj.setUTCMilliseconds(0);\n        var reporter = insert_report_func(acc, service);\n        var datetime = dateobj.getTime();\n        data.id = [acc, service, datetime];\n        data.acc = acc;\n        if (window.msIndexedDB) {\n            data.serviceacc = service + acc;\n        }\n        data.service = service;\n        data.retrieved = datetime;\n        var req = store.put(data);\n        // req.onsuccess = reporter;\n        req.onerror = reporter;\n    };\n\n    get_db_data = function get_db_data(acc, service, cback) {\n        var timestamps = max_age ? [min_age, max_age] : [min_age, new Date().getTime()];\n        return find_latest_data(acc, service, timestamps, cback);\n    };\n\n    find_latest_data = function find_latest_data(acc, service, timestamps, cback) {\n        if (!acc) {\n            cback.call();\n            return;\n        }\n        var trans = idb.transaction([\"cached\"], \"readonly\");\n        var store = trans.objectStore(\"cached\");\n        var idx = store.index(window.msIndexedDB ? \"entries-ms\" : \"entries\");\n        var max_stamp = -1;\n        var result = null;\n        var range = IDBKeyRange.only(window.msIndexedDB ? service + acc : [acc, service]);\n        idx.openCursor(range).onsuccess = function (event) {\n            var cursor = event.target.result;\n            if (cursor) {\n                var ts = window.msIndexedDB ? cursor.value.retrieved : cursor.primaryKey[2];\n                var c_acc = window.msIndexedDB ? cursor.value.acc : cursor.primaryKey[0];\n                var serv = window.msIndexedDB ? cursor.value.service : cursor.primaryKey[1];\n                if (ts >= timestamps[0] && ts <= timestamps[1]) {\n                    if (ts > max_stamp && c_acc == acc && serv == service) {\n                        result = cursor.value;\n                        max_stamp = ts;\n                        result.retrieved = new Date(ts);\n                    }\n                }\n                cursor.continue();\n            } else {\n                if (result) {\n                    // result = result.data\n                }\n                cback.call(null, null, result);\n            }\n        };\n    };\n\n    sweep_cache = function sweep_cache(timestamp) {\n        var trans = idb.transaction([\"cached\"], \"readwrite\");\n        var store = trans.objectStore(\"cached\");\n        var idx = store.index(\"timestamps\");\n        var results = [];\n        idx.openKeyCursor(null, \"nextunique\").onsuccess = function (event) {\n            var cursor = event.target.result;\n            if (cursor) {\n                if (timestamp >= cursor.key[1]) {\n                    store.delete(cursor.primaryKey);\n                }\n                cursor.continue();\n            }\n        };\n    };\n\n    data_timestamps = function data_timestamps(service, timestamps, cback) {\n\n        if (!timestamps || typeof timestamps != 'object' || !timestamps.length) {\n            timestamps = [0, new Date().getTime()];\n        }\n\n        var trans = idb.transaction([\"cached\"], \"readonly\");\n        var store = trans.objectStore(\"cached\");\n        var idx = store.index(\"timestamps\");\n        var results = [];\n        idx.openKeyCursor(null, \"nextunique\").onsuccess = function (event) {\n            var cursor = event.target.result;\n            if (cursor) {\n                if (cursor.key[0] == service && timestamps[0] <= cursor.key[1] && timestamps[1] >= cursor.key[1]) {\n                    results.push(new Date(parseInt(cursor.key[1])));\n                }\n                cursor.continue();\n            } else {\n                cback.call(null, results);\n            }\n        };\n    };\n\n    clear_service = function clear_service(service, acc, callback) {\n        var trans = idb.transaction([\"cached\"], \"readwrite\");\n        var store = trans.objectStore(\"cached\");\n        var idx = store.index(\"services\");\n        var range = IDBKeyRange.only(service);\n        idx.openCursor(range).onsuccess = function (event) {\n            var cursor = event.target.result;\n            if (cursor) {\n                if (!acc || cursor.value.acc == acc) {\n                    if (window.msIndexedDB) {\n                        store.delete(cursor.value.serviceacc);\n                    } else {\n                        store.delete(cursor.value.id ? cursor.value.id : cursor.primaryKey);\n                    }\n                }\n                cursor.continue();\n            }\n        };\n        trans.oncomplete = function () {\n            callback.call(_Service__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n        };\n    };\n\n    search_service = function search_service(service, cback) {\n        var trans = idb.transaction([\"cached\"], \"readonly\");\n        var store = trans.objectStore(\"cached\");\n        var idx = store.index(\"services\");\n        var results = [];\n        var range = IDBKeyRange.only(service);\n        idx.openKeyCursor(range, \"nextunique\").onsuccess = function (event) {\n            var cursor = event.target.result;\n            if (cursor) {\n                results.push(cursor.key);\n                cursor.continue();\n            } else {\n                cback.call(_Service__WEBPACK_IMPORTED_MODULE_0__[\"default\"], results);\n            }\n        };\n    };\n    first_accession = function first_accession(service, cback) {\n        var trans = idb.transaction([\"cached\"], \"readonly\");\n        var store = trans.objectStore(\"cached\");\n        var idx = store.index(\"services\");\n        var range = IDBKeyRange.only(service);\n        idx.openCursor(range, \"nextunique\").onsuccess = function (event) {\n            var cursor = event.target.result;\n            if (cursor) {\n                cback.call(_Service__WEBPACK_IMPORTED_MODULE_0__[\"default\"], cursor.value.acc);\n            } else {\n                cback.call(_Service__WEBPACK_IMPORTED_MODULE_0__[\"default\"], null);\n            }\n        };\n    };\n    cached_accessions = function cached_accessions(service, cback) {\n        var trans = idb.transaction([\"cached\"], \"readonly\");\n        var store = trans.objectStore(\"cached\");\n        var idx = store.index(\"services\");\n        var results = [];\n        var range = IDBKeyRange.only(service);\n        idx.openCursor(range).onsuccess = function (event) {\n            var cursor = event.target.result;\n            if (cursor) {\n                results.push(cursor.value.acc);\n                cursor.continue();\n            } else {\n                cback.call(_Service__WEBPACK_IMPORTED_MODULE_0__[\"default\"], results);\n            }\n        };\n    };\n};\nvar setup_websql = function setup_websql(db) {\n    db.all('SELECT version from versions where tablename = \"datacache\"', function (err, rows) {\n        var version = rows && rows.length > 0 ? rows[0].version : null;\n        if (version == 1.3) {\n            if (_MASCP__WEBPACK_IMPORTED_MODULE_1__[\"default\"].events) {\n                _MASCP__WEBPACK_IMPORTED_MODULE_1__[\"default\"].events.emit('ready');\n            }\n            if (_MASCP__WEBPACK_IMPORTED_MODULE_1__[\"default\"].ready) {\n                _MASCP__WEBPACK_IMPORTED_MODULE_1__[\"default\"].ready();\n                _MASCP__WEBPACK_IMPORTED_MODULE_1__[\"default\"].ready = true;\n            } else {\n                _MASCP__WEBPACK_IMPORTED_MODULE_1__[\"default\"].ready = true;\n            }\n            return;\n        }\n\n        if (!version || version == \"\" || version < 1.0) {\n            db.exec('CREATE TABLE if not exists versions (version REAL, tablename TEXT);');\n            db.exec('CREATE TABLE if not exists \"datacache\" (agi TEXT,service TEXT,retrieved REAL,data TEXT);', function (err) {\n                if (err && err != \"Error: not an error\") {\n                    throw err;\n                }\n            });\n            db.exec('DELETE FROM versions where tablename = \"datacache\"');\n            db.exec('INSERT INTO versions(version,tablename) VALUES(1.1,\"datacache\");', function (err, rows) {\n                if (!err) {\n                    //                        console.log(\"Upgrade to 1.1 completed\");\n                }\n            });\n            version = 1.1;\n        }\n        if (version < 1.2) {\n            db.exec('DROP TABLE if exists datacache_tmp;');\n            db.exec('CREATE TABLE if not exists datacache_tmp (acc TEXT,service TEXT,retrieved REAL,data TEXT);');\n            db.exec('INSERT INTO datacache_tmp(acc,service,retrieved,data) SELECT agi,service,retrieved,data FROM datacache;');\n            db.exec('DROP TABLE datacache;');\n            db.exec('ALTER TABLE datacache_tmp RENAME TO datacache;');\n            db.exec('CREATE INDEX accessions on datacache(acc);');\n            db.exec('CREATE INDEX accessions_service on datacache(acc,service);');\n            db.exec('DELETE FROM versions where tablename = \"datacache\"');\n            db.exec('INSERT INTO versions(version,tablename) VALUES(1.2,\"datacache\");', function (err, rows) {\n                if (!err) {\n                    //                          console.log(\"Upgrade to 1.2 completed\");\n                }\n            });\n            version = 1.2;\n        }\n        if (version < 1.3) {\n            db.exec('CREATE INDEX if not exists services on datacache(service);');\n            db.exec('DELETE FROM versions where tablename = \"datacache\"');\n            db.exec('INSERT INTO versions(version,tablename) VALUES(1.3,\"datacache\");', function (err, rows) {\n                if (!err) {\n                    if (_MASCP__WEBPACK_IMPORTED_MODULE_1__[\"default\"].events) {\n                        _MASCP__WEBPACK_IMPORTED_MODULE_1__[\"default\"].events.emit('ready');\n                    }\n                    if (_MASCP__WEBPACK_IMPORTED_MODULE_1__[\"default\"].ready) {\n                        _MASCP__WEBPACK_IMPORTED_MODULE_1__[\"default\"].ready();\n                        _MASCP__WEBPACK_IMPORTED_MODULE_1__[\"default\"].ready = true;\n                    } else {\n                        _MASCP__WEBPACK_IMPORTED_MODULE_1__[\"default\"].ready = true;\n                    }\n                }\n            });\n            version = 1.3;\n        }\n    });\n\n    begin_transaction = function begin_transaction(callback, trans) {\n        callback.call({ \"transaction\": trans });\n    };\n    end_transaction = function end_transaction(callback) {\n        callback();\n    };\n\n    sweep_cache = function sweep_cache(timestamp) {\n        db.all(\"DELETE from datacache where retrieved <= ? \", [timestamp], function () {});\n    };\n\n    clear_service = function clear_service(service, acc, callback) {\n        var servicename = service;\n        servicename += \"%\";\n        if (!acc) {\n            db.all(\"DELETE from datacache where service like ? \", [servicename], function () {\n                callback.call(_Service__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n            });\n        } else {\n            db.all(\"DELETE from datacache where service like ? and acc = ?\", [servicename, acc.toLowerCase()], function () {\n                callback.call(_Service__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n            });\n        }\n    };\n\n    search_service = function search_service(service, cback) {\n        db.all(\"SELECT distinct service from datacache where service like ? \", [service + \"%\"], function (err, records) {\n            var results = {};\n            if (records && records.length > 0) {\n                records.forEach(function (record) {\n                    results[record.service] = true;\n                });\n            }\n            var uniques = [];\n            for (var k in results) {\n                if (results.hasOwnProperty(k)) {\n                    uniques.push(k);\n                }\n            }\n            cback.call(_Service__WEBPACK_IMPORTED_MODULE_0__[\"default\"], uniques);\n            return uniques;\n        });\n    };\n\n    first_accession = function first_accession(service, cback) {\n        db.all(\"SELECT distinct acc from datacache where service = ? limit 1\", [service], function (err, records) {\n            if (!records || records.length < 1) {\n                cback.call(_Service__WEBPACK_IMPORTED_MODULE_0__[\"default\"], null);\n            } else {\n                cback.call(_Service__WEBPACK_IMPORTED_MODULE_0__[\"default\"], records[0].acc);\n            }\n        });\n    };\n\n    cached_accessions = function cached_accessions(service, cback) {\n        db.all(\"SELECT distinct acc from datacache where service = ?\", [service], function (err, records) {\n            var results = [];\n            for (var i = 0; i < records.length; i++) {\n                results.push(records[i].acc);\n            }\n            cback.call(_Service__WEBPACK_IMPORTED_MODULE_0__[\"default\"], results);\n        });\n    };\n\n    get_snapshot = function get_snapshot(service, timestamps, wanted, cback) {\n        if (!timestamps || typeof timestamps != 'object' || !timestamps.length) {\n            timestamps = [0, new Date().getTime()];\n        }\n        var sql;\n        var args = [service, timestamps[0], timestamps[1]];\n        if (wanted && Array.isArray(wanted)) {\n            var question_marks = new Array(wanted.length + 1).join(',?').substring(1);\n            args = args.concat(wanted);\n            sql = \"SELECT * from datacache where service = ? AND retrieved >= ? AND retrieved <= ? AND acc in (\" + question_marks + \") ORDER BY retrieved ASC\";\n        } else {\n            if (wanted && /^\\d+$/.test(wanted.toString())) {\n                sql = \"SELECT * from datacache where service = ? AND retrieved >= ? AND retrieved <= ? LIMIT ? ORDER BY retrieved ASC\";\n                args = args.concat(parseInt(wanted.toString()));\n            } else {\n                sql = \"SELECT * from datacache where service = ? AND retrieved >= ? AND retrieved <= ? ORDER BY retrieved ASC\";\n            }\n        }\n        db.all(sql, args, function (err, records) {\n            records = records || [];\n            var results = {};\n            records.forEach(function (record) {\n                var data = typeof record.data === 'string' ? JSON.parse(record.data) : record.data;\n                if (data) {\n                    data.retrieved = new Date(parseInt(record.retrieved));\n                }\n                if (results[record.acc] && results[record.acc].retrieved > record.retrieved) {\n                    return;\n                }\n                results[record.acc] = record;\n            });\n            cback.call(null, null, results);\n        });\n    };\n\n    get_db_data = function get_db_data(acc, service, cback) {\n        var timestamps = max_age ? [min_age, max_age] : [min_age, new Date().getTime()];\n        return find_latest_data(acc, service, timestamps, cback);\n    };\n\n    var insert_report_func = function insert_report_func(acc, service) {\n        return function (err, rows) {\n            if (!err && rows) {\n                //                    console.log(\"Caching result for \"+acc+\" in \"+service);\n            }\n        };\n    };\n\n    store_db_data = function store_db_data(acc, service, data) {\n        if (typeof data != 'object' || typeof Document != 'undefined' && data instanceof Document) {\n            return;\n        }\n        var str_rep;\n        try {\n            str_rep = JSON.stringify(data);\n        } catch (err) {\n            return;\n        }\n        var dateobj = data.retrieved ? data.retrieved : new Date();\n        if (typeof dateobj == 'string') {\n            dateobj = new Date();\n        }\n        dateobj.setUTCHours(0);\n        dateobj.setUTCMinutes(0);\n        dateobj.setUTCSeconds(0);\n        dateobj.setUTCMilliseconds(0);\n        var datetime = dateobj.getTime();\n        data = {};\n        db.all(\"INSERT INTO datacache(acc,service,retrieved,data) VALUES(?,?,?,?)\", [acc, service, datetime, str_rep], insert_report_func(acc, service));\n    };\n\n    find_latest_data = function find_latest_data(acc, service, timestamps, cback) {\n        var sql = \"SELECT * from datacache where acc=? and service=? and retrieved >= ? and retrieved <= ? ORDER BY retrieved DESC LIMIT 1\";\n        var args = [acc, service, timestamps[0], timestamps[1]];\n        db.all(sql, args, function (err, records) {\n            if (records && records.length > 0 && typeof records[0] != \"undefined\") {\n                var data = typeof records[0].data === 'string' ? JSON.parse(records[0].data) : records[0].data;\n                if (data) {\n                    data.retrieved = new Date(parseInt(records[0].retrieved));\n                }\n                cback.call(null, null, data);\n            } else {\n                cback.call(null, null, null);\n            }\n        });\n    };\n\n    data_timestamps = function data_timestamps(service, timestamps, cback) {\n        if (!timestamps || typeof timestamps != 'object' || !timestamps.length) {\n            timestamps = [0, new Date().getTime()];\n        }\n        var sql = \"SELECT distinct retrieved from datacache where service=? and retrieved >= ? and retrieved <= ? ORDER BY retrieved ASC\";\n        var args = [service, timestamps[0], timestamps[1]];\n        db.all(sql, args, function (err, records) {\n            var result = [];\n            if (records && records.length > 0 && typeof records[0] != \"undefined\") {\n                for (var i = records.length - 1; i >= 0; i--) {\n                    result.push(new Date(parseInt(records[i].retrieved)));\n                }\n            }\n            cback.call(null, result);\n        });\n    };\n};\nvar setup_localstorage = function setup_localstorage() {\n    sweep_cache = function sweep_cache(timestamp) {\n        if (\"localStorage\" in window) {\n            var keys = [];\n            for (var i = 0, len = localStorage.length; i < len; i++) {\n                keys.push(localStorage.key(i));\n            }\n            var key = keys.shift();\n            while (key) {\n                if (new RegExp(\"^MASCP.*\").test(key)) {\n                    var data = localStorage[key];\n                    if (data && typeof data === 'string') {\n                        var datablock = JSON.parse(data);\n                        datablock.retrieved = timestamp;\n                        localStorage.removeItem(key);\n                    }\n                }\n                key = keys.shift();\n            }\n        }\n    };\n\n    clear_service = function clear_service(service, acc, callback) {\n        if (\"localStorage\" in window) {\n            var keys = [];\n            for (var i = 0, len = localStorage.length; i < len; i++) {\n                keys.push(localStorage.key(i));\n            }\n            var key = keys.shift();\n            while (key) {\n                if (new RegExp(\"^\" + service + \".*\" + (acc ? \"#\" + acc.toLowerCase() + \"$\" : \"\")).test(key)) {\n                    localStorage.removeItem(key);\n                    if (acc) {\n                        return;\n                    }\n                }\n                key = keys.shift();\n            }\n            callback.call(_Service__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n        }\n    };\n\n    search_service = function search_service(service, cback) {\n        var results = {};\n        if (\"localStorage\" in window) {\n            var key;\n            var re = new RegExp(\"^\" + service + \".*\");\n            for (var i = 0, len = localStorage.length; i < len; i++) {\n                key = localStorage.key(i);\n                if (re.test(key)) {\n                    results[key.replace(/\\.#.*$/g, '')] = true;\n                }\n            }\n        }\n\n        var uniques = [];\n        for (var k in results) {\n            if (results.hasOwnProperty(k)) {\n                uniques.push(k);\n            }\n        }\n\n        cback.call(CachingService, uniques);\n\n        return uniques;\n    };\n\n    first_accession = function first_accession(service, cback) {\n        if (\"localStorage\" in window) {\n            var key;\n            var re = new RegExp(\"^\" + service);\n            for (var i = 0, len = localStorage.length; i < len; i++) {\n                key = localStorage.key(i);\n                if (re.test(key)) {\n                    key = key.replace(service, '');\n                    cback.call(CachingService, key);\n                    return;\n                }\n            }\n        }\n        cback.call(CachingService, null);\n    };\n\n    cached_accessions = function cached_accessions(service, cback) {\n        if (\"localStorage\" in window) {\n            var key;\n            var re = new RegExp(\"^\" + service);\n            for (var i = 0, len = localStorage.length; i < len; i++) {\n                key = localStorage.key(i);\n                if (re.test(key)) {\n                    key = key.replace(service, '');\n                    results[key] = true;\n                }\n            }\n        }\n\n        var uniques = [];\n        for (var k in results) {\n            if (results.hasOwnProperty(k)) {\n                uniques.push(k);\n            }\n        }\n\n        cback.call(CachingService, uniques);\n    };\n\n    get_db_data = function get_db_data(acc, service, cback) {\n        var data = localStorage[service.toString() + \".#\" + (acc || '').toLowerCase()];\n        if (data && typeof data === 'string') {\n            var datablock = JSON.parse(data);\n            datablock.retrieved = new Date(parseInt(datablock.retrieved));\n            cback.call(null, null, datablock);\n        } else {\n            cback.call(null, null, null);\n        }\n    };\n\n    store_db_data = function store_db_data(acc, service, data) {\n        if (data && (typeof data !== 'object' || data instanceof Document || data.nodeName)) {\n            return;\n        }\n        data.retrieved = new Date().getTime();\n        localStorage[service.toString() + \".#\" + (acc || '').toLowerCase()] = JSON.stringify(data);\n    };\n\n    find_latest_data = function find_latest_data(acc, service, timestamp, cback) {\n        // We don't actually retrieve historical data for this\n        return get_db_data(acc, service, cback);\n    };\n\n    data_timestamps = function data_timestamps(service, timestamp, cback) {\n        cback.call(null, []);\n    };\n\n    begin_transaction = function begin_transaction(callback) {\n        // No support for transactions here. Do nothing.\n        setTimeout(function () {\n            callback.call();\n        }, 0);\n    };\n    end_transaction = function end_transaction(callback) {\n        // No support for transactions here. Do nothing.\n        setTimeout(function () {\n            callback();\n        }, 0);\n    };\n\n    if (_MASCP__WEBPACK_IMPORTED_MODULE_1__[\"default\"].events) {\n        _MASCP__WEBPACK_IMPORTED_MODULE_1__[\"default\"].events.emit('ready');\n    }\n    setTimeout(function () {\n        if (_MASCP__WEBPACK_IMPORTED_MODULE_1__[\"default\"].ready) {\n            _MASCP__WEBPACK_IMPORTED_MODULE_1__[\"default\"].ready();\n            _MASCP__WEBPACK_IMPORTED_MODULE_1__[\"default\"].ready = true;\n        } else {\n            _MASCP__WEBPACK_IMPORTED_MODULE_1__[\"default\"].ready = true;\n        }\n    }, 100);\n};\n\nvar db, idb;\n\nif (\"openDatabase\" in window || \"indexedDB\" in window) {\n\n    if (\"indexedDB\" in window) {\n\n        /* Versioning of DB schema */\n\n        var change_func = function change_func(version, transaction) {\n            var db = transaction.db;\n            if (db.objectStoreNames && db.objectStoreNames.contains(\"cached\")) {\n                db.deleteObjectStore(\"cached\");\n            }\n            var keypath = window.msIndexedDB ? \"serviceacc\" : \"id\";\n            var store = db.createObjectStore(\"cached\", { keyPath: keypath });\n            store.createIndex(\"entries\", [\"acc\", \"service\"], { unique: false });\n            if (window.msIndexedDB) {\n                store.createIndex(\"entries-ms\", \"serviceacc\", { unique: false });\n            }\n            store.createIndex(\"timestamps\", [\"service\", \"retrieved\"], { unique: false });\n            store.createIndex(\"services\", \"service\", { unique: false });\n            transaction.oncomplete = function () {\n                database_ready(db);\n                database_ready = function database_ready() {};\n            };\n        };\n\n        idb = true;\n        var db_version = 2;\n        var req = indexedDB.open(\"datacache\", db_version);\n\n        req.onupgradeneeded = function (e) {\n            var transaction = req.transaction;\n            change_func(e.oldVersion, transaction);\n        };\n\n        var database_ready = function database_ready(db) {\n            if (db) {\n                idb = db;\n            }\n            setup_idb(idb);\n\n            if (_MASCP__WEBPACK_IMPORTED_MODULE_1__[\"default\"].events) {\n                _MASCP__WEBPACK_IMPORTED_MODULE_1__[\"default\"].events.emit(\"ready\");\n            }\n            if (_MASCP__WEBPACK_IMPORTED_MODULE_1__[\"default\"].ready) {\n                _MASCP__WEBPACK_IMPORTED_MODULE_1__[\"default\"].ready();\n                _MASCP__WEBPACK_IMPORTED_MODULE_1__[\"default\"].ready = true;\n            } else {\n                _MASCP__WEBPACK_IMPORTED_MODULE_1__[\"default\"].ready = true;\n            }\n        };\n        req.onerror = function (e) {\n            console.log(\"Error loading Database\");\n            setup_localstorage();\n            // setTimeout(function() {\n            //     indexedDB.deleteDatabase(\"datacache\").onsuccess = function() {\n\n            //     }\n            // },0);\n        };\n        req.onsuccess = function (e) {\n            idb = e.target.result;\n            var version = db_version;\n            if (idb.version != Number(version)) {\n                var versionRequest = db.setVersion(ver);\n                versionRequest.onsuccess = function (e) {\n                    var transaction = versionRequest.result;\n                    change_func(oldVersion, transaction);\n                };\n            } else {\n                database_ready();\n            }\n        };\n    } else {\n        try {\n            db = openDatabase(\"cached\", \"\", \"MASCP Gator cache\", 1024 * 1024);\n        } catch (err) {\n            throw err;\n        }\n        db.all = function (sql, args, callback) {\n            this.exec(sql, args, callback);\n        };\n        db.exec = function (sql, args, callback) {\n            var self = this;\n            var sqlargs = args;\n            var cback = callback;\n            if (typeof cback == 'undefined' && sqlargs && Object.prototype.toString.call(sqlargs) != '[object Array]') {\n                cback = args;\n                sqlargs = null;\n            }\n            self.transaction(function (tx) {\n                tx.executeSql(sql, sqlargs, function (tx, result) {\n                    var res = [];\n                    for (var i = 0; i < result.rows.length; i++) {\n                        res.push(result.rows.item(i));\n                    }\n                    if (cback) {\n                        cback.call(db, null, res);\n                    }\n                }, function (tx, err) {\n                    if (cback) {\n                        cback.call(db, err);\n                    }\n                });\n            });\n        };\n    }\n}\nif (typeof idb !== 'undefined') {\n    // Do nothing\n} else if (typeof db !== 'undefined') {\n    setup_websql(db);\n} else if (\"localStorage\" in window) {\n    setup_localstorage();\n} else {\n\n    sweep_cache = function sweep_cache(timestamp) {};\n\n    clear_service = function clear_service(service, acc) {};\n\n    search_service = function search_service(service, cback) {};\n\n    cached_accessions = function cached_accessions(service, cback) {\n        cback.call(CachingService, []);\n    };\n\n    get_db_data = function get_db_data(acc, service, cback) {\n        cback.call(null, null, null);\n    };\n\n    store_db_data = function store_db_data(acc, service, data) {};\n\n    find_latest_data = function find_latest_data(acc, service, timestamp, cback) {\n        // We don't actually retrieve historical data for this\n        cback.call(null, []);\n    };\n\n    data_timestamps = function data_timestamps(service, timestamp, cback) {\n        cback.call(null, []);\n    };\n\n    begin_transaction = function begin_transaction(callback, trans) {\n        // No support for transactions here. Do nothing.\n        setTimeout(function () {\n            callback({ \"transaction\": trans });\n        }, 0);\n    };\n    end_transaction = function end_transaction(callback) {\n        // No support for transactions here. Do nothing.\n        setTimeout(function () {\n            callback();\n        }, 0);\n    };\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (CachingService);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9qcy9saWIvU2VydmljZUNhY2hpbmcuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vanMvbGliL1NlcnZpY2VDYWNoaW5nLmpzP2YxODUiXSwic291cmNlc0NvbnRlbnQiOlsiXG5pbXBvcnQgU2VydmljZSBmcm9tICcuL1NlcnZpY2UnO1xuaW1wb3J0IE1BU0NQIGZyb20gJy4vTUFTQ1AnO1xuXG52YXIgZ2V0X2RiX2RhdGEsIHN0b3JlX2RiX2RhdGEsIHNlYXJjaF9zZXJ2aWNlLCBjbGVhcl9zZXJ2aWNlLCBmaW5kX2xhdGVzdF9kYXRhLCBkYXRhX3RpbWVzdGFtcHMsIHN3ZWVwX2NhY2hlLCBjYWNoZWRfYWNjZXNzaW9ucywgYmVnaW5fdHJhbnNhY3Rpb24sIGVuZF90cmFuc2FjdGlvbixmaXJzdF9hY2Nlc3Npb247XG5cbnZhciBtYXhfYWdlID0gMCwgbWluX2FnZSA9IDA7XG5cbmNsYXNzIENhY2hpbmdTZXJ2aWNlIGV4dGVuZHMgU2VydmljZSB7XG59XG5cbkNhY2hpbmdTZXJ2aWNlLkJlZ2luQ2FjaGluZyA9IGZ1bmN0aW9uKCkge1xuICAgIENhY2hpbmdTZXJ2aWNlLkNhY2hlU2VydmljZShDYWNoaW5nU2VydmljZS5wcm90b3R5cGUpO1xufTtcblxuLy8gVG8gZG8gNyBkYXlzIGFnbywgeW91IGRvXG4vLyB2YXIgZGF0ZSA9IG5ldyBEYXRlKCk7XG4vLyBkYXRlLnNldERhdGUoZGF0ZS5nZXREYXRlKCkgLSAxKTtcbi8vIFNlcnZpY2UuU2V0TWluaW11bUZyZXNobmVzc0FnZShkYXRlKTtcblxuLy8gU2V0IHRoZSBtaW5pbXVtIGFnZSBpZiB5b3Ugd2FudCBub3RoaW5nIE9MREVSIHRoYW4gdGhpcyBkYXRlXG5DYWNoaW5nU2VydmljZS5TZXRNaW5pbXVtQWdlID0gZnVuY3Rpb24oZGF0ZSkge1xuICAgIGlmIChkYXRlID09PSAwKSB7XG4gICAgICAgIG1pbl9hZ2UgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG1pbl9hZ2UgPSBkYXRlLmdldFRpbWUoKTtcbiAgICB9XG59O1xuXG4vLyBTZXQgdGhlIG1heGltdW0gYWdlIGlmIHlvdSB3YW50IG5vdGhpbmcgTkVXRVIgdGhhbiB0aGlzIGRhdGVcbkNhY2hpbmdTZXJ2aWNlLlNldE1heGltdW1BZ2UgPSBmdW5jdGlvbihkYXRlKSB7XG4gICAgaWYgKGRhdGUgPT09IDApIHtcbiAgICAgICAgbWF4X2FnZSA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgbWF4X2FnZSA9IGRhdGUuZ2V0VGltZSgpO1xuICAgIH1cbn07XG5cbkNhY2hpbmdTZXJ2aWNlLlN3ZWVwQ2FjaGUgPSBmdW5jdGlvbihkYXRlKSB7XG4gICAgaWYgKCEgZGF0ZSkge1xuICAgICAgICBkYXRlID0gKG5ldyBEYXRlKCkpO1xuICAgIH1cbiAgICBzd2VlcF9jYWNoZShkYXRlLmdldFRpbWUoKSk7XG59O1xuXG5DYWNoaW5nU2VydmljZS5DYWNoZVNlcnZpY2UgPSBmdW5jdGlvbihyZWFkZXIpIHtcbiAgICBpZiAoKHJlYWRlci5wcm90b3R5cGUgJiYgcmVhZGVyLnByb3RvdHlwZS5yZXRyaWV2ZS5jYWNoaW5nKSB8fCByZWFkZXIucmV0cmlldmUuY2FjaGluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBfb2xkUmV0cmlldmUgPSByZWFkZXIucmV0cmlldmU7XG4gICAgdmFyIGhhc19hdm9pZDtcbiAgICByZWFkZXIucmV0cmlldmUgPSBmdW5jdGlvbihhZ2ksY2JhY2spIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgaWQgPSBhZ2kgPyBhZ2kgOiBzZWxmLmFnaTtcbiAgICAgICAgaWYgKCAhIGlkICkge1xuICAgICAgICAgICAgX29sZFJldHJpZXZlLmNhbGwoc2VsZixpZCxjYmFjayk7XG4gICAgICAgICAgICByZXR1cm4gc2VsZjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlkID0gaWQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgc2VsZi5hZ2kgPSBpZDtcblxuICAgICAgICBpZiAoc2VsZi5hdm9pZF9kYXRhYmFzZSkge1xuICAgICAgICAgICAgaWYgKGhhc19hdm9pZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhhc19hdm9pZCA9IHNlbGYuX2RhdGFSZWNlaXZlZDtcbiAgICAgICAgICAgIHNlbGYuX2RhdGFSZWNlaXZlZCA9IChmdW5jdGlvbigpIHsgcmV0dXJuIGZ1bmN0aW9uKGRhdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzID0gaGFzX2F2b2lkLmNhbGwodGhpcyxkYXQpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgaWQgPSBzZWxmLmFnaTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcyAmJiB0aGlzLnJlc3VsdCAmJiB0aGlzLnJlc3VsdC5fcmF3X2RhdGEgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JlX2RiX2RhdGEoaWQsdGhpcy50b1N0cmluZygpLHRoaXMucmVzdWx0Ll9yYXdfZGF0YSB8fCB7fSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZGF0ID0ge307XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICAgICAgfTt9KSgpO1xuICAgICAgICAgICAgY2JhY2suY2FsbChzZWxmKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzX2F2b2lkICYmICEgc2VsZi5hdm9pZF9kYXRhYmFzZSkge1xuICAgICAgICAgICAgc2VsZi5fZGF0YVJlY2VpdmVkID0gaGFzX2F2b2lkO1xuICAgICAgICAgICAgaGFzX2F2b2lkID0gbnVsbDtcbiAgICAgICAgICAgIGNiYWNrLmNhbGwoc2VsZik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBnZXRfZGJfZGF0YShpZCxzZWxmLnRvU3RyaW5nKCksZnVuY3Rpb24oZXJyLGRhdGEpIHtcbiAgICAgICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYucmVzdWx0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRvbmVfZnVuYyA9IGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmVhbi5yZW1vdmUoc2VsZixcInJlc3VsdFJlY2VpdmVkXCIsYXJndW1lbnRzLmNhbGxlZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBiZWFuLnJlbW92ZShzZWxmLFwiZXJyb3JcIixhcmd1bWVudHMuY2FsbGVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNiYWNrLmNhbGwoc2VsZixlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBiZWFuLmFkZChzZWxmLFwicmVzdWx0UmVjZWl2ZWRcIixkb25lX2Z1bmMpO1xuICAgICAgICAgICAgICAgICAgICBiZWFuLmFkZChzZWxmLFwiZXJyb3JcIiwgZG9uZV9mdW5jKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgcmVjZWl2ZWRfZmxhZyA9IHNlbGYuX2RhdGFSZWNlaXZlZChkYXRhLFwiZGJcIik7XG5cbiAgICAgICAgICAgICAgICBpZiAocmVjZWl2ZWRfZmxhZykge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmdvdFJlc3VsdCgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChyZWNlaXZlZF9mbGFnICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYucmVxdWVzdENvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5yZXF1ZXN0SW5jb21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgb2xkX3JlY2VpdmVkID0gc2VsZi5fZGF0YVJlY2VpdmVkO1xuICAgICAgICAgICAgICAgIHNlbGYuX2RhdGFSZWNlaXZlZCA9IChmdW5jdGlvbigpIHsgcmV0dXJuIGZ1bmN0aW9uKGRhdCxzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlcyA9IG9sZF9yZWNlaXZlZC5jYWxsKHRoaXMsZGF0LHNvdXJjZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXMgJiYgdGhpcy5yZXN1bHQgJiYgdGhpcy5yZXN1bHQuX3Jhd19kYXRhICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9yZV9kYl9kYXRhKGlkLHRoaXMudG9TdHJpbmcoKSx0aGlzLnJlc3VsdC5fcmF3X2RhdGEgfHwge30pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RhdGFSZWNlaXZlZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RhdGFSZWNlaXZlZCA9IG9sZF9yZWNlaXZlZDtcbiAgICAgICAgICAgICAgICAgICAgZGF0ID0ge307XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICAgICAgfTt9KSgpO1xuICAgICAgICAgICAgICAgIHZhciBvbGRfdXJsID0gc2VsZi5fZW5kcG9pbnRVUkw7XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSBhIG1heGltdW0gYWdlLCBpLmUuIHdlIGRvbid0IHdhbnQgYW55dGhpbmcgbmV3ZXIgdGhhbiBhIGRhdGVcbiAgICAgICAgICAgICAgICAvLyB3ZSBzaG91bGQgbm90IGFjdHVhbGx5IGRvIGEgcmVxdWVzdCB0aGF0IHdvbid0IHJlc3BlY3QgdGhhdC5cbiAgICAgICAgICAgICAgICAvLyBXZSBjYW4gc2V0IGEgbWluaW11bSBhZ2UsIHNpbmNlIHRoZSBsYXRlc3QgZGF0YSB3aWxsIGJlLCBieSBkZWZpbml0aW9uIGJlIHRoZSBsYXRlc3QhXG4gICAgICAgICAgICAgICAgaWYgKChtYXhfYWdlICE9PSAwKSkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLl9lbmRwb2ludFVSTCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF9vbGRSZXRyaWV2ZS5jYWxsKHNlbGYsaWQsY2JhY2spO1xuICAgICAgICAgICAgICAgIHNlbGYuX2VuZHBvaW50VVJMID0gb2xkX3VybDtcbiAgICAgICAgICAgIH0gICAgICAgICAgICAgXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuICAgIHJlYWRlci5yZXRyaWV2ZS5jYWNoaW5nID0gdHJ1ZTtcbn07XG5cbkNhY2hpbmdTZXJ2aWNlLkZpbmRDYWNoZWRTZXJ2aWNlID0gZnVuY3Rpb24oc2VydmljZSxjYmFjaykge1xuICAgIHZhciBzZXJ2aWNlU3RyaW5nID0gc2VydmljZS50b1N0cmluZygpO1xuICAgIHNlYXJjaF9zZXJ2aWNlKHNlcnZpY2VTdHJpbmcsY2JhY2spO1xuICAgIHJldHVybiB0cnVlO1xufTtcblxuQ2FjaGluZ1NlcnZpY2UuQ2FjaGVkQWdpcyA9IGZ1bmN0aW9uKHNlcnZpY2UsY2JhY2spIHtcbiAgICB2YXIgc2VydmljZVN0cmluZyA9IHNlcnZpY2UudG9TdHJpbmcoKTtcbiAgICBjYWNoZWRfYWNjZXNzaW9ucyhzZXJ2aWNlU3RyaW5nLGNiYWNrKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbkNhY2hpbmdTZXJ2aWNlLkZpcnN0QWdpID0gZnVuY3Rpb24oc2VydmljZSxjYmFjaykge1xuICAgIHZhciBzZXJ2aWNlU3RyaW5nID0gc2VydmljZS50b1N0cmluZygpO1xuICAgIGZpcnN0X2FjY2Vzc2lvbihzZXJ2aWNlU3RyaW5nLGNiYWNrKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbkNhY2hpbmdTZXJ2aWNlLkNsZWFyQ2FjaGUgPSBmdW5jdGlvbihzZXJ2aWNlLGFnaSxjYWxsYmFjaykge1xuICAgIHZhciBzZXJ2aWNlU3RyaW5nID0gc2VydmljZS50b1N0cmluZygpO1xuICAgIGlmICggISBjYWxsYmFjayApIHtcbiAgICAgICAgY2FsbGJhY2sgPSBmdW5jdGlvbigpIHt9O1xuICAgIH1cbiAgICBjbGVhcl9zZXJ2aWNlKHNlcnZpY2VTdHJpbmcsYWdpLGNhbGxiYWNrKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbkNhY2hpbmdTZXJ2aWNlLkhpc3RvcnlGb3JTZXJ2aWNlID0gZnVuY3Rpb24oc2VydmljZSxjYmFjaykge1xuICAgIHZhciBzZXJ2aWNlU3RyaW5nID0gc2VydmljZS50b1N0cmluZygpO1xuICAgIGRhdGFfdGltZXN0YW1wcyhzZXJ2aWNlU3RyaW5nLG51bGwsY2JhY2spO1xufTtcblxuQ2FjaGluZ1NlcnZpY2UuU25hcHNob3QgPSBmdW5jdGlvbihzZXJ2aWNlLGRhdGUsd2FudGVkLGNiYWNrKSB7XG4gICAgdmFyIHNlcnZpY2VTdHJpbmcgPSBzZXJ2aWNlLnRvU3RyaW5nKCk7XG4gICAgZ2V0X3NuYXBzaG90KHNlcnZpY2VTdHJpbmcsbnVsbCx3YW50ZWQsY2JhY2spO1xufTtcblxudmFyIHRyYW5zYWN0aW9uX3JlZl9jb3VudCA9IDA7XG52YXIgd2FpdGluZ19jYWxsYmFja3MgPSBbXTtcbkNhY2hpbmdTZXJ2aWNlLkJ1bGtPcGVyYXRpb24gPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgIHRyYW5zYWN0aW9uX3JlZl9jb3VudCsrO1xuICAgIHZhciB0cmFucyA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICggISBjYWxsYmFjayApIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gZnVuY3Rpb24oKSB7fTtcbiAgICAgICAgfVxuICAgICAgICB0cmFuc2FjdGlvbl9yZWZfY291bnQtLTtcbiAgICAgICAgd2FpdGluZ19jYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgICAgIGlmICh0cmFuc2FjdGlvbl9yZWZfY291bnQgPT0gMCkge1xuICAgICAgICAgICAgZW5kX3RyYW5zYWN0aW9uKGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgICAgIHdhaXRpbmdfY2FsbGJhY2tzLmZvckVhY2goZnVuY3Rpb24oY2JhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgY2JhY2soZXJyKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB3YWl0aW5nX2NhbGxiYWNrcyA9IFtdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGJlZ2luX3RyYW5zYWN0aW9uKGNhbGxiYWNrLHRyYW5zKTtcbiAgICByZXR1cm4gdHJhbnM7XG59O1xuXG52YXIgc2V0dXBfaWRiID0gZnVuY3Rpb24oaWRiKSB7XG4gICAgdmFyIHRyYW5zYWN0aW9uX3N0b3JlX2RiO1xuICAgIHZhciB0cmFuc2FjdGlvbl9maW5kX2xhdGVzdDtcbiAgICB2YXIgdHJhbnNhY3Rpb25fZGF0YSA9IFtdO1xuICAgIGJlZ2luX3RyYW5zYWN0aW9uID0gZnVuY3Rpb24oY2FsbGJhY2ssdHJhbnMpIHtcbiAgICAgICAgaWYgKHRyYW5zYWN0aW9uX3N0b3JlX2RiICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2suY2FsbCh7IFwidHJhbnNhY3Rpb25cIiA6IHRyYW5zIH0pO1xuICAgICAgICAgICAgfSwwKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0cmFuc2FjdGlvbl9zdG9yZV9kYiA9IHN0b3JlX2RiX2RhdGE7XG4gICAgICAgIHN0b3JlX2RiX2RhdGEgPSBmdW5jdGlvbihhY2Msc2VydmljZSxkYXRhKSB7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbl9kYXRhLnB1c2goW2FjYyxzZXJ2aWNlLGRhdGFdKTtcbiAgICAgICAgfTtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwoeyBcInRyYW5zYWN0aW9uXCIgOiB0cmFucyB9KTtcbiAgICAgICAgfSwwKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcblxuICAgIGVuZF90cmFuc2FjdGlvbiA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0cmFuc2FjdGlvbl9zdG9yZV9kYiA9PT0gbnVsbCkge1xuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc3RvcmVfZGJfZGF0YSA9IHRyYW5zYWN0aW9uX3N0b3JlX2RiO1xuICAgICAgICB0cmFuc2FjdGlvbl9zdG9yZV9kYiA9IG51bGw7XG4gICAgICAgIHZhciB0cmFucyA9IGlkYi50cmFuc2FjdGlvbihbXCJjYWNoZWRcIl0sIFwicmVhZHdyaXRlXCIpO1xuICAgICAgICB2YXIgc3RvcmUgPSB0cmFucy5vYmplY3RTdG9yZShcImNhY2hlZFwiKTtcbiAgICAgICAgdHJhbnMub25jb21wbGV0ZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsKTtcbiAgICAgICAgfTtcbiAgICAgICAgdHJhbnMub25lcnJvciA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICBjYWxsYmFjayhldmVudC50YXJnZXQuZXJyb3JDb2RlKTtcbiAgICAgICAgfTtcbiAgICAgICAgd2hpbGUgKHRyYW5zYWN0aW9uX2RhdGEubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyIHJvdyA9IHRyYW5zYWN0aW9uX2RhdGEuc2hpZnQoKTtcbiAgICAgICAgICAgIHZhciBhY2MgPSByb3dbMF07XG4gICAgICAgICAgICB2YXIgc2VydmljZSA9IHJvd1sxXTtcbiAgICAgICAgICAgIHZhciBkYXRhID0gcm93WzJdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRhICE9ICdvYmplY3QnIHx8IGRhdGEuY29uc3RydWN0b3IubmFtZSAhPT0gJ09iamVjdCcgfHwgKCgodHlwZW9mIERvY3VtZW50KSAhPSAndW5kZWZpbmVkJykgJiYgZGF0YSBpbnN0YW5jZW9mIERvY3VtZW50KSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGRhdGVvYmogPSBkYXRhLnJldHJpZXZlZCA/IGRhdGEucmV0cmlldmVkIDogKG5ldyBEYXRlKCkpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRlb2JqID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgZGF0ZW9iaiA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICBkYXRlb2JqID0gbmV3IERhdGUoZGF0ZW9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkYXRlb2JqLnNldFVUQ0hvdXJzKDApO1xuICAgICAgICAgICAgZGF0ZW9iai5zZXRVVENNaW51dGVzKDApO1xuICAgICAgICAgICAgZGF0ZW9iai5zZXRVVENTZWNvbmRzKDApO1xuICAgICAgICAgICAgZGF0ZW9iai5zZXRVVENNaWxsaXNlY29uZHMoMCk7XG4gICAgICAgICAgICB2YXIgcmVwb3J0ZXIgPSBpbnNlcnRfcmVwb3J0X2Z1bmMoYWNjLHNlcnZpY2UpO1xuICAgICAgICAgICAgdmFyIGRhdGV0aW1lID0gZGF0ZW9iai5nZXRUaW1lKCk7XG4gICAgICAgICAgICBkYXRhLmlkID0gW2FjYyxzZXJ2aWNlLGRhdGV0aW1lXTtcbiAgICAgICAgICAgIGRhdGEuYWNjID0gYWNjO1xuICAgICAgICAgICAgZGF0YS5zZXJ2aWNlID0gc2VydmljZTtcbiAgICAgICAgICAgIGlmICh3aW5kb3cubXNJbmRleGVkREIpIHtcbiAgICAgICAgICAgICAgICBkYXRhLnNlcnZpY2VhY2MgPSBzZXJ2aWNlK2FjYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRhdGEucmV0cmlldmVkID0gZGF0ZXRpbWU7XG4gICAgICAgICAgICB2YXIgcmVxID0gc3RvcmUucHV0KGRhdGEpO1xuICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSByZXBvcnRlcjtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgaW5zZXJ0X3JlcG9ydF9mdW5jID0gZnVuY3Rpb24oYWNjLHNlcnZpY2UpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGVycixyb3dzKSB7XG4gICAgICAgICAgICBpZiAoICEgZXJyICYmIHJvd3MpIHtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgc3RvcmVfZGJfZGF0YSA9IGZ1bmN0aW9uKGFjYyxzZXJ2aWNlLGRhdGEpIHtcbiAgICAgICAgdmFyIHRyYW5zID0gaWRiLnRyYW5zYWN0aW9uKFtcImNhY2hlZFwiXSwgXCJyZWFkd3JpdGVcIik7XG4gICAgICAgIHZhciBzdG9yZSA9IHRyYW5zLm9iamVjdFN0b3JlKFwiY2FjaGVkXCIpO1xuICAgICAgICBpZiAodHlwZW9mIGRhdGEgIT0gJ29iamVjdCcgfHwgKCgodHlwZW9mIERvY3VtZW50KSAhPSAndW5kZWZpbmVkJykgJiYgZGF0YSBpbnN0YW5jZW9mIERvY3VtZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkYXRlb2JqID0gZGF0YS5yZXRyaWV2ZWQgPyBkYXRhLnJldHJpZXZlZCA6IChuZXcgRGF0ZSgpKTtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRlb2JqID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgZGF0ZW9iaiA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIGRhdGVvYmogPSBuZXcgRGF0ZShkYXRlb2JqKTtcbiAgICAgICAgfVxuICAgICAgICBkYXRlb2JqLnNldFVUQ0hvdXJzKDApO1xuICAgICAgICBkYXRlb2JqLnNldFVUQ01pbnV0ZXMoMCk7XG4gICAgICAgIGRhdGVvYmouc2V0VVRDU2Vjb25kcygwKTtcbiAgICAgICAgZGF0ZW9iai5zZXRVVENNaWxsaXNlY29uZHMoMCk7XG4gICAgICAgIHZhciByZXBvcnRlciA9IGluc2VydF9yZXBvcnRfZnVuYyhhY2Msc2VydmljZSk7XG4gICAgICAgIHZhciBkYXRldGltZSA9IGRhdGVvYmouZ2V0VGltZSgpO1xuICAgICAgICBkYXRhLmlkID0gW2FjYyxzZXJ2aWNlLGRhdGV0aW1lXTtcbiAgICAgICAgZGF0YS5hY2MgPSBhY2M7XG4gICAgICAgIGlmICh3aW5kb3cubXNJbmRleGVkREIpIHtcbiAgICAgICAgICAgIGRhdGEuc2VydmljZWFjYyA9IHNlcnZpY2UrYWNjO1xuICAgICAgICB9XG4gICAgICAgIGRhdGEuc2VydmljZSA9IHNlcnZpY2U7XG4gICAgICAgIGRhdGEucmV0cmlldmVkID0gZGF0ZXRpbWU7XG4gICAgICAgIHZhciByZXEgPSBzdG9yZS5wdXQoZGF0YSk7XG4gICAgICAgIC8vIHJlcS5vbnN1Y2Nlc3MgPSByZXBvcnRlcjtcbiAgICAgICAgcmVxLm9uZXJyb3IgPSByZXBvcnRlcjtcbiAgICB9O1xuXG4gICAgZ2V0X2RiX2RhdGEgPSBmdW5jdGlvbihhY2Msc2VydmljZSxjYmFjaykge1xuICAgICAgICB2YXIgdGltZXN0YW1wcyA9IG1heF9hZ2UgPyBbbWluX2FnZSxtYXhfYWdlXSA6IFttaW5fYWdlLCAobmV3IERhdGUoKSkuZ2V0VGltZSgpXTtcbiAgICAgICAgcmV0dXJuIGZpbmRfbGF0ZXN0X2RhdGEoYWNjLHNlcnZpY2UsdGltZXN0YW1wcyxjYmFjayk7XG4gICAgfTtcblxuICAgIGZpbmRfbGF0ZXN0X2RhdGEgPSBmdW5jdGlvbihhY2Msc2VydmljZSx0aW1lc3RhbXBzLGNiYWNrKSB7XG4gICAgICAgIGlmICggISBhY2MgKSB7XG4gICAgICAgICAgICBjYmFjay5jYWxsKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRyYW5zID0gaWRiLnRyYW5zYWN0aW9uKFtcImNhY2hlZFwiXSxcInJlYWRvbmx5XCIpO1xuICAgICAgICB2YXIgc3RvcmUgPSB0cmFucy5vYmplY3RTdG9yZShcImNhY2hlZFwiKTtcbiAgICAgICAgdmFyIGlkeCA9IHN0b3JlLmluZGV4KHdpbmRvdy5tc0luZGV4ZWREQiA/IFwiZW50cmllcy1tc1wiIDogXCJlbnRyaWVzXCIpO1xuICAgICAgICB2YXIgbWF4X3N0YW1wID0gLTE7XG4gICAgICAgIHZhciByZXN1bHQgPSBudWxsO1xuICAgICAgICB2YXIgcmFuZ2UgPSBJREJLZXlSYW5nZS5vbmx5KHdpbmRvdy5tc0luZGV4ZWREQiA/IHNlcnZpY2UrYWNjIDogW2FjYyxzZXJ2aWNlXSk7XG4gICAgICAgIGlkeC5vcGVuQ3Vyc29yKHJhbmdlKS5vbnN1Y2Nlc3MgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgdmFyIGN1cnNvciA9IGV2ZW50LnRhcmdldC5yZXN1bHQ7XG4gICAgICAgICAgICBpZiAoY3Vyc29yKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRzID0gd2luZG93Lm1zSW5kZXhlZERCID8gY3Vyc29yLnZhbHVlLnJldHJpZXZlZCA6IGN1cnNvci5wcmltYXJ5S2V5WzJdO1xuICAgICAgICAgICAgICAgIHZhciBjX2FjYyA9IHdpbmRvdy5tc0luZGV4ZWREQiA/IGN1cnNvci52YWx1ZS5hY2MgOiBjdXJzb3IucHJpbWFyeUtleVswXTtcbiAgICAgICAgICAgICAgICB2YXIgc2VydiA9IHdpbmRvdy5tc0luZGV4ZWREQiA/IGN1cnNvci52YWx1ZS5zZXJ2aWNlIDogY3Vyc29yLnByaW1hcnlLZXlbMV07XG4gICAgICAgICAgICAgICAgaWYgKHRzID49IHRpbWVzdGFtcHNbMF0gJiYgdHMgPD0gdGltZXN0YW1wc1sxXSApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRzID4gbWF4X3N0YW1wICYmIGNfYWNjID09IGFjYyAmJiBzZXJ2ID09IHNlcnZpY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IGN1cnNvci52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heF9zdGFtcCA9IHRzO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnJldHJpZXZlZCA9IG5ldyBEYXRlKHRzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXJzb3IuY29udGludWUoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAvLyByZXN1bHQgPSByZXN1bHQuZGF0YVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYmFjay5jYWxsKG51bGwsbnVsbCxyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICBzd2VlcF9jYWNoZSA9IGZ1bmN0aW9uKHRpbWVzdGFtcCkge1xuICAgICAgICB2YXIgdHJhbnMgPSBpZGIudHJhbnNhY3Rpb24oW1wiY2FjaGVkXCJdLFwicmVhZHdyaXRlXCIpO1xuICAgICAgICB2YXIgc3RvcmUgPSB0cmFucy5vYmplY3RTdG9yZShcImNhY2hlZFwiKTtcbiAgICAgICAgdmFyIGlkeCA9IHN0b3JlLmluZGV4KFwidGltZXN0YW1wc1wiKTtcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgaWR4Lm9wZW5LZXlDdXJzb3IobnVsbCwgXCJuZXh0dW5pcXVlXCIpLm9uc3VjY2VzcyA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgY3Vyc29yID0gZXZlbnQudGFyZ2V0LnJlc3VsdDtcbiAgICAgICAgICAgIGlmIChjdXJzb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoIHRpbWVzdGFtcCA+PSBjdXJzb3Iua2V5WzFdICkge1xuICAgICAgICAgICAgICAgICAgICBzdG9yZS5kZWxldGUoY3Vyc29yLnByaW1hcnlLZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXJzb3IuY29udGludWUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgZGF0YV90aW1lc3RhbXBzID0gZnVuY3Rpb24oc2VydmljZSx0aW1lc3RhbXBzLGNiYWNrKSB7XG5cbiAgICAgICAgaWYgKCEgdGltZXN0YW1wcyB8fCB0eXBlb2YgdGltZXN0YW1wcyAhPSAnb2JqZWN0JyB8fCAhIHRpbWVzdGFtcHMubGVuZ3RoICkge1xuICAgICAgICAgICAgdGltZXN0YW1wcyA9IFswLChuZXcgRGF0ZSgpKS5nZXRUaW1lKCldO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRyYW5zID0gaWRiLnRyYW5zYWN0aW9uKFtcImNhY2hlZFwiXSxcInJlYWRvbmx5XCIpO1xuICAgICAgICB2YXIgc3RvcmUgPSB0cmFucy5vYmplY3RTdG9yZShcImNhY2hlZFwiKTtcbiAgICAgICAgdmFyIGlkeCA9IHN0b3JlLmluZGV4KFwidGltZXN0YW1wc1wiKTtcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgaWR4Lm9wZW5LZXlDdXJzb3IobnVsbCwgXCJuZXh0dW5pcXVlXCIpLm9uc3VjY2VzcyA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgY3Vyc29yID0gZXZlbnQudGFyZ2V0LnJlc3VsdDtcbiAgICAgICAgICAgIGlmIChjdXJzb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3Vyc29yLmtleVswXSA9PSBzZXJ2aWNlICYmIHRpbWVzdGFtcHNbMF0gPD0gY3Vyc29yLmtleVsxXSAmJiB0aW1lc3RhbXBzWzFdID49IGN1cnNvci5rZXlbMV0gKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChuZXcgRGF0ZShwYXJzZUludChjdXJzb3Iua2V5WzFdKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXJzb3IuY29udGludWUoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2JhY2suY2FsbChudWxsLHJlc3VsdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICBjbGVhcl9zZXJ2aWNlID0gZnVuY3Rpb24oc2VydmljZSxhY2MsY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHRyYW5zID0gaWRiLnRyYW5zYWN0aW9uKFtcImNhY2hlZFwiXSxcInJlYWR3cml0ZVwiKTtcbiAgICAgICAgdmFyIHN0b3JlID0gdHJhbnMub2JqZWN0U3RvcmUoXCJjYWNoZWRcIik7XG4gICAgICAgIHZhciBpZHggPSBzdG9yZS5pbmRleChcInNlcnZpY2VzXCIpO1xuICAgICAgICB2YXIgcmFuZ2UgPSBJREJLZXlSYW5nZS5vbmx5KHNlcnZpY2UpO1xuICAgICAgICBpZHgub3BlbkN1cnNvcihyYW5nZSkub25zdWNjZXNzID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBjdXJzb3IgPSBldmVudC50YXJnZXQucmVzdWx0O1xuICAgICAgICAgICAgaWYgKGN1cnNvcikge1xuICAgICAgICAgICAgICAgIGlmICgoISBhY2MgfHwgKGN1cnNvci52YWx1ZS5hY2MgPT0gYWNjKSApKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh3aW5kb3cubXNJbmRleGVkREIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JlLmRlbGV0ZShjdXJzb3IudmFsdWUuc2VydmljZWFjYyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9yZS5kZWxldGUoY3Vyc29yLnZhbHVlLmlkID8gY3Vyc29yLnZhbHVlLmlkIDogY3Vyc29yLnByaW1hcnlLZXkgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXJzb3IuY29udGludWUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdHJhbnMub25jb21wbGV0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgY2FsbGJhY2suY2FsbChTZXJ2aWNlKTtcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgc2VhcmNoX3NlcnZpY2UgPSBmdW5jdGlvbihzZXJ2aWNlLGNiYWNrKSB7XG4gICAgICAgIHZhciB0cmFucyA9IGlkYi50cmFuc2FjdGlvbihbXCJjYWNoZWRcIl0sXCJyZWFkb25seVwiKTtcbiAgICAgICAgdmFyIHN0b3JlID0gdHJhbnMub2JqZWN0U3RvcmUoXCJjYWNoZWRcIik7XG4gICAgICAgIHZhciBpZHggPSBzdG9yZS5pbmRleChcInNlcnZpY2VzXCIpO1xuICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgICAgICB2YXIgcmFuZ2UgPSBJREJLZXlSYW5nZS5vbmx5KHNlcnZpY2UpO1xuICAgICAgICBpZHgub3BlbktleUN1cnNvcihyYW5nZSwgXCJuZXh0dW5pcXVlXCIpLm9uc3VjY2VzcyA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgY3Vyc29yID0gZXZlbnQudGFyZ2V0LnJlc3VsdDtcbiAgICAgICAgICAgIGlmIChjdXJzb3IpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2goY3Vyc29yLmtleSk7XG4gICAgICAgICAgICAgICAgY3Vyc29yLmNvbnRpbnVlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNiYWNrLmNhbGwoU2VydmljZSxyZXN1bHRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xuICAgIGZpcnN0X2FjY2Vzc2lvbiA9IGZ1bmN0aW9uKHNlcnZpY2UsY2JhY2spIHtcbiAgICAgICAgdmFyIHRyYW5zID0gaWRiLnRyYW5zYWN0aW9uKFtcImNhY2hlZFwiXSxcInJlYWRvbmx5XCIpO1xuICAgICAgICB2YXIgc3RvcmUgPSB0cmFucy5vYmplY3RTdG9yZShcImNhY2hlZFwiKTtcbiAgICAgICAgdmFyIGlkeCA9IHN0b3JlLmluZGV4KFwic2VydmljZXNcIik7XG4gICAgICAgIHZhciByYW5nZSA9IElEQktleVJhbmdlLm9ubHkoc2VydmljZSk7XG4gICAgICAgIGlkeC5vcGVuQ3Vyc29yKHJhbmdlLFwibmV4dHVuaXF1ZVwiKS5vbnN1Y2Nlc3MgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgdmFyIGN1cnNvciA9IGV2ZW50LnRhcmdldC5yZXN1bHQ7XG4gICAgICAgICAgICBpZiAoY3Vyc29yKSB7XG4gICAgICAgICAgICAgICAgY2JhY2suY2FsbChTZXJ2aWNlLGN1cnNvci52YWx1ZS5hY2MpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYmFjay5jYWxsKFNlcnZpY2UsbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBjYWNoZWRfYWNjZXNzaW9ucyA9IGZ1bmN0aW9uKHNlcnZpY2UsY2JhY2spIHtcbiAgICAgICAgdmFyIHRyYW5zID0gaWRiLnRyYW5zYWN0aW9uKFtcImNhY2hlZFwiXSxcInJlYWRvbmx5XCIpO1xuICAgICAgICB2YXIgc3RvcmUgPSB0cmFucy5vYmplY3RTdG9yZShcImNhY2hlZFwiKTtcbiAgICAgICAgdmFyIGlkeCA9IHN0b3JlLmluZGV4KFwic2VydmljZXNcIik7XG4gICAgICAgIHZhciByZXN1bHRzID0gW107XG4gICAgICAgIHZhciByYW5nZSA9IElEQktleVJhbmdlLm9ubHkoc2VydmljZSk7XG4gICAgICAgIGlkeC5vcGVuQ3Vyc29yKHJhbmdlKS5vbnN1Y2Nlc3MgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgdmFyIGN1cnNvciA9IGV2ZW50LnRhcmdldC5yZXN1bHQ7XG4gICAgICAgICAgICBpZiAoY3Vyc29yKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGN1cnNvci52YWx1ZS5hY2MpO1xuICAgICAgICAgICAgICAgIGN1cnNvci5jb250aW51ZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYmFjay5jYWxsKFNlcnZpY2UscmVzdWx0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfTtcbn07XG52YXIgc2V0dXBfd2Vic3FsID0gZnVuY3Rpb24oZGIpIHtcbiAgICBkYi5hbGwoJ1NFTEVDVCB2ZXJzaW9uIGZyb20gdmVyc2lvbnMgd2hlcmUgdGFibGVuYW1lID0gXCJkYXRhY2FjaGVcIicsZnVuY3Rpb24oZXJyLHJvd3MpIHsgXG4gICAgICAgIHZhciB2ZXJzaW9uID0gKHJvd3MgJiYgcm93cy5sZW5ndGggPiAwKSA/IHJvd3NbMF0udmVyc2lvbiA6IG51bGw7XG4gICAgICAgIGlmICh2ZXJzaW9uID09IDEuMykge1xuICAgICAgICAgICAgaWYgKE1BU0NQLmV2ZW50cykge1xuICAgICAgICAgICAgICAgIE1BU0NQLmV2ZW50cy5lbWl0KCdyZWFkeScpOyAgICAgICAgICAgIFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKE1BU0NQLnJlYWR5KSB7XG4gICAgICAgICAgICAgICAgTUFTQ1AucmVhZHkoKTtcbiAgICAgICAgICAgICAgICBNQVNDUC5yZWFkeSA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIE1BU0NQLnJlYWR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjsgICAgICAgICAgICAgICAgXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmICghIHZlcnNpb24gfHwgdmVyc2lvbiA9PSBcIlwiIHx8IHZlcnNpb24gPCAxLjAgKSB7XG4gICAgICAgICAgICBkYi5leGVjKCdDUkVBVEUgVEFCTEUgaWYgbm90IGV4aXN0cyB2ZXJzaW9ucyAodmVyc2lvbiBSRUFMLCB0YWJsZW5hbWUgVEVYVCk7Jyk7XG4gICAgICAgICAgICBkYi5leGVjKCdDUkVBVEUgVEFCTEUgaWYgbm90IGV4aXN0cyBcImRhdGFjYWNoZVwiIChhZ2kgVEVYVCxzZXJ2aWNlIFRFWFQscmV0cmlldmVkIFJFQUwsZGF0YSBURVhUKTsnLGZ1bmN0aW9uKGVycikgeyBpZiAoZXJyICYmIGVyciAhPSBcIkVycm9yOiBub3QgYW4gZXJyb3JcIikgeyB0aHJvdyBlcnI7IH0gfSk7XG4gICAgICAgICAgICBkYi5leGVjKCdERUxFVEUgRlJPTSB2ZXJzaW9ucyB3aGVyZSB0YWJsZW5hbWUgPSBcImRhdGFjYWNoZVwiJyk7XG4gICAgICAgICAgICBkYi5leGVjKCdJTlNFUlQgSU5UTyB2ZXJzaW9ucyh2ZXJzaW9uLHRhYmxlbmFtZSkgVkFMVUVTKDEuMSxcImRhdGFjYWNoZVwiKTsnLGZ1bmN0aW9uKGVycixyb3dzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCAhIGVyciApIHtcbi8vICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJVcGdyYWRlIHRvIDEuMSBjb21wbGV0ZWRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2ZXJzaW9uID0gMS4xO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2ZXJzaW9uIDwgMS4yKSB7XG4gICAgICAgICAgICBkYi5leGVjKCdEUk9QIFRBQkxFIGlmIGV4aXN0cyBkYXRhY2FjaGVfdG1wOycpO1xuICAgICAgICAgICAgZGIuZXhlYygnQ1JFQVRFIFRBQkxFIGlmIG5vdCBleGlzdHMgZGF0YWNhY2hlX3RtcCAoYWNjIFRFWFQsc2VydmljZSBURVhULHJldHJpZXZlZCBSRUFMLGRhdGEgVEVYVCk7Jyk7XG4gICAgICAgICAgICBkYi5leGVjKCdJTlNFUlQgSU5UTyBkYXRhY2FjaGVfdG1wKGFjYyxzZXJ2aWNlLHJldHJpZXZlZCxkYXRhKSBTRUxFQ1QgYWdpLHNlcnZpY2UscmV0cmlldmVkLGRhdGEgRlJPTSBkYXRhY2FjaGU7Jyk7XG4gICAgICAgICAgICBkYi5leGVjKCdEUk9QIFRBQkxFIGRhdGFjYWNoZTsnKTtcbiAgICAgICAgICAgIGRiLmV4ZWMoJ0FMVEVSIFRBQkxFIGRhdGFjYWNoZV90bXAgUkVOQU1FIFRPIGRhdGFjYWNoZTsnKTtcbiAgICAgICAgICAgIGRiLmV4ZWMoJ0NSRUFURSBJTkRFWCBhY2Nlc3Npb25zIG9uIGRhdGFjYWNoZShhY2MpOycpO1xuICAgICAgICAgICAgZGIuZXhlYygnQ1JFQVRFIElOREVYIGFjY2Vzc2lvbnNfc2VydmljZSBvbiBkYXRhY2FjaGUoYWNjLHNlcnZpY2UpOycpO1xuICAgICAgICAgICAgZGIuZXhlYygnREVMRVRFIEZST00gdmVyc2lvbnMgd2hlcmUgdGFibGVuYW1lID0gXCJkYXRhY2FjaGVcIicpO1xuICAgICAgICAgICAgZGIuZXhlYygnSU5TRVJUIElOVE8gdmVyc2lvbnModmVyc2lvbix0YWJsZW5hbWUpIFZBTFVFUygxLjIsXCJkYXRhY2FjaGVcIik7JyxmdW5jdGlvbihlcnIscm93cykge1xuICAgICAgICAgICAgICAgIGlmICggISBlcnIgKSB7XG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJVcGdyYWRlIHRvIDEuMiBjb21wbGV0ZWRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2ZXJzaW9uID0gMS4yO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2ZXJzaW9uIDwgMS4zKSB7XG4gICAgICAgICAgICBkYi5leGVjKCdDUkVBVEUgSU5ERVggaWYgbm90IGV4aXN0cyBzZXJ2aWNlcyBvbiBkYXRhY2FjaGUoc2VydmljZSk7Jyk7XG4gICAgICAgICAgICBkYi5leGVjKCdERUxFVEUgRlJPTSB2ZXJzaW9ucyB3aGVyZSB0YWJsZW5hbWUgPSBcImRhdGFjYWNoZVwiJyk7XG4gICAgICAgICAgICBkYi5leGVjKCdJTlNFUlQgSU5UTyB2ZXJzaW9ucyh2ZXJzaW9uLHRhYmxlbmFtZSkgVkFMVUVTKDEuMyxcImRhdGFjYWNoZVwiKTsnLGZ1bmN0aW9uKGVycixyb3dzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCAhIGVyciApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKE1BU0NQLmV2ZW50cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgTUFTQ1AuZXZlbnRzLmVtaXQoJ3JlYWR5Jyk7ICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKE1BU0NQLnJlYWR5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBNQVNDUC5yZWFkeSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgTUFTQ1AucmVhZHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgTUFTQ1AucmVhZHkgID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmVyc2lvbiA9IDEuMzsgICAgICAgICAgICAgICAgXG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGJlZ2luX3RyYW5zYWN0aW9uID0gZnVuY3Rpb24oY2FsbGJhY2ssdHJhbnMpIHtcbiAgICAgICAgY2FsbGJhY2suY2FsbCh7IFwidHJhbnNhY3Rpb25cIiA6IHRyYW5zIH0pO1xuICAgIH07XG4gICAgZW5kX3RyYW5zYWN0aW9uID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICB9O1xuXG4gICAgc3dlZXBfY2FjaGUgPSBmdW5jdGlvbih0aW1lc3RhbXApIHtcbiAgICAgICAgZGIuYWxsKFwiREVMRVRFIGZyb20gZGF0YWNhY2hlIHdoZXJlIHJldHJpZXZlZCA8PSA/IFwiLFt0aW1lc3RhbXBdLGZ1bmN0aW9uKCkge30pO1xuICAgIH07XG4gICAgXG4gICAgY2xlYXJfc2VydmljZSA9IGZ1bmN0aW9uKHNlcnZpY2UsYWNjLGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBzZXJ2aWNlbmFtZSA9IHNlcnZpY2U7XG4gICAgICAgIHNlcnZpY2VuYW1lICs9IFwiJVwiO1xuICAgICAgICBpZiAoICEgYWNjICkge1xuICAgICAgICAgICAgZGIuYWxsKFwiREVMRVRFIGZyb20gZGF0YWNhY2hlIHdoZXJlIHNlcnZpY2UgbGlrZSA/IFwiLFtzZXJ2aWNlbmFtZV0sZnVuY3Rpb24oKSB7IGNhbGxiYWNrLmNhbGwoU2VydmljZSk7IH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGIuYWxsKFwiREVMRVRFIGZyb20gZGF0YWNhY2hlIHdoZXJlIHNlcnZpY2UgbGlrZSA/IGFuZCBhY2MgPSA/XCIsW3NlcnZpY2VuYW1lLGFjYy50b0xvd2VyQ2FzZSgpXSxmdW5jdGlvbigpIHsgY2FsbGJhY2suY2FsbChTZXJ2aWNlKTsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgfTtcbiAgICBcbiAgICBzZWFyY2hfc2VydmljZSA9IGZ1bmN0aW9uKHNlcnZpY2UsY2JhY2spIHtcbiAgICAgICAgZGIuYWxsKFwiU0VMRUNUIGRpc3RpbmN0IHNlcnZpY2UgZnJvbSBkYXRhY2FjaGUgd2hlcmUgc2VydmljZSBsaWtlID8gXCIsW3NlcnZpY2UrXCIlXCJdLGZ1bmN0aW9uKGVycixyZWNvcmRzKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0cyA9IHt9O1xuICAgICAgICAgICAgaWYgKHJlY29yZHMgJiYgcmVjb3Jkcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcmVjb3Jkcy5mb3JFYWNoKGZ1bmN0aW9uKHJlY29yZCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRzW3JlY29yZC5zZXJ2aWNlXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdW5pcXVlcyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgayBpbiByZXN1bHRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdHMuaGFzT3duUHJvcGVydHkoaykpIHsgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB1bmlxdWVzLnB1c2goayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2JhY2suY2FsbChTZXJ2aWNlLHVuaXF1ZXMpO1xuICAgICAgICAgICAgcmV0dXJuIHVuaXF1ZXM7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBmaXJzdF9hY2Nlc3Npb24gPSBmdW5jdGlvbihzZXJ2aWNlLGNiYWNrKSB7XG4gICAgICAgIGRiLmFsbChcIlNFTEVDVCBkaXN0aW5jdCBhY2MgZnJvbSBkYXRhY2FjaGUgd2hlcmUgc2VydmljZSA9ID8gbGltaXQgMVwiLFtzZXJ2aWNlXSxmdW5jdGlvbihlcnIscmVjb3Jkcykge1xuICAgICAgICAgICAgaWYgKCEgcmVjb3JkcyB8fCByZWNvcmRzLmxlbmd0aCA8IDEpIHtcbiAgICAgICAgICAgICAgICBjYmFjay5jYWxsKFNlcnZpY2UsbnVsbCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNiYWNrLmNhbGwoU2VydmljZSxyZWNvcmRzWzBdLmFjYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBcbiAgICBjYWNoZWRfYWNjZXNzaW9ucyA9IGZ1bmN0aW9uKHNlcnZpY2UsY2JhY2spIHtcbiAgICAgICAgZGIuYWxsKFwiU0VMRUNUIGRpc3RpbmN0IGFjYyBmcm9tIGRhdGFjYWNoZSB3aGVyZSBzZXJ2aWNlID0gP1wiLFtzZXJ2aWNlXSxmdW5jdGlvbihlcnIscmVjb3Jkcykge1xuICAgICAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVjb3Jkcy5sZW5ndGg7IGkrKyApe1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChyZWNvcmRzW2ldLmFjYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYmFjay5jYWxsKFNlcnZpY2UscmVzdWx0cyk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgXG4gICAgZ2V0X3NuYXBzaG90ID0gZnVuY3Rpb24oc2VydmljZSx0aW1lc3RhbXBzLHdhbnRlZCxjYmFjaykge1xuICAgICAgICBpZiAoISB0aW1lc3RhbXBzIHx8IHR5cGVvZiB0aW1lc3RhbXBzICE9ICdvYmplY3QnIHx8ICEgdGltZXN0YW1wcy5sZW5ndGggKSB7XG4gICAgICAgICAgICB0aW1lc3RhbXBzID0gWzAsKG5ldyBEYXRlKCkpLmdldFRpbWUoKV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNxbDtcbiAgICAgICAgdmFyIGFyZ3MgPSBbc2VydmljZSx0aW1lc3RhbXBzWzBdLHRpbWVzdGFtcHNbMV1dO1xuICAgICAgICBpZiAod2FudGVkICYmIEFycmF5LmlzQXJyYXkod2FudGVkKSkge1xuICAgICAgICAgICAgdmFyIHF1ZXN0aW9uX21hcmtzID0gKG5ldyBBcnJheSh3YW50ZWQubGVuZ3RoKzEpLmpvaW4oJyw/JykpLnN1YnN0cmluZygxKTtcbiAgICAgICAgICAgIGFyZ3MgPSBhcmdzLmNvbmNhdCh3YW50ZWQpO1xuICAgICAgICAgICAgc3FsID0gXCJTRUxFQ1QgKiBmcm9tIGRhdGFjYWNoZSB3aGVyZSBzZXJ2aWNlID0gPyBBTkQgcmV0cmlldmVkID49ID8gQU5EIHJldHJpZXZlZCA8PSA/IEFORCBhY2MgaW4gKFwiK3F1ZXN0aW9uX21hcmtzK1wiKSBPUkRFUiBCWSByZXRyaWV2ZWQgQVNDXCI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAod2FudGVkICYmIC9eXFxkKyQvLnRlc3Qod2FudGVkLnRvU3RyaW5nKCkpKSB7XG4gICAgICAgICAgICAgICAgc3FsID0gXCJTRUxFQ1QgKiBmcm9tIGRhdGFjYWNoZSB3aGVyZSBzZXJ2aWNlID0gPyBBTkQgcmV0cmlldmVkID49ID8gQU5EIHJldHJpZXZlZCA8PSA/IExJTUlUID8gT1JERVIgQlkgcmV0cmlldmVkIEFTQ1wiO1xuICAgICAgICAgICAgICAgIGFyZ3MgPSBhcmdzLmNvbmNhdChwYXJzZUludCh3YW50ZWQudG9TdHJpbmcoKSkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzcWwgPSBcIlNFTEVDVCAqIGZyb20gZGF0YWNhY2hlIHdoZXJlIHNlcnZpY2UgPSA/IEFORCByZXRyaWV2ZWQgPj0gPyBBTkQgcmV0cmlldmVkIDw9ID8gT1JERVIgQlkgcmV0cmlldmVkIEFTQ1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRiLmFsbChzcWwsYXJncyxmdW5jdGlvbihlcnIscmVjb3Jkcykge1xuICAgICAgICAgICAgcmVjb3JkcyA9IHJlY29yZHMgfHwgW107XG4gICAgICAgICAgICB2YXIgcmVzdWx0cyA9IHt9O1xuICAgICAgICAgICAgcmVjb3Jkcy5mb3JFYWNoKGZ1bmN0aW9uKHJlY29yZCkge1xuICAgICAgICAgICAgICAgIHZhciBkYXRhID0gdHlwZW9mIHJlY29yZC5kYXRhID09PSAnc3RyaW5nJyA/IEpTT04ucGFyc2UocmVjb3JkLmRhdGEpIDogcmVjb3JkLmRhdGE7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5yZXRyaWV2ZWQgPSBuZXcgRGF0ZShwYXJzZUludChyZWNvcmQucmV0cmlldmVkKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHRzW3JlY29yZC5hY2NdICYmIHJlc3VsdHNbcmVjb3JkLmFjY10ucmV0cmlldmVkID4gcmVjb3JkLnJldHJpZXZlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdHNbcmVjb3JkLmFjY10gPSByZWNvcmQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNiYWNrLmNhbGwobnVsbCxudWxsLHJlc3VsdHMpO1xuICAgICAgICB9KTtcbiAgICB9O1xuXG4gICAgZ2V0X2RiX2RhdGEgPSBmdW5jdGlvbihhY2Msc2VydmljZSxjYmFjaykge1xuICAgICAgICB2YXIgdGltZXN0YW1wcyA9IG1heF9hZ2UgPyBbbWluX2FnZSxtYXhfYWdlXSA6IFttaW5fYWdlLCAobmV3IERhdGUoKSkuZ2V0VGltZSgpXTtcbiAgICAgICAgcmV0dXJuIGZpbmRfbGF0ZXN0X2RhdGEoYWNjLHNlcnZpY2UsdGltZXN0YW1wcyxjYmFjayk7XG4gICAgfTtcblxuICAgIHZhciBpbnNlcnRfcmVwb3J0X2Z1bmMgPSBmdW5jdGlvbihhY2Msc2VydmljZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oZXJyLHJvd3MpIHtcbiAgICAgICAgICAgIGlmICggISBlcnIgJiYgcm93cykge1xuLy8gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiQ2FjaGluZyByZXN1bHQgZm9yIFwiK2FjYytcIiBpbiBcIitzZXJ2aWNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgc3RvcmVfZGJfZGF0YSA9IGZ1bmN0aW9uKGFjYyxzZXJ2aWNlLGRhdGEpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhICE9ICdvYmplY3QnIHx8ICgoKHR5cGVvZiBEb2N1bWVudCkgIT0gJ3VuZGVmaW5lZCcpICYmIGRhdGEgaW5zdGFuY2VvZiBEb2N1bWVudCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RyX3JlcDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHN0cl9yZXAgPSBKU09OLnN0cmluZ2lmeShkYXRhKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRhdGVvYmogPSBkYXRhLnJldHJpZXZlZCA/IGRhdGEucmV0cmlldmVkIDogKG5ldyBEYXRlKCkpO1xuICAgICAgICBpZiAodHlwZW9mIGRhdGVvYmogPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGRhdGVvYmogPSBuZXcgRGF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGRhdGVvYmouc2V0VVRDSG91cnMoMCk7XG4gICAgICAgIGRhdGVvYmouc2V0VVRDTWludXRlcygwKTtcbiAgICAgICAgZGF0ZW9iai5zZXRVVENTZWNvbmRzKDApO1xuICAgICAgICBkYXRlb2JqLnNldFVUQ01pbGxpc2Vjb25kcygwKTtcbiAgICAgICAgdmFyIGRhdGV0aW1lID0gZGF0ZW9iai5nZXRUaW1lKCk7XG4gICAgICAgIGRhdGEgPSB7fTtcbiAgICAgICAgZGIuYWxsKFwiSU5TRVJUIElOVE8gZGF0YWNhY2hlKGFjYyxzZXJ2aWNlLHJldHJpZXZlZCxkYXRhKSBWQUxVRVMoPyw/LD8sPylcIixbYWNjLHNlcnZpY2UsZGF0ZXRpbWUsc3RyX3JlcF0saW5zZXJ0X3JlcG9ydF9mdW5jKGFjYyxzZXJ2aWNlKSk7XG4gICAgfTtcblxuICAgIGZpbmRfbGF0ZXN0X2RhdGEgPSBmdW5jdGlvbihhY2Msc2VydmljZSx0aW1lc3RhbXBzLGNiYWNrKSB7XG4gICAgICAgIHZhciBzcWwgPSBcIlNFTEVDVCAqIGZyb20gZGF0YWNhY2hlIHdoZXJlIGFjYz0/IGFuZCBzZXJ2aWNlPT8gYW5kIHJldHJpZXZlZCA+PSA/IGFuZCByZXRyaWV2ZWQgPD0gPyBPUkRFUiBCWSByZXRyaWV2ZWQgREVTQyBMSU1JVCAxXCI7XG4gICAgICAgIHZhciBhcmdzID0gW2FjYyxzZXJ2aWNlLHRpbWVzdGFtcHNbMF0sdGltZXN0YW1wc1sxXV07ICAgICAgICAgICAgXG4gICAgICAgIGRiLmFsbChzcWwsYXJncyxmdW5jdGlvbihlcnIscmVjb3Jkcykge1xuICAgICAgICAgICAgaWYgKHJlY29yZHMgJiYgcmVjb3Jkcy5sZW5ndGggPiAwICYmIHR5cGVvZiByZWNvcmRzWzBdICE9IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IHR5cGVvZiByZWNvcmRzWzBdLmRhdGEgPT09ICdzdHJpbmcnID8gSlNPTi5wYXJzZShyZWNvcmRzWzBdLmRhdGEpIDogcmVjb3Jkc1swXS5kYXRhO1xuICAgICAgICAgICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEucmV0cmlldmVkID0gbmV3IERhdGUocGFyc2VJbnQocmVjb3Jkc1swXS5yZXRyaWV2ZWQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2JhY2suY2FsbChudWxsLG51bGwsZGF0YSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNiYWNrLmNhbGwobnVsbCxudWxsLG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFxuICAgIGRhdGFfdGltZXN0YW1wcyA9IGZ1bmN0aW9uKHNlcnZpY2UsdGltZXN0YW1wcyxjYmFjaykge1xuICAgICAgICBpZiAoISB0aW1lc3RhbXBzIHx8IHR5cGVvZiB0aW1lc3RhbXBzICE9ICdvYmplY3QnIHx8ICEgdGltZXN0YW1wcy5sZW5ndGggKSB7XG4gICAgICAgICAgICB0aW1lc3RhbXBzID0gWzAsKG5ldyBEYXRlKCkpLmdldFRpbWUoKV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNxbCA9IFwiU0VMRUNUIGRpc3RpbmN0IHJldHJpZXZlZCBmcm9tIGRhdGFjYWNoZSB3aGVyZSBzZXJ2aWNlPT8gYW5kIHJldHJpZXZlZCA+PSA/IGFuZCByZXRyaWV2ZWQgPD0gPyBPUkRFUiBCWSByZXRyaWV2ZWQgQVNDXCI7XG4gICAgICAgIHZhciBhcmdzID0gW3NlcnZpY2UsdGltZXN0YW1wc1swXSx0aW1lc3RhbXBzWzFdXTtcbiAgICAgICAgZGIuYWxsKHNxbCxhcmdzLGZ1bmN0aW9uKGVycixyZWNvcmRzKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgICAgICBpZiAocmVjb3JkcyAmJiByZWNvcmRzLmxlbmd0aCA+IDAgJiYgdHlwZW9mIHJlY29yZHNbMF0gIT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSByZWNvcmRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ldyBEYXRlKHBhcnNlSW50KHJlY29yZHNbaV0ucmV0cmlldmVkKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNiYWNrLmNhbGwobnVsbCxyZXN1bHQpO1xuICAgICAgICB9KTsgICAgICAgICAgICBcbiAgICB9O1xufTtcbnZhciBzZXR1cF9sb2NhbHN0b3JhZ2UgPSBmdW5jdGlvbigpIHtcbiAgICBzd2VlcF9jYWNoZSA9IGZ1bmN0aW9uKHRpbWVzdGFtcCkge1xuICAgICAgICBpZiAoXCJsb2NhbFN0b3JhZ2VcIiBpbiB3aW5kb3cpIHtcbiAgICAgICAgICAgIHZhciBrZXlzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbG9jYWxTdG9yYWdlLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAga2V5cy5wdXNoKGxvY2FsU3RvcmFnZS5rZXkoaSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGtleSA9IGtleXMuc2hpZnQoKTtcbiAgICAgICAgICAgIHdoaWxlIChrZXkpIHtcbiAgICAgICAgICAgICAgICBpZiAobmV3IFJlZ0V4cChcIl5NQVNDUC4qXCIpLnRlc3Qoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IGxvY2FsU3RvcmFnZVtrZXldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YSAmJiB0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkYXRhYmxvY2sgPSBKU09OLnBhcnNlKGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YWJsb2NrLnJldHJpZXZlZCA9IHRpbWVzdGFtcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKGtleSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAga2V5ID0ga2V5cy5zaGlmdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBcbiAgICBjbGVhcl9zZXJ2aWNlID0gZnVuY3Rpb24oc2VydmljZSxhY2MsY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKFwibG9jYWxTdG9yYWdlXCIgaW4gd2luZG93KSB7XG4gICAgICAgICAgICB2YXIga2V5cyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGxvY2FsU3RvcmFnZS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGtleXMucHVzaChsb2NhbFN0b3JhZ2Uua2V5KGkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzLnNoaWZ0KCk7XG4gICAgICAgICAgICB3aGlsZSAoa2V5KSB7XG4gICAgICAgICAgICAgICAgaWYgKChuZXcgUmVnRXhwKFwiXlwiK3NlcnZpY2UrXCIuKlwiKyhhY2M/XCIjXCIrYWNjLnRvTG93ZXJDYXNlKCkrXCIkXCIgOiBcIlwiKSkpLnRlc3Qoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShrZXkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWNjKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAga2V5ID0ga2V5cy5zaGlmdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsbGJhY2suY2FsbChTZXJ2aWNlKTtcbiAgICAgICAgfSAgICAgICAgICAgIFxuICAgIH07XG4gICAgXG4gICAgc2VhcmNoX3NlcnZpY2UgPSBmdW5jdGlvbihzZXJ2aWNlLGNiYWNrKSB7XG4gICAgICAgIHZhciByZXN1bHRzID0ge307XG4gICAgICAgIGlmIChcImxvY2FsU3RvcmFnZVwiIGluIHdpbmRvdykge1xuICAgICAgICAgICAgdmFyIGtleTtcbiAgICAgICAgICAgIHZhciByZSA9IG5ldyBSZWdFeHAoXCJeXCIrc2VydmljZStcIi4qXCIpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGxvY2FsU3RvcmFnZS5sZW5ndGg7IGkgPCBsZW47IGkrKyl7XG4gICAgICAgICAgICAgICAga2V5ID0gbG9jYWxTdG9yYWdlLmtleShpKTtcbiAgICAgICAgICAgICAgICBpZiAocmUudGVzdChrZXkpKSB7ICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHNba2V5LnJlcGxhY2UoL1xcLiMuKiQvZywnJyldID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdW5pcXVlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBrIGluIHJlc3VsdHMpIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHRzLmhhc093blByb3BlcnR5KGspKSB7XG4gICAgICAgICAgICAgICAgdW5pcXVlcy5wdXNoKGspO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY2JhY2suY2FsbChDYWNoaW5nU2VydmljZSx1bmlxdWVzKTtcblxuICAgICAgICByZXR1cm4gdW5pcXVlcztcbiAgICB9O1xuXG4gICAgZmlyc3RfYWNjZXNzaW9uID0gZnVuY3Rpb24oc2VydmljZSxjYmFjaykge1xuICAgICAgICBpZiAoXCJsb2NhbFN0b3JhZ2VcIiBpbiB3aW5kb3cpIHtcbiAgICAgICAgICAgIHZhciBrZXk7XG4gICAgICAgICAgICB2YXIgcmUgPSBuZXcgUmVnRXhwKFwiXlwiK3NlcnZpY2UpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGxvY2FsU3RvcmFnZS5sZW5ndGg7IGkgPCBsZW47IGkrKyl7XG4gICAgICAgICAgICAgICAga2V5ID0gbG9jYWxTdG9yYWdlLmtleShpKTtcbiAgICAgICAgICAgICAgICBpZiAocmUudGVzdChrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGtleSA9IGtleS5yZXBsYWNlKHNlcnZpY2UsJycpO1xuICAgICAgICAgICAgICAgICAgICBjYmFjay5jYWxsKENhY2hpbmdTZXJ2aWNlLGtleSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2JhY2suY2FsbChDYWNoaW5nU2VydmljZSxudWxsKTtcbiAgICB9O1xuXG4gICAgY2FjaGVkX2FjY2Vzc2lvbnMgPSBmdW5jdGlvbihzZXJ2aWNlLGNiYWNrKSB7XG4gICAgICAgIGlmIChcImxvY2FsU3RvcmFnZVwiIGluIHdpbmRvdykge1xuICAgICAgICAgICAgdmFyIGtleTtcbiAgICAgICAgICAgIHZhciByZSA9IG5ldyBSZWdFeHAoXCJeXCIrc2VydmljZSk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbG9jYWxTdG9yYWdlLmxlbmd0aDsgaSA8IGxlbjsgaSsrKXtcbiAgICAgICAgICAgICAgICBrZXkgPSBsb2NhbFN0b3JhZ2Uua2V5KGkpO1xuICAgICAgICAgICAgICAgIGlmIChyZS50ZXN0KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAga2V5ID0ga2V5LnJlcGxhY2Uoc2VydmljZSwnJyk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHNba2V5XSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHVuaXF1ZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgayBpbiByZXN1bHRzKSB7XG4gICAgICAgICAgICBpZiAocmVzdWx0cy5oYXNPd25Qcm9wZXJ0eShrKSkge1xuICAgICAgICAgICAgICAgIHVuaXF1ZXMucHVzaChrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNiYWNrLmNhbGwoQ2FjaGluZ1NlcnZpY2UsdW5pcXVlcyk7XG4gICAgfTtcblxuICAgIGdldF9kYl9kYXRhID0gZnVuY3Rpb24oYWNjLHNlcnZpY2UsY2JhY2spIHtcbiAgICAgICAgdmFyIGRhdGEgPSBsb2NhbFN0b3JhZ2Vbc2VydmljZS50b1N0cmluZygpK1wiLiNcIisoYWNjIHx8ICcnKS50b0xvd2VyQ2FzZSgpXTtcbiAgICAgICAgaWYgKGRhdGEgJiYgdHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB2YXIgZGF0YWJsb2NrID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgICAgICAgIGRhdGFibG9jay5yZXRyaWV2ZWQgPSBuZXcgRGF0ZShwYXJzZUludChkYXRhYmxvY2sucmV0cmlldmVkKSk7XG4gICAgICAgICAgICBjYmFjay5jYWxsKG51bGwsbnVsbCxkYXRhYmxvY2spO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2JhY2suY2FsbChudWxsLG51bGwsbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgfTtcbiAgICBcbiAgICBzdG9yZV9kYl9kYXRhID0gZnVuY3Rpb24oYWNjLHNlcnZpY2UsZGF0YSkge1xuICAgICAgICBpZiAoZGF0YSAmJiAodHlwZW9mIGRhdGEgIT09ICdvYmplY3QnIHx8IGRhdGEgaW5zdGFuY2VvZiBEb2N1bWVudCB8fCBkYXRhLm5vZGVOYW1lKSl7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZGF0YS5yZXRyaWV2ZWQgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xuICAgICAgICBsb2NhbFN0b3JhZ2Vbc2VydmljZS50b1N0cmluZygpK1wiLiNcIisoYWNjIHx8ICcnKS50b0xvd2VyQ2FzZSgpXSA9IEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuICAgIH07XG5cbiAgICBmaW5kX2xhdGVzdF9kYXRhID0gZnVuY3Rpb24oYWNjLHNlcnZpY2UsdGltZXN0YW1wLGNiYWNrKSB7XG4gICAgICAgIC8vIFdlIGRvbid0IGFjdHVhbGx5IHJldHJpZXZlIGhpc3RvcmljYWwgZGF0YSBmb3IgdGhpc1xuICAgICAgICByZXR1cm4gZ2V0X2RiX2RhdGEoYWNjLHNlcnZpY2UsY2JhY2spO1xuICAgIH07XG5cbiAgICBkYXRhX3RpbWVzdGFtcHMgPSBmdW5jdGlvbihzZXJ2aWNlLHRpbWVzdGFtcCxjYmFjaykge1xuICAgICAgICBjYmFjay5jYWxsKG51bGwsW10pO1xuICAgIH07XG4gICAgXG4gICAgYmVnaW5fdHJhbnNhY3Rpb24gPSBmdW5jdGlvbihjYWxsYmFjaykge1xuICAgICAgICAvLyBObyBzdXBwb3J0IGZvciB0cmFuc2FjdGlvbnMgaGVyZS4gRG8gbm90aGluZy5cbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwoKTtcbiAgICAgICAgfSwwKTtcbiAgICB9O1xuICAgIGVuZF90cmFuc2FjdGlvbiA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAgIC8vIE5vIHN1cHBvcnQgZm9yIHRyYW5zYWN0aW9ucyBoZXJlLiBEbyBub3RoaW5nLlxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9LDApO1xuICAgIH07XG5cbiAgICBpZiAoTUFTQ1AuZXZlbnRzKSB7XG4gICAgICAgIE1BU0NQLmV2ZW50cy5lbWl0KCdyZWFkeScpO1xuICAgIH1cbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoTUFTQ1AucmVhZHkpIHtcbiAgICAgICAgICAgIE1BU0NQLnJlYWR5KCk7XG4gICAgICAgICAgICBNQVNDUC5yZWFkeSA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBNQVNDUC5yZWFkeSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9LDEwMCk7XG59O1xuXG52YXIgZGIsaWRiO1xuXG5pZiAoXCJvcGVuRGF0YWJhc2VcIiBpbiB3aW5kb3cgfHwgXCJpbmRleGVkREJcIiBpbiB3aW5kb3cpIHtcblxuICAgIGlmIChcImluZGV4ZWREQlwiIGluIHdpbmRvdykge1xuXG4gICAgICAgIC8qIFZlcnNpb25pbmcgb2YgREIgc2NoZW1hICovXG5cbiAgICAgICAgdmFyIGNoYW5nZV9mdW5jID0gZnVuY3Rpb24odmVyc2lvbix0cmFuc2FjdGlvbikge1xuICAgICAgICAgICAgdmFyIGRiID0gdHJhbnNhY3Rpb24uZGI7XG4gICAgICAgICAgICBpZiAoZGIub2JqZWN0U3RvcmVOYW1lcyAmJiBkYi5vYmplY3RTdG9yZU5hbWVzLmNvbnRhaW5zKFwiY2FjaGVkXCIpKSB7XG4gICAgICAgICAgICAgICAgZGIuZGVsZXRlT2JqZWN0U3RvcmUoXCJjYWNoZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIga2V5cGF0aCA9IHdpbmRvdy5tc0luZGV4ZWREQiA/IFwic2VydmljZWFjY1wiIDogXCJpZFwiO1xuICAgICAgICAgICAgdmFyIHN0b3JlID0gZGIuY3JlYXRlT2JqZWN0U3RvcmUoXCJjYWNoZWRcIiwgeyBrZXlQYXRoOiBrZXlwYXRoIH0pO1xuICAgICAgICAgICAgc3RvcmUuY3JlYXRlSW5kZXgoXCJlbnRyaWVzXCIsIFsgXCJhY2NcIiAsIFwic2VydmljZVwiIF0sIHsgdW5pcXVlIDogZmFsc2UgfSk7XG4gICAgICAgICAgICBpZiAod2luZG93Lm1zSW5kZXhlZERCKSB7XG4gICAgICAgICAgICAgICAgc3RvcmUuY3JlYXRlSW5kZXgoXCJlbnRyaWVzLW1zXCIsXCJzZXJ2aWNlYWNjXCIsIHsgdW5pcXVlIDogZmFsc2UgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdG9yZS5jcmVhdGVJbmRleChcInRpbWVzdGFtcHNcIiwgWyBcInNlcnZpY2VcIiAsIFwicmV0cmlldmVkXCIgXSwgeyB1bmlxdWUgOiBmYWxzZSB9KTtcbiAgICAgICAgICAgIHN0b3JlLmNyZWF0ZUluZGV4KFwic2VydmljZXNcIiwgXCJzZXJ2aWNlXCIsIHsgdW5pcXVlIDogZmFsc2UgfSk7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbi5vbmNvbXBsZXRlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgZGF0YWJhc2VfcmVhZHkoZGIpO1xuICAgICAgICAgICAgICAgIGRhdGFiYXNlX3JlYWR5ID0gZnVuY3Rpb24oKSB7fTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG5cblxuICAgICAgICBpZGIgPSB0cnVlO1xuICAgICAgICB2YXIgZGJfdmVyc2lvbiA9IDI7XG4gICAgICAgIHZhciByZXEgPSBpbmRleGVkREIub3BlbihcImRhdGFjYWNoZVwiLGRiX3ZlcnNpb24pO1xuXG4gICAgICAgIHJlcS5vbnVwZ3JhZGVuZWVkZWQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIHZhciB0cmFuc2FjdGlvbiA9IHJlcS50cmFuc2FjdGlvbjtcbiAgICAgICAgICBjaGFuZ2VfZnVuYyhlLm9sZFZlcnNpb24sIHRyYW5zYWN0aW9uKTtcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgZGF0YWJhc2VfcmVhZHkgPSBmdW5jdGlvbihkYikge1xuICAgICAgICAgICAgaWYgKGRiKSB7XG4gICAgICAgICAgICAgICAgaWRiID0gZGI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXR1cF9pZGIoaWRiKTtcblxuICAgICAgICAgICAgaWYgKE1BU0NQLmV2ZW50cykge1xuICAgICAgICAgICAgICAgIE1BU0NQLmV2ZW50cy5lbWl0KFwicmVhZHlcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoTUFTQ1AucmVhZHkpIHtcbiAgICAgICAgICAgICAgICBNQVNDUC5yZWFkeSgpO1xuICAgICAgICAgICAgICAgIE1BU0NQLnJlYWR5ID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgTUFTQ1AucmVhZHkgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXEub25lcnJvciA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiRXJyb3IgbG9hZGluZyBEYXRhYmFzZVwiKTtcbiAgICAgICAgICAgIHNldHVwX2xvY2Fsc3RvcmFnZSgpO1xuICAgICAgICAgICAgLy8gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vICAgICBpbmRleGVkREIuZGVsZXRlRGF0YWJhc2UoXCJkYXRhY2FjaGVcIikub25zdWNjZXNzID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgIC8vICAgICB9XG4gICAgICAgICAgICAvLyB9LDApO1xuICAgICAgICB9XG4gICAgICAgIHJlcS5vbnN1Y2Nlc3MgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBpZGIgPSBlLnRhcmdldC5yZXN1bHQ7XG4gICAgICAgICAgICB2YXIgdmVyc2lvbiA9IGRiX3ZlcnNpb247XG4gICAgICAgICAgICBpZiAoaWRiLnZlcnNpb24gIT0gTnVtYmVyKHZlcnNpb24pKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZlcnNpb25SZXF1ZXN0ID0gZGIuc2V0VmVyc2lvbih2ZXIpO1xuICAgICAgICAgICAgICAgIHZlcnNpb25SZXF1ZXN0Lm9uc3VjY2VzcyA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0cmFuc2FjdGlvbiA9IHZlcnNpb25SZXF1ZXN0LnJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgY2hhbmdlX2Z1bmMob2xkVmVyc2lvbiwgdHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGRhdGFiYXNlX3JlYWR5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGRiID0gb3BlbkRhdGFiYXNlKFwiY2FjaGVkXCIsXCJcIixcIk1BU0NQIEdhdG9yIGNhY2hlXCIsMTAyNCoxMDI0KTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgIH1cbiAgICAgICAgZGIuYWxsID0gZnVuY3Rpb24oc3FsLGFyZ3MsY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHRoaXMuZXhlYyhzcWwsYXJncyxjYWxsYmFjayk7XG4gICAgICAgIH07XG4gICAgICAgIGRiLmV4ZWMgPSBmdW5jdGlvbihzcWwsYXJncyxjYWxsYmFjaykge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIHNxbGFyZ3MgPSBhcmdzO1xuICAgICAgICAgICAgdmFyIGNiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNiYWNrID09ICd1bmRlZmluZWQnICYmIHNxbGFyZ3MgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHNxbGFyZ3MpICE9ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgICAgICAgICAgICBjYmFjayA9IGFyZ3M7XG4gICAgICAgICAgICAgICAgc3FsYXJncyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLnRyYW5zYWN0aW9uKGZ1bmN0aW9uKHR4KSB7XG4gICAgICAgICAgICAgICAgdHguZXhlY3V0ZVNxbChzcWwsc3FsYXJncyxmdW5jdGlvbih0eCxyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc3VsdC5yb3dzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXMucHVzaChyZXN1bHQucm93cy5pdGVtKGkpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoY2JhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNiYWNrLmNhbGwoZGIsbnVsbCxyZXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxmdW5jdGlvbih0eCxlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYmFjay5jYWxsKGRiLGVycik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgIH1cbn1cbmlmICh0eXBlb2YgaWRiICE9PSAndW5kZWZpbmVkJykge1xuICAgIC8vIERvIG5vdGhpbmdcbn0gZWxzZSBpZiAodHlwZW9mIGRiICE9PSAndW5kZWZpbmVkJykge1xuICAgIHNldHVwX3dlYnNxbChkYik7XG59IGVsc2UgaWYgKFwibG9jYWxTdG9yYWdlXCIgaW4gd2luZG93KSB7XG4gICAgc2V0dXBfbG9jYWxzdG9yYWdlKCk7XG59IGVsc2Uge1xuXG4gICAgc3dlZXBfY2FjaGUgPSBmdW5jdGlvbih0aW1lc3RhbXApIHtcbiAgICB9O1xuICAgIFxuICAgIGNsZWFyX3NlcnZpY2UgPSBmdW5jdGlvbihzZXJ2aWNlLGFjYykge1xuICAgIH07XG4gICAgXG4gICAgc2VhcmNoX3NlcnZpY2UgPSBmdW5jdGlvbihzZXJ2aWNlLGNiYWNrKSB7XG4gICAgfTtcblxuICAgIGNhY2hlZF9hY2Nlc3Npb25zID0gZnVuY3Rpb24oc2VydmljZSxjYmFjaykge1xuICAgICAgICBjYmFjay5jYWxsKENhY2hpbmdTZXJ2aWNlLFtdKTtcbiAgICB9O1xuXG4gICAgZ2V0X2RiX2RhdGEgPSBmdW5jdGlvbihhY2Msc2VydmljZSxjYmFjaykge1xuICAgICAgICBjYmFjay5jYWxsKG51bGwsbnVsbCxudWxsKTtcbiAgICB9O1xuICAgIFxuICAgIHN0b3JlX2RiX2RhdGEgPSBmdW5jdGlvbihhY2Msc2VydmljZSxkYXRhKSB7XG4gICAgfTtcblxuICAgIGZpbmRfbGF0ZXN0X2RhdGEgPSBmdW5jdGlvbihhY2Msc2VydmljZSx0aW1lc3RhbXAsY2JhY2spIHtcbiAgICAgICAgLy8gV2UgZG9uJ3QgYWN0dWFsbHkgcmV0cmlldmUgaGlzdG9yaWNhbCBkYXRhIGZvciB0aGlzXG4gICAgICAgIGNiYWNrLmNhbGwobnVsbCxbXSk7XG4gICAgfTtcblxuICAgIGRhdGFfdGltZXN0YW1wcyA9IGZ1bmN0aW9uKHNlcnZpY2UsdGltZXN0YW1wLGNiYWNrKSB7XG4gICAgICAgIGNiYWNrLmNhbGwobnVsbCxbXSk7XG4gICAgfTtcbiAgICBcbiAgICBiZWdpbl90cmFuc2FjdGlvbiA9IGZ1bmN0aW9uKGNhbGxiYWNrLHRyYW5zKSB7XG4gICAgICAgIC8vIE5vIHN1cHBvcnQgZm9yIHRyYW5zYWN0aW9ucyBoZXJlLiBEbyBub3RoaW5nLlxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICBjYWxsYmFjayh7XCJ0cmFuc2FjdGlvblwiOiB0cmFuc30pO1xuICAgICAgICB9LDApO1xuICAgIH07XG4gICAgZW5kX3RyYW5zYWN0aW9uID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgLy8gTm8gc3VwcG9ydCBmb3IgdHJhbnNhY3Rpb25zIGhlcmUuIERvIG5vdGhpbmcuXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH0sMCk7XG4gICAgfTtcbn1cblxuXG5leHBvcnQgZGVmYXVsdCBDYWNoaW5nU2VydmljZTsiXSwibWFwcGluZ3MiOiI7Ozs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQUE7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./js/lib/ServiceCaching.js\n");

/***/ }),

/***/ "./js/lib/TrackRendererComponent.js":
/*!******************************************!*\
  !*** ./js/lib/TrackRendererComponent.js ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _GatorComponent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./GatorComponent */ \"./js/lib/GatorComponent.js\");\n/* harmony import */ var _jsandbox__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../jsandbox */ \"./js/jsandbox.js\");\n/* harmony import */ var _MASCP__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./MASCP */ \"./js/lib/MASCP.js\");\nvar _this = undefined;\n\n\n\n\n\nconst SANDBOXES = new Map();\n\nlet retrieve_renderer = function retrieve_renderer() {\n  let renderer_url = this.getAttribute('src');\n  return fetch(renderer_url).then(dat => dat.text());\n};\n\nfunction WrapHTML() {\n  return Reflect.construct(HTMLElement, [], Object.getPrototypeOf(this).constructor);\n}\nObject.setPrototypeOf(WrapHTML.prototype, HTMLElement.prototype);\nObject.setPrototypeOf(WrapHTML, HTMLElement);\n\nlet get_renderer_sequence = (renderer, accession) => {\n  return new Promise(resolve => {\n    (function () {\n      var obj = { \"gotResult\": function gotResult() {\n          resolve(renderer.sequence);\n        }, \"acc\": accession };\n      renderer.trigger('readerRegistered', [obj]);\n      obj.gotResult();\n    })();\n  });\n};\n\nlet set_basic_offset = (objects, basic_offset) => {\n  objects.forEach(function (obj) {\n    if (obj.options) {\n      if (obj.options.offset) {\n        obj.options.offset += basic_offset;\n        return;\n      }\n      obj.options.offset = basic_offset;\n    } else {\n      obj.options = { \"offset\": basic_offset };\n    }\n  });\n};\n\nlet apply_rendering = (renderer, default_track, objects) => {\n  if (Array.isArray(objects)) {\n    var temp_objects = {};\n    console.log('No accession provided');\n    temp_objects['DEFAULTACC'] = objects;\n    objects = temp_objects;\n  }\n  for (let acc of Object.keys(objects)) {\n    let r = objects[acc];\n    set_basic_offset(r, 0);\n\n    renderer.renderObjects(default_track, r.filter(function (item) {\n      return !item.track;\n    }));\n\n    console.log(_MASCP__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getLayer(default_track));\n\n    var items_by_track = {};\n    r.filter(function (item) {\n      return item.track;\n    }).forEach(function (item) {\n      items_by_track[item.track] = items_by_track[item.track] || [];\n      items_by_track[item.track].push(item);\n    });\n    Object.keys(items_by_track).forEach(function (track) {\n      if (_MASCP__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getLayer(track)) {\n        _MASCP__WEBPACK_IMPORTED_MODULE_2__[\"default\"].registerLayer(track, {}, [renderer]);\n        // We force a refresh of the track order\n        // to pick up any layers that have been re-enabled\n        renderer.trackOrder = renderer.trackOrder;\n        renderer.renderObjects(track, items_by_track[track]);\n      }\n    });\n    renderer.trigger('resultsRendered', [_this]);\n    renderer.refresh();\n  }\n};\n\nlet do_rendering = (renderer, script, data, default_track) => {\n  const SANDBOX = SANDBOXES.get(script) || new _jsandbox__WEBPACK_IMPORTED_MODULE_1__[\"default\"]();\n  SANDBOXES.set(script, SANDBOX);\n  get_renderer_sequence(renderer).then(sequence => {\n    SANDBOX.eval(script, () => {\n      SANDBOX.eval({ 'data': 'renderData(input.sequence,input.data,input.acc,input.track)',\n        'input': { 'sequence': sequence, 'data': data, 'track': default_track },\n        'onerror': message => {\n          throw new Error(message);\n        },\n        'callback': apply_rendering.bind(null, renderer, default_track)\n      });\n    });\n  });\n};\n\nclass TrackRendererComponent extends WrapHTML {\n  static get observedAttributes() {\n    return ['track'];\n  }\n\n  constructor() {\n    super();\n  }\n\n  connectedCallback() {\n    this.script = retrieve_renderer.call(this);\n  }\n\n  render(renderer, data, track) {\n    this.script.then(script => {\n      do_rendering(renderer, script, data, track);\n    });\n  }\n\n  get data() {\n    return this._data;\n  }\n\n  set data(data) {\n    this._data = data;\n    this.render(this.ownerDocument.getElementById(this.getAttribute('renderer')).renderer, this._data, this.getAttribute('track'));\n  }\n\n  attributeChangedCallback(name) {\n    if (this.hasAttribute('renderer') && this.data) {\n      this.render(document.getElementById(this.getAttribute('renderer')).renderer, this._data, this.getAttribute('track'));\n    }\n  }\n}\n\ncustomElements.define('x-trackrenderer', TrackRendererComponent);\n\nlet create_track = function create_track() {\n  _MASCP__WEBPACK_IMPORTED_MODULE_2__[\"default\"].registerLayer(this.name, {});\n  _MASCP__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getLayer(this.name).fullname = this.fullname || this.name;\n  _MASCP__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getLayer(this.name).scales.clear();\n  for (let scale of this.scale) {\n    _MASCP__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getLayer(this.name).scales.add(scale);\n  }\n};\n\nclass TrackComponent extends WrapHTML {\n  static get observedAttributes() {\n    return ['name', 'fullname', 'scale'];\n  }\n\n  constructor() {\n    super();\n  }\n\n  connectedCallback() {\n    create_track.call(this);\n  }\n\n  get name() {\n    return this.getAttribute('name');\n  }\n\n  set name(name) {\n    return this.setAttribute('name', name);\n  }\n\n  get fullname() {\n    return this.getAttribute('fullname');\n  }\n\n  set fullname(name) {\n    return this.setAttribute('fullname', name);\n  }\n\n  get scale() {\n    return (this.getAttribute('scale') || '').split(',');\n  }\n\n  set scale(scale) {\n    return this.setAttribute('scale', scale);\n  }\n\n  attributeChangedCallback(name) {\n    create_track.call(this);\n  }\n}\n\ncustomElements.define('x-gatortrack', TrackComponent);\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (TrackRendererComponent);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9qcy9saWIvVHJhY2tSZW5kZXJlckNvbXBvbmVudC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9qcy9saWIvVHJhY2tSZW5kZXJlckNvbXBvbmVudC5qcz83OWNkIl0sInNvdXJjZXNDb250ZW50IjpbIlxuaW1wb3J0IEdhdG9yQ29tcG9uZW50IGZyb20gJy4vR2F0b3JDb21wb25lbnQnO1xuaW1wb3J0IEpTYW5kYm94IGZyb20gJy4uL2pzYW5kYm94JztcbmltcG9ydCBNQVNDUCBmcm9tICcuL01BU0NQJztcblxuY29uc3QgU0FOREJPWEVTID0gbmV3IE1hcCgpO1xuXG5sZXQgcmV0cmlldmVfcmVuZGVyZXIgPSBmdW5jdGlvbigpIHtcbiAgbGV0IHJlbmRlcmVyX3VybCA9IHRoaXMuZ2V0QXR0cmlidXRlKCdzcmMnKTtcbiAgcmV0dXJuIGZldGNoKHJlbmRlcmVyX3VybClcbiAgLnRoZW4oIGRhdCA9PiBkYXQudGV4dCgpICk7XG59O1xuXG5mdW5jdGlvbiBXcmFwSFRNTCgpIHsgcmV0dXJuIFJlZmxlY3QuY29uc3RydWN0KEhUTUxFbGVtZW50LCBbXSwgT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLmNvbnN0cnVjdG9yKTsgfVxuT2JqZWN0LnNldFByb3RvdHlwZU9mKFdyYXBIVE1MLnByb3RvdHlwZSwgSFRNTEVsZW1lbnQucHJvdG90eXBlKTtcbk9iamVjdC5zZXRQcm90b3R5cGVPZihXcmFwSFRNTCwgSFRNTEVsZW1lbnQpO1xuXG5sZXQgZ2V0X3JlbmRlcmVyX3NlcXVlbmNlID0gKHJlbmRlcmVyLGFjY2Vzc2lvbikgPT4ge1xuICByZXR1cm4gbmV3IFByb21pc2UoIHJlc29sdmUgPT4ge1xuICAoZnVuY3Rpb24oKSB7XG4gICAgdmFyIG9iaiA9ICh7IFwiZ290UmVzdWx0XCIgOiBmdW5jdGlvbigpIHtcbiAgICAgIHJlc29sdmUocmVuZGVyZXIuc2VxdWVuY2UpO1xuICAgIH0sIFwiYWNjXCIgOiBhY2Nlc3Npb24gfSk7XG4gICAgcmVuZGVyZXIudHJpZ2dlcigncmVhZGVyUmVnaXN0ZXJlZCcsW29ial0pO1xuICAgIG9iai5nb3RSZXN1bHQoKTtcbiAgfSkoKTtcbiAgfSk7XG59O1xuXG5sZXQgc2V0X2Jhc2ljX29mZnNldCA9IChvYmplY3RzLGJhc2ljX29mZnNldCkgPT4ge1xuICBvYmplY3RzLmZvckVhY2goZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKG9iai5vcHRpb25zKSB7XG4gICAgICBpZiAob2JqLm9wdGlvbnMub2Zmc2V0KSB7XG4gICAgICAgIG9iai5vcHRpb25zLm9mZnNldCArPSBiYXNpY19vZmZzZXQ7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG9iai5vcHRpb25zLm9mZnNldCA9IGJhc2ljX29mZnNldDtcbiAgICB9IGVsc2Uge1xuICAgICAgb2JqLm9wdGlvbnMgPSB7IFwib2Zmc2V0XCIgOiBiYXNpY19vZmZzZXQgfTtcbiAgICB9XG4gIH0pO1xufTtcblxubGV0IGFwcGx5X3JlbmRlcmluZyA9IChyZW5kZXJlcixkZWZhdWx0X3RyYWNrLG9iamVjdHMpID0+IHtcbiAgaWYgKCBBcnJheS5pc0FycmF5KG9iamVjdHMpICkge1xuICAgIHZhciB0ZW1wX29iamVjdHMgPSB7fVxuICAgIGNvbnNvbGUubG9nKCdObyBhY2Nlc3Npb24gcHJvdmlkZWQnKTtcbiAgICB0ZW1wX29iamVjdHNbJ0RFRkFVTFRBQ0MnXSA9IG9iamVjdHM7XG4gICAgb2JqZWN0cyA9IHRlbXBfb2JqZWN0cztcbiAgfVxuICBmb3IgKGxldCBhY2Mgb2YgT2JqZWN0LmtleXMob2JqZWN0cykpIHtcbiAgICBsZXQgciA9IG9iamVjdHNbYWNjXTtcbiAgICBzZXRfYmFzaWNfb2Zmc2V0KHIsMCk7XG5cbiAgICByZW5kZXJlci5yZW5kZXJPYmplY3RzKGRlZmF1bHRfdHJhY2ssci5maWx0ZXIoIGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgIHJldHVybiAhIGl0ZW0udHJhY2s7XG4gICAgfSkpO1xuXG4gICAgY29uc29sZS5sb2coTUFTQ1AuZ2V0TGF5ZXIoZGVmYXVsdF90cmFjaykpO1xuXG5cbiAgICB2YXIgaXRlbXNfYnlfdHJhY2sgPSB7fTtcbiAgICByLmZpbHRlciggZnVuY3Rpb24oaXRlbSkge1xuICAgICAgcmV0dXJuIGl0ZW0udHJhY2s7XG4gICAgfSkuZm9yRWFjaChmdW5jdGlvbihpdGVtKSB7XG4gICAgICBpdGVtc19ieV90cmFja1tpdGVtLnRyYWNrXSA9IGl0ZW1zX2J5X3RyYWNrW2l0ZW0udHJhY2tdIHx8IFtdO1xuICAgICAgaXRlbXNfYnlfdHJhY2tbaXRlbS50cmFja10ucHVzaChpdGVtKTtcbiAgICB9KTtcbiAgICBPYmplY3Qua2V5cyhpdGVtc19ieV90cmFjaykuZm9yRWFjaChmdW5jdGlvbih0cmFjaykge1xuICAgICAgaWYgKE1BU0NQLmdldExheWVyKHRyYWNrKSkge1xuICAgICAgICBNQVNDUC5yZWdpc3RlckxheWVyKHRyYWNrLHt9LFtyZW5kZXJlcl0pO1xuICAgICAgICAvLyBXZSBmb3JjZSBhIHJlZnJlc2ggb2YgdGhlIHRyYWNrIG9yZGVyXG4gICAgICAgIC8vIHRvIHBpY2sgdXAgYW55IGxheWVycyB0aGF0IGhhdmUgYmVlbiByZS1lbmFibGVkXG4gICAgICAgIHJlbmRlcmVyLnRyYWNrT3JkZXIgPSByZW5kZXJlci50cmFja09yZGVyO1xuICAgICAgICByZW5kZXJlci5yZW5kZXJPYmplY3RzKHRyYWNrLGl0ZW1zX2J5X3RyYWNrW3RyYWNrXSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmVuZGVyZXIudHJpZ2dlcigncmVzdWx0c1JlbmRlcmVkJyxbdGhpc10pO1xuICAgIHJlbmRlcmVyLnJlZnJlc2goKTtcbiAgfVxufTtcblxubGV0IGRvX3JlbmRlcmluZyA9IChyZW5kZXJlcixzY3JpcHQsZGF0YSxkZWZhdWx0X3RyYWNrKSA9PiB7XG4gIGNvbnN0IFNBTkRCT1ggPSBTQU5EQk9YRVMuZ2V0KHNjcmlwdCkgfHwgbmV3IEpTYW5kYm94KCk7XG4gIFNBTkRCT1hFUy5zZXQoc2NyaXB0LFNBTkRCT1gpO1xuICBnZXRfcmVuZGVyZXJfc2VxdWVuY2UocmVuZGVyZXIpXG4gIC50aGVuKCBzZXF1ZW5jZSA9PiB7XG4gICAgU0FOREJPWC5ldmFsKHNjcmlwdCwgKCkgPT4ge1xuICAgICAgU0FOREJPWC5ldmFsKHsgJ2RhdGEnIDogJ3JlbmRlckRhdGEoaW5wdXQuc2VxdWVuY2UsaW5wdXQuZGF0YSxpbnB1dC5hY2MsaW5wdXQudHJhY2spJyxcbiAgICAgICAgICAgICAgICAgICdpbnB1dCcgOiB7ICdzZXF1ZW5jZScgOiBzZXF1ZW5jZSwgJ2RhdGEnIDogZGF0YSwgJ3RyYWNrJyA6IGRlZmF1bHRfdHJhY2sgfSxcbiAgICAgICAgICAgICAgICAgICdvbmVycm9yJzogbWVzc2FnZSA9PiB7IHRocm93IG5ldyBFcnJvcihtZXNzYWdlKSB9LFxuICAgICAgICAgICAgICAgICAgJ2NhbGxiYWNrJyA6IGFwcGx5X3JlbmRlcmluZy5iaW5kKG51bGwscmVuZGVyZXIsZGVmYXVsdF90cmFjaylcbiAgICAgICAgICAgICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xufTtcblxuY2xhc3MgVHJhY2tSZW5kZXJlckNvbXBvbmVudCBleHRlbmRzIFdyYXBIVE1MICB7XG4gIHN0YXRpYyBnZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzKCkge1xuICAgIHJldHVybiBbJ3RyYWNrJ107XG4gIH1cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICB9XG5cbiAgY29ubmVjdGVkQ2FsbGJhY2soKSB7XG4gICAgdGhpcy5zY3JpcHQgPSByZXRyaWV2ZV9yZW5kZXJlci5jYWxsKHRoaXMpO1xuICB9XG5cbiAgcmVuZGVyKHJlbmRlcmVyLGRhdGEsdHJhY2spIHtcbiAgICB0aGlzLnNjcmlwdFxuICAgIC50aGVuIChzY3JpcHQgPT4ge1xuICAgICAgZG9fcmVuZGVyaW5nKHJlbmRlcmVyLHNjcmlwdCxkYXRhLHRyYWNrKTtcbiAgICB9KTtcbiAgfVxuXG4gIGdldCBkYXRhKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhO1xuICB9XG5cbiAgc2V0IGRhdGEoZGF0YSkge1xuICAgIHRoaXMuX2RhdGEgPSBkYXRhO1xuICAgIHRoaXMucmVuZGVyKHRoaXMub3duZXJEb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLmdldEF0dHJpYnV0ZSgncmVuZGVyZXInKSkucmVuZGVyZXIsdGhpcy5fZGF0YSx0aGlzLmdldEF0dHJpYnV0ZSgndHJhY2snKSk7XG4gIH1cblxuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sobmFtZSkge1xuICAgIGlmICh0aGlzLmhhc0F0dHJpYnV0ZSgncmVuZGVyZXInKSAmJiB0aGlzLmRhdGEpIHtcbiAgICAgIHRoaXMucmVuZGVyKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuZ2V0QXR0cmlidXRlKCdyZW5kZXJlcicpKS5yZW5kZXJlcix0aGlzLl9kYXRhLHRoaXMuZ2V0QXR0cmlidXRlKCd0cmFjaycpKTtcbiAgICB9XG4gIH1cbn1cblxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCd4LXRyYWNrcmVuZGVyZXInLFRyYWNrUmVuZGVyZXJDb21wb25lbnQpO1xuXG5sZXQgY3JlYXRlX3RyYWNrID0gZnVuY3Rpb24oKSB7XG4gIE1BU0NQLnJlZ2lzdGVyTGF5ZXIodGhpcy5uYW1lLHt9KTtcbiAgTUFTQ1AuZ2V0TGF5ZXIodGhpcy5uYW1lKS5mdWxsbmFtZSA9IHRoaXMuZnVsbG5hbWUgfHwgdGhpcy5uYW1lO1xuICBNQVNDUC5nZXRMYXllcih0aGlzLm5hbWUpLnNjYWxlcy5jbGVhcigpO1xuICBmb3IgKGxldCBzY2FsZSBvZiB0aGlzLnNjYWxlKSB7XG4gICAgTUFTQ1AuZ2V0TGF5ZXIodGhpcy5uYW1lKS5zY2FsZXMuYWRkKHNjYWxlKTtcbiAgfVxufTtcblxuY2xhc3MgVHJhY2tDb21wb25lbnQgZXh0ZW5kcyBXcmFwSFRNTCAge1xuICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICByZXR1cm4gWyduYW1lJywnZnVsbG5hbWUnLCdzY2FsZSddO1xuICB9XG5cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoKTtcbiAgfVxuXG4gIGNvbm5lY3RlZENhbGxiYWNrKCkge1xuICAgIGNyZWF0ZV90cmFjay5jYWxsKHRoaXMpO1xuICB9XG5cbiAgZ2V0IG5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCduYW1lJyk7XG4gIH1cblxuICBzZXQgbmFtZShuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0QXR0cmlidXRlKCduYW1lJyxuYW1lKTtcbiAgfVxuXG4gIGdldCBmdWxsbmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ2Z1bGxuYW1lJyk7XG4gIH1cblxuICBzZXQgZnVsbG5hbWUobmFtZSkge1xuICAgIHJldHVybiB0aGlzLnNldEF0dHJpYnV0ZSgnZnVsbG5hbWUnLG5hbWUpO1xuICB9XG5cbiAgZ2V0IHNjYWxlKCkge1xuICAgIHJldHVybiAodGhpcy5nZXRBdHRyaWJ1dGUoJ3NjYWxlJykgfHwgJycpLnNwbGl0KCcsJyk7XG4gIH1cblxuICBzZXQgc2NhbGUoc2NhbGUpIHtcbiAgICByZXR1cm4gdGhpcy5zZXRBdHRyaWJ1dGUoJ3NjYWxlJyxzY2FsZSk7XG4gIH1cblxuXG4gIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayhuYW1lKSB7XG4gICAgY3JlYXRlX3RyYWNrLmNhbGwodGhpcyk7XG4gIH1cbn1cblxuY3VzdG9tRWxlbWVudHMuZGVmaW5lKCd4LWdhdG9ydHJhY2snLFRyYWNrQ29tcG9uZW50KTtcblxuZXhwb3J0IGRlZmF1bHQgVHJhY2tSZW5kZXJlckNvbXBvbmVudDsiXSwibWFwcGluZ3MiOiI7Ozs7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFIQTtBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBakNBO0FBQ0E7QUFtQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBeENBO0FBQ0E7QUEwQ0E7QUFDQTtBQUNBIiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./js/lib/TrackRendererComponent.js\n");

/***/ }),

/***/ "./js/lib/UniprotReader.js":
/*!*********************************!*\
  !*** ./js/lib/UniprotReader.js ***!
  \*********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Service__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Service */ \"./js/lib/Service.js\");\n/* harmony import */ var _UserdataReader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./UserdataReader */ \"./js/lib/UserdataReader.js\");\n/* harmony import */ var _bean__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../bean */ \"./js/bean.js\");\n/* harmony import */ var _MASCP__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./MASCP */ \"./js/lib/MASCP.js\");\n/**\n * @fileOverview    Classes for reading data from Uniprot database\n */\n\n\n\n\n\n\n/** Default class constructor\n *  @class      Service class that will retrieve data from Uniprot for a given AGI.\n *  @param      {String} agi            Agi to look up\n *  @param      {String} endpointURL    Endpoint URL for this service\n *  @extends    MASCP.Service\n */\nconst UniprotReader = _Service__WEBPACK_IMPORTED_MODULE_0__[\"default\"].buildService(function (data) {\n    if (data && typeof data === 'string') {\n        var dats = UniprotReader.parseFasta(data);\n        var key;\n        for (key in dats) {\n            if (dats.hasOwnProperty(key)) {\n                data = { 'data': dats[key] };\n                this._raw_data = data;\n            }\n        }\n    }\n    this._data = data || {};\n    if (!this._data.data) {\n        this._data = { 'data': ['', ''] };\n    }\n    return this;\n});\n\nUniprotReader.SERVICE_URL = null;\n\nUniprotReader.prototype.requestData = function () {\n    var self = this;\n    if (!UniprotReader.SERVICE_URL) {\n        throw new Error('No service URL for UniprotReader');\n    }\n    return {\n        type: \"GET\",\n        dataType: \"json\",\n        'auth': _MASCP__WEBPACK_IMPORTED_MODULE_3__[\"default\"].GATOR_AUTH_TOKEN,\n        'api_key': _MASCP__WEBPACK_IMPORTED_MODULE_3__[\"default\"].GATOR_CLIENT_ID,\n        'url': UniprotReader.SERVICE_URL + '/' + this.agi.toUpperCase()\n    };\n};\n\nUniprotReader.Result.prototype.getDescription = function () {\n    return this._data.data[1];\n};\n\nUniprotReader.Result.prototype.getSequence = function () {\n    return this._data.data[0];\n};\n\nUniprotReader.parseFasta = function (datablock) {\n    var chunks = datablock.split('>');\n    var datas = {};\n    chunks.forEach(function (entry) {\n        var lines = entry.split(/\\n/);\n        if (lines.length <= 1) {\n            return;\n        }\n        var header = lines.shift();\n        var seq = lines.join(\"\");\n        var header_data = header.split('|');\n        var acc = header_data[1];\n        var desc = header_data[2];\n        datas[acc] = [seq, desc];\n    });\n    return datas;\n};\n\nUniprotReader.readFastaFile = function (datablock, callback) {\n\n    var datas = UniprotReader.parseFasta(datablock);\n\n    var writer = new _UserdataReader__WEBPACK_IMPORTED_MODULE_1__[\"default\"]();\n    writer.toString = function () {\n        return \"UniprotReader\";\n    };\n    writer.map = function (dat) {\n        return dat.data;\n    };\n    writer.datasetname = \"UniprotReader\";\n    callback(writer);\n    setTimeout(function () {\n        writer.avoid_database = true;\n        writer.setData(\"UniprotReader\", { \"data\": datas });\n    }, 0);\n    return writer;\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (UniprotReader);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9qcy9saWIvVW5pcHJvdFJlYWRlci5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy9qcy9saWIvVW5pcHJvdFJlYWRlci5qcz9hMjFkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGZpbGVPdmVydmlldyAgICBDbGFzc2VzIGZvciByZWFkaW5nIGRhdGEgZnJvbSBVbmlwcm90IGRhdGFiYXNlXG4gKi9cblxuaW1wb3J0IFNlcnZpY2UgZnJvbSAnLi9TZXJ2aWNlJztcbmltcG9ydCBVc2VyZGF0YVJlYWRlciBmcm9tICcuL1VzZXJkYXRhUmVhZGVyJztcbmltcG9ydCBiZWFuIGZyb20gJy4uL2JlYW4nO1xuaW1wb3J0IE1BU0NQIGZyb20gJy4vTUFTQ1AnO1xuXG5cbi8qKiBEZWZhdWx0IGNsYXNzIGNvbnN0cnVjdG9yXG4gKiAgQGNsYXNzICAgICAgU2VydmljZSBjbGFzcyB0aGF0IHdpbGwgcmV0cmlldmUgZGF0YSBmcm9tIFVuaXByb3QgZm9yIGEgZ2l2ZW4gQUdJLlxuICogIEBwYXJhbSAgICAgIHtTdHJpbmd9IGFnaSAgICAgICAgICAgIEFnaSB0byBsb29rIHVwXG4gKiAgQHBhcmFtICAgICAge1N0cmluZ30gZW5kcG9pbnRVUkwgICAgRW5kcG9pbnQgVVJMIGZvciB0aGlzIHNlcnZpY2VcbiAqICBAZXh0ZW5kcyAgICBNQVNDUC5TZXJ2aWNlXG4gKi9cbmNvbnN0IFVuaXByb3RSZWFkZXIgPSBTZXJ2aWNlLmJ1aWxkU2VydmljZShmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIGRhdGEgJiYgdHlwZW9mKGRhdGEpID09PSAnc3RyaW5nJyApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGF0cyA9IFVuaXByb3RSZWFkZXIucGFyc2VGYXN0YShkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIga2V5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoa2V5IGluIGRhdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdHMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHsgJ2RhdGEnIDogZGF0c1trZXldIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9yYXdfZGF0YSA9IGRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kYXRhID0gZGF0YSB8fCB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggISB0aGlzLl9kYXRhLmRhdGEgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZGF0YSA9IHsgJ2RhdGEnIDogWycnLCcnXSB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG5Vbmlwcm90UmVhZGVyLlNFUlZJQ0VfVVJMID0gbnVsbDtcblxuVW5pcHJvdFJlYWRlci5wcm90b3R5cGUucmVxdWVzdERhdGEgPSBmdW5jdGlvbigpXG57XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIGlmICggISBVbmlwcm90UmVhZGVyLlNFUlZJQ0VfVVJMKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gc2VydmljZSBVUkwgZm9yIFVuaXByb3RSZWFkZXInKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJHRVRcIixcbiAgICAgICAgZGF0YVR5cGU6IFwianNvblwiLFxuICAgICAgICAnYXV0aCcgOiBNQVNDUC5HQVRPUl9BVVRIX1RPS0VOLFxuICAgICAgICAnYXBpX2tleScgOiBNQVNDUC5HQVRPUl9DTElFTlRfSUQsXG4gICAgICAgICd1cmwnICAgOiBVbmlwcm90UmVhZGVyLlNFUlZJQ0VfVVJMKycvJysodGhpcy5hZ2kpLnRvVXBwZXJDYXNlKClcbiAgICB9O1xufTtcblxuVW5pcHJvdFJlYWRlci5SZXN1bHQucHJvdG90eXBlLmdldERlc2NyaXB0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGEuZGF0YVsxXTtcbn07XG5cblVuaXByb3RSZWFkZXIuUmVzdWx0LnByb3RvdHlwZS5nZXRTZXF1ZW5jZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9kYXRhLmRhdGFbMF07XG59O1xuXG5Vbmlwcm90UmVhZGVyLnBhcnNlRmFzdGEgPSBmdW5jdGlvbihkYXRhYmxvY2spIHtcbiAgICB2YXIgY2h1bmtzID0gKGRhdGFibG9jay5zcGxpdCgnPicpKTtcbiAgICB2YXIgZGF0YXMgPSB7fTtcbiAgICBjaHVua3MuZm9yRWFjaChmdW5jdGlvbihlbnRyeSkge1xuICAgICAgICB2YXIgbGluZXMgPSBlbnRyeS5zcGxpdCgvXFxuLyk7XG4gICAgICAgIGlmIChsaW5lcy5sZW5ndGggPD0gMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBoZWFkZXIgPSBsaW5lcy5zaGlmdCgpO1xuICAgICAgICB2YXIgc2VxID0gbGluZXMuam9pbihcIlwiKTtcbiAgICAgICAgdmFyIGhlYWRlcl9kYXRhID0gaGVhZGVyLnNwbGl0KCd8Jyk7XG4gICAgICAgIHZhciBhY2MgPSBoZWFkZXJfZGF0YVsxXTtcbiAgICAgICAgdmFyIGRlc2MgPSBoZWFkZXJfZGF0YVsyXTtcbiAgICAgICAgZGF0YXNbYWNjXSA9IFtzZXEsZGVzY107XG4gICAgfSk7XG4gICAgcmV0dXJuIGRhdGFzO1xufVxuXG5Vbmlwcm90UmVhZGVyLnJlYWRGYXN0YUZpbGUgPSBmdW5jdGlvbihkYXRhYmxvY2ssY2FsbGJhY2spIHtcblxuICAgIHZhciBkYXRhcyA9IFVuaXByb3RSZWFkZXIucGFyc2VGYXN0YShkYXRhYmxvY2spO1xuXG4gICAgdmFyIHdyaXRlciA9IG5ldyBVc2VyZGF0YVJlYWRlcigpO1xuICAgIHdyaXRlci50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gXCJVbmlwcm90UmVhZGVyXCI7XG4gICAgfTtcbiAgICB3cml0ZXIubWFwID0gZnVuY3Rpb24oZGF0KSB7XG4gICAgICAgIHJldHVybiBkYXQuZGF0YTtcbiAgICB9O1xuICAgIHdyaXRlci5kYXRhc2V0bmFtZSA9IFwiVW5pcHJvdFJlYWRlclwiO1xuICAgIGNhbGxiYWNrKHdyaXRlcik7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgd3JpdGVyLmF2b2lkX2RhdGFiYXNlID0gdHJ1ZTtcbiAgICAgICAgd3JpdGVyLnNldERhdGEoXCJVbmlwcm90UmVhZGVyXCIse1wiZGF0YVwiIDogZGF0YXN9KTtcbiAgICB9LDApO1xuICAgIHJldHVybiB3cml0ZXI7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBVbmlwcm90UmVhZGVyO1xuXG5cblxuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBTEE7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./js/lib/UniprotReader.js\n");

/***/ }),

/***/ "./js/lib/UserdataReader.js":
/*!**********************************!*\
  !*** ./js/lib/UserdataReader.js ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Service__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Service */ \"./js/lib/Service.js\");\n/* harmony import */ var _ServiceCaching__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ServiceCaching */ \"./js/lib/ServiceCaching.js\");\n/* harmony import */ var _MASCP__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./MASCP */ \"./js/lib/MASCP.js\");\n/* harmony import */ var _bean__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../bean */ \"./js/bean.js\");\n/**\n * @fileOverview    Classes for getting arbitrary user data onto the GATOR\n */\n\n\n\n\n\n\n/** Default class constructor\n *  @class      Service class that will retrieve sequence data for a given AGI from a given ecotype\n *  @param      {String} agi            Agi to look up\n *  @param      {String} endpointURL    Endpoint URL for this service\n *  @extends    MASCP.Service\n */\nconst UserdataReader = _Service__WEBPACK_IMPORTED_MODULE_0__[\"default\"].buildService(function (data) {\n    if (!data) {\n        return this;\n    }\n    this._raw_data = data;\n    return this;\n});\n\nUserdataReader.prototype.toString = function () {\n    return 'UserdataReader.' + this.datasetname;\n};\n\nUserdataReader.prototype.requestData = function () {\n    var agi = this.agi.toUpperCase();\n    return {\n        type: \"GET\",\n        dataType: \"json\",\n        data: { 'agi': agi,\n            'service': this.datasetname\n        }\n    };\n};\n\nUserdataReader.prototype.setupSequenceRenderer = function (renderer) {\n    // We don't have any default rendering for the UserDataReader\n    // since it's all going to be custom stuff anyway\n};\n\nvar apply_map = function apply_map(data_block) {\n    var map = this.map;\n    var databits = data_block.data;\n    var headers = databits.shift();\n    var dataset = {};\n    var id_col = headers.indexOf(map.id);\n    var cols_to_add = [];\n    for (var col in map) {\n        if (col == \"id\") {\n            continue;\n        }\n        if (map.hasOwnProperty(col)) {\n            cols_to_add.push({ \"name\": col, \"index\": headers.indexOf(map[col]) });\n        }\n    }\n    while (databits.length > 0) {\n        var row = databits.shift();\n        var id = row[id_col].toLowerCase();\n        if (!dataset[id]) {\n            dataset[id] = { \"data\": {} };\n        }\n        var obj = dataset[id];\n        var i;\n        for (i = cols_to_add.length - 1; i >= 0; i--) {\n            if (!obj.data[cols_to_add[i].name]) {\n                obj.data[cols_to_add[i].name] = [];\n            }\n            obj.data[cols_to_add[i].name] = obj.data[cols_to_add[i].name].concat((row[cols_to_add[i].index] || '').split(','));\n        }\n        obj.retrieved = data_block.retrieved;\n        obj.title = data_block.title;\n        if (data_block.etag) {\n            obj.etag = data_block.etag;\n        }\n    }\n    return dataset;\n};\n\nUserdataReader.prototype.setData = function (name, data) {\n\n    if (!data) {\n        return;\n    }\n\n    var self = this;\n\n    // Call CacheService on this object/class\n    // just to make sure that it has access\n    // to the cache retrieval mechanisms\n\n    _ServiceCaching__WEBPACK_IMPORTED_MODULE_1__[\"default\"].CacheService(this);\n\n    this.datasetname = name;\n\n    if (!data.retrieved) {\n        data.retrieved = new Date();\n    }\n    if (!data.title) {\n        data.title = name;\n    }\n\n    self.title = data.title;\n\n    var dataset = {}; // Format is { \"accession\" : { \"data\" : {}, \"retrieved\" : \"\" , \"title\" : \"\"  } };\n\n    if (typeof this.map == 'object') {\n        dataset = apply_map.call(this, data);\n    }\n    if (typeof this.map == 'function') {\n\n        if (this.map.callback) {\n            var self_func = arguments.callee;\n            this.map(data, function (parsed) {\n                self.map = function (d) {\n                    return d;\n                };\n                self_func.call(self, name, parsed);\n            });\n            return;\n        }\n        dataset = this.map(data);\n    }\n\n    if (!this.map) {\n        return;\n    }\n    this.data = dataset;\n\n    var inserter = new UserdataReader();\n\n    inserter.toString = function () {\n        return self.toString();\n    };\n\n    inserter.data = dataset;\n\n    inserter.retrieve = function (an_acc, cback) {\n        this.agi = an_acc;\n        // this._dataReceived(dataset[this.agi]);\n        cback.call(this);\n    };\n\n    _ServiceCaching__WEBPACK_IMPORTED_MODULE_1__[\"default\"].CacheService(inserter);\n\n    var accs = [];\n    var acc;\n    for (acc in dataset) {\n        if (dataset.hasOwnProperty(acc)) {\n            if (acc.match(/[A-Z]/)) {\n                dataset[acc.toLowerCase()] = dataset[acc];\n                delete dataset[acc];\n                acc = acc.toLowerCase();\n            }\n            accs.push(acc);\n        }\n    }\n    var total = accs.length;\n\n    var retrieve = this.retrieve;\n\n    this.retrieve = function (id, cback) {\n        console.log(\"Data not ready! Waiting for ready state\");\n        var self = this;\n        _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].add(self, 'ready', function () {\n            _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].remove(self, 'ready', arguments.callee);\n            self.retrieve(id, cback);\n        });\n    };\n    if (accs.length < 1) {\n        setTimeout(function () {\n            self.retrieve = retrieve;\n            _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].fire(self, 'ready', [data]);\n        }, 0);\n        return;\n    }\n    _ServiceCaching__WEBPACK_IMPORTED_MODULE_1__[\"default\"].BulkOperation(function (err) {\n        if (err) {\n            _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].fire(self, 'error', [err]);\n            return;\n        }\n        var trans = this.transaction;\n        inserter.avoid_database = true;\n        inserter.retrieve(accs[0], function () {\n            while (accs.length > 0) {\n                var acc = accs.shift();\n                _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].fire(self, 'progress', [100 * ((total - accs.length) / total), total - accs.length, total]);\n                inserter.agi = acc;\n                inserter._dataReceived(dataset[acc]);\n                if (accs.length === 0) {\n                    self.retrieve = retrieve;\n                    trans(function (err) {\n                        if (!err) {\n                            _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].fire(self, 'ready', [data]);\n                        } else {\n                            _bean__WEBPACK_IMPORTED_MODULE_3__[\"default\"].fire(self, 'error');\n                        }\n                    });\n                    return;\n                }\n            }\n        });\n    });\n};\n\nUserdataReader.datasets = function (cback, done) {\n    _ServiceCaching__WEBPACK_IMPORTED_MODULE_1__[\"default\"].FindCachedService(this, function (services) {\n        var result = [];\n        for (var i = 0, len = services.length; i < len; i++) {\n            result.push(services[i].replace(/UserdataReader./, ''));\n        }\n        if (result.forEach) {\n            result.forEach(cback);\n        }\n        if (done) {\n            done();\n        }\n    });\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (UserdataReader);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9qcy9saWIvVXNlcmRhdGFSZWFkZXIuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vanMvbGliL1VzZXJkYXRhUmVhZGVyLmpzPzg4YWIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAZmlsZU92ZXJ2aWV3ICAgIENsYXNzZXMgZm9yIGdldHRpbmcgYXJiaXRyYXJ5IHVzZXIgZGF0YSBvbnRvIHRoZSBHQVRPUlxuICovXG5cbmltcG9ydCBTZXJ2aWNlIGZyb20gJy4vU2VydmljZSc7XG5pbXBvcnQgQ2FjaGluZ1NlcnZpY2UgZnJvbSAnLi9TZXJ2aWNlQ2FjaGluZyc7XG5pbXBvcnQgTUFTQ1AgZnJvbSAnLi9NQVNDUCc7XG5pbXBvcnQgYmVhbiBmcm9tICcuLi9iZWFuJztcblxuXG4vKiogRGVmYXVsdCBjbGFzcyBjb25zdHJ1Y3RvclxuICogIEBjbGFzcyAgICAgIFNlcnZpY2UgY2xhc3MgdGhhdCB3aWxsIHJldHJpZXZlIHNlcXVlbmNlIGRhdGEgZm9yIGEgZ2l2ZW4gQUdJIGZyb20gYSBnaXZlbiBlY290eXBlXG4gKiAgQHBhcmFtICAgICAge1N0cmluZ30gYWdpICAgICAgICAgICAgQWdpIHRvIGxvb2sgdXBcbiAqICBAcGFyYW0gICAgICB7U3RyaW5nfSBlbmRwb2ludFVSTCAgICBFbmRwb2ludCBVUkwgZm9yIHRoaXMgc2VydmljZVxuICogIEBleHRlbmRzICAgIE1BU0NQLlNlcnZpY2VcbiAqL1xuY29uc3QgVXNlcmRhdGFSZWFkZXIgPSBTZXJ2aWNlLmJ1aWxkU2VydmljZShmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoICEgZGF0YSApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3Jhd19kYXRhID0gZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgICAgICB9KTtcblxuVXNlcmRhdGFSZWFkZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICdVc2VyZGF0YVJlYWRlci4nK3RoaXMuZGF0YXNldG5hbWU7XG59O1xuXG5Vc2VyZGF0YVJlYWRlci5wcm90b3R5cGUucmVxdWVzdERhdGEgPSBmdW5jdGlvbigpXG57XG4gICAgdmFyIGFnaSA9IHRoaXMuYWdpLnRvVXBwZXJDYXNlKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJHRVRcIixcbiAgICAgICAgZGF0YVR5cGU6IFwianNvblwiLFxuICAgICAgICBkYXRhOiB7ICdhZ2knICAgICAgIDogYWdpLFxuICAgICAgICAgICAgICAgICdzZXJ2aWNlJyAgIDogdGhpcy5kYXRhc2V0bmFtZSBcbiAgICAgICAgfVxuICAgIH07XG59O1xuXG5cblVzZXJkYXRhUmVhZGVyLnByb3RvdHlwZS5zZXR1cFNlcXVlbmNlUmVuZGVyZXIgPSBmdW5jdGlvbihyZW5kZXJlcikge1xuLy8gV2UgZG9uJ3QgaGF2ZSBhbnkgZGVmYXVsdCByZW5kZXJpbmcgZm9yIHRoZSBVc2VyRGF0YVJlYWRlclxuLy8gc2luY2UgaXQncyBhbGwgZ29pbmcgdG8gYmUgY3VzdG9tIHN0dWZmIGFueXdheVxufTtcblxudmFyIGFwcGx5X21hcCA9IGZ1bmN0aW9uKGRhdGFfYmxvY2spIHtcbiAgICB2YXIgbWFwID0gdGhpcy5tYXA7XG4gICAgdmFyIGRhdGFiaXRzID0gZGF0YV9ibG9jay5kYXRhO1xuICAgIHZhciBoZWFkZXJzID0gZGF0YWJpdHMuc2hpZnQoKTtcbiAgICB2YXIgZGF0YXNldCA9IHt9O1xuICAgIHZhciBpZF9jb2wgPSBoZWFkZXJzLmluZGV4T2YobWFwLmlkKTtcbiAgICB2YXIgY29sc190b19hZGQgPSBbXTtcbiAgICBmb3IgKHZhciBjb2wgaW4gbWFwKSB7XG4gICAgICAgIGlmIChjb2wgPT0gXCJpZFwiKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWFwLmhhc093blByb3BlcnR5KGNvbCkpIHtcbiAgICAgICAgICAgIGNvbHNfdG9fYWRkLnB1c2goeyBcIm5hbWVcIiA6IGNvbCwgXCJpbmRleFwiIDogaGVhZGVycy5pbmRleE9mKG1hcFtjb2xdKSB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB3aGlsZSAoZGF0YWJpdHMubGVuZ3RoID4gMCkge1xuICAgICAgICB2YXIgcm93ID0gZGF0YWJpdHMuc2hpZnQoKTtcbiAgICAgICAgdmFyIGlkID0gcm93W2lkX2NvbF0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKCAhIGRhdGFzZXRbaWRdICkge1xuICAgICAgICAgICAgZGF0YXNldFtpZF0gPSB7XCJkYXRhXCIgOiB7fX07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9iaiA9IGRhdGFzZXRbaWRdO1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgZm9yIChpID0gY29sc190b19hZGQubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGlmICggISBvYmouZGF0YVtjb2xzX3RvX2FkZFtpXS5uYW1lXSApIHtcbiAgICAgICAgICAgICAgICBvYmouZGF0YVtjb2xzX3RvX2FkZFtpXS5uYW1lXSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2JqLmRhdGFbY29sc190b19hZGRbaV0ubmFtZV0gPSBvYmouZGF0YVtjb2xzX3RvX2FkZFtpXS5uYW1lXS5jb25jYXQoKHJvd1tjb2xzX3RvX2FkZFtpXS5pbmRleF0gfHwgJycpLnNwbGl0KCcsJykpO1xuICAgICAgICB9XG4gICAgICAgIG9iai5yZXRyaWV2ZWQgPSBkYXRhX2Jsb2NrLnJldHJpZXZlZDtcbiAgICAgICAgb2JqLnRpdGxlID0gZGF0YV9ibG9jay50aXRsZTtcbiAgICAgICAgaWYgKGRhdGFfYmxvY2suZXRhZykge1xuICAgICAgICAgICAgb2JqLmV0YWcgPSBkYXRhX2Jsb2NrLmV0YWc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRhdGFzZXQ7XG59O1xuXG5Vc2VyZGF0YVJlYWRlci5wcm90b3R5cGUuc2V0RGF0YSA9IGZ1bmN0aW9uKG5hbWUsZGF0YSkge1xuICAgIFxuICAgIGlmICggISBkYXRhICkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIFxuICAgIC8vIENhbGwgQ2FjaGVTZXJ2aWNlIG9uIHRoaXMgb2JqZWN0L2NsYXNzXG4gICAgLy8ganVzdCB0byBtYWtlIHN1cmUgdGhhdCBpdCBoYXMgYWNjZXNzXG4gICAgLy8gdG8gdGhlIGNhY2hlIHJldHJpZXZhbCBtZWNoYW5pc21zXG5cbiAgICBDYWNoaW5nU2VydmljZS5DYWNoZVNlcnZpY2UodGhpcyk7XG4gICAgXG4gICAgdGhpcy5kYXRhc2V0bmFtZSA9IG5hbWU7XG5cbiAgICBpZiAoICEgZGF0YS5yZXRyaWV2ZWQgKSB7XG4gICAgICAgIGRhdGEucmV0cmlldmVkID0gbmV3IERhdGUoKTtcbiAgICB9XG4gICAgaWYgKCAhIGRhdGEudGl0bGUgKSB7XG4gICAgICAgIGRhdGEudGl0bGUgPSBuYW1lO1xuICAgIH1cblxuICAgIHNlbGYudGl0bGUgPSBkYXRhLnRpdGxlO1xuXG4gICAgdmFyIGRhdGFzZXQgPSB7fTsgLy8gRm9ybWF0IGlzIHsgXCJhY2Nlc3Npb25cIiA6IHsgXCJkYXRhXCIgOiB7fSwgXCJyZXRyaWV2ZWRcIiA6IFwiXCIgLCBcInRpdGxlXCIgOiBcIlwiICB9IH07XG5cbiAgICBpZiAodHlwZW9mIHRoaXMubWFwID09ICdvYmplY3QnKSB7XG4gICAgICAgIGRhdGFzZXQgPSBhcHBseV9tYXAuY2FsbCh0aGlzLGRhdGEpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHRoaXMubWFwID09ICdmdW5jdGlvbicpIHtcblxuICAgICAgICBpZiAodGhpcy5tYXAuY2FsbGJhY2spIHtcbiAgICAgICAgICAgIHZhciBzZWxmX2Z1bmMgPSBhcmd1bWVudHMuY2FsbGVlO1xuICAgICAgICAgICAgdGhpcy5tYXAoZGF0YSxmdW5jdGlvbihwYXJzZWQpIHtcbiAgICAgICAgICAgICAgICBzZWxmLm1hcCA9IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIChkKTsgfTtcbiAgICAgICAgICAgICAgICBzZWxmX2Z1bmMuY2FsbChzZWxmLG5hbWUscGFyc2VkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGRhdGFzZXQgPSB0aGlzLm1hcChkYXRhKTtcbiAgICB9XG5cbiAgICBpZiAoICEgdGhpcy5tYXAgKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5kYXRhID0gZGF0YXNldDtcbiAgICBcbiAgICB2YXIgaW5zZXJ0ZXIgPSBuZXcgVXNlcmRhdGFSZWFkZXIoKTtcblxuICAgIGluc2VydGVyLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBzZWxmLnRvU3RyaW5nKCk7XG4gICAgfTtcblxuICAgIGluc2VydGVyLmRhdGEgPSBkYXRhc2V0O1xuICAgIFxuICAgIGluc2VydGVyLnJldHJpZXZlID0gZnVuY3Rpb24oYW5fYWNjLGNiYWNrKSB7XG4gICAgICAgIHRoaXMuYWdpID0gYW5fYWNjO1xuICAgICAgICAvLyB0aGlzLl9kYXRhUmVjZWl2ZWQoZGF0YXNldFt0aGlzLmFnaV0pO1xuICAgICAgICBjYmFjay5jYWxsKHRoaXMpO1xuICAgIH07XG4gICAgXG4gICAgQ2FjaGluZ1NlcnZpY2UuQ2FjaGVTZXJ2aWNlKGluc2VydGVyKTtcblxuICAgIHZhciBhY2NzID0gW107XG4gICAgdmFyIGFjYztcbiAgICBmb3IgKGFjYyBpbiBkYXRhc2V0KSB7XG4gICAgICAgIGlmIChkYXRhc2V0Lmhhc093blByb3BlcnR5KGFjYykpIHtcbiAgICAgICAgICAgIGlmIChhY2MubWF0Y2goL1tBLVpdLykpIHtcbiAgICAgICAgICAgICAgICBkYXRhc2V0W2FjYy50b0xvd2VyQ2FzZSgpXSA9IGRhdGFzZXRbYWNjXTtcbiAgICAgICAgICAgICAgICBkZWxldGUgZGF0YXNldFthY2NdO1xuICAgICAgICAgICAgICAgIGFjYyA9IGFjYy50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWNjcy5wdXNoKGFjYyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIHRvdGFsID0gYWNjcy5sZW5ndGg7XG5cbiAgICB2YXIgcmV0cmlldmUgPSB0aGlzLnJldHJpZXZlO1xuXG4gICAgdGhpcy5yZXRyaWV2ZSA9IGZ1bmN0aW9uKGlkLGNiYWNrKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiRGF0YSBub3QgcmVhZHkhIFdhaXRpbmcgZm9yIHJlYWR5IHN0YXRlXCIpO1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7ICAgICAgICBcbiAgICAgICAgYmVhbi5hZGQoc2VsZiwncmVhZHknLGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgYmVhbi5yZW1vdmUoc2VsZiwncmVhZHknLGFyZ3VtZW50cy5jYWxsZWUpO1xuICAgICAgICAgICAgc2VsZi5yZXRyaWV2ZShpZCxjYmFjayk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgaWYgKGFjY3MubGVuZ3RoIDwgMSkge1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2VsZi5yZXRyaWV2ZSA9IHJldHJpZXZlO1xuICAgICAgICAgICAgYmVhbi5maXJlKHNlbGYsJ3JlYWR5JyxbZGF0YV0pO1xuICAgICAgICB9LDApO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIENhY2hpbmdTZXJ2aWNlLkJ1bGtPcGVyYXRpb24oZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIGJlYW4uZmlyZShzZWxmLCdlcnJvcicsW2Vycl0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0cmFucyA9IHRoaXMudHJhbnNhY3Rpb247XG4gICAgICAgIGluc2VydGVyLmF2b2lkX2RhdGFiYXNlID0gdHJ1ZTtcbiAgICAgICAgaW5zZXJ0ZXIucmV0cmlldmUoYWNjc1swXSxmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHdoaWxlIChhY2NzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgYWNjID0gYWNjcy5zaGlmdCgpO1xuICAgICAgICAgICAgICAgIGJlYW4uZmlyZShzZWxmLCdwcm9ncmVzcycsWzEwMCAqICgodG90YWwgLSBhY2NzLmxlbmd0aCkgLyB0b3RhbCksIHRvdGFsIC0gYWNjcy5sZW5ndGgsIHRvdGFsXSk7XG4gICAgICAgICAgICAgICAgaW5zZXJ0ZXIuYWdpID0gYWNjO1xuICAgICAgICAgICAgICAgIGluc2VydGVyLl9kYXRhUmVjZWl2ZWQoZGF0YXNldFthY2NdKTtcbiAgICAgICAgICAgICAgICBpZiAoYWNjcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5yZXRyaWV2ZSA9IHJldHJpZXZlO1xuICAgICAgICAgICAgICAgICAgICB0cmFucyhmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICggISBlcnIgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVhbi5maXJlKHNlbGYsJ3JlYWR5JyxbZGF0YV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZWFuLmZpcmUoc2VsZiwnZXJyb3InKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG5cbn07XG5cblVzZXJkYXRhUmVhZGVyLmRhdGFzZXRzID0gZnVuY3Rpb24oY2JhY2ssZG9uZSkge1xuICAgIENhY2hpbmdTZXJ2aWNlLkZpbmRDYWNoZWRTZXJ2aWNlKHRoaXMsZnVuY3Rpb24oc2VydmljZXMpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gc2VydmljZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspe1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goc2VydmljZXNbaV0ucmVwbGFjZSgvVXNlcmRhdGFSZWFkZXIuLywnJykpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQuZm9yRWFjaCkge1xuICAgICAgICAgICAgcmVzdWx0LmZvckVhY2goY2JhY2spO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICBkb25lKCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IFVzZXJkYXRhUmVhZGVyOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7QUFNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQURBO0FBSEE7QUFPQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./js/lib/UserdataReader.js\n");

/***/ }),

/***/ "./node_modules/webpack/buildin/amd-options.js":
/*!****************************************!*\
  !*** (webpack)/buildin/amd-options.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {/* globals __webpack_amd_options__ */\r\nmodule.exports = __webpack_amd_options__;\r\n\n/* WEBPACK VAR INJECTION */}.call(this, {}))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay9idWlsZGluL2FtZC1vcHRpb25zLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL2FtZC1vcHRpb25zLmpzPzAwODYiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZ2xvYmFscyBfX3dlYnBhY2tfYW1kX29wdGlvbnNfXyAqL1xyXG5tb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19hbWRfb3B0aW9uc19fO1xyXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/webpack/buildin/amd-options.js\n");

/***/ }),

/***/ "./node_modules/webpack/buildin/harmony-module.js":
/*!*******************************************!*\
  !*** (webpack)/buildin/harmony-module.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = function (originalModule) {\n\tif (!originalModule.webpackPolyfill) {\n\t\tvar module = Object.create(originalModule);\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function get() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function get() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"exports\", {\n\t\t\tenumerable: true\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd2VicGFjay9idWlsZGluL2hhcm1vbnktbW9kdWxlLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy93ZWJwYWNrL2J1aWxkaW4vaGFybW9ueS1tb2R1bGUuanM/MTZhMiJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9yaWdpbmFsTW9kdWxlKSB7XG5cdGlmICghb3JpZ2luYWxNb2R1bGUud2VicGFja1BvbHlmaWxsKSB7XG5cdFx0dmFyIG1vZHVsZSA9IE9iamVjdC5jcmVhdGUob3JpZ2luYWxNb2R1bGUpO1xuXHRcdC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxuXHRcdGlmICghbW9kdWxlLmNoaWxkcmVuKSBtb2R1bGUuY2hpbGRyZW4gPSBbXTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImxvYWRlZFwiLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5sO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwiaWRcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBtb2R1bGUuaTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImV4cG9ydHNcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZVxuXHRcdH0pO1xuXHRcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xuXHR9XG5cdHJldHVybiBtb2R1bGU7XG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUpBO0FBTUE7QUFDQTtBQURBO0FBR0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/webpack/buildin/harmony-module.js\n");

/***/ }),

/***/ 0:
/*!***************************!*\
  !*** multi ./js/gator.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./js/gator.js */"./js/gator.js");


/***/ })

/******/ });